<!DOCTYPE html>
<html><head><meta charset=utf-8><title>rawip(4)</title><keywords content=man,rawip></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>rawip(4)</h1><table class=head><tr><td class=head-ltitle>IP(4)</td><td class=head-vol>FreeBSD Kernel Interfaces Manual</td><td class=head-rtitle>IP(4)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>ip</code> — <div class=Nd>Internet Protocol</div></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/sys/types.h.html>sys/types.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/sys/socket.h.html>sys/socket.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/netinet/in.h.html>netinet/in.h</a>&gt;</code><p class=Pp><var class=Ft>int</var><br><code class=Fn>socket</code>(<var class=Fa style="white-space: nowrap;">AF_INET</var>, <var class=Fa style="white-space: nowrap;">SOCK_RAW</var>, <var class=Fa style="white-space: nowrap;">proto</var>);</p></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> IP is the transport layer protocol used by the Internet protocol family. Options may be set at the IP level when using higher-level protocols that are based on IP (such as TCP and UDP). It may also be accessed through a “raw socket” when developing new protocols, or special-purpose applications. <p class=Pp>There are several IP-level <a class=Xr href=setsockopt.2.html>setsockopt(2)</a> and <a class=Xr href=getsockopt.2.html>getsockopt(2)</a> options. <code class=Dv>IP_OPTIONS</code> may be used to provide IP options to be transmitted in the IP header of each outgoing packet or to examine the header options on incoming packets. IP options may be used with any socket type in the Internet family. The format of IP options to be sent is that specified by the IP protocol specification (RFC-791), with one exception: the list of addresses for Source Route options must include the first-hop gateway at the beginning of the list of gateways. The first-hop gateway address will be extracted from the option list and the size adjusted accordingly before use. To disable previously specified options, use a zero-length buffer:</p><div class="Bd Pp"><pre>
setsockopt(s, IPPROTO_IP, IP_OPTIONS, NULL, 0);
</pre></div><p class=Pp><code class=Dv>IP_TOS</code> and <code class=Dv>IP_TTL</code> may be used to set the type-of-service and time-to-live fields in the IP header for <code class=Dv>SOCK_STREAM</code>, <code class=Dv>SOCK_DGRAM</code>, and certain types of <code class=Dv>SOCK_RAW</code> sockets. For example,</p><div class="Bd Pp"><pre>
int tos = IPTOS_LOWDELAY;       /* see &lt;netinet/ip.h&gt; */
setsockopt(s, IPPROTO_IP, IP_TOS, &amp;tos, sizeof(tos));

int ttl = 60;                   /* max = 255 */
setsockopt(s, IPPROTO_IP, IP_TTL, &amp;ttl, sizeof(ttl));
</pre></div><p class=Pp><code class=Dv>IP_MINTTL</code> may be used to set the minimum acceptable TTL a packet must have when received on a socket. All packets with a lower TTL are silently dropped. This option is only really useful when set to 255, preventing packets from outside the directly connected networks reaching local listeners on sockets.</p><p class=Pp><code class=Dv>IP_DONTFRAG</code> may be used to set the Don't Fragment flag on IP packets. Currently this option is respected only on <a class=Xr href=udp.4.html>udp(4)</a> and raw <code class=Nm>ip</code> sockets, unless the <code class=Dv>IP_HDRINCL</code> option has been set. On <a class=Xr href=tcp.4.html>tcp(4)</a> sockets, the Don't Fragment flag is controlled by the Path MTU Discovery option. Sending a packet larger than the MTU size of the egress interface, determined by the destination address, returns an <code class=Er>EMSGSIZE</code> error.</p><p class=Pp>If the <code class=Dv>IP_ORIGDSTADDR</code> option is enabled on a <code class=Dv>SOCK_DGRAM</code> socket, the <a class=Xr href=recvmsg.2.html>recvmsg(2)</a> call will return the destination IP address and destination port for a UDP datagram. The <var class=Vt>msg_control</var> field in the <var class=Vt>msghdr</var> structure points to a buffer that contains a <var class=Vt>cmsghdr</var> structure followed by the sockaddr_in structure. The <var class=Vt>cmsghdr</var> fields have the following values:</p><div class="Bd Pp"><pre>
cmsg_len = CMSG_LEN(sizeof(struct sockaddr_in))
cmsg_level = IPPROTO_IP
cmsg_type = IP_ORIGDSTADDR
</pre></div><p class=Pp>If the <code class=Dv>IP_RECVDSTADDR</code> option is enabled on a <code class=Dv>SOCK_DGRAM</code> socket, the <a class=Xr href=recvmsg.2.html>recvmsg(2)</a> call will return the destination IP address for a UDP datagram. The <var class=Vt>msg_control</var> field in the <var class=Vt>msghdr</var> structure points to a buffer that contains a <var class=Vt>cmsghdr</var> structure followed by the IP address. The <var class=Vt>cmsghdr</var> fields have the following values:</p><div class="Bd Pp"><pre>
cmsg_len = CMSG_LEN(sizeof(struct in_addr))
cmsg_level = IPPROTO_IP
cmsg_type = IP_RECVDSTADDR
</pre></div><p class=Pp>The source address to be used for outgoing UDP datagrams on a socket can be specified as ancillary data with a type code of <code class=Dv>IP_SENDSRCADDR</code>. The msg_control field in the msghdr structure should point to a buffer that contains a <var class=Vt>cmsghdr</var> structure followed by the IP address. The cmsghdr fields should have the following values:</p><div class="Bd Pp"><pre>
cmsg_len = CMSG_LEN(sizeof(struct in_addr))
cmsg_level = IPPROTO_IP
cmsg_type = IP_SENDSRCADDR
</pre></div><p class=Pp>The socket should be either bound to <code class=Dv>INADDR_ANY</code> and a local port, and the address supplied with <code class=Dv>IP_SENDSRCADDR</code> should't be <code class=Dv>INADDR_ANY</code>, or the socket should be bound to a local address and the address supplied with <code class=Dv>IP_SENDSRCADDR</code> should be <code class=Dv>INADDR_ANY</code>. In the latter case bound address is overridden via generic source address selection logic, which would choose IP address of interface closest to destination.</p><p class=Pp>For convenience, <code class=Dv>IP_SENDSRCADDR</code> is defined to have the same value as <code class=Dv>IP_RECVDSTADDR</code>, so the <code class=Dv>IP_RECVDSTADDR</code> control message from <a class=Xr href=recvmsg.2.html>recvmsg(2)</a> can be used directly as a control message for <a class=Xr href=sendmsg.2.html>sendmsg(2)</a>.</p><p class=Pp>If the <code class=Dv>IP_ONESBCAST</code> option is enabled on a <code class=Dv>SOCK_DGRAM</code> or a <code class=Dv>SOCK_RAW</code> socket, the destination address of outgoing broadcast datagrams on that socket will be forced to the undirected broadcast address, <code class=Dv>INADDR_BROADCAST</code>, before transmission. This is in contrast to the default behavior of the system, which is to transmit undirected broadcasts via the first network interface with the <code class=Dv>IFF_BROADCAST</code> flag set.</p><p class=Pp>This option allows applications to choose which interface is used to transmit an undirected broadcast datagram. For example, the following code would force an undirected broadcast to be transmitted via the interface configured with the broadcast address 192.168.2.255:</p><div class="Bd Pp"><pre>
char msg[512];
struct sockaddr_in sin;
int onesbcast = 1;	/* 0 = disable (default), 1 = enable */

setsockopt(s, IPPROTO_IP, IP_ONESBCAST, &amp;onesbcast, sizeof(onesbcast));
sin.sin_addr.s_addr = inet_addr("192.168.2.255");
sin.sin_port = htons(1234);
sendto(s, msg, sizeof(msg), 0, &amp;sin, sizeof(sin));
</pre></div><p class=Pp>It is the application's responsibility to set the <code class=Dv>IP_TTL</code> option to an appropriate value in order to prevent broadcast storms. The application must have sufficient credentials to set the <code class=Dv>SO_BROADCAST</code> socket level option, otherwise the <code class=Dv>IP_ONESBCAST</code> option has no effect.</p><p class=Pp>If the <code class=Dv>IP_BINDANY</code> option is enabled on a <code class=Dv>SOCK_STREAM</code>, <code class=Dv>SOCK_DGRAM</code> or a <code class=Dv>SOCK_RAW</code> socket, one can <a class=Xr href=bind.2.html>bind(2)</a> to any address, even one not bound to any available network interface in the system. This functionality (in conjunction with special firewall rules) can be used for implementing a transparent proxy. The <code class=Dv>PRIV_NETINET_BINDANY</code> privilege is needed to set this option.</p><p class=Pp>If the <code class=Dv>IP_RECVTTL</code> option is enabled on a <code class=Dv>SOCK_DGRAM</code> socket, the <a class=Xr href=recvmsg.2.html>recvmsg(2)</a> call will return the IP TTL (time to live) field for a UDP datagram. The msg_control field in the msghdr structure points to a buffer that contains a cmsghdr structure followed by the TTL. The cmsghdr fields have the following values:</p><div class="Bd Pp"><pre>
cmsg_len = CMSG_LEN(sizeof(u_char))
cmsg_level = IPPROTO_IP
cmsg_type = IP_RECVTTL
</pre></div><p class=Pp>If the <code class=Dv>IP_RECVTOS</code> option is enabled on a <code class=Dv>SOCK_DGRAM</code> socket, the <a class=Xr href=recvmsg.2.html>recvmsg(2)</a> call will return the IP TOS (type of service) field for a UDP datagram. The msg_control field in the msghdr structure points to a buffer that contains a cmsghdr structure followed by the TOS. The cmsghdr fields have the following values:</p><div class="Bd Pp"><pre>
cmsg_len = CMSG_LEN(sizeof(u_char))
cmsg_level = IPPROTO_IP
cmsg_type = IP_RECVTOS
</pre></div><p class=Pp>If the <code class=Dv>IP_RECVIF</code> option is enabled on a <code class=Dv>SOCK_DGRAM</code> socket, the <a class=Xr href=recvmsg.2.html>recvmsg(2)</a> call returns a <var class=Vt>struct sockaddr_dl</var> corresponding to the interface on which the packet was received. The <var class=Va>msg_control</var> field in the <var class=Vt>msghdr</var> structure points to a buffer that contains a <var class=Vt>cmsghdr</var> structure followed by the <var class=Vt>struct sockaddr_dl</var>. The <var class=Vt>cmsghdr</var> fields have the following values:</p><div class="Bd Pp"><pre>
cmsg_len = CMSG_LEN(sizeof(struct sockaddr_dl))
cmsg_level = IPPROTO_IP
cmsg_type = IP_RECVIF
</pre></div><p class=Pp><code class=Dv>IP_PORTRANGE</code> may be used to set the port range used for selecting a local port number on a socket with an unspecified (zero) port number. It has the following possible values:</p><dl class=Bl-tag><dt><a class=permalink href=#IP_PORTRANGE_DEFAULT><code class=Dv id=IP_PORTRANGE_DEFAULT>IP_PORTRANGE_DEFAULT</code></a></dt><dd>use the default range of values, normally <code class=Dv>IPPORT_HIFIRSTAUTO</code> through <code class=Dv>IPPORT_HILASTAUTO</code>. This is adjustable through the sysctl setting: <var class=Va>net.inet.ip.portrange.first</var> and <var class=Va>net.inet.ip.portrange.last</var>.</dd><dt><a class=permalink href=#IP_PORTRANGE_HIGH><code class=Dv id=IP_PORTRANGE_HIGH>IP_PORTRANGE_HIGH</code></a></dt><dd>use a high range of values, normally <code class=Dv>IPPORT_HIFIRSTAUTO</code> and <code class=Dv>IPPORT_HILASTAUTO</code>. This is adjustable through the sysctl setting: <var class=Va>net.inet.ip.portrange.hifirst</var> and <var class=Va>net.inet.ip.portrange.hilast</var>.</dd><dt><a class=permalink href=#IP_PORTRANGE_LOW><code class=Dv id=IP_PORTRANGE_LOW>IP_PORTRANGE_LOW</code></a></dt><dd>use a low range of ports, which are normally restricted to privileged processes on <span class=Ux>UNIX</span> systems. The range is normally from <code class=Dv>IPPORT_RESERVED</code> - 1 down to <code class=Li>IPPORT_RESERVEDSTART</code> in descending order. This is adjustable through the sysctl setting: <var class=Va>net.inet.ip.portrange.lowfirst</var> and <var class=Va>net.inet.ip.portrange.lowlast</var>.</dd></dl><p class=Pp>The range of privileged ports which only may be opened by root-owned processes may be modified by the <var class=Va>net.inet.ip.portrange.reservedlow</var> and <var class=Va>net.inet.ip.portrange.reservedhigh</var> sysctl settings. The values default to the traditional range, 0 through <code class=Dv>IPPORT_RESERVED</code> - 1 (0 through 1023), respectively. Note that these settings do not affect and are not accounted for in the use or calculation of the other <var class=Va>net.inet.ip.portrange</var> values above. Changing these values departs from <span class=Ux>UNIX</span> tradition and has security consequences that the administrator should carefully evaluate before modifying these settings.</p><p class=Pp>Ports are allocated at random within the specified port range in order to increase the difficulty of random spoofing attacks. In scenarios such as benchmarking, this behavior may be undesirable. In these cases, <var class=Va>net.inet.ip.portrange.randomized</var> can be used to toggle randomization off. If more than <var class=Va>net.inet.ip.portrange.randomcps</var> ports have been allocated in the last second, then return to sequential port allocation. Return to random allocation only once the current port allocation rate drops below <var class=Va>net.inet.ip.portrange.randomcps</var> for at least <var class=Va>net.inet.ip.portrange.randomtime</var> seconds. The default values for <var class=Va>net.inet.ip.portrange.randomcps</var> and <var class=Va>net.inet.ip.portrange.randomtime</var> are 10 port allocations per second and 45 seconds correspondingly.</p><section class=Ss><h2 class=Ss id=Multicast_Options><a class=permalink href=#Multicast_Options>Multicast Options</a></h2> IP multicasting is supported only on <code class=Dv>AF_INET</code> sockets of type <code class=Dv>SOCK_DGRAM</code> and <code class=Dv>SOCK_RAW</code>, and only on networks where the interface driver supports multicasting. <p class=Pp>The <code class=Dv>IP_MULTICAST_TTL</code> option changes the time-to-live (TTL) for outgoing multicast datagrams in order to control the scope of the multicasts:</p><div class="Bd Pp"><pre>
u_char ttl;	/* range: 0 to 255, default = 1 */
setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, &amp;ttl, sizeof(ttl));
</pre></div><p class=Pp>Datagrams with a TTL of 1 are not forwarded beyond the local network. Multicast datagrams with a TTL of 0 will not be transmitted on any network, but may be delivered locally if the sending host belongs to the destination group and if multicast loopback has not been disabled on the sending socket (see below). Multicast datagrams with TTL greater than 1 may be forwarded to other networks if a multicast router is attached to the local network.</p><p class=Pp>For hosts with multiple interfaces, where an interface has not been specified for a multicast group membership, each multicast transmission is sent from the primary network interface. The <code class=Dv>IP_MULTICAST_IF</code> option overrides the default for subsequent transmissions from a given socket:</p><div class="Bd Pp"><pre>
struct in_addr addr;
setsockopt(s, IPPROTO_IP, IP_MULTICAST_IF, &amp;addr, sizeof(addr));
</pre></div><p class=Pp>where "addr" is the local IP address of the desired interface or <code class=Dv>INADDR_ANY</code> to specify the default interface.</p><p class=Pp>To specify an interface by index, an instance of <var class=Vt>ip_mreqn</var> may be passed instead. The <var class=Vt>imr_ifindex</var> member should be set to the index of the desired interface, or 0 to specify the default interface. The kernel differentiates between these two structures by their size.</p><p class=Pp>The use of <var class=Vt>IP_MULTICAST_IF</var> is <i class=Em>not recommended</i>, as multicast memberships are scoped to each individual interface. It is supported for legacy use only by applications, such as routing daemons, which expect to be able to transmit link-local IPv4 multicast datagrams (224.0.0.0/24) on multiple interfaces, without requesting an individual membership for each interface.</p><p class=Pp>An interface's local IP address and multicast capability can be obtained via the <code class=Dv>SIOCGIFCONF</code> and <code class=Dv>SIOCGIFFLAGS</code> ioctls. Normal applications should not need to use this option.</p><p class=Pp>If a multicast datagram is sent to a group to which the sending host itself belongs (on the outgoing interface), a copy of the datagram is, by default, looped back by the IP layer for local delivery. The <code class=Dv>IP_MULTICAST_LOOP</code> option gives the sender explicit control over whether or not subsequent datagrams are looped back:</p><div class="Bd Pp"><pre>
u_char loop;	/* 0 = disable, 1 = enable (default) */
setsockopt(s, IPPROTO_IP, IP_MULTICAST_LOOP, &amp;loop, sizeof(loop));
</pre></div><p class=Pp>This option improves performance for applications that may have no more than one instance on a single host (such as a routing daemon), by eliminating the overhead of receiving their own transmissions. It should generally not be used by applications for which there may be more than one instance on a single host (such as a conferencing program) or for which the sender does not belong to the destination group (such as a time querying program).</p><p class=Pp>The sysctl setting <var class=Va>net.inet.ip.mcast.loop</var> controls the default setting of the <code class=Dv>IP_MULTICAST_LOOP</code> socket option for new sockets.</p><p class=Pp>A multicast datagram sent with an initial TTL greater than 1 may be delivered to the sending host on a different interface from that on which it was sent, if the host belongs to the destination group on that other interface. The loopback control option has no effect on such delivery.</p><p class=Pp>A host must become a member of a multicast group before it can receive datagrams sent to the group. To join a multicast group, use the <code class=Dv>IP_ADD_MEMBERSHIP</code> option:</p><div class="Bd Pp"><pre>
struct ip_mreqn mreqn;
setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreqn, sizeof(mreqn));
</pre></div><p class=Pp>where <var class=Fa>mreqn</var> is the following structure:</p><div class="Bd Pp"><pre>
struct ip_mreqn {
    struct in_addr imr_multiaddr; /* IP multicast address of group */
    struct in_addr imr_interface; /* local IP address of interface */
    int            imr_ifindex;   /* interface index */
}
</pre></div><p class=Pp><var class=Va>imr_ifindex</var> should be set to the index of a particular multicast-capable interface if the host is multihomed. If <var class=Va>imr_ifindex</var> is non-zero, value of <var class=Va>imr_interface</var> is ignored. Otherwise, if <var class=Va>imr_ifindex</var> is 0, kernel will use IP address from <var class=Va>imr_interface</var> to lookup the interface. Value of <var class=Va>imr_interface</var> may be set to <var class=Va>INADDR_ANY</var> to choose the default interface, although this is not recommended; this is considered to be the first interface corresponding to the default route. Otherwise, the first multicast-capable interface configured in the system will be used.</p><p class=Pp>Legacy <var class=Vt>struct ip_mreq</var>, that lacks <var class=Va>imr_ifindex</var> field is also supported by <code class=Dv>IP_ADD_MEMBERSHIP</code> setsockopt. In this case kernel would behave as if <var class=Va>imr_ifindex</var> was set to zero: <var class=Va>imr_interface</var> will be used to lookup interface.</p><p class=Pp>Prior to <span class=Ux>FreeBSD 7.0</span>, if the <var class=Va>imr_interface</var> member is within the network range <code class=Li>0.0.0.0/8</code>, it is treated as an interface index in the system interface MIB, as per the RIP Version 2 MIB Extension (RFC-1724). In versions of <span class=Ux>FreeBSD</span> since 7.0, this behavior is no longer supported. Developers should instead use the RFC 3678 multicast source filter APIs; in particular, <code class=Dv>MCAST_JOIN_GROUP</code>.</p><p class=Pp>Up to <code class=Dv>IP_MAX_MEMBERSHIPS</code> memberships may be added on a single socket. Membership is associated with a single interface; programs running on multihomed hosts may need to join the same group on more than one interface.</p><p class=Pp>To drop a membership, use:</p><div class="Bd Pp"><pre>
struct ip_mreq mreq;
setsockopt(s, IPPROTO_IP, IP_DROP_MEMBERSHIP, &amp;mreq, sizeof(mreq));
</pre></div><p class=Pp>where <var class=Fa>mreq</var> contains the same values as used to add the membership. Memberships are dropped when the socket is closed or the process exits.</p><p class=Pp>The IGMP protocol uses the primary IP address of the interface as its identifier for group membership. This is the first IP address configured on the interface. If this address is removed or changed, the results are undefined, as the IGMP membership state will then be inconsistent. If multiple IP aliases are configured on the same interface, they will be ignored.</p><p class=Pp>This shortcoming was addressed in IPv6; MLDv2 requires that the unique link-local address for an interface is used to identify an MLDv2 listener.</p></section><section class=Ss><h2 class=Ss id=Source_Specific_Multicast_Options><a class=permalink href=#Source_Specific_Multicast_Options>Source-Specific Multicast Options</a></h2> Since <span class=Ux>FreeBSD 8.0</span>, the use of Source-Specific Multicast (SSM) is supported. These extensions require an IGMPv3 multicast router in order to make best use of them. If a legacy multicast router is present on the link, <span class=Ux>FreeBSD</span> will simply downgrade to the version of IGMP spoken by the router, and the benefits of source filtering on the upstream link will not be present, although the kernel will continue to squelch transmissions from blocked sources. <p class=Pp>Each group membership on a socket now has a filter mode:</p><dl class=Bl-tag><dt><a class=permalink href=#MCAST_EXCLUDE><code class=Dv id=MCAST_EXCLUDE>MCAST_EXCLUDE</code></a></dt><dd>Datagrams sent to this group are accepted, unless the source is in a list of blocked source addresses.</dd><dt><a class=permalink href=#MCAST_INCLUDE><code class=Dv id=MCAST_INCLUDE>MCAST_INCLUDE</code></a></dt><dd>Datagrams sent to this group are accepted only if the source is in a list of accepted source addresses.</dd></dl><p class=Pp>Groups joined using the legacy <code class=Dv>IP_ADD_MEMBERSHIP</code> option are placed in exclusive-mode, and are able to request that certain sources are blocked or allowed. This is known as the <i class=Em>delta-based API</i>.</p><p class=Pp>To block a multicast source on an existing group membership:</p><div class="Bd Pp"><pre>
struct ip_mreq_source mreqs;
setsockopt(s, IPPROTO_IP, IP_BLOCK_SOURCE, &amp;mreqs, sizeof(mreqs));
</pre></div><p class=Pp>where <var class=Fa>mreqs</var> is the following structure:</p><div class="Bd Pp"><pre>
struct ip_mreq_source {
    struct in_addr imr_multiaddr; /* IP multicast address of group */
    struct in_addr imr_sourceaddr; /* IP address of source */
    struct in_addr imr_interface; /* local IP address of interface */
}
</pre></div><var class=Va>imr_sourceaddr</var> should be set to the address of the source to be blocked. <p class=Pp>To unblock a multicast source on an existing group:</p><div class="Bd Pp"><pre>
struct ip_mreq_source mreqs;
setsockopt(s, IPPROTO_IP, IP_UNBLOCK_SOURCE, &amp;mreqs, sizeof(mreqs));
</pre></div><p class=Pp>The <code class=Dv>IP_BLOCK_SOURCE</code> and <code class=Dv>IP_UNBLOCK_SOURCE</code> options are <i class=Em>not permitted</i> for inclusive-mode group memberships.</p><p class=Pp>To join a multicast group in <code class=Dv>MCAST_INCLUDE</code> mode with a single source, or add another source to an existing inclusive-mode membership:</p><div class="Bd Pp"><pre>
struct ip_mreq_source mreqs;
setsockopt(s, IPPROTO_IP, IP_ADD_SOURCE_MEMBERSHIP, &amp;mreqs, sizeof(mreqs));
</pre></div><p class=Pp>To leave a single source from an existing group in inclusive mode:</p><div class="Bd Pp"><pre>
struct ip_mreq_source mreqs;
setsockopt(s, IPPROTO_IP, IP_DROP_SOURCE_MEMBERSHIP, &amp;mreqs, sizeof(mreqs));
</pre></div> If this is the last accepted source for the group, the membership will be dropped. <p class=Pp>The <code class=Dv>IP_ADD_SOURCE_MEMBERSHIP</code> and <code class=Dv>IP_DROP_SOURCE_MEMBERSHIP</code> options are <i class=Em>not accepted</i> for exclusive-mode group memberships. However, both exclusive and inclusive mode memberships support the use of the <i class=Em>full-state API</i> documented in RFC 3678. For management of source filter lists using this API, please refer to <a class=Xr href=sourcefilter.3.html>sourcefilter(3)</a>.</p><p class=Pp>The sysctl settings <var class=Va>net.inet.ip.mcast.maxsocksrc</var> and <var class=Va>net.inet.ip.mcast.maxgrpsrc</var> are used to specify an upper limit on the number of per-socket and per-group source filter entries which the kernel may allocate.</p></section><section class=Ss><h2 class=Ss id=Raw_IP_Sockets><a class=permalink href=#Raw_IP_Sockets>Raw IP Sockets</a></h2> Raw IP sockets are connectionless, and are normally used with the <a class=Xr href=sendto.2.html>sendto(2)</a> and <a class=Xr href=recvfrom.2.html>recvfrom(2)</a> calls, though the <a class=Xr href=connect.2.html>connect(2)</a> call may also be used to fix the destination for future packets (in which case the <a class=Xr href=read.2.html>read(2)</a> or <a class=Xr href=recv.2.html>recv(2)</a> and <a class=Xr href=write.2.html>write(2)</a> or <a class=Xr href=send.2.html>send(2)</a> system calls may be used). <p class=Pp>If <var class=Fa>proto</var> is 0, the default protocol <code class=Dv>IPPROTO_RAW</code> is used for outgoing packets, and only incoming packets destined for that protocol are received. If <var class=Fa>proto</var> is non-zero, that protocol number will be used on outgoing packets and to filter incoming packets.</p><p class=Pp>Outgoing packets automatically have an IP header prepended to them (based on the destination address and the protocol number the socket is created with), unless the <code class=Dv>IP_HDRINCL</code> option has been set. Unlike in previous <span class=Ux>BSD</span> releases, incoming packets are received with IP header and options intact, leaving all fields in network byte order.</p><p class=Pp><code class=Dv>IP_HDRINCL</code> indicates the complete IP header is included with the data and may be used only with the <code class=Dv>SOCK_RAW</code> type.</p><div class="Bd Pp"><pre>
#include &lt;netinet/in_systm.h&gt;
#include &lt;netinet/ip.h&gt;

int hincl = 1;                  /* 1 = on, 0 = off */
setsockopt(s, IPPROTO_IP, IP_HDRINCL, &amp;hincl, sizeof(hincl));
</pre></div><p class=Pp>Unlike previous <span class=Ux>BSD</span> releases, the program must set all the fields of the IP header, including the following:</p><div class="Bd Pp"><pre>
ip-&gt;ip_v = IPVERSION;
ip-&gt;ip_hl = hlen &gt;&gt; 2;
ip-&gt;ip_id = 0;  /* 0 means kernel set appropriate value */
ip-&gt;ip_off = htons(offset);
ip-&gt;ip_len = htons(len);
</pre></div><p class=Pp>The packet should be provided as is to be sent over wire. This implies all fields, including <var class=Va>ip_len</var> and <var class=Va>ip_off</var> to be in network byte order. See <a class=Xr href=byteorder.3.html>byteorder(3)</a> for more information on network byte order. If the <var class=Va>ip_id</var> field is set to 0 then the kernel will choose an appropriate value. If the header source address is set to <code class=Dv>INADDR_ANY</code>, the kernel will choose an appropriate address.</p></section></section><section class=Sh><h2 class=Sh id=ERRORS><a class=permalink href=#ERRORS>ERRORS</a></h2> A socket operation may fail with one of the following errors returned: <dl class=Bl-tag><dt>[<a class=permalink href=#EISCONN><code class=Er id=EISCONN>EISCONN</code></a>]</dt><dd>when trying to establish a connection on a socket which already has one, or when trying to send a datagram with the destination address specified and the socket is already connected;</dd><dt>[<a class=permalink href=#ENOTCONN><code class=Er id=ENOTCONN>ENOTCONN</code></a>]</dt><dd>when trying to send a datagram, but no destination address is specified, and the socket has not been connected;</dd><dt>[<a class=permalink href=#ENOBUFS><code class=Er id=ENOBUFS>ENOBUFS</code></a>]</dt><dd>when the system runs out of memory for an internal data structure;</dd><dt>[<a class=permalink href=#EADDRNOTAVAIL><code class=Er id=EADDRNOTAVAIL>EADDRNOTAVAIL</code></a>]</dt><dd>when an attempt is made to create a socket with a network address for which no network interface exists.</dd><dt>[<a class=permalink href=#EACCES><code class=Er id=EACCES>EACCES</code></a>]</dt><dd>when an attempt is made to create a raw IP socket by a non-privileged process.</dd></dl><p class=Pp>The following errors specific to IP may occur when setting or getting IP options:</p><dl class=Bl-tag><dt>[<a class=permalink href=#EINVAL><code class=Er id=EINVAL>EINVAL</code></a>]</dt><dd>An unknown socket option name was given.</dd><dt>[<a class=permalink href=#EINVAL_2><code class=Er id=EINVAL_2>EINVAL</code></a>]</dt><dd>The IP option field was improperly formed; an option field was shorter than the minimum value or longer than the option buffer provided.</dd></dl><p class=Pp>The following errors may occur when attempting to send IP datagrams via a “raw socket” with the <code class=Dv>IP_HDRINCL</code> option set:</p><dl class=Bl-tag><dt>[<a class=permalink href=#EINVAL_3><code class=Er id=EINVAL_3>EINVAL</code></a>]</dt><dd>The user-supplied <var class=Va>ip_len</var> field was not equal to the length of the datagram written to the socket.</dd></dl></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=getsockopt.2.html>getsockopt(2)</a>, <a class=Xr href=recv.2.html>recv(2)</a>, <a class=Xr href=send.2.html>send(2)</a>, <a class=Xr href=byteorder.3.html>byteorder(3)</a>, <a class=Xr href=CMSG_DATA.3.html>CMSG_DATA(3)</a>, <a class=Xr href=sourcefilter.3.html>sourcefilter(3)</a>, <a class=Xr href=icmp.4.html>icmp(4)</a>, <a class=Xr href=igmp.4.html>igmp(4)</a>, <a class=Xr href=inet.4.html>inet(4)</a>, <a class=Xr href=intro.4.html>intro(4)</a>, <a class=Xr href=multicast.4.html>multicast(4)</a><p class=Pp><cite class=Rs><span class=RsA>D. Thaler</span>, <span class=RsA>B. Fenner</span>, and <span class=RsA>B. Quinn</span>, <span class=RsT>Socket Interface Extensions for Multicast Source Filters</span>, <span class=RsN>RFC 3678</span>, <span class=RsD>Jan 2004</span>.</cite></p></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> The <code class=Nm>ip</code> protocol appeared in <span class=Ux>4.2BSD</span>. The <var class=Vt>ip_mreqn</var> structure appeared in Linux 2.4. </section><section class=Sh><h2 class=Sh id=BUGS><a class=permalink href=#BUGS>BUGS</a></h2> Before <span class=Ux>FreeBSD 10.0</span> packets received on raw IP sockets had the <var class=Va>ip_hl</var> subtracted from the <var class=Va>ip_len</var> field. <p class=Pp>Before <span class=Ux>FreeBSD 11.0</span> packets received on raw IP sockets had the <var class=Va>ip_len</var> and <var class=Va>ip_off</var> fields converted to host byte order. Packets written to raw IP sockets were expected to have <var class=Va>ip_len</var> and <var class=Va>ip_off</var> in host byte order.</p></section></div><table class=foot><tr><td class=foot-date>May 24, 2020</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>