<!DOCTYPE html>
<html><head><meta charset=utf-8><title>securelevel(7)</title><keywords content=man,securelevel></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>securelevel(7)</h1><table class=head><tr><td class=head-ltitle>SECURITY(7)</td><td class=head-vol>FreeBSD Miscellaneous Information Manual</td><td class=head-rtitle>SECURITY(7)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>security</code> — <div class=Nd>introduction to security under FreeBSD</div></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> Security is a function that begins and ends with the system administrator. While all <span class=Ux>BSD</span> multi-user systems have some inherent security, the job of building and maintaining additional security mechanisms to keep users “honest” is probably one of the single largest undertakings of the sysadmin. Machines are only as secure as you make them, and security concerns are ever competing with the human necessity for convenience. <span class=Ux>UNIX</span> systems, in general, are capable of running a huge number of simultaneous processes and many of these processes operate as servers — meaning that external entities can connect and talk to them. As yesterday's mini-computers and mainframes become today's desktops, and as computers become networked and internetworked, security becomes an ever bigger issue. <p class=Pp>Security is best implemented through a layered onion approach. In a nutshell, what you want to do is to create as many layers of security as are convenient and then carefully monitor the system for intrusions.</p><p class=Pp>System security also pertains to dealing with various forms of attacks, including attacks that attempt to crash or otherwise make a system unusable but do not attempt to break root. Security concerns can be split up into several categories:</p><ol class="Bl-enum Bd-indent"><li>Denial of Service attacks (DoS)</li><li>User account compromises</li><li>Root compromise through accessible servers</li><li>Root compromise via user accounts</li><li>Backdoor creation</li></ol><p class=Pp>A denial of service attack is an action that deprives the machine of needed resources. Typically, DoS attacks are brute-force mechanisms that attempt to crash or otherwise make a machine unusable by overwhelming its servers or network stack. Some DoS attacks try to take advantages of bugs in the networking stack to crash a machine with a single packet. The latter can only be fixed by applying a bug fix to the kernel. Attacks on servers can often be fixed by properly specifying options to limit the load the servers incur on the system under adverse conditions. Brute-force network attacks are harder to deal with. A spoofed-packet attack, for example, is nearly impossible to stop short of cutting your system off from the Internet. It may not be able to take your machine down, but it can fill up your Internet pipe.</p><p class=Pp>A user account compromise is even more common than a DoS attack. Many sysadmins still run standard <a class=Xr href=telnetd.8.html>telnetd(8)</a> and <a class=Xr href=ftpd.8.html>ftpd(8)</a> servers on their machines. These servers, by default, do not operate over encrypted connections. The result is that if you have any moderate-sized user base, one or more of your users logging into your system from a remote location (which is the most common and convenient way to log in to a system) will have his or her password sniffed. The attentive system administrator will analyze his remote access logs looking for suspicious source addresses even for successful logins.</p><p class=Pp>One must always assume that once an attacker has access to a user account, the attacker can break root. However, the reality is that in a well secured and maintained system, access to a user account does not necessarily give the attacker access to root. The distinction is important because without access to root the attacker cannot generally hide his tracks and may, at best, be able to do nothing more than mess with the user's files or crash the machine. User account compromises are very common because users tend not to take the precautions that sysadmins take.</p><p class=Pp>System administrators must keep in mind that there are potentially many ways to break root on a machine. The attacker may know the root password, the attacker may find a bug in a root-run server and be able to break root over a network connection to that server, or the attacker may know of a bug in an SUID-root program that allows the attacker to break root once he has broken into a user's account. If an attacker has found a way to break root on a machine, the attacker may not have a need to install a backdoor. Many of the root holes found and closed to date involve a considerable amount of work by the attacker to clean up after himself, so most attackers do install backdoors. This gives you a convenient way to detect the attacker. Making it impossible for an attacker to install a backdoor may actually be detrimental to your security because it will not close off the hole the attacker used to break in originally.</p><p class=Pp>Security remedies should always be implemented with a multi-layered “onion peel” approach and can be categorized as follows:</p><ol class="Bl-enum Bd-indent"><li>Securing root and staff accounts</li><li>Securing root — root-run servers and SUID/SGID binaries</li><li>Securing user accounts</li><li>Securing the password file</li><li>Securing the kernel core, raw devices, and file systems</li><li>Quick detection of inappropriate changes made to the system</li><li>Paranoia</li></ol></section><section class=Sh><h2 class=Sh id=SECURING_THE_ROOT_ACCOUNT_AND_SECURING_STAFF_ACCOUNTS><a class=permalink href=#SECURING_THE_ROOT_ACCOUNT_AND_SECURING_STAFF_ACCOUNTS>SECURING THE ROOT ACCOUNT AND SECURING STAFF ACCOUNTS</a></h2> Do not bother securing staff accounts if you have not secured the root account. Most systems have a password assigned to the root account. The first thing you do is assume that the password is <i class=Em>always</i> compromised. This does not mean that you should remove the password. The password is almost always necessary for console access to the machine. What it does mean is that you should not make it possible to use the password outside of the console or possibly even with a <a class=Xr href=su.1.html>su(1)</a> utility. For example, make sure that your PTYs are specified as being “<code class=Li>insecure</code>” in the <span class=Pa>/etc/ttys</span> file so that direct root logins via <a class=Xr href=telnet.1.html>telnet(1)</a> are disallowed. If using other login services such as <a class=Xr href=sshd.8.html>sshd(8)</a>, make sure that direct root logins are disabled there as well. Consider every access method — services such as <a class=Xr href=ftp.1.html>ftp(1)</a> often fall through the cracks. Direct root logins should only be allowed via the system console. <p class=Pp>Of course, as a sysadmin you have to be able to get to root, so we open up a few holes. But we make sure these holes require additional password verification to operate. One way to make root accessible is to add appropriate staff accounts to the “<code class=Li>wheel</code>” group (in <span class=Pa>/etc/group</span>). The staff members placed in the <code class=Li>wheel</code> group are allowed to <a class=Xr href=su.1.html>su(1)</a> to root. You should never give staff members native <code class=Li>wheel</code> access by putting them in the <code class=Li>wheel</code> group in their password entry. Staff accounts should be placed in a “<code class=Li>staff</code>” group, and then added to the <code class=Li>wheel</code> group via the <span class=Pa>/etc/group</span> file. Only those staff members who actually need to have root access should be placed in the <code class=Li>wheel</code> group. It is also possible, when using an authentication method such as Kerberos, to use Kerberos's <span class=Pa>.k5login</span> file in the root account to allow a <a class=Xr href=ksu.1.html>ksu(1)</a> to root without having to place anyone at all in the <code class=Li>wheel</code> group. This may be the better solution since the <code class=Li>wheel</code> mechanism still allows an intruder to break root if the intruder has gotten hold of your password file and can break into a staff account. While having the <code class=Li>wheel</code> mechanism is better than having nothing at all, it is not necessarily the safest option.</p><p class=Pp>An indirect way to secure the root account is to secure your staff accounts by using an alternative login access method and *'ing out the crypted password for the staff accounts. This way an intruder may be able to steal the password file but will not be able to break into any staff accounts or root, even if root has a crypted password associated with it (assuming, of course, that you have limited root access to the console). Staff members get into their staff accounts through a secure login mechanism such as <a class=Xr href=kerberos.8.html>kerberos(8)</a> or <a class=Xr href=ssh.1.html>ssh(1)</a> using a private/public key pair. When you use something like Kerberos you generally must secure the machines which run the Kerberos servers and your desktop workstation. When you use a public/private key pair with SSH, you must generally secure the machine you are logging in <i class=Em>from</i> (typically your workstation), but you can also add an additional layer of protection to the key pair by password protecting the keypair when you create it with <a class=Xr href=ssh-keygen.1.html>ssh-keygen(1)</a>. Being able to *-out the passwords for staff accounts also guarantees that staff members can only log in through secure access methods that you have set up. You can thus force all staff members to use secure, encrypted connections for all their sessions which closes an important hole used by many intruders: that of sniffing the network from an unrelated, less secure machine.</p><p class=Pp>The more indirect security mechanisms also assume that you are logging in from a more restrictive server to a less restrictive server. For example, if your main box is running all sorts of servers, your workstation should not be running any. In order for your workstation to be reasonably secure you should run as few servers as possible, up to and including no servers at all, and you should run a password-protected screen blanker. Of course, given physical access to a workstation, an attacker can break any sort of security you put on it. This is definitely a problem that you should consider but you should also consider the fact that the vast majority of break-ins occur remotely, over a network, from people who do not have physical access to your workstation or servers.</p><p class=Pp>Using something like Kerberos also gives you the ability to disable or change the password for a staff account in one place and have it immediately affect all the machines the staff member may have an account on. If a staff member's account gets compromised, the ability to instantly change his password on all machines should not be underrated. With discrete passwords, changing a password on N machines can be a mess. You can also impose re-passwording restrictions with Kerberos: not only can a Kerberos ticket be made to timeout after a while, but the Kerberos system can require that the user choose a new password after a certain period of time (say, once a month).</p></section><section class=Sh><h2 class=Sh id=SECURING_ROOT__(em_ROOT_RUN_SERVERS_AND_SUID/SGID_BINARIES><a class=permalink href=#SECURING_ROOT__(em_ROOT_RUN_SERVERS_AND_SUID/SGID_BINARIES>SECURING ROOT — ROOT-RUN SERVERS AND SUID/SGID BINARIES</a></h2> The prudent sysadmin only runs the servers he needs to, no more, no less. Be aware that third party servers are often the most bug-prone. For example, running an old version of <a class=Xr href=imapd.8.html>imapd(8)</a> or <a class=Xr href=popper.8.html>popper(8)</a> (<span class=Pa>ports/mail/popper</span>) is like giving a universal root ticket out to the entire world. Never run a server that you have not checked out carefully. Many servers do not need to be run as root. For example, the <a class=Xr href=talkd.8.html>talkd(8)</a>, <a class=Xr href=comsat.8.html>comsat(8)</a>, and <a class=Xr href=fingerd.8.html>fingerd(8)</a> daemons can be run in special user “sandboxes”. A sandbox is not perfect unless you go to a large amount of trouble, but the onion approach to security still stands: if someone is able to break in through a server running in a sandbox, they still have to break out of the sandbox. The more layers the attacker must break through, the lower the likelihood of his success. Root holes have historically been found in virtually every server ever run as root, including basic system servers. If you are running a machine through which people only log in via <a class=Xr href=sshd.8.html>sshd(8)</a> and never log in via <a class=Xr href=telnetd.8.html>telnetd(8)</a> then turn off those services! <p class=Pp><span class=Ux>FreeBSD</span> now defaults to running <a class=Xr href=talkd.8.html>talkd(8)</a>, <a class=Xr href=comsat.8.html>comsat(8)</a>, and <a class=Xr href=fingerd.8.html>fingerd(8)</a> in a sandbox. Depending on whether you are installing a new system or upgrading an existing system, the special user accounts used by these sandboxes may not be installed. The prudent sysadmin would research and implement sandboxes for servers whenever possible.</p><p class=Pp>There are a number of other servers that typically do not run in sandboxes: <a class=Xr href=sendmail.8.html>sendmail(8)</a>, <a class=Xr href=popper.8.html>popper(8)</a>, <a class=Xr href=imapd.8.html>imapd(8)</a>, <a class=Xr href=ftpd.8.html>ftpd(8)</a>, and others. There are alternatives to some of these, but installing them may require more work than you are willing to put (the convenience factor strikes again). You may have to run these servers as root and rely on other mechanisms to detect break-ins that might occur through them.</p><p class=Pp>The other big potential root hole in a system are the SUID-root and SGID binaries installed on the system. Most of these binaries, such as <a class=Xr href=su.1.html>su(1)</a>, reside in <span class=Pa>/bin</span>, <span class=Pa>/sbin</span>, <span class=Pa>/usr/bin</span>, or <span class=Pa>/usr/sbin</span>. While nothing is 100% safe, the system-default SUID and SGID binaries can be considered reasonably safe. Still, root holes are occasionally found in these binaries. A root hole was found in Xlib in 1998 that made <a class=Xr href=xterm.1.html>xterm(1)</a> (<span class=Pa>ports/x11/xterm</span>) (which is typically SUID) vulnerable. It is better to be safe than sorry and the prudent sysadmin will restrict SUID binaries that only staff should run to a special group that only staff can access, and get rid of (“<code class=Li>chmod 000</code>”) any SUID binaries that nobody uses. A server with no display generally does not need an <a class=Xr href=xterm.1.html>xterm(1)</a> binary. SGID binaries can be almost as dangerous. If an intruder can break an SGID-kmem binary the intruder might be able to read <span class=Pa>/dev/kmem</span> and thus read the crypted password file, potentially compromising any passworded account. Alternatively an intruder who breaks group “<code class=Li>kmem</code>” can monitor keystrokes sent through PTYs, including PTYs used by users who log in through secure methods. An intruder that breaks the “<code class=Li>tty</code>” group can write to almost any user's TTY. If a user is running a terminal program or emulator with a keyboard-simulation feature, the intruder can potentially generate a data stream that causes the user's terminal to echo a command, which is then run as that user.</p></section><section class=Sh><h2 class=Sh id=SECURING_USER_ACCOUNTS><a class=permalink href=#SECURING_USER_ACCOUNTS>SECURING USER ACCOUNTS</a></h2> User accounts are usually the most difficult to secure. While you can impose draconian access restrictions on your staff and *-out their passwords, you may not be able to do so with any general user accounts you might have. If you do have sufficient control then you may win out and be able to secure the user accounts properly. If not, you simply have to be more vigilant in your monitoring of those accounts. Use of SSH and Kerberos for user accounts is more problematic due to the extra administration and technical support required, but still a very good solution compared to a crypted password file. </section><section class=Sh><h2 class=Sh id=SECURING_THE_PASSWORD_FILE><a class=permalink href=#SECURING_THE_PASSWORD_FILE>SECURING THE PASSWORD FILE</a></h2> The only sure fire way is to *-out as many passwords as you can and use SSH or Kerberos for access to those accounts. Even though the crypted password file (<span class=Pa>/etc/spwd.db</span>) can only be read by root, it may be possible for an intruder to obtain read access to that file even if the attacker cannot obtain root-write access. <p class=Pp>Your security scripts should always check for and report changes to the password file (see <a class=Sx href=#CHECKING_FILE_INTEGRITY>CHECKING FILE INTEGRITY</a> below).</p></section><section class=Sh><h2 class=Sh id=SECURING_THE_KERNEL_CORE,_RAW_DEVICES,_AND_FILE_SYSTEMS><a class=permalink href=#SECURING_THE_KERNEL_CORE,_RAW_DEVICES,_AND_FILE_SYSTEMS>SECURING THE KERNEL CORE, RAW DEVICES, AND FILE SYSTEMS</a></h2> If an attacker breaks root he can do just about anything, but there are certain conveniences. For example, most modern kernels have a packet sniffing device driver built in. Under <span class=Ux>FreeBSD</span> it is called the <a class=Xr href=bpf.4.html>bpf(4)</a> device. An intruder will commonly attempt to run a packet sniffer on a compromised machine. You do not need to give the intruder the capability and most systems should not have the <a class=Xr href=bpf.4.html>bpf(4)</a> device compiled in. <p class=Pp>But even if you turn off the <a class=Xr href=bpf.4.html>bpf(4)</a> device, you still have <span class=Pa>/dev/mem</span> and <span class=Pa>/dev/kmem</span> to worry about. For that matter, the intruder can still write to raw disk devices. Also, there is another kernel feature called the module loader, <a class=Xr href=kldload.8.html>kldload(8)</a>. An enterprising intruder can use a KLD module to install his own <a class=Xr href=bpf.4.html>bpf(4)</a> device or other sniffing device on a running kernel. To avoid these problems you have to run the kernel at a higher security level, at least level 1. The security level can be set with a <a class=Xr href=sysctl.8.html>sysctl(8)</a> on the <var class=Va>kern.securelevel</var> variable. Once you have set the security level to 1, write access to raw devices will be denied and special <a class=Xr href=chflags.1.html>chflags(1)</a> flags, such as <code class=Cm>schg</code>, will be enforced. You must also ensure that the <code class=Cm>schg</code> flag is set on critical startup binaries, directories, and script files — everything that gets run up to the point where the security level is set. This might be overdoing it, and upgrading the system is much more difficult when you operate at a higher security level. You may compromise and run the system at a higher security level but not set the <code class=Cm>schg</code> flag for every system file and directory under the sun. Another possibility is to simply mount <span class=Pa>/</span> and <span class=Pa>/usr</span> read-only. It should be noted that being too draconian in what you attempt to protect may prevent the all-important detection of an intrusion.</p><p class=Pp>The kernel runs with five different security levels. Any super-user process can raise the level, but no process can lower it. The security levels are:</p><dl class=Bl-tag><dt><a class=permalink href=#-1><code class=Ic id=-1>-1</code></a></dt><dd>Permanently insecure mode - always run the system in insecure mode. This is the default initial value.</dd><dt><a class=permalink href=#0><code class=Ic id=0>0</code></a></dt><dd>Insecure mode - immutable and append-only flags may be turned off. All devices may be read or written subject to their permissions.</dd><dt><a class=permalink href=#1><code class=Ic id=1>1</code></a></dt><dd>Secure mode - the system immutable and system append-only flags may not be turned off; disks for mounted file systems, <span class=Pa>/dev/mem</span> and <span class=Pa>/dev/kmem</span> may not be opened for writing; <span class=Pa>/dev/io</span> (if your platform has it) may not be opened at all; kernel modules (see <a class=Xr href=kld.4.html>kld(4)</a>) may not be loaded or unloaded. The kernel debugger may not be entered using the <var class=Va>debug.kdb.enter</var> sysctl. A panic or trap cannot be forced using the <var class=Va>debug.kdb.panic</var> and other sysctl's.</dd><dt><a class=permalink href=#2><code class=Ic id=2>2</code></a></dt><dd>Highly secure mode - same as secure mode, plus disks may not be opened for writing (except by <a class=Xr href=mount.2.html>mount(2)</a>) whether mounted or not. This level precludes tampering with file systems by unmounting them, but also inhibits running <a class=Xr href=newfs.8.html>newfs(8)</a> while the system is multi-user. <p class=Pp>In addition, kernel time changes are restricted to less than or equal to one second. Attempts to change the time by more than this will log the message “Time adjustment clamped to +1 second”.</p></dd><dt><a class=permalink href=#3><code class=Ic id=3>3</code></a></dt><dd>Network secure mode - same as highly secure mode, plus IP packet filter rules (see <a class=Xr href=ipfw.8.html>ipfw(8)</a>, <a class=Xr href=ipfirewall.4.html>ipfirewall(4)</a> and <a class=Xr href=pfctl.8.html>pfctl(8)</a>) cannot be changed and <a class=Xr href=dummynet.4.html>dummynet(4)</a> or <a class=Xr href=pf.4.html>pf(4)</a> configuration cannot be adjusted.</dd></dl><p class=Pp>The security level can be configured with variables documented in <a class=Xr href=rc.conf.5.html>rc.conf(5)</a>.</p></section><section class=Sh><h2 class=Sh id=CHECKING_FILE_INTEGRITY:_BINARIES,_CONFIG_FILES,_ETC><a class=permalink href=#CHECKING_FILE_INTEGRITY:_BINARIES,_CONFIG_FILES,_ETC>CHECKING FILE INTEGRITY: BINARIES, CONFIG FILES, ETC</a></h2> When it comes right down to it, you can only protect your core system configuration and control files so much before the convenience factor rears its ugly head. For example, using <a class=Xr href=chflags.1.html>chflags(1)</a> to set the <code class=Cm>schg</code> bit on most of the files in <span class=Pa>/</span> and <span class=Pa>/usr</span> is probably counterproductive because while it may protect the files, it also closes a detection window. The last layer of your security onion is perhaps the most important — detection. The rest of your security is pretty much useless (or, worse, presents you with a false sense of safety) if you cannot detect potential incursions. Half the job of the onion is to slow down the attacker rather than stop him in order to give the detection layer a chance to catch him in the act. <p class=Pp>The best way to detect an incursion is to look for modified, missing, or unexpected files. The best way to look for modified files is from another (often centralized) limited-access system. Writing your security scripts on the extra-secure limited-access system makes them mostly invisible to potential attackers, and this is important. In order to take maximum advantage you generally have to give the limited-access box significant access to the other machines in the business, usually either by doing a read-only NFS export of the other machines to the limited-access box, or by setting up SSH keypairs to allow the limit-access box to SSH to the other machines. Except for its network traffic, NFS is the least visible method — allowing you to monitor the file systems on each client box virtually undetected. If your limited-access server is connected to the client boxes through a switch, the NFS method is often the better choice. If your limited-access server is connected to the client boxes through a hub or through several layers of routing, the NFS method may be too insecure (network-wise) and using SSH may be the better choice even with the audit-trail tracks that SSH lays.</p><p class=Pp>Once you give a limit-access box at least read access to the client systems it is supposed to monitor, you must write scripts to do the actual monitoring. Given an NFS mount, you can write scripts out of simple system utilities such as <a class=Xr href=find.1.html>find(1)</a> and <a class=Xr href=md5.1.html>md5(1)</a>. It is best to physically <a class=Xr href=md5.1.html>md5(1)</a> the client-box files boxes at least once a day, and to test control files such as those found in <span class=Pa>/etc</span> and <span class=Pa>/usr/local/etc</span> even more often. When mismatches are found relative to the base MD5 information the limited-access machine knows is valid, it should scream at a sysadmin to go check it out. A good security script will also check for inappropriate SUID binaries and for new or deleted files on system partitions such as <span class=Pa>/</span> and <span class=Pa>/usr</span>.</p><p class=Pp>When using SSH rather than NFS, writing the security script is much more difficult. You essentially have to <a class=Xr href=scp.1.html>scp(1)</a> the scripts to the client box in order to run them, making them visible, and for safety you also need to <a class=Xr href=scp.1.html>scp(1)</a> the binaries (such as <a class=Xr href=find.1.html>find(1)</a>) that those scripts use. The <a class=Xr href=sshd.8.html>sshd(8)</a> daemon on the client box may already be compromised. All in all, using SSH may be necessary when running over unsecure links, but it is also a lot harder to deal with.</p><p class=Pp>A good security script will also check for changes to user and staff members access configuration files: <span class=Pa>.rhosts</span>, <span class=Pa>.shosts</span>, <span class=Pa>.ssh/authorized_keys</span> and so forth, files that might fall outside the purview of the MD5 check.</p><p class=Pp>If you have a huge amount of user disk space it may take too long to run through every file on those partitions. In this case, setting mount flags to disallow SUID binaries on those partitions is a good idea. The <code class=Cm>nosuid</code> option (see <a class=Xr href=mount.8.html>mount(8)</a>) is what you want to look into. I would scan them anyway at least once a week, since the object of this layer is to detect a break-in whether or not the break-in is effective.</p><p class=Pp>Process accounting (see <a class=Xr href=accton.8.html>accton(8)</a>) is a relatively low-overhead feature of the operating system which I recommend using as a post-break-in evaluation mechanism. It is especially useful in tracking down how an intruder has actually broken into a system, assuming the file is still intact after the break-in occurs.</p><p class=Pp>Finally, security scripts should process the log files and the logs themselves should be generated in as secure a manner as possible — remote syslog can be very useful. An intruder tries to cover his tracks, and log files are critical to the sysadmin trying to track down the time and method of the initial break-in. One way to keep a permanent record of the log files is to run the system console to a serial port and collect the information on a continuing basis through a secure machine monitoring the consoles.</p></section><section class=Sh><h2 class=Sh id=PARANOIA><a class=permalink href=#PARANOIA>PARANOIA</a></h2> A little paranoia never hurts. As a rule, a sysadmin can add any number of security features as long as they do not affect convenience, and can add security features that do affect convenience with some added thought. Even more importantly, a security administrator should mix it up a bit — if you use recommendations such as those given by this manual page verbatim, you give away your methodologies to the prospective attacker who also has access to this manual page. </section><section class=Sh><h2 class=Sh id=SPECIAL_SECTION_ON_DoS_ATTACKS><a class=permalink href=#SPECIAL_SECTION_ON_DoS_ATTACKS>SPECIAL SECTION ON DoS ATTACKS</a></h2> This section covers Denial of Service attacks. A DoS attack is typically a packet attack. While there is not much you can do about modern spoofed packet attacks that saturate your network, you can generally limit the damage by ensuring that the attacks cannot take down your servers. <ol class="Bl-enum Bd-indent"><li>Limiting server forks</li><li>Limiting springboard attacks (ICMP response attacks, ping broadcast, etc.)</li><li>Kernel Route Cache</li></ol><p class=Pp>A common DoS attack is against a forking server that attempts to cause the server to eat processes, file descriptors, and memory until the machine dies. The <a class=Xr href=inetd.8.html>inetd(8)</a> server has several options to limit this sort of attack. It should be noted that while it is possible to prevent a machine from going down it is not generally possible to prevent a service from being disrupted by the attack. Read the <a class=Xr href=inetd.8.html>inetd(8)</a> manual page carefully and pay specific attention to the <code class=Fl>-c</code>, <code class=Fl>-C</code>, and <code class=Fl>-R</code> options. Note that spoofed-IP attacks will circumvent the <code class=Fl>-C</code> option to <a class=Xr href=inetd.8.html>inetd(8)</a>, so typically a combination of options must be used. Some standalone servers have self-fork-limitation parameters.</p><p class=Pp>The <a class=Xr href=sendmail.8.html>sendmail(8)</a> daemon has its <code class=Fl>-OMaxDaemonChildren</code> option which tends to work much better than trying to use <a class=Xr href=sendmail.8.html>sendmail(8)</a>'s load limiting options due to the load lag. You should specify a <var class=Va>MaxDaemonChildren</var> parameter when you start <a class=Xr href=sendmail.8.html>sendmail(8)</a> high enough to handle your expected load but not so high that the computer cannot handle that number of <code class=Nm>sendmail</code>'s without falling on its face. It is also prudent to run <a class=Xr href=sendmail.8.html>sendmail(8)</a> in “queued” mode (<code class=Fl>-ODeliveryMode=queued</code>) and to run the daemon (“<code class=Nm>sendmail</code><code class=Fl>-bd</code>”) separate from the queue-runs (“<code class=Nm>sendmail</code><code class=Fl>-q15m</code>”). If you still want real-time delivery you can run the queue at a much lower interval, such as <code class=Fl>-q1m</code>, but be sure to specify a reasonable <var class=Va>MaxDaemonChildren</var> option for that <a class=Xr href=sendmail.8.html>sendmail(8)</a> to prevent cascade failures.</p><p class=Pp>The <a class=Xr href=syslogd.8.html>syslogd(8)</a> daemon can be attacked directly and it is strongly recommended that you use the <code class=Fl>-s</code> option whenever possible, and the <code class=Fl>-a</code> option otherwise.</p><p class=Pp>You should also be fairly careful with connect-back services such as tcpwrapper's reverse-identd, which can be attacked directly. You generally do not want to use the reverse-ident feature of tcpwrappers for this reason.</p><p class=Pp>It is a very good idea to protect internal services from external access by firewalling them off at your border routers. The idea here is to prevent saturation attacks from outside your LAN, not so much to protect internal services from network-based root compromise. Always configure an exclusive firewall, i.e., ‘firewall everything <i class=Em>except</i> ports A, B, C, D, and M-Z’. This way you can firewall off all of your low ports except for certain specific services such as <a class=Xr href=talkd.8.html>talkd(8)</a>, <a class=Xr href=sendmail.8.html>sendmail(8)</a>, and other internet-accessible services. If you try to configure the firewall the other way — as an inclusive or permissive firewall, there is a good chance that you will forget to “close” a couple of services or that you will add a new internal service and forget to update the firewall. You can still open up the high-numbered port range on the firewall to allow permissive-like operation without compromising your low ports. Also take note that <span class=Ux>FreeBSD</span> allows you to control the range of port numbers used for dynamic binding via the various <var class=Va>net.inet.ip.portrange</var> sysctl's (“<code class=Li>sysctl net.inet.ip.portrange</code>”), which can also ease the complexity of your firewall's configuration. I usually use a normal first/last range of 4000 to 5000, and a hiport range of 49152 to 65535, then block everything under 4000 off in my firewall (except for certain specific internet-accessible ports, of course).</p><p class=Pp>Another common DoS attack is called a springboard attack — to attack a server in a manner that causes the server to generate responses which then overload the server, the local network, or some other machine. The most common attack of this nature is the ICMP PING BROADCAST attack. The attacker spoofs ping packets sent to your LAN's broadcast address with the source IP address set to the actual machine they wish to attack. If your border routers are not configured to stomp on ping's to broadcast addresses, your LAN winds up generating sufficient responses to the spoofed source address to saturate the victim, especially when the attacker uses the same trick on several dozen broadcast addresses over several dozen different networks at once. Broadcast attacks of over a hundred and twenty megabits have been measured. A second common springboard attack is against the ICMP error reporting system. By constructing packets that generate ICMP error responses, an attacker can saturate a server's incoming network and cause the server to saturate its outgoing network with ICMP responses. This type of attack can also crash the server by running it out of <var class=Vt>mbuf</var>'s, especially if the server cannot drain the ICMP responses it generates fast enough. The <span class=Ux>FreeBSD</span> kernel has a new kernel compile option called <code class=Dv>ICMP_BANDLIM</code> which limits the effectiveness of these sorts of attacks. The last major class of springboard attacks is related to certain internal <a class=Xr href=inetd.8.html>inetd(8)</a> services such as the UDP echo service. An attacker simply spoofs a UDP packet with the source address being server A's echo port, and the destination address being server B's echo port, where server A and B are both on your LAN. The two servers then bounce this one packet back and forth between each other. The attacker can overload both servers and their LANs simply by injecting a few packets in this manner. Similar problems exist with the internal chargen port. A competent sysadmin will turn off all of these <a class=Xr href=inetd.8.html>inetd(8)</a>-internal test services.</p></section><section class=Sh><h2 class=Sh id=ACCESS_ISSUES_WITH_KERBEROS_AND_SSH><a class=permalink href=#ACCESS_ISSUES_WITH_KERBEROS_AND_SSH>ACCESS ISSUES WITH KERBEROS AND SSH</a></h2> There are a few issues with both Kerberos and SSH that need to be addressed if you intend to use them. Kerberos5 is an excellent authentication protocol but the kerberized <a class=Xr href=telnet.1.html>telnet(1)</a> suck rocks. There are bugs that make them unsuitable for dealing with binary streams. Also, by default Kerberos does not encrypt a session unless you use the <code class=Fl>-x</code> option. SSH encrypts everything by default. <p class=Pp>SSH works quite well in every respect except when it is set up to forward encryption keys. What this means is that if you have a secure workstation holding keys that give you access to the rest of the system, and you <a class=Xr href=ssh.1.html>ssh(1)</a> to an unsecure machine, your keys become exposed. The actual keys themselves are not exposed, but <a class=Xr href=ssh.1.html>ssh(1)</a> installs a forwarding port for the duration of your login and if an attacker has broken root on the unsecure machine he can utilize that port to use your keys to gain access to any other machine that your keys unlock.</p><p class=Pp>We recommend that you use SSH in combination with Kerberos whenever possible for staff logins. SSH can be compiled with Kerberos support. This reduces your reliance on potentially exposable SSH keys while at the same time protecting passwords via Kerberos. SSH keys should only be used for automated tasks from secure machines (something that Kerberos is unsuited to). We also recommend that you either turn off key-forwarding in the SSH configuration, or that you make use of the <var class=Va>from</var>=<var class=Ar>IP/DOMAIN</var> option that SSH allows in its <span class=Pa>authorized_keys</span> file to make the key only usable to entities logging in from specific machines.</p></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=chflags.1.html>chflags(1)</a>, <a class=Xr href=find.1.html>find(1)</a>, <a class=Xr href=md5.1.html>md5(1)</a>, <a class=Xr href=netstat.1.html>netstat(1)</a>, <a class=Xr href=openssl.1.html>openssl(1)</a>, <a class=Xr href=ssh.1.html>ssh(1)</a>, <a class=Xr href=xdm.1.html>xdm(1)</a> (<span class=Pa>ports/x11/xorg-clients</span>), <a class=Xr href=group.5.html>group(5)</a>, <a class=Xr href=ttys.5.html>ttys(5)</a>, <a class=Xr href=accton.8.html>accton(8)</a>, <a class=Xr href=init.8.html>init(8)</a>, <a class=Xr href=sshd.8.html>sshd(8)</a>, <a class=Xr href=sysctl.8.html>sysctl(8)</a>, <a class=Xr href=syslogd.8.html>syslogd(8)</a>, <a class=Xr href=vipw.8.html>vipw(8)</a></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> The <code class=Nm>security</code> manual page was originally written by <span class=An>Matthew Dillon</span> and first appeared in <span class=Ux>FreeBSD 3.1</span>, December 1998. </section></div><table class=foot><tr><td class=foot-date>August 13, 2019</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>