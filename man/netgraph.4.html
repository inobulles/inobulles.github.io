<!DOCTYPE html>
<html><head><meta charset=utf-8><title>netgraph(4)</title><keywords content=man,netgraph></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>netgraph(4)</h1><table class=head><tr><td class=head-ltitle>NETGRAPH(4)</td><td class=head-vol>FreeBSD Kernel Interfaces Manual</td><td class=head-rtitle>NETGRAPH(4)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>netgraph</code> — <div class=Nd>graph based kernel networking subsystem</div></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> The <code class=Nm>netgraph</code> system provides a uniform and modular system for the implementation of kernel objects which perform various networking functions. The objects, known as <i class=Em>nodes</i>, can be arranged into arbitrarily complicated graphs. Nodes have <i class=Em>hooks</i> which are used to connect two nodes together, forming the edges in the graph. Nodes communicate along the edges to process data, implement protocols, etc. <p class=Pp>The aim of <code class=Nm>netgraph</code> is to supplement rather than replace the existing kernel networking infrastructure. It provides:</p><p class=Pp></p><ul class="Bl-bullet Bl-compact"><li>A flexible way of combining protocol and link level drivers.</li><li>A modular way to implement new protocols.</li><li>A common framework for kernel entities to inter-communicate.</li><li>A reasonably fast, kernel-based implementation.</li></ul><section class=Ss><h2 class=Ss id=Nodes_and_Types><a class=permalink href=#Nodes_and_Types>Nodes and Types</a></h2> The most fundamental concept in <code class=Nm>netgraph</code> is that of a <i class=Em>node</i>. All nodes implement a number of predefined methods which allow them to interact with other nodes in a well defined manner. <p class=Pp>Each node has a <i class=Em>type</i>, which is a static property of the node determined at node creation time. A node's type is described by a unique ASCII type name. The type implies what the node does and how it may be connected to other nodes.</p><p class=Pp>In object-oriented language, types are classes, and nodes are instances of their respective class. All node types are subclasses of the generic node type, and hence inherit certain common functionality and capabilities (e.g., the ability to have an ASCII name).</p><p class=Pp>Nodes may be assigned a globally unique ASCII name which can be used to refer to the node. The name must not contain the characters ‘<code class=Li>.</code>’ or ‘<code class=Li>:</code>’, and is limited to <code class=Dv>NG_NODESIZ</code> characters (including the terminating <code class=Dv>NUL</code> character).</p><p class=Pp>Each node instance has a unique <i class=Em>ID number</i> which is expressed as a 32-bit hexadecimal value. This value may be used to refer to a node when there is no ASCII name assigned to it.</p></section><section class=Ss><h2 class=Ss id=Hooks><a class=permalink href=#Hooks>Hooks</a></h2> Nodes are connected to other nodes by connecting a pair of <i class=Em>hooks</i>, one from each node. Data flows bidirectionally between nodes along connected pairs of hooks. A node may have as many hooks as it needs, and may assign whatever meaning it wants to a hook. <p class=Pp>Hooks have these properties:</p><ul class=Bl-bullet><li>A hook has an ASCII name which is unique among all hooks on that node (other hooks on other nodes may have the same name). The name must not contain the characters ‘<code class=Li>.</code>’ or ‘<code class=Li>:</code>’, and is limited to <code class=Dv>NG_HOOKSIZ</code> characters (including the terminating <code class=Dv>NUL</code> character).</li><li>A hook is always connected to another hook. That is, hooks are created at the time they are connected, and breaking an edge by removing either hook destroys both hooks.</li><li>A hook can be set into a state where incoming packets are always queued by the input queueing system, rather than being delivered directly. This can be used when the data is sent from an interrupt handler, and processing must be quick so as not to block other interrupts.</li><li>A hook may supply overriding receive data and receive message functions, which should be used for data and messages received through that hook in preference to the general node-wide methods.</li></ul><p class=Pp>A node may decide to assign special meaning to some hooks. For example, connecting to the hook named <var class=Va>debug</var> might trigger the node to start sending debugging information to that hook.</p></section><section class=Ss><h2 class=Ss id=Data_Flow><a class=permalink href=#Data_Flow>Data Flow</a></h2> Two types of information flow between nodes: data messages and control messages. Data messages are passed in <var class=Vt>mbuf chains</var> along the edges in the graph, one edge at a time. The first <var class=Vt>mbuf</var> in a chain must have the <code class=Dv>M_PKTHDR</code> flag set. Each node decides how to handle data received through one of its hooks. <p class=Pp>Along with data, nodes can also receive control messages. There are generic and type-specific control messages. Control messages have a common header format, followed by type-specific data, and are binary structures for efficiency. However, node types may also support conversion of the type-specific data between binary and ASCII formats, for debugging and human interface purposes (see the <code class=Dv>NGM_ASCII2BINARY</code> and <code class=Dv>NGM_BINARY2ASCII</code> generic control messages below). Nodes are not required to support these conversions.</p><p class=Pp>There are three ways to address a control message. If there is a sequence of edges connecting the two nodes, the message may be “source routed” by specifying the corresponding sequence of ASCII hook names as the destination address for the message (relative addressing). If the destination is adjacent to the source, then the source node may simply specify (as a pointer in the code) the hook across which the message should be sent. Otherwise, the recipient node's global ASCII name (or equivalent ID-based name) is used as the destination address for the message (absolute addressing). The two types of ASCII addressing may be combined, by specifying an absolute start node and a sequence of hooks. Only the ASCII addressing modes are available to control programs outside the kernel; use of direct pointers is limited to kernel modules.</p><p class=Pp>Messages often represent commands that are followed by a reply message in the reverse direction. To facilitate this, the recipient of a control message is supplied with a “return address” that is suitable for addressing a reply.</p><p class=Pp>Each control message contains a 32-bit value, called a “typecookie”, indicating the type of the message, i.e. how to interpret it. Typically each type defines a unique typecookie for the messages that it understands. However, a node may choose to recognize and implement more than one type of messages.</p><p class=Pp>If a message is delivered to an address that implies that it arrived at that node through a particular hook (as opposed to having been directly addressed using its ID or global name) then that hook is identified to the receiving node. This allows a message to be re-routed or passed on, should a node decide that this is required, in much the same way that data packets are passed around between nodes. A set of standard messages for flow control and link management purposes are defined by the base system that are usually passed around in this manner. Flow control message would usually travel in the opposite direction to the data to which they pertain.</p></section><section class=Ss><h2 class=Ss id=Netgraph_is_(Usually)_Functional><a class=permalink href=#Netgraph_is_(Usually)_Functional>Netgraph is (Usually) Functional</a></h2> In order to minimize latency, most <code class=Nm>netgraph</code> operations are functional. That is, data and control messages are delivered by making function calls rather than by using queues and mailboxes. For example, if node A wishes to send a data <var class=Vt>mbuf</var> to neighboring node B, it calls the generic <code class=Nm>netgraph</code> data delivery function. This function in turn locates node B and calls B's “receive data” method. There are exceptions to this. <p class=Pp>Each node has an input queue, and some operations can be considered to be <i class=Em>writers</i> in that they alter the state of the node. Obviously, in an SMP world it would be bad if the state of a node were changed while another data packet were transiting the node. For this purpose, the input queue implements a <i class=Em>reader/writer</i> semantic so that when there is a writer in the node, all other requests are queued, and while there are readers, a writer, and any following packets are queued. In the case where there is no reason to queue the data, the input method is called directly, as mentioned above.</p><p class=Pp>A node may declare that all requests should be considered as writers, or that requests coming in over a particular hook should be considered to be a writer, or even that packets leaving or entering across a particular hook should always be queued, rather than delivered directly (often useful for interrupt routines who want to get back to the hardware quickly). By default, all control message packets are considered to be writers unless specifically declared to be a reader in their definition. (See <code class=Dv>NGM_READONLY</code> in <code class=In>&lt;<a class=In href=../src/netgraph/ng_message.h.html>netgraph/ng_message.h</a>&gt;</code>.)</p><p class=Pp>While this mode of operation results in good performance, it has a few implications for node developers:</p><ul class=Bl-bullet><li>Whenever a node delivers a data or control message, the node may need to allow for the possibility of receiving a returning message before the original delivery function call returns.</li><li><code class=Nm>Netgraph</code> provides internal synchronization between nodes. Data always enters a “graph” at an <i class=Em>edge node</i>. An <i class=Em>edge node</i> is a node that interfaces between <code class=Nm>netgraph</code> and some other part of the system. Examples of “edge nodes” include device drivers, the <var class=Vt>socket</var>, <var class=Vt>ether</var>, <var class=Vt>tty</var>, and <var class=Vt>ksocket</var> node type. In these <i class=Em>edge nodes</i>, the calling thread directly executes code in the node, and from that code calls upon the <code class=Nm>netgraph</code> framework to deliver data across some edge in the graph. From an execution point of view, the calling thread will execute the <code class=Nm>netgraph</code> framework methods, and if it can acquire a lock to do so, the input methods of the next node. This continues until either the data is discarded or queued for some device or system entity, or the thread is unable to acquire a lock on the next node. In that case, the data is queued for the node, and execution rewinds back to the original calling entity. The queued data will be picked up and processed by either the current holder of the lock when they have completed their operations, or by a special <code class=Nm>netgraph</code> thread that is activated when there are such items queued.</li><li>It is possible for an infinite loop to occur if the graph contains cycles.</li></ul><p class=Pp>So far, these issues have not proven problematical in practice.</p></section><section class=Ss><h2 class=Ss id=Interaction_with_Other_Parts_of_the_Kernel><a class=permalink href=#Interaction_with_Other_Parts_of_the_Kernel>Interaction with Other Parts of the Kernel</a></h2> A node may have a hidden interaction with other components of the kernel outside of the <code class=Nm>netgraph</code> subsystem, such as device hardware, kernel protocol stacks, etc. In fact, one of the benefits of <code class=Nm>netgraph</code> is the ability to join disparate kernel networking entities together in a consistent communication framework. <p class=Pp>An example is the <var class=Vt>socket</var> node type which is both a <code class=Nm>netgraph</code> node and a <a class=Xr href=socket.2.html>socket(2)</a> in the protocol family <code class=Dv>PF_NETGRAPH</code>. Socket nodes allow user processes to participate in <code class=Nm>netgraph</code>. Other nodes communicate with socket nodes using the usual methods, and the node hides the fact that it is also passing information to and from a cooperating user process.</p><p class=Pp>Another example is a device driver that presents a node interface to the hardware.</p></section><section class=Ss><h2 class=Ss id=Node_Methods><a class=permalink href=#Node_Methods>Node Methods</a></h2> Nodes are notified of the following actions via function calls to the following node methods, and may accept or reject that action (by returning the appropriate error code): <dl class=Bl-tag><dt>Creation of a new node</dt><dd>The constructor for the type is called. If creation of a new node is allowed, constructor method may allocate any special resources it needs. For nodes that correspond to hardware, this is typically done during the device attach routine. Often a global ASCII name corresponding to the device name is assigned here as well.</dd><dt>Creation of a new hook</dt><dd>The hook is created and tentatively linked to the node, and the node is told about the name that will be used to describe this hook. The node sets up any special data structures it needs, or may reject the connection, based on the name of the hook.</dd><dt>Successful connection of two hooks</dt><dd>After both ends have accepted their hooks, and the links have been made, the nodes get a chance to find out who their peer is across the link, and can then decide to reject the connection. Tear-down is automatic. This is also the time at which a node may decide whether to set a particular hook (or its peer) into the <i class=Em>queueing</i> mode.</dd><dt>Destruction of a hook</dt><dd>The node is notified of a broken connection. The node may consider some hooks to be critical to operation and others to be expendable: the disconnection of one hook may be an acceptable event while for another it may effect a total shutdown for the node.</dd><dt>Preshutdown of a node</dt><dd>This method is called before real shutdown, which is discussed below. While in this method, the node is fully operational and can send a “goodbye” message to its peers, or it can exclude itself from the chain and reconnect its peers together, like the <a class=Xr href=ng_tee.4.html>ng_tee(4)</a> node type does.</dd><dt>Shutdown of a node</dt><dd>This method allows a node to clean up and to ensure that any actions that need to be performed at this time are taken. The method is called by the generic (i.e., superclass) node destructor which will get rid of the generic components of the node. Some nodes (usually associated with a piece of hardware) may be <i class=Em>persistent</i> in that a shutdown breaks all edges and resets the node, but does not remove it. In this case, the shutdown method should not free its resources, but rather, clean up and then call the <code class=Fn>NG_NODE_REVIVE</code>() macro to signal the generic code that the shutdown is aborted. In the case where the shutdown is started by the node itself due to hardware removal or unloading (via <code class=Fn>ng_rmnode_self</code>()), it should set the <code class=Dv>NGF_REALLY_DIE</code> flag to signal to its own shutdown method that it is not to persist.</dd></dl></section><section class=Ss><h2 class=Ss id=Sending_and_Receiving_Data><a class=permalink href=#Sending_and_Receiving_Data>Sending and Receiving Data</a></h2> Two other methods are also supported by all nodes: <dl class=Bl-tag><dt>Receive data message</dt><dd>A <code class=Nm>netgraph</code><i class=Em>queueable request item</i>, usually referred to as an <i class=Em>item</i>, is received by this function. The item contains a pointer to an <var class=Vt>mbuf</var>. <p class=Pp>The node is notified on which hook the item has arrived, and can use this information in its processing decision. The receiving node must always <code class=Fn>NG_FREE_M</code>() the <var class=Vt>mbuf chain</var> on completion or error, or pass it on to another node (or kernel module) which will then be responsible for freeing it. Similarly, the <i class=Em>item</i> must be freed if it is not to be passed on to another node, by using the <code class=Fn>NG_FREE_ITEM</code>() macro. If the item still holds references to <var class=Vt>mbufs</var> at the time of freeing then they will also be appropriately freed. Therefore, if there is any chance that the <var class=Vt>mbuf</var> will be changed or freed separately from the item, it is very important that it be retrieved using the <code class=Fn>NGI_GET_M</code>() macro that also removes the reference within the item. (Or multiple frees of the same object will occur.)</p><p class=Pp>If it is only required to examine the contents of the <var class=Vt>mbufs</var>, then it is possible to use the <code class=Fn>NGI_M</code>() macro to both read and rewrite <var class=Vt>mbuf</var> pointer inside the item.</p><p class=Pp>If developer needs to pass any meta information along with the <var class=Vt>mbuf chain</var>, he should use <a class=Xr href=mbuf_tags.9.html>mbuf_tags(9)</a> framework.</p><div class="Bf Sy">Note that old <code class=Nm>netgraph</code> specific meta-data format is obsoleted now.</div><p class=Pp>The receiving node may decide to defer the data by queueing it in the <code class=Nm>netgraph</code> NETISR system (see below). It achieves this by setting the <code class=Dv>HK_QUEUE</code> flag in the flags word of the hook on which that data will arrive. The infrastructure will respect that bit and queue the data for delivery at a later time, rather than deliver it directly. A node may decide to set the bit on the <i class=Em>peer</i> node, so that its own output packets are queued.</p><p class=Pp>The node may elect to nominate a different receive data function for data received on a particular hook, to simplify coding. It uses the <code class=Fn>NG_HOOK_SET_RCVDATA</code>(<var class=Fa>hook</var>, <var class=Fa>fn</var>) macro to do this. The function receives the same arguments in every way other than it will receive all (and only) packets from that hook.</p></dd><dt>Receive control message</dt><dd>This method is called when a control message is addressed to the node. As with the received data, an <i class=Em>item</i> is received, with a pointer to the control message. The message can be examined using the <code class=Fn>NGI_MSG</code>() macro, or completely extracted from the item using the <code class=Fn>NGI_GET_MSG</code>() which also removes the reference within the item. If the item still holds a reference to the message when it is freed (using the <code class=Fn>NG_FREE_ITEM</code>() macro), then the message will also be freed appropriately. If the reference has been removed, the node must free the message itself using the <code class=Fn>NG_FREE_MSG</code>() macro. A return address is always supplied, giving the address of the node that originated the message so a reply message can be sent anytime later. The return address is retrieved from the <i class=Em>item</i> using the <code class=Fn>NGI_RETADDR</code>() macro and is of type <var class=Vt>ng_ID_t</var>. All control messages and replies are allocated with the <a class=Xr href=malloc.9.html>malloc(9)</a> type <code class=Dv>M_NETGRAPH_MSG</code>, however it is more convenient to use the <code class=Fn>NG_MKMESSAGE</code>() and <code class=Fn>NG_MKRESPONSE</code>() macros to allocate and fill out a message. Messages must be freed using the <code class=Fn>NG_FREE_MSG</code>() macro. <p class=Pp>If the message was delivered via a specific hook, that hook will also be made known, which allows the use of such things as flow-control messages, and status change messages, where the node may want to forward the message out another hook to that on which it arrived.</p><p class=Pp>The node may elect to nominate a different receive message function for messages received on a particular hook, to simplify coding. It uses the <code class=Fn>NG_HOOK_SET_RCVMSG</code>(<var class=Fa>hook</var>, <var class=Fa>fn</var>) macro to do this. The function receives the same arguments in every way other than it will receive all (and only) messages from that hook.</p></dd></dl><p class=Pp>Much use has been made of reference counts, so that nodes being freed of all references are automatically freed, and this behaviour has been tested and debugged to present a consistent and trustworthy framework for the “type module” writer to use.</p></section><section class=Ss><h2 class=Ss id=Addressing><a class=permalink href=#Addressing>Addressing</a></h2> The <code class=Nm>netgraph</code> framework provides an unambiguous and simple to use method of specifically addressing any single node in the graph. The naming of a node is independent of its type, in that another node, or external component need not know anything about the node's type in order to address it so as to send it a generic message type. Node and hook names should be chosen so as to make addresses meaningful. <p class=Pp>Addresses are either absolute or relative. An absolute address begins with a node name or ID, followed by a colon, followed by a sequence of hook names separated by periods. This addresses the node reached by starting at the named node and following the specified sequence of hooks. A relative address includes only the sequence of hook names, implicitly starting hook traversal at the local node.</p><p class=Pp>There are a couple of special possibilities for the node name. The name ‘<code class=Li>.</code>’ (referred to as ‘<code class=Li>.:</code>’) always refers to the local node. Also, nodes that have no global name may be addressed by their ID numbers, by enclosing the hexadecimal representation of the ID number within the square brackets. Here are some examples of valid <code class=Nm>netgraph</code> addresses:</p><div class="Bd Pp Bd-indent"><pre>
.:
[3f]:
foo:
.:hook1
foo:hook1.hook2
[d80]:hook1
</pre></div><p class=Pp>The following set of nodes might be created for a site with a single physical frame relay line having two active logical DLCI channels, with RFC 1490 frames on DLCI 16 and PPP frames over DLCI 20:</p><div class="Bd Pp"><pre>
[type SYNC ]                  [type FRAME]                 [type RFC1490]
[ "Frame1" ](uplink)&lt;--&gt;(data)[&lt;un-named&gt;](dlci16)&lt;--&gt;(mux)[&lt;un-named&gt;  ]
[    A     ]                  [    B     ](dlci20)&lt;---+    [     C      ]
                                                      |
                                                      |      [ type PPP ]
                                                      +&gt;(mux)[&lt;un-named&gt;]
                                                             [    D     ]
</pre></div><p class=Pp>One could always send a control message to node C from anywhere by using the name “<code class=Li>Frame1:uplink.dlci16</code>”. In this case, node C would also be notified that the message reached it via its hook <var class=Va>mux</var>. Similarly, “<code class=Li>Frame1:uplink.dlci20</code>” could reliably be used to reach node D, and node A could refer to node B as “<code class=Li>.:uplink</code>”, or simply “<code class=Li>uplink</code>”. Conversely, B can refer to A as “<code class=Li>data</code>”. The address “<code class=Li>mux.data</code>” could be used by both nodes C and D to address a message to node A.</p><p class=Pp>Note that this is only for <i class=Em>control messages</i>. In each of these cases, where a relative addressing mode is used, the recipient is notified of the hook on which the message arrived, as well as the originating node. This allows the option of hop-by-hop distribution of messages and state information. Data messages are <i class=Em>only</i> routed one hop at a time, by specifying the departing hook, with each node making the next routing decision. So when B receives a frame on hook <var class=Va>data</var>, it decodes the frame relay header to determine the DLCI, and then forwards the unwrapped frame to either C or D.</p><p class=Pp>In a similar way, flow control messages may be routed in the reverse direction to outgoing data. For example a “buffer nearly full” message from “<code class=Li>Frame1:</code>” would be passed to node B which might decide to send similar messages to both nodes C and D. The nodes would use <i class=Em>direct hook pointer</i> addressing to route the messages. The message may have travelled from “<code class=Li>Frame1:</code>” to B as a synchronous reply, saving time and cycles.</p></section><section class=Ss><h2 class=Ss id=Netgraph_Structures><a class=permalink href=#Netgraph_Structures>Netgraph Structures</a></h2> Structures are defined in <code class=In>&lt;<a class=In href=../src/netgraph/netgraph.h.html>netgraph/netgraph.h</a>&gt;</code> (for kernel structures only of interest to nodes) and <code class=In>&lt;<a class=In href=../src/netgraph/ng_message.h.html>netgraph/ng_message.h</a>&gt;</code> (for message definitions also of interest to user programs). <p class=Pp>The two basic object types that are of interest to node authors are <i class=Em>nodes</i> and <i class=Em>hooks</i>. These two objects have the following properties that are also of interest to the node writers.</p><dl class=Bl-tag><dt><var class=Vt>struct ng_node</var></dt><dd>Node authors should always use the following <code class=Ic>typedef</code> to declare their pointers, and should never actually declare the structure. <p class=Pp><code class=Fd>typedef struct ng_node *node_p;</code></p><p class=Pp>The following properties are associated with a node, and can be accessed in the following manner:</p><dl class=Bl-tag><dt>Validity</dt><dd>A driver or interrupt routine may want to check whether the node is still valid. It is assumed that the caller holds a reference on the node so it will not have been freed, however it may have been disabled or otherwise shut down. Using the <code class=Fn>NG_NODE_IS_VALID</code>(<var class=Fa>node</var>) macro will return this state. Eventually it should be almost impossible for code to run in an invalid node but at this time that work has not been completed.</dd><dt>Node ID (<var class=Vt>ng_ID_t</var>)</dt><dd>This property can be retrieved using the macro <code class=Fn>NG_NODE_ID</code>(<var class=Fa>node</var>).</dd><dt>Node name</dt><dd>Optional globally unique name, <code class=Dv>NUL</code> terminated string. If there is a value in here, it is the name of the node. <div class="Bd Pp Bd-indent"><pre>
if (NG_NODE_NAME(node)[0] != '\0') ...

if (strcmp(NG_NODE_NAME(node), "fred") == 0) ...
        </pre></div></dd><dt>A node dependent opaque cookie</dt><dd>Anything of the pointer type can be placed here. The macros <code class=Fn>NG_NODE_SET_PRIVATE</code>(<var class=Fa>node</var>, <var class=Fa>value</var>) and <code class=Fn>NG_NODE_PRIVATE</code>(<var class=Fa>node</var>) set and retrieve this property, respectively.</dd><dt>Number of hooks</dt><dd>The <code class=Fn>NG_NODE_NUMHOOKS</code>(<var class=Fa>node</var>) macro is used to retrieve this value.</dd><dt>Hooks</dt><dd>The node may have a number of hooks. A traversal method is provided to allow all the hooks to be tested for some condition. <code class=Fn>NG_NODE_FOREACH_HOOK</code>(<var class=Fa>node</var>, <var class=Fa>fn</var>, <var class=Fa>arg</var>, <var class=Fa>rethook</var>) where <var class=Fa>fn</var> is a function that will be called for each hook with the form <code class=Fn>fn</code>(<var class=Fa>hook</var>, <var class=Fa>arg</var>) and returning 0 to terminate the search. If the search is terminated, then <var class=Fa>rethook</var> will be set to the hook at which the search was terminated.</dd></dl></dd><dt><var class=Vt>struct ng_hook</var></dt><dd>Node authors should always use the following <code class=Ic>typedef</code> to declare their hook pointers. <p class=Pp><code class=Fd>typedef struct ng_hook *hook_p;</code></p><p class=Pp>The following properties are associated with a hook, and can be accessed in the following manner:</p><dl class=Bl-tag><dt>A hook dependent opaque cookie</dt><dd>Anything of the pointer type can be placed here. The macros <code class=Fn>NG_HOOK_SET_PRIVATE</code>(<var class=Fa>hook</var>, <var class=Fa>value</var>) and <code class=Fn>NG_HOOK_PRIVATE</code>(<var class=Fa>hook</var>) set and retrieve this property, respectively.</dd><dt>An associate node</dt><dd>The macro <code class=Fn>NG_HOOK_NODE</code>(<var class=Fa>hook</var>) finds the associated node.</dd><dt>A peer hook (<var class=Vt>hook_p</var>)</dt><dd>The other hook in this connected pair. The <code class=Fn>NG_HOOK_PEER</code>(<var class=Fa>hook</var>) macro finds the peer.</dd><dt>References</dt><dd>The <code class=Fn>NG_HOOK_REF</code>(<var class=Fa>hook</var>) and <code class=Fn>NG_HOOK_UNREF</code>(<var class=Fa>hook</var>) macros increment and decrement the hook reference count accordingly. After decrement you should always assume the hook has been freed unless you have another reference still valid.</dd><dt>Override receive functions</dt><dd>The <code class=Fn>NG_HOOK_SET_RCVDATA</code>(<var class=Fa>hook</var>, <var class=Fa>fn</var>) and <code class=Fn>NG_HOOK_SET_RCVMSG</code>(<var class=Fa>hook</var>, <var class=Fa>fn</var>) macros can be used to set override methods that will be used in preference to the generic receive data and receive message functions. To unset these, use the macros to set them to <code class=Dv>NULL</code>. They will only be used for data and messages received on the hook on which they are set.</dd></dl><p class=Pp>The maintenance of the names, reference counts, and linked list of hooks for each node is handled automatically by the <code class=Nm>netgraph</code> subsystem. Typically a node's private info contains a back-pointer to the node or hook structure, which counts as a new reference that must be included in the reference count for the node. When the node constructor is called, there is already a reference for this calculated in, so that when the node is destroyed, it should remember to do a <code class=Fn>NG_NODE_UNREF</code>() on the node.</p><p class=Pp>From a hook you can obtain the corresponding node, and from a node, it is possible to traverse all the active hooks.</p><p class=Pp>A current example of how to define a node can always be seen in <span class=Pa>src/sys/netgraph/ng_sample.c</span> and should be used as a starting point for new node writers.</p></dd></dl></section><section class=Ss><h2 class=Ss id=Netgraph_Message_Structure><a class=permalink href=#Netgraph_Message_Structure>Netgraph Message Structure</a></h2> Control messages have the following structure: <div class="Bd Pp"><pre>
#define NG_CMDSTRSIZ    32      /* Max command string (including null) */

struct ng_mesg {
  struct ng_msghdr {
    u_char      version;        /* Must equal NG_VERSION */
    u_char      spare;          /* Pad to 4 bytes */
    uint16_t    spare2;
    uint32_t    arglen;         /* Length of cmd/resp data */
    uint32_t    cmd;            /* Command identifier */
    uint32_t    flags;          /* Message status flags */
    uint32_t    token;          /* Reply should have the same token */
    uint32_t    typecookie;     /* Node type understanding this message */
    u_char      cmdstr[NG_CMDSTRSIZ];  /* cmd string +   */
  } header;
  char  data[];                 /* placeholder for actual data */
};

#define NG_ABI_VERSION  12              /* Netgraph kernel ABI version */
#define NG_VERSION      8               /* Netgraph message version */
#define NGF_ORIG        0x00000000      /* The msg is the original request */
#define NGF_RESP        0x00000001      /* The message is a response */
</pre></div><p class=Pp>Control messages have the fixed header shown above, followed by a variable length data section which depends on the type cookie and the command. Each field is explained below:</p><dl class=Bl-tag><dt><var class=Va>version</var></dt><dd>Indicates the version of the <code class=Nm>netgraph</code> message protocol itself. The current version is <code class=Dv>NG_VERSION</code>.</dd><dt><var class=Va>arglen</var></dt><dd>This is the length of any extra arguments, which begin at <var class=Va>data</var>.</dd><dt><var class=Va>flags</var></dt><dd>Indicates whether this is a command or a response control message.</dd><dt><var class=Va>token</var></dt><dd>The <var class=Va>token</var> is a means by which a sender can match a reply message to the corresponding command message; the reply always has the same token.</dd><dt><var class=Va>typecookie</var></dt><dd>The corresponding node type's unique 32-bit value. If a node does not recognize the type cookie it must reject the message by returning <code class=Er>EINVAL</code>. <p class=Pp>Each type should have an include file that defines the commands, argument format, and cookie for its own messages. The typecookie ensures that the same header file was included by both sender and receiver; when an incompatible change in the header file is made, the typecookie <i class=Em>must</i> be changed. The de-facto method for generating unique type cookies is to take the seconds from the Epoch at the time the header file is written (i.e., the output of “<code class=Nm>date</code><code class=Fl>-u</code><code class=Li>+%s</code>”).</p><p class=Pp>There is a predefined typecookie <code class=Dv>NGM_GENERIC_COOKIE</code> for the <var class=Vt>generic</var> node type, and a corresponding set of generic messages which all nodes understand. The handling of these messages is automatic.</p></dd><dt><var class=Va>cmd</var></dt><dd>The identifier for the message command. This is type specific, and is defined in the same header file as the typecookie.</dd><dt><var class=Va>cmdstr</var></dt><dd>Room for a short human readable version of <var class=Va>command</var> (for debugging purposes only).</dd></dl><p class=Pp>Some modules may choose to implement messages from more than one of the header files and thus recognize more than one type cookie.</p></section><section class=Ss><h2 class=Ss id=Control_Message_ASCII_Form><a class=permalink href=#Control_Message_ASCII_Form>Control Message ASCII Form</a></h2> Control messages are in binary format for efficiency. However, for debugging and human interface purposes, and if the node type supports it, control messages may be converted to and from an equivalent ASCII form. The ASCII form is similar to the binary form, with two exceptions: <ol class=Bl-enum><li>The <var class=Va>cmdstr</var> header field must contain the ASCII name of the command, corresponding to the <var class=Va>cmd</var> header field.</li><li>The arguments field contains a <code class=Dv>NUL</code>-terminated ASCII string version of the message arguments.</li></ol><p class=Pp>In general, the arguments field of a control message can be any arbitrary C data type. <code class=Nm>Netgraph</code> includes parsing routines to support some pre-defined datatypes in ASCII with this simple syntax:</p><ul class=Bl-bullet><li>Integer types are represented by base 8, 10, or 16 numbers.</li><li>Strings are enclosed in double quotes and respect the normal C language backslash escapes.</li><li>IP addresses have the obvious form.</li><li>Arrays are enclosed in square brackets, with the elements listed consecutively starting at index zero. An element may have an optional index and equals sign (‘<code class=Li>=</code>’) preceding it. Whenever an element does not have an explicit index, the index is implicitly the previous element's index plus one.</li><li>Structures are enclosed in curly braces, and each field is specified in the form <var class=Ar>fieldname</var>=<var class=Ar>value</var>.</li><li>Any array element or structure field whose value is equal to its “default value” may be omitted. For integer types, the default value is usually zero; for string types, the empty string.</li><li>Array elements and structure fields may be specified in any order.</li></ul><p class=Pp>Each node type may define its own arbitrary types by providing the necessary routines to parse and unparse. ASCII forms defined for a specific node type are documented in the corresponding man page.</p></section><section class=Ss><h2 class=Ss id=Generic_Control_Messages><a class=permalink href=#Generic_Control_Messages>Generic Control Messages</a></h2> There are a number of standard predefined messages that will work for any node, as they are supported directly by the framework itself. These are defined in <code class=In>&lt;<a class=In href=../src/netgraph/ng_message.h.html>netgraph/ng_message.h</a>&gt;</code> along with the basic layout of messages and other similar information. <dl class=Bl-tag><dt><a class=permalink href=#NGM_CONNECT><code class=Dv id=NGM_CONNECT>NGM_CONNECT</code></a></dt><dd>Connect to another node, using the supplied hook names on either end.</dd><dt><a class=permalink href=#NGM_MKPEER><code class=Dv id=NGM_MKPEER>NGM_MKPEER</code></a></dt><dd>Construct a node of the given type and then connect to it using the supplied hook names.</dd><dt><a class=permalink href=#NGM_SHUTDOWN><code class=Dv id=NGM_SHUTDOWN>NGM_SHUTDOWN</code></a></dt><dd>The target node should disconnect from all its neighbours and shut down. Persistent nodes such as those representing physical hardware might not disappear from the node namespace, but only reset themselves. The node must disconnect all of its hooks. This may result in neighbors shutting themselves down, and possibly a cascading shutdown of the entire connected graph.</dd><dt><a class=permalink href=#NGM_NAME><code class=Dv id=NGM_NAME>NGM_NAME</code></a></dt><dd>Assign a name to a node. Nodes can exist without having a name, and this is the default for nodes created using the <code class=Dv>NGM_MKPEER</code> method. Such nodes can only be addressed relatively or by their ID number.</dd><dt><a class=permalink href=#NGM_RMHOOK><code class=Dv id=NGM_RMHOOK>NGM_RMHOOK</code></a></dt><dd>Ask the node to break a hook connection to one of its neighbours. Both nodes will have their “disconnect” method invoked. Either node may elect to totally shut down as a result.</dd><dt><a class=permalink href=#NGM_NODEINFO><code class=Dv id=NGM_NODEINFO>NGM_NODEINFO</code></a></dt><dd>Asks the target node to describe itself. The four returned fields are the node name (if named), the node type, the node ID and the number of hooks attached. The ID is an internal number unique to that node.</dd><dt><a class=permalink href=#NGM_LISTHOOKS><code class=Dv id=NGM_LISTHOOKS>NGM_LISTHOOKS</code></a></dt><dd>This returns the information given by <code class=Dv>NGM_NODEINFO</code>, but in addition includes an array of fields describing each link, and the description for the node at the far end of that link.</dd><dt><a class=permalink href=#NGM_LISTNAMES><code class=Dv id=NGM_LISTNAMES>NGM_LISTNAMES</code></a></dt><dd>This returns an array of node descriptions (as for <code class=Dv>NGM_NODEINFO</code>) where each entry of the array describes a named node. All named nodes will be described.</dd><dt><a class=permalink href=#NGM_LISTNODES><code class=Dv id=NGM_LISTNODES>NGM_LISTNODES</code></a></dt><dd>This is the same as <code class=Dv>NGM_LISTNAMES</code> except that all nodes are listed regardless of whether they have a name or not.</dd><dt><a class=permalink href=#NGM_LISTTYPES><code class=Dv id=NGM_LISTTYPES>NGM_LISTTYPES</code></a></dt><dd>This returns a list of all currently installed <code class=Nm>netgraph</code> types.</dd><dt><a class=permalink href=#NGM_TEXT_STATUS><code class=Dv id=NGM_TEXT_STATUS>NGM_TEXT_STATUS</code></a></dt><dd>The node may return a text formatted status message. The status information is determined entirely by the node type. It is the only “generic” message that requires any support within the node itself and as such the node may elect to not support this message. The text response must be less than <code class=Dv>NG_TEXTRESPONSE</code> bytes in length (presently 1024). This can be used to return general status information in human readable form.</dd><dt><a class=permalink href=#NGM_BINARY2ASCII><code class=Dv id=NGM_BINARY2ASCII>NGM_BINARY2ASCII</code></a></dt><dd>This message converts a binary control message to its ASCII form. The entire control message to be converted is contained within the arguments field of the <code class=Dv>NGM_BINARY2ASCII</code> message itself. If successful, the reply will contain the same control message in ASCII form. A node will typically only know how to translate messages that it itself understands, so the target node of the <code class=Dv>NGM_BINARY2ASCII</code> is often the same node that would actually receive that message.</dd><dt><a class=permalink href=#NGM_ASCII2BINARY><code class=Dv id=NGM_ASCII2BINARY>NGM_ASCII2BINARY</code></a></dt><dd>The opposite of <code class=Dv>NGM_BINARY2ASCII</code>. The entire control message to be converted, in ASCII form, is contained in the arguments section of the <code class=Dv>NGM_ASCII2BINARY</code> and need only have the <var class=Va>flags</var>, <var class=Va>cmdstr</var>, and <var class=Va>arglen</var> header fields filled in, plus the <code class=Dv>NUL</code>-terminated string version of the arguments in the arguments field. If successful, the reply contains the binary version of the control message.</dd></dl></section><section class=Ss><h2 class=Ss id=Flow_Control_Messages><a class=permalink href=#Flow_Control_Messages>Flow Control Messages</a></h2> In addition to the control messages that affect nodes with respect to the graph, there are also a number of <i class=Em>flow control</i> messages defined. At present these are <i class=Em>not</i> handled automatically by the system, so nodes need to handle them if they are going to be used in a graph utilising flow control, and will be in the likely path of these messages. The default action of a node that does not understand these messages should be to pass them onto the next node. Hopefully some helper functions will assist in this eventually. These messages are also defined in <code class=In>&lt;<a class=In href=../src/netgraph/ng_message.h.html>netgraph/ng_message.h</a>&gt;</code> and have a separate cookie <code class=Dv>NG_FLOW_COOKIE</code> to help identify them. They will not be covered in depth here. </section></section><section class=Sh><h2 class=Sh id=INITIALIZATION><a class=permalink href=#INITIALIZATION>INITIALIZATION</a></h2> The base <code class=Nm>netgraph</code> code may either be statically compiled into the kernel or else loaded dynamically as a KLD via <a class=Xr href=kldload.8.html>kldload(8)</a>. In the former case, include <p class=Pp></p><div class="Bd Bd-indent"><code class=Cd>options NETGRAPH</code></div><p class=Pp>in your kernel configuration file. You may also include selected node types in the kernel compilation, for example:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Cd>options NETGRAPH</code></div><div class="Bd Bd-indent"><code class=Cd>options NETGRAPH_SOCKET</code></div><div class="Bd Bd-indent"><code class=Cd>options NETGRAPH_ECHO</code></div><p class=Pp>Once the <code class=Nm>netgraph</code> subsystem is loaded, individual node types may be loaded at any time as KLD modules via <a class=Xr href=kldload.8.html>kldload(8)</a>. Moreover, <code class=Nm>netgraph</code> knows how to automatically do this; when a request to create a new node of unknown type <var class=Ar>type</var> is made, <code class=Nm>netgraph</code> will attempt to load the KLD module <span class=Pa>ng_</span>⟨<var class=Ar>type</var>⟩<span class=Pa>.ko</span>.</p><p class=Pp>Types can also be installed at boot time, as certain device drivers may want to export each instance of the device as a <code class=Nm>netgraph</code> node.</p><p class=Pp>In general, new types can be installed at any time from within the kernel by calling <code class=Fn>ng_newtype</code>(), supplying a pointer to the type's <var class=Vt>struct ng_type</var> structure.</p><p class=Pp>The <code class=Fn>NETGRAPH_INIT</code>() macro automates this process by using a linker set.</p></section><section class=Sh><h2 class=Sh id=EXISTING_NODE_TYPES><a class=permalink href=#EXISTING_NODE_TYPES>EXISTING NODE TYPES</a></h2> Several node types currently exist. Each is fully documented in its own man page: <dl class=Bl-tag><dt>SOCKET</dt><dd>The socket type implements two new sockets in the new protocol domain <code class=Dv>PF_NETGRAPH</code>. The new sockets protocols are <code class=Dv>NG_DATA</code> and <code class=Dv>NG_CONTROL</code>, both of type <code class=Dv>SOCK_DGRAM</code>. Typically one of each is associated with a socket node. When both sockets have closed, the node will shut down. The <code class=Dv>NG_DATA</code> socket is used for sending and receiving data, while the <code class=Dv>NG_CONTROL</code> socket is used for sending and receiving control messages. Data and control messages are passed using the <a class=Xr href=sendto.2.html>sendto(2)</a> and <a class=Xr href=recvfrom.2.html>recvfrom(2)</a> system calls, using a <var class=Vt>struct sockaddr_ng</var> socket address.</dd><dt>HOLE</dt><dd>Responds only to generic messages and is a “black hole” for data. Useful for testing. Always accepts new hooks.</dd><dt>ECHO</dt><dd>Responds only to generic messages and always echoes data back through the hook from which it arrived. Returns any non-generic messages as their own response. Useful for testing. Always accepts new hooks.</dd><dt>TEE</dt><dd>This node is useful for “snooping”. It has 4 hooks: <var class=Va>left</var>, <var class=Va>right</var>, <var class=Va>left2right</var>, and <var class=Va>right2left</var>. Data entering from the <var class=Va>right</var> is passed to the <var class=Va>left</var> and duplicated on <var class=Va>right2left</var>, and data entering from the <var class=Va>left</var> is passed to the <var class=Va>right</var> and duplicated on <var class=Va>left2right</var>. Data entering from <var class=Va>left2right</var> is sent to the <var class=Va>right</var> and data from <var class=Va>right2left</var> to <var class=Va>left</var>.</dd><dt>RFC1490 MUX</dt><dd>Encapsulates/de-encapsulates frames encoded according to RFC 1490. Has a hook for the encapsulated packets (<var class=Va>downstream</var>) and one hook for each protocol (i.e., IP, PPP, etc.).</dd><dt>FRAME RELAY MUX</dt><dd>Encapsulates/de-encapsulates Frame Relay frames. Has a hook for the encapsulated packets (<var class=Va>downstream</var>) and one hook for each DLCI.</dd><dt>FRAME RELAY LMI</dt><dd>Automatically handles frame relay “LMI” (link management interface) operations and packets. Automatically probes and detects which of several LMI standards is in use at the exchange.</dd><dt>TTY</dt><dd>This node is also a line discipline. It simply converts between <var class=Vt>mbuf</var> frames and sequential serial data, allowing a TTY to appear as a <code class=Nm>netgraph</code> node. It has a programmable “hotkey” character.</dd><dt>ASYNC</dt><dd>This node encapsulates and de-encapsulates asynchronous frames according to RFC 1662. This is used in conjunction with the TTY node type for supporting PPP links over asynchronous serial lines.</dd><dt>ETHERNET</dt><dd>This node is attached to every Ethernet interface in the system. It allows capturing raw Ethernet frames from the network, as well as sending frames out of the interface.</dd><dt>INTERFACE</dt><dd>This node is also a system networking interface. It has hooks representing each protocol family (IP, IPv6) and appears in the output of <a class=Xr href=ifconfig.8.html>ifconfig(8)</a>. The interfaces are named “<code class=Li>ng0</code>”, “<code class=Li>ng1</code>”, etc.</dd><dt>ONE2MANY</dt><dd>This node implements a simple round-robin multiplexer. It can be used for example to make several LAN ports act together to get a higher speed link between two machines.</dd><dt>Various PPP related nodes</dt><dd>There is a full multilink PPP implementation that runs in <code class=Nm>netgraph</code>. The <span class=Pa>net/mpd5</span> port can use these modules to make a very low latency high capacity PPP system. It also supports PPTP VPNs using the PPTP node.</dd><dt>PPPOE</dt><dd>A server and client side implementation of PPPoE. Used in conjunction with either <a class=Xr href=ppp.8.html>ppp(8)</a> or the <span class=Pa>net/mpd5</span> port.</dd><dt>BRIDGE</dt><dd>This node, together with the Ethernet nodes, allows a very flexible bridging system to be implemented.</dd><dt>KSOCKET</dt><dd>This intriguing node looks like a socket to the system but diverts all data to and from the <code class=Nm>netgraph</code> system for further processing. This allows such things as UDP tunnels to be almost trivially implemented from the command line.</dd></dl><p class=Pp>Refer to the section at the end of this man page for more nodes types.</p></section><section class=Sh><h2 class=Sh id=NOTES><a class=permalink href=#NOTES>NOTES</a></h2> Whether a named node exists can be checked by trying to send a control message to it (e.g., <code class=Dv>NGM_NODEINFO</code>). If it does not exist, <code class=Er>ENOENT</code> will be returned. <p class=Pp>All data messages are <var class=Vt>mbuf chains</var> with the <code class=Dv>M_PKTHDR</code> flag set.</p><p class=Pp>Nodes are responsible for freeing what they allocate. There are three exceptions:</p><ol class=Bl-enum><li><var class=Vt>Mbufs</var> sent across a data link are never to be freed by the sender. In the case of error, they should be considered freed.</li><li>Messages sent using one of <code class=Fn>NG_SEND_MSG_*</code>() family macros are freed by the recipient. As in the case above, the addresses associated with the message are freed by whatever allocated them so the recipient should copy them if it wants to keep that information.</li><li>Both control messages and data are delivered and queued with a <code class=Nm>netgraph</code><i class=Em>item</i>. The item must be freed using <code class=Fn>NG_FREE_ITEM</code>(<var class=Fa>item</var>) or passed on to another node.</li></ol></section><section class=Sh><h2 class=Sh id=FILES><a class=permalink href=#FILES>FILES</a></h2><dl class=Bl-tag><dt><code class=In>&lt;<a class=In href=../src/netgraph/netgraph.h.html>netgraph/netgraph.h</a>&gt;</code></dt><dd>Definitions for use solely within the kernel by <code class=Nm>netgraph</code> nodes.</dd><dt><code class=In>&lt;<a class=In href=../src/netgraph/ng_message.h.html>netgraph/ng_message.h</a>&gt;</code></dt><dd>Definitions needed by any file that needs to deal with <code class=Nm>netgraph</code> messages.</dd><dt><code class=In>&lt;<a class=In href=../src/netgraph/ng_socket.h.html>netgraph/ng_socket.h</a>&gt;</code></dt><dd>Definitions needed to use <code class=Nm>netgraph</code><var class=Vt>socket</var> type nodes.</dd><dt><code class=In>&lt;<a class=In href=../src/netgraph/ng_.html>netgraph/ng_</a>&gt;</code>⟨<var class=Ar>type</var>⟩<span class=Pa>.h</span></dt><dd>Definitions needed to use <code class=Nm>netgraph</code><var class=Ar>type</var> nodes, including the type cookie definition.</dd><dt><span class=Pa>/boot/kernel/netgraph.ko</span></dt><dd>The <code class=Nm>netgraph</code> subsystem loadable KLD module.</dd><dt><span class=Pa>/boot/kernel/ng_</span>⟨<var class=Ar>type</var>⟩<span class=Pa>.ko</span></dt><dd>Loadable KLD module for node type <var class=Ar>type</var>.</dd><dt><span class=Pa>src/sys/netgraph/ng_sample.c</span></dt><dd>Skeleton <code class=Nm>netgraph</code> node. Use this as a starting point for new node types.</dd></dl></section><section class=Sh><h2 class=Sh id=USER_MODE_SUPPORT><a class=permalink href=#USER_MODE_SUPPORT>USER MODE SUPPORT</a></h2> There is a library for supporting user-mode programs that wish to interact with the <code class=Nm>netgraph</code> system. See <a class=Xr href=netgraph.3.html>netgraph(3)</a> for details. <p class=Pp>Two user-mode support programs, <a class=Xr href=ngctl.8.html>ngctl(8)</a> and <a class=Xr href=nghook.8.html>nghook(8)</a>, are available to assist manual configuration and debugging.</p><p class=Pp>There are a few useful techniques for debugging new node types. First, implementing new node types in user-mode first makes debugging easier. The <var class=Vt>tee</var> node type is also useful for debugging, especially in conjunction with <a class=Xr href=ngctl.8.html>ngctl(8)</a> and <a class=Xr href=nghook.8.html>nghook(8)</a>.</p><p class=Pp>Also look in <span class=Pa>/usr/share/examples/netgraph</span> for solutions to several common networking problems, solved using <code class=Nm>netgraph</code>.</p></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=socket.2.html>socket(2)</a>, <a class=Xr href=netgraph.3.html>netgraph(3)</a>, <a class=Xr href=ng_async.4.html>ng_async(4)</a>, <a class=Xr href=ng_atm.4.html>ng_atm(4)</a>, <a class=Xr href=ng_atmllc.4.html>ng_atmllc(4)</a>, <a class=Xr href=ng_bluetooth.4.html>ng_bluetooth(4)</a>, <a class=Xr href=ng_bpf.4.html>ng_bpf(4)</a>, <a class=Xr href=ng_bridge.4.html>ng_bridge(4)</a>, <a class=Xr href=ng_btsocket.4.html>ng_btsocket(4)</a>, <a class=Xr href=ng_car.4.html>ng_car(4)</a>, <a class=Xr href=ng_cisco.4.html>ng_cisco(4)</a>, <a class=Xr href=ng_device.4.html>ng_device(4)</a>, <a class=Xr href=ng_echo.4.html>ng_echo(4)</a>, <a class=Xr href=ng_eiface.4.html>ng_eiface(4)</a>, <a class=Xr href=ng_etf.4.html>ng_etf(4)</a>, <a class=Xr href=ng_ether.4.html>ng_ether(4)</a>, <a class=Xr href=ng_frame_relay.4.html>ng_frame_relay(4)</a>, <a class=Xr href=ng_gif.4.html>ng_gif(4)</a>, <a class=Xr href=ng_gif_demux.4.html>ng_gif_demux(4)</a>, <a class=Xr href=ng_hci.4.html>ng_hci(4)</a>, <a class=Xr href=ng_hole.4.html>ng_hole(4)</a>, <a class=Xr href=ng_hub.4.html>ng_hub(4)</a>, <a class=Xr href=ng_iface.4.html>ng_iface(4)</a>, <a class=Xr href=ng_ip_input.4.html>ng_ip_input(4)</a>, <a class=Xr href=ng_ipfw.4.html>ng_ipfw(4)</a>, <a class=Xr href=ng_ksocket.4.html>ng_ksocket(4)</a>, <a class=Xr href=ng_l2cap.4.html>ng_l2cap(4)</a>, <a class=Xr href=ng_l2tp.4.html>ng_l2tp(4)</a>, <a class=Xr href=ng_lmi.4.html>ng_lmi(4)</a>, <a class=Xr href=ng_mppc.4.html>ng_mppc(4)</a>, <a class=Xr href=ng_nat.4.html>ng_nat(4)</a>, <a class=Xr href=ng_netflow.4.html>ng_netflow(4)</a>, <a class=Xr href=ng_one2many.4.html>ng_one2many(4)</a>, <a class=Xr href=ng_patch.4.html>ng_patch(4)</a>, <a class=Xr href=ng_ppp.4.html>ng_ppp(4)</a>, <a class=Xr href=ng_pppoe.4.html>ng_pppoe(4)</a>, <a class=Xr href=ng_pptpgre.4.html>ng_pptpgre(4)</a>, <a class=Xr href=ng_rfc1490.4.html>ng_rfc1490(4)</a>, <a class=Xr href=ng_socket.4.html>ng_socket(4)</a>, <a class=Xr href=ng_split.4.html>ng_split(4)</a>, <a class=Xr href=ng_sscfu.4.html>ng_sscfu(4)</a>, <a class=Xr href=ng_sscop.4.html>ng_sscop(4)</a>, <a class=Xr href=ng_tee.4.html>ng_tee(4)</a>, <a class=Xr href=ng_tty.4.html>ng_tty(4)</a>, <a class=Xr href=ng_ubt.4.html>ng_ubt(4)</a>, <a class=Xr href=ng_UI.4.html>ng_UI(4)</a>, <a class=Xr href=ng_uni.4.html>ng_uni(4)</a>, <a class=Xr href=ng_vjc.4.html>ng_vjc(4)</a>, <a class=Xr href=ng_vlan.4.html>ng_vlan(4)</a>, <a class=Xr href=ngctl.8.html>ngctl(8)</a>, <a class=Xr href=nghook.8.html>nghook(8)</a></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> The <code class=Nm>netgraph</code> system was designed and first implemented at Whistle Communications, Inc. in a version of <span class=Ux>FreeBSD 2.2</span> customized for the Whistle InterJet. It first made its debut in the main tree in <span class=Ux>FreeBSD 3.4</span>. </section><section class=Sh><h2 class=Sh id=AUTHORS><a class=permalink href=#AUTHORS>AUTHORS</a></h2><span class=An>Julian Elischer</span> &lt;<a class=Mt href=mailto:julian@FreeBSD.org>julian@FreeBSD.org</a>&gt;, with contributions by <span class=An>Archie Cobbs</span> &lt;<a class=Mt href=mailto:archie@FreeBSD.org>archie@FreeBSD.org</a>&gt;. </section></div><table class=foot><tr><td class=foot-date>September 29, 2021</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>