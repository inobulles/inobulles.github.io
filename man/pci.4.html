<!DOCTYPE html>
<html><head><meta charset=utf-8><title>pci(4)</title><keywords content=man,pci></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>pci(4)</h1><table class=head><tr><td class=head-ltitle>PCI(4)</td><td class=head-vol>FreeBSD Kernel Interfaces Manual</td><td class=head-rtitle>PCI(4)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>pci</code> — <div class=Nd>generic PCI/PCIe bus driver</div></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2> To compile the PCI bus driver into the kernel, place the following line in your kernel configuration file: <div class="Bd Pp Bd-indent"><code class=Cd>device pci</code></div><p class=Pp>To compile in support for Single Root I/O Virtualization (SR-IOV):</p><div class="Bd Pp Bd-indent"><code class=Cd>options PCI_IOV</code></div><p class=Pp>To compile in support for native PCI-express HotPlug:</p><div class="Bd Pp Bd-indent"><code class=Cd>options PCI_HP</code></div></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> The <code class=Nm>pci</code> driver provides support for PCI and PCIe devices in the kernel and limited access to PCI devices for userland. <p class=Pp>The <code class=Nm>pci</code> driver provides a <span class=Pa>/dev/pci</span> character device that can be used by userland programs to read and write PCI configuration registers. Programs can also use this device to get a list of all PCI devices, or all PCI devices that match various patterns.</p><p class=Pp>Since the <code class=Nm>pci</code> driver provides a write interface for PCI configuration registers, system administrators should exercise caution when granting access to the <code class=Nm>pci</code> device. If used improperly, this driver can allow userland applications to crash a machine or cause data loss. In particular, driver only allows operations on the opened <span class=Pa>/dev/pci</span> to modify system state if the file descriptor was opened for writing. For instance, the <code class=Dv>PCIOCREAD</code> and <code class=Dv>PCIOCBARMMAP</code> operations require a writeable descriptor, because reading a config register or a BAR read access could have function-specific side-effects.</p><p class=Pp>The <code class=Nm>pci</code> driver implements the PCI bus in the kernel. It enumerates any devices on the PCI bus and gives PCI client drivers the chance to attach to them. It assigns resources to children, when the BIOS does not. It takes care of routing interrupts when necessary. It reprobes the unattached PCI children when PCI client drivers are dynamically loaded at runtime. The <code class=Nm>pci</code> driver also includes support for PCI-PCI bridges, various platform-specific Host-PCI bridges, and basic support for PCI VGA adapters.</p></section><section class=Sh><h2 class=Sh id=IOCTLS><a class=permalink href=#IOCTLS>IOCTLS</a></h2> The following <a class=Xr href=ioctl.2.html>ioctl(2)</a> calls are supported by the <code class=Nm>pci</code> driver. They are defined in the header file <code class=In>&lt;<a class=In href=../src/sys/pciio.h.html>sys/pciio.h</a>&gt;</code>. <dl class=Bl-tag><dt>PCIOCGETCONF</dt><dd>This <a class=Xr href=ioctl.2.html>ioctl(2)</a> takes a <var class=Va>pci_conf_io</var> structure. It allows the user to retrieve information on all PCI devices in the system, or on PCI devices matching patterns supplied by the user. The call may set <var class=Va>errno</var> to any value specified in either <a class=Xr href=copyin.9.html>copyin(9)</a> or <a class=Xr href=copyout.9.html>copyout(9)</a>. The <var class=Va>pci_conf_io</var> structure consists of a number of fields: <dl class=Bl-tag><dt>pat_buf_len</dt><dd>The length, in bytes, of the buffer filled with user-supplied patterns.</dd><dt>num_patterns</dt><dd>The number of user-supplied patterns.</dd><dt>patterns</dt><dd>Pointer to a buffer filled with user-supplied patterns. <var class=Va>patterns</var> is a pointer to <var class=Va>num_patterns</var><var class=Va>pci_match_conf</var> structures. The <var class=Va>pci_match_conf</var> structure consists of the following elements: <dl class=Bl-tag><dt>pc_sel</dt><dd>PCI domain, bus, slot and function.</dd><dt>pd_name</dt><dd>PCI device driver name.</dd><dt>pd_unit</dt><dd>PCI device driver unit number.</dd><dt>pc_vendor</dt><dd>PCI vendor ID.</dd><dt>pc_device</dt><dd>PCI device ID.</dd><dt>pc_class</dt><dd>PCI device class.</dd><dt>flags</dt><dd>The flags describe which of the fields the kernel should match against. A device must match all specified fields in order to be returned. The match flags are enumerated in the <var class=Va>pci_getconf_flags</var> structure. Hopefully the flag values are obvious enough that they do not need to described in detail.</dd></dl></dd><dt>match_buf_len</dt><dd>Length of the <var class=Va>matches</var> buffer allocated by the user to hold the results of the <code class=Dv>PCIOCGETCONF</code> query.</dd><dt>num_matches</dt><dd>Number of matches returned by the kernel.</dd><dt>matches</dt><dd>Buffer containing matching devices returned by the kernel. The items in this buffer are of type <var class=Va>pci_conf</var>, which consists of the following items: <dl class=Bl-tag><dt>pc_sel</dt><dd>PCI domain, bus, slot and function.</dd><dt>pc_hdr</dt><dd>PCI header type.</dd><dt>pc_subvendor</dt><dd>PCI subvendor ID.</dd><dt>pc_subdevice</dt><dd>PCI subdevice ID.</dd><dt>pc_vendor</dt><dd>PCI vendor ID.</dd><dt>pc_device</dt><dd>PCI device ID.</dd><dt>pc_class</dt><dd>PCI device class.</dd><dt>pc_subclass</dt><dd>PCI device subclass.</dd><dt>pc_progif</dt><dd>PCI device programming interface.</dd><dt>pc_revid</dt><dd>PCI revision ID.</dd><dt>pd_name</dt><dd>Driver name.</dd><dt>pd_unit</dt><dd>Driver unit number.</dd></dl></dd><dt>offset</dt><dd>The offset is passed in by the user to tell the kernel where it should start traversing the device list. The value passed out by the kernel points to the record immediately after the last one returned. The user may pass the value returned by the kernel in subsequent calls to the <code class=Dv>PCIOCGETCONF</code> ioctl. If the user does not intend to use the offset, it must be set to zero.</dd><dt>generation</dt><dd>PCI configuration generation. This value only needs to be set if the offset is set. The kernel will compare the current generation number of its internal device list to the generation passed in by the user to determine whether its device list has changed since the user last called the <code class=Dv>PCIOCGETCONF</code> ioctl. If the device list has changed, a status of <var class=Va>PCI_GETCONF_LIST_CHANGED</var> will be passed back.</dd><dt>status</dt><dd>The status tells the user the disposition of his request for a device list. The possible status values are: <dl class=Bl-ohang><dt>PCI_GETCONF_LAST_DEVICE</dt><dd>This means that there are no more devices in the PCI device list matching the specified criteria after the ones returned in the <var class=Va>matches</var> buffer.</dd><dt>PCI_GETCONF_LIST_CHANGED</dt><dd>This status tells the user that the PCI device list has changed since his last call to the <code class=Dv>PCIOCGETCONF</code> ioctl and he must reset the <var class=Va>offset</var> and <var class=Va>generation</var> to zero to start over at the beginning of the list.</dd><dt>PCI_GETCONF_MORE_DEVS</dt><dd>This tells the user that his buffer was not large enough to hold all of the remaining devices in the device list that match his criteria.</dd><dt>PCI_GETCONF_ERROR</dt><dd>This indicates a general error while servicing the user's request. If the <var class=Va>pat_buf_len</var> is not equal to <var class=Va>num_patterns</var> times <code class=Fn>sizeof</code>(<var class=Fa>struct pci_match_conf</var>), <var class=Va>errno</var> will be set to <code class=Er>EINVAL</code>.</dd></dl></dd></dl></dd><dt>PCIOCREAD</dt><dd>This <a class=Xr href=ioctl.2.html>ioctl(2)</a> reads the PCI configuration registers specified by the passed-in <var class=Va>pci_io</var> structure. The <var class=Va>pci_io</var> structure consists of the following fields: <dl class=Bl-tag><dt>pi_sel</dt><dd>A <var class=Va>pcisel</var> structure which specifies the domain, bus, slot and function the user would like to query. If the specific bus is not found, errno will be set to ENODEV and -1 returned from the ioctl.</dd><dt>pi_reg</dt><dd>The PCI configuration registers the user would like to access.</dd><dt>pi_width</dt><dd>The width, in bytes, of the data the user would like to read. This value may be either 1, 2, or 4. 3-byte reads and reads larger than 4 bytes are not supported. If an invalid width is passed, errno will be set to EINVAL.</dd><dt>pi_data</dt><dd>The data returned by the kernel.</dd></dl></dd><dt>PCIOCWRITE</dt><dd>This <a class=Xr href=ioctl.2.html>ioctl(2)</a> allows users to write to the PCI configuration registers specified in the passed-in <var class=Va>pci_io</var> structure. The <var class=Va>pci_io</var> structure is described above. The limitations on data width described for reading registers, above, also apply to writing PCI configuration registers.</dd><dt>PCIOCATTACHED</dt><dd>This <a class=Xr href=ioctl.2.html>ioctl(2)</a> allows users to query if a driver is attached to the PCI device specified in the passed-in <var class=Va>pci_io</var> structure. The <var class=Va>pci_io</var> structure is described above, however, the <var class=Va>pi_reg</var> and <var class=Va>pi_width</var> fields are not used. The status of the device is stored in the <var class=Va>pi_data</var> field. A value of 0 indicates no driver is attached, while a value larger than 0 indicates that a driver is attached.</dd><dt>PCIOCBARMMAP</dt><dd>This <a class=Xr href=ioctl.2.html>ioctl(2)</a> command allows userspace processes to <a class=Xr href=mmap.2.html>mmap(2)</a> the memory-mapped PCI BAR into its address space. The input parameters and results are passed in the <var class=Va>pci_bar_mmap</var> structure, which has the following fields: <dl class=Bl-tag><dt><var class=Vt>uint64_t pbm_map_base</var></dt><dd>Reports the established mapping base to the caller. If <var class=Va>PCIIO_BAR_MMAP_FIXED</var> flag was specified, then this field must be filled before the call with the desired address for the mapping.</dd><dt><var class=Vt>uint64_t pbm_map_length</var></dt><dd>Reports the mapped length of the BAR, in bytes. Its .Vt uint64_t value is always multiple of machine pages.</dd><dt><var class=Vt>int64_t pbm_bar_length</var></dt><dd>Reports length of the bar as exposed by the device.</dd><dt><var class=Vt>int pbm_bar_off</var></dt><dd>Reports offset from the mapped base to the start of the first register in the bar.</dd><dt><var class=Vt>struct pcisel pbm_sel</var></dt><dd>Should be filled before the call. Describes the device to operate on.</dd><dt><var class=Vt>int pbm_reg</var></dt><dd>The BAR index to mmap.</dd><dt><var class=Vt>int pbm_flags</var></dt><dd>Flags which augments the operation. See below.</dd><dt><var class=Vt>int pbm_memattr</var></dt><dd>The caching attribute for the mapping. Typical values are <code class=Dv>VM_MEMATTR_UNCACHEABLE</code> for control registers BARs, and <code class=Dv>VM_MEMATTR_WRITE_COMBINING</code> for frame buffers. Regular memory-like BAR should be mapped with <code class=Dv>VM_MEMATTR_DEFAULT</code> attribute.</dd></dl><p class=Pp>Currently defined flags are:</p><dl class=Bl-tag><dt>PCIIO_BAR_MMAP_FIXED</dt><dd>The resulted mappings should be established at the address specified by the <var class=Va>pbm_map_base</var> member, otherwise fail.</dd><dt>PCIIO_BAR_MMAP_EXCL</dt><dd>Must be used together with <code class=Dv>PCIIO_BAR_MMAP_FIXED</code> If the specified base contains already established mappings, the operation fails instead of implicitly unmapping them.</dd><dt>PCIIO_BAR_MMAP_RW</dt><dd>The requested mapping allows both reading and writing. Without the flag, read-only mapping is established. Note that it is common for the device registers to have side-effects even on reads.</dd><dt>PCIIO_BAR_MMAP_ACTIVATE</dt><dd>(Unimplemented) If the BAR is not activated, activate it in the course of mapping. Currently attempt to mmap an inactive BAR results in error.</dd></dl></dd><dt>PCIOCBARIO</dt><dd>This <a class=Xr href=ioctl.2.html>ioctl(2)</a> command allows users to read from and write to BARs. The I/O request parameters are passed in a <var class=Va>struct pci_bar_ioreq</var> structure, which has the following fields: <dl class=Bl-tag><dt><var class=Vt>struct pcisel pbi_sel</var></dt><dd>Describes the device to operate on.</dd><dt><var class=Vt>int pbi_op</var></dt><dd>The operation to perform. Currently supported values are <code class=Dv>PCIBARIO_READ</code> and <code class=Dv>PCIBARIO_WRITE</code>.</dd><dt><var class=Vt>uint32_t pbi_bar</var></dt><dd>The index of the BAR on which to operate.</dd><dt><var class=Vt>uint32_t pbi_offset</var></dt><dd>The offset into the BAR at which to operate.</dd><dt><var class=Vt>uint32_t pbi_width</var></dt><dd>The size, in bytes, of the I/O operation. 1-byte, 2-byte, 4-byte and 8-byte perations are supported.</dd><dt><var class=Vt>uint32_t pbi_value</var></dt><dd>For reads, the value is returned in this field. For writes, the caller specifies the value to be written in this field. <p class=Pp>Note that this operation maps and unmaps the corresponding resource and so is relatively expensive for memory BARs. The <var class=Va>PCIOCBARMMAP</var><a class=Xr href=ioctl.2.html>ioctl(2)</a> can be used to create a persistent userspace mapping for such BARs instead.</p></dd></dl></dd></dl></section><section class=Sh><h2 class=Sh id=LOADER_TUNABLES><a class=permalink href=#LOADER_TUNABLES>LOADER TUNABLES</a></h2> Tunables can be set at the <a class=Xr href=loader.8.html>loader(8)</a> prompt before booting the kernel, or stored in <a class=Xr href=loader.conf.5.html>loader.conf(5)</a>. The current value of these tunables can be examined at runtime via <a class=Xr href=sysctl.8.html>sysctl(8)</a> nodes of the same name. Unless otherwise specified, each of these tunables is a boolean that can be enabled by setting the tunable to a non-zero value. <dl class=Bl-tag><dt><var class=Va>hw.pci.clear_bars</var> (Defaults to 0)</dt><dd>Ignore any firmware-assigned memory and I/O port resources. This forces the PCI bus driver to allocate resource ranges for memory and I/O port resources from scratch.</dd><dt><var class=Va>hw.pci.clear_buses</var> (Defaults to 0)</dt><dd>Ignore any firmware-assigned bus number registers in PCI-PCI bridges. This forces the PCI bus driver and PCI-PCI bridge driver to allocate bus numbers for secondary buses behind PCI-PCI bridges.</dd><dt><var class=Va>hw.pci.clear_pcib</var> (Defaults to 0)</dt><dd>Ignore any firmware-assigned memory and I/O port resource windows in PCI-PCI bridges. This forces the PCI-PCI bridge driver to allocate memory and I/O port resources for resource windows from scratch. <p class=Pp>By default the PCI-PCI bridge driver will allocate windows that contain the firmware-assigned resources devices behind the bridge. In addition, the PCI-PCI bridge driver will suballocate from existing window regions when possible to satisfy a resource request. As a result, both <var class=Va>hw.pci.clear_bars</var> and <var class=Va>hw.pci.clear_pcib</var> must be enabled to fully ignore firmware-supplied resource assignments.</p></dd><dt><var class=Va>hw.pci.default_vgapci_unit</var> (Defaults to -1)</dt><dd>By default, the first PCI VGA adapter encountered by the system is assumed to be the boot display device. This tunable can be set to choose a specific VGA adapter by specifying the unit number of the associated <var class=Va>vgapci</var><var class=Ar>X</var> device.</dd><dt><var class=Va>hw.pci.do_power_nodriver</var> (Defaults to 0)</dt><dd>Place devices into a low power state (D3) when a suitable device driver is not found. Can be set to one of the following values: <dl class=Bl-tag><dt>3</dt><dd>Powers down all PCI devices without a device driver.</dd><dt>2</dt><dd>Powers down most devices without a device driver. PCI devices with the display, memory, and base peripheral device classes are not powered down.</dd><dt>1</dt><dd>Similar to a setting of 2 except that storage controllers are also not powered down.</dd><dt>0</dt><dd>All devices are left fully powered.</dd></dl><p class=Pp>A PCI device must support power management to be powered down. Placing a device into a low power state may not reduce power consumption.</p></dd><dt><var class=Va>hw.pci.do_power_resume</var> (Defaults to 1)</dt><dd>Place PCI devices into the fully powered state when resuming either the system or an individual device. Setting this to zero is discouraged as the system will not attempt to power up non-powered PCI devices after a suspend.</dd><dt><var class=Va>hw.pci.do_power_suspend</var> (Defaults to 1)</dt><dd>Place PCI devices into a low power state when suspending either the system or individual devices. Normally the D3 state is used as the low power state, but firmware may override the desired power state during a system suspend.</dd><dt><var class=Va>hw.pci.enable_ari</var> (Defaults to 1)</dt><dd>Enable support for PCI-express Alternative RID Interpretation. This is often used in conjunction with SR-IOV.</dd><dt><var class=Va>hw.pci.enable_io_modes</var> (Defaults to 1)</dt><dd>Enable memory or I/O port decoding in a PCI device's command register if it has firmware-assigned memory or I/O port resources. The firmware (BIOS) in some systems does not enable memory or I/O port decoding for some devices even when it has assigned resources to the device. This enables decoding for such resources during bus probe.</dd><dt><var class=Va>hw.pci.enable_msi</var> (Defaults to 1)</dt><dd>Enable support for Message Signalled Interrupts (MSI). MSI interrupts can be disabled by setting this tunable to 0.</dd><dt><var class=Va>hw.pci.enable_msix</var> (Defaults to 1)</dt><dd>Enable support for extended Message Signalled Interrupts (MSI-X). MSI-X interrupts can be disabled by setting this tunable to 0.</dd><dt><var class=Va>hw.pci.enable_pcie_hp</var> (Defaults to 1)</dt><dd>Enable support for native PCI-express HotPlug.</dd><dt><var class=Va>hw.pci.honor_msi_blacklist</var> (Defaults to 1)</dt><dd>MSI and MSI-X interrupts are disabled for certain chipsets known to have broken MSI and MSI-X implementations when this tunable is set. It can be set to zero to permit use of MSI and MSI-X interrupts if the chipset match is a false positive.</dd><dt><var class=Va>hw.pci.iov_max_config</var> (Defaults to 1MB)</dt><dd>The maximum amount of memory permitted for the configuration parameters used when creating Virtual Functions via SR-IOV. This tunable can also be changed at runtime via <a class=Xr href=sysctl.8.html>sysctl(8)</a>.</dd><dt><var class=Va>hw.pci.realloc_bars</var> (Defaults to 0)</dt><dd>Attempt to allocate a new resource range during the initial device scan for any memory or I/O port resources with firmware-assigned ranges that conflict with another active resource.</dd><dt><var class=Va>hw.pci.usb_early_takeover</var> (Defaults to 1 on amd64 and i386)</dt><dd>Disable legacy device emulation of USB devices during the initial device scan. Set this tunable to zero to use USB devices via legacy emulation when using a custom kernel without USB controller drivers.</dd><dt><var class=Va>hw.pci&lt;D&gt;.&lt;B&gt;.&lt;S&gt;.INT&lt;P&gt;.irq</var></dt><dd>These tunables can be used to override the interrupt routing for legacy PCI INTx interrupts. Unlike other tunables in this list, these do not have corresponding sysctl nodes. The tunable name includes the address of the PCI device as well as the pin of the desired INTx IRQ to override: <dl class=Bl-tag><dt>&lt;D&gt;</dt><dd>The domain (or segment) of the PCI device in decimal.</dd><dt>&lt;B&gt;</dt><dd>The bus address of the PCI device in decimal.</dd><dt>&lt;S&gt;</dt><dd>The slot of the PCI device in decimal.</dd><dt>&lt;P&gt;</dt><dd>The interrupt pin of the PCI slot to override. One of ‘<code class=Li>A</code>’, ‘<code class=Li>B</code>’, ‘<code class=Li>C</code>’, or ‘<code class=Li>D</code>’.</dd></dl><p class=Pp>The value of the tunable is the raw IRQ value to use for the INTx interrupt pin identified by the tunable name. Mapping of IRQ values to platform interrupt sources is machine dependent.</p></dd></dl></section><section class=Sh><h2 class=Sh id=DEVICE_WIRING><a class=permalink href=#DEVICE_WIRING>DEVICE WIRING</a></h2> You can wire the device unit at a given location with device.hints. Entries of the form <var class=Va>hints.&lt;name&gt;.&lt;unit&gt;.at="pci&lt;B&gt;:&lt;S&gt;:&lt;F&gt;"</var> or <var class=Va>hints.&lt;name&gt;.&lt;unit&gt;.at="pci&lt;D&gt;:&lt;B&gt;:&lt;S&gt;:&lt;F&gt;"</var> will force the driver <var class=Va>name</var> to probe and attach at unit <var class=Va>unit</var> for any PCI device found to match the specification, where: <dl class=Bl-tag><dt>&lt;D&gt;</dt><dd>The domain (or segment) of the PCI device in decimal. Defaults to 0 if unspecified</dd><dt>&lt;B&gt;</dt><dd>The bus address of the PCI device in decimal.</dd><dt>&lt;S&gt;</dt><dd>The slot of the PCI device in decimal.</dd><dt>&lt;F&gt;</dt><dd>The function of the PCI device in decimal.</dd></dl><p class=Pp>The code to do the matching requires an exact string match. Do not specify the angle brackets (&lt; &gt;) in the hints file. Wiring multiple devices to the same <var class=Va>name</var> and <var class=Va>unit</var> produces undefined results.</p><section class=Ss><h2 class=Ss id=Examples><a class=permalink href=#Examples>Examples</a></h2> Given the following lines in <span class=Pa>/boot/device.hints</span>: <code class=Cd>hint.nvme.3.at="pci6:0:0"</code><code class=Cd>hint.igb.8.at="pci14:0:0"</code> If there is a device that supports <a class=Xr href=igb.4.html>igb(4)</a> at PCI bus 14 slot 0 function 0, then it will be assigned igb8 for probe and attach. Likewise, if there is an <a class=Xr href=nvme.4.html>nvme(4)</a> card at PCI bus 6 slot 0 function 0, then it will be assigned nvme3 for probe and attach. If another type of card is in either of these locations, the name and unit of that card will be the default names and will be unaffected by these hints. If other igb or nvme cards are located elsewhere, they will be assigned their unit numbers sequentially, skipping the unit numbers that have 'at' hints. </section></section><section class=Sh><h2 class=Sh id=FILES><a class=permalink href=#FILES>FILES</a></h2><dl class="Bl-tag Bl-compact"><dt><span class=Pa>/dev/pci</span></dt><dd>Character device for the <code class=Nm>pci</code> driver.</dd></dl></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=pciconf.8.html>pciconf(8)</a></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> The <code class=Nm>pci</code> driver (not the kernel's PCI support code) first appeared in <span class=Ux>FreeBSD 2.2</span>, and was written by Stefan Esser and Garrett Wollman. Support for device listing and matching was re-implemented by Kenneth Merry, and first appeared in <span class=Ux>FreeBSD 3.0</span>. </section><section class=Sh><h2 class=Sh id=AUTHORS><a class=permalink href=#AUTHORS>AUTHORS</a></h2><span class=An>Kenneth Merry</span> &lt;<a class=Mt href=mailto:ken@FreeBSD.org>ken@FreeBSD.org</a>&gt; </section><section class=Sh><h2 class=Sh id=BUGS><a class=permalink href=#BUGS>BUGS</a></h2> It is not possible for users to specify an accurate offset into the device list without calling the <code class=Dv>PCIOCGETCONF</code> at least once, since they have no way of knowing the current generation number otherwise. This probably is not a serious problem, though, since users can easily narrow their search by specifying a pattern or patterns for the kernel to match against. </section></div><table class=foot><tr><td class=foot-date>August 13, 2021</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>