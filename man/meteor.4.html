<!DOCTYPE html>
<html><head><meta charset=utf-8><title>meteor(4)</title><keywords content=man,meteor></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>meteor(4)</h1><table class=head><tr><td class=head-ltitle>METEOR(4)</td><td class=head-vol>FreeBSD Kernel Interfaces Manual</td><td class=head-rtitle>METEOR(4)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>meteor</code> — <div class=Nd>video capture driver interface</div></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> The <code class=Nm>meteor</code> driver defined a video capture interface. The <code class=Nm>meteor</code> driver is no longer in the tree, but other devices support this interface so the interface portion is documented here. <section class=Ss><h2 class=Ss id=Meteor_Capture_Modes><a class=permalink href=#Meteor_Capture_Modes>Meteor Capture Modes</a></h2> The <code class=Nm>meteor</code> capture driver has three modes of capture operation. <ol class=Bl-enum><li>Conventional <a class=Xr href=read.2.html>read(2)</a> interface. <p class=Pp>This mode is the easiest and slowest to use. This mode is great for capturing a single field at little programming cost.</p><p class=Pp>In this mode, the user opens the device, sets the capture mode and size (see: <code class=Dv>METEORSETGEO</code><a class=Xr href=ioctl.2.html>ioctl(2)</a> call), and uses the <a class=Xr href=read.2.html>read(2)</a> system call to load the data into a buffer.</p><p class=Pp><span class=Pa>meteor_read.c</span>; read 400x300 RGB24 into a viewable PPM file</p><div class="Bd Pp"><pre>
#include &lt;sys/fcntl.h&gt;
#include &lt;machine/ioctl_meteor.h&gt;

extern int errno;
#define ROWS 300
#define COLS 400
#define SIZE (ROWS * COLS * 4)
main()
{
	struct meteor_geomet geo;
	char buf[SIZE],b[4],header[16],*p;
	int i,o,c;

	if ((i = open("/dev/meteor0", O_RDONLY)) &lt; 0) {
		printf("open failed: %d\n", errno);
		exit(1);
	}
	/* set up the capture type and size */
        geo.rows = ROWS;
        geo.columns = COLS;
        geo.frames = 1;
        geo.oformat = METEOR_GEO_RGB24 ;

        if (ioctl(i, METEORSETGEO, &amp;geo) &lt; 0) {
		printf("ioctl failed: %d\n", errno);
		exit(1);
	}

	c = METEOR_FMT_NTSC;

        if (ioctl(i, METEORSFMT, &amp;c) &lt; 0) {
		printf("ioctl failed: %d\n", errno);
		exit(1);
	}

	c = METEOR_INPUT_DEV0;

        if (ioctl(i, METEORSINPUT, &amp;c) &lt; 0) {
		printf("ioctl failed: %d\n", errno);
		exit(1);
	}

	if ((c=read(i, &amp;buf[0], SIZE)) &lt; SIZE) {
		printf("read failed %d %d %d\n", c, i, errno);
		close(i);
		exit(1);
	}
	close(i);

	if ((o = open("rgb24.ppm", O_WRONLY | O_CREAT, 0644)) &lt; 0) {
		printf("ppm open failed: %d\n", errno);
		exit(1);
	}

	/* make PPM header and save to file */
	strcpy(&amp;header[0], "P6 400 300 255 ");
	header[2] = header[6]  = header[10] = header[14] = '\n';
	write (o, &amp;header[0], 15);
	/* save the RGB data to PPM file */
	for (p = &amp;buf[0]; p &lt; &amp;buf[SIZE]; ) {
		b[2] = *p++;		/* blue */
		b[1] = *p++;		/* green */
		b[0] = *p++;		/* red */
		*p++;			/* NULL byte */
		write(o,&amp;b[0], 3);	/* not very efficient */
	}
	close(o);
	exit(0);
}
    </pre></div></li><li>Memory mapped single capture or unsynchronized continuous capture. <p class=Pp>The single capture mode is designed for conferencing tools such as <code class=Nm>nv</code>. These tools need to control the starting of the image capture and also need several frames a second. The continuous capture mode is designed for applications that want free-running data.</p><p class=Pp>In this mode, the user opens the device, sets the capture mode and size (see: <code class=Dv>METEORSETGEO</code><a class=Xr href=ioctl.2.html>ioctl(2)</a> call), <a class=Xr href=mmap.2.html>mmap(2)</a>s the frame buffer memory into the user process space, and issues either the single-capture or the continuous capture call (see: <code class=Dv>METEORCAPTUR</code><a class=Xr href=ioctl.2.html>ioctl(2)</a> call) to load the data into the memory mapped buffer.</p><p class=Pp>As explained in the <code class=Dv>METEORCAPTUR</code><a class=Xr href=ioctl.2.html>ioctl(2)</a> call, the single frame capture <a class=Xr href=ioctl.2.html>ioctl(2)</a> will block until the capture is complete, the continuous capture will return immediately.</p><p class=Pp><span class=Pa>meteor_mmap_single_continuous.c</span></p><div class="Bd Pp"><pre>
#include &lt;sys/types.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/fcntl.h&gt;
#include &lt;machine/ioctl_meteor.h&gt;

extern int errno;
#define ROWS 480
#define COLS 640
#define SIZE (ROWS * COLS * 2)
main()
{
	struct meteor_geomet geo;
	char buf[SIZE];
	char *mmbuf;
	int i,c;

	if ((i = open("/dev/meteor0", O_RDONLY)) &lt; 0) {
		printf("open failed\n");
		exit(1);
	}

        geo.rows = ROWS;
        geo.columns = COLS;
        geo.frames = 1;
        geo.oformat = METEOR_GEO_RGB16 ;

        if (ioctl(i, METEORSETGEO, &amp;geo) &lt; 0) {
		printf("ioctl failed: %d\n", errno);
		exit(1);
	}

	c = METEOR_FMT_NTSC;

        if (ioctl(i, METEORSFMT, &amp;c) &lt; 0) {
		printf("ioctl failed: %d\n", errno);
		exit(1);
	}

	c = METEOR_INPUT_DEV0;

        if (ioctl(i, METEORSINPUT, &amp;c) &lt; 0) {
		printf("ioctl failed: %d\n", errno);
		exit(1);
	}

        mmbuf=(char *)mmap((caddr_t)0, SIZE, PROT_READ,
		MAP_SHARED, i, (off_t)0);

#ifdef SINGLE_MODE
	/* single frame capture */
	c = METEOR_CAP_SINGLE ;
        ioctl(i, METEORCAPTUR, &amp;c);	/* wait for the frame */

	/* directly access the frame buffer array data in mmbuf */
#else
	/* continuous frame capture */
	c = METEOR_CAP_CONTINOUS ;
        ioctl(i, METEORCAPTUR, &amp;c);	/* returns immediately */

	/* directly access the frame buffer array data in mmbuf */

	c = METEOR_CAP_STOP_CONT ;
        ioctl(i, METEORCAPTUR, &amp;c);	/* close will also stop capture */
#endif

	close(i);
	exit(0);
}
    </pre></div></li><li>Memory mapped, multi-frame ring buffer synchronize capture. <p class=Pp>This continuous capture mode is synchronized with the application that processes up to 32 frames. This gives the advantages of both single and continuous capture modes.</p><p class=Pp>The kernel notifies the application of a new data by raising an application defined signal. The driver also shares a structure with the application that allows them to communicate which frame has been written by the kernel and which frame has been read by the application.</p><p class=Pp>The shared structure starts on the first page after your data. The structure address can be found by calculation:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>(number_rows * number_columns * pixel_depth + 4095) &amp; 0xfffff000</code></div> or <div class="Bd Bd-indent"><code class=Li>((number_rows * number_columns * pixel_depth + 4095)/4096) * 4096</code></div><p class=Pp>The shared structure is of type <var class=Va>struct meteor_mem</var>. The two most important fields are called <var class=Va>active</var> and <var class=Va>num_active_buf</var>. <var class=Va>active</var> is a bitmap of frames written by the kernel. <var class=Va>num_active_bufs</var> is a count of frames marked in the <var class=Va>active</var> field. When a frame is read in by the driver, the <var class=Va>num_active_bufs</var> count is tested, if this count is below the threshold of number of active frames (value in <var class=Va>meteor_mem</var>'s <var class=Va>hiwat</var> variable), the bit representing frame number in the buffer is stored in the <var class=Va>active</var> variable, the <var class=Va>num_active_bufs</var> is incremented, the kernel then raises the specified signal to activate the user application. The user application's responsibility when getting the signal is to check the active bitmap to determine the lowest active frame, use the data as the application desires, clear the bitmap entry for that frame, and decrement the <var class=Va>num_active_bufs</var>. If the threshold of number of active frames (<var class=Va>hiwat</var>) has been exceeded, no new frames or signal from the kernel will occur until the <var class=Va>num_active_bufs</var> is less than or equal to <var class=Va>lowat</var>.</p><p class=Pp>The driver loads the frames in a round-robin fashion. It is expected that the user removes them in the same order. The driver does not check to see if the frame is already active.</p><p class=Pp>The <var class=Va>frame_size</var> and number of frames in the buffer are also provided to the <var class=Va>meteor_mem</var> structure, but changing these fields in the application will not change the operation of the driver.</p><p class=Pp>In programming for this mode, the user opens the device, sets the geometry, <a class=Xr href=mmap.2.html>mmap(2)</a>s the data/common control structure, then starts the continuous capture mode. A special signal catcher is required to process the frames as they are read by the kernel.</p><p class=Pp>When specifying the geometry (see: <code class=Dv>METEORSETGEO</code><a class=Xr href=ioctl.2.html>ioctl(2)</a> call), it is important that the number of frames is set greater than 1.</p><p class=Pp><span class=Pa>skeleton_capture_n.c</span></p><div class="Bd Pp"><pre>
#include &lt;sys/types.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/fcntl.h&gt;
#include &lt;sys/signal.h&gt;
#include &lt;machine/ioctl_meteor.h&gt;

int video;  /* made global if you wish to stop capture in signal handler */
caddr_t data_frames;
struct meteor_mem *common_mem;
extern int errno;

#define FRAME_MAX

void
usr2_catcher()
{
#ifdef SIGNAL_STOP
	struct meteor_capframe capframe;	/* for ioctl */
#endif
	char *frame;

	/* find frame */
	frame = (char *) (data_frames + sig_cnt * common_mem-&gt;frame_size) ;

	/* add frame processing here */
	/* deactivate frame */
	common_mem-&gt;active &amp;= ~(1 &lt;&lt; (sig_cnt % 16));
	common_mem-&gt;num_active_bufs--;

	/* process next frame on next interrupt */
	sig_cnt = ((sig_cnt+1) % FRAME_MAX);

#ifdef SIGNAL_STOP
	if (some_condition_requiring_stopping) {
		capframe.command=METEOR_CAP_STOP_FRAMES;

		if (ioctl(i, METEORCAPFRM, &amp;capframe) &lt; 0) {
			printf("METEORCAPFRM failed %d\n", errno);
			exit(1);
		}
	}
#endif
}

main()
{
	struct meteor_geomet geo;
	int height, width, depth, frames, size;
	struct meteor_capframe capframe;

	if ((i = open("/dev/meteor0", O_RDONLY)) &lt; 0) {
		printf("open failed\n");
		exit(1);
	}
	printf("test %d %d\n", errno, i);

        height = geo.rows = 120;
        width= geo.columns = 320;
        frames = geo.frames = FRAME_MAX;
	depth = 2;	/* 2 bytes per pixel for RGB*/


        geo.oformat = METEOR_GEO_RGB16;

        if (ioctl(i, METEORSETGEO, &amp;geo) &lt; 0) {
		printf("METEORSETGEO failed %d\n", errno);
		exit(1);
	}

	c = METEOR_FMT_NTSC;

        if (ioctl(i, METEORSFMT, &amp;c) &lt; 0) {
		printf("ioctl failed: %d\n", errno);
		exit(1);
	}

	c = METEOR_INPUT_DEV0;

        if (ioctl(i, METEORSINPUT, &amp;c) &lt; 0) {
		printf("ioctl failed: %d\n", errno);
		exit(1);
	}

	size = ((width*height*depth*frames+4095)/4096)*4096;
	/* add one page after data for meteor_mem */
	data_frames = mmap((caddr_t)0, size + 4096, PROT_READ | PROT_WRITE,
						MAP_SHARED, i, (off_t)0);

	if (data_frames == (caddr_t) MAP_FAILED) return (0);

	/* common_mem is located at page following data */
	common_mem = (struct meteor_mem *) (y + size);

	signal(SIGUSR2, usr2_catcher);	/* catch new frame message */

	capframe.command=METEOR_CAP_N_FRAMES;
	capframe.signal=SIGUSR2;
	capframe.lowat=12;		/* must be &lt; hiwat */
	capframe.hiwat=14;		/* must be &lt; FRAME_MAX */

					/* start the sync capture */
        if (ioctl(i, METEORCAPFRM, &amp;capframe) &lt; 0) {
		printf("METEORCAPFRM failed %d\n", errno);
		exit(1);
	}

	/* this is the background working area, or you can sleep */


	/* to stop capture */
	capframe.command=METEOR_CAP_STOP_FRAMES;

        if (ioctl(i, METEORCAPFRM, &amp;capframe) &lt; 0) {
		printf("METEORCAPFRM failed %d\n", errno);
		exit(1);
	}
}
    </pre></div></li></ol></section><section class=Ss><h2 class=Ss id=Meteor_IOCTL_Call_and_Parameters><a class=permalink href=#Meteor_IOCTL_Call_and_Parameters>Meteor IOCTL Call and Parameters</a></h2> The <code class=Nm>meteor</code> capture driver has <a class=Xr href=ioctl.2.html>ioctl(2)</a> requests for capturing, reading card status, for setting and reading the geometry, and for setting and reading the attributes. <p class=Pp></p><div class="Bf Sy">IT IS VERY IMPORTANT TO CHECK FOR ERRORS ON THESE RETURNING IOCTLs.</div> Errors indicate that something is very wrong with the <a class=Xr href=ioctl.2.html>ioctl(2)</a> and the application should not attempt to proceed further with capturing. The <code class=Nm>meteor</code> capture driver still makes attempts to stop the next capture step if an error occurred in a previous step but was ignored by the application programmer. <ol class=Bl-enum><li><a class=Xr href=ioctl.2.html>ioctl(2)</a> requests <code class=Dv>METEORSETGEO</code> and <code class=Dv>METEORGETGEO</code><p class=Pp><code class=Dv>METEORSETGEO</code> and <code class=Dv>METEORGETGEO</code> are used to set and read the input size, input device, and output format for frame capture.</p><p class=Pp>These <a class=Xr href=ioctl.2.html>ioctl(2)</a> routines use the <var class=Va>meteor_geomet</var> structure that has the following entries:</p><dl class=Bl-tag><dt><var class=Va>rows</var></dt><dd>number of rows (lines high) in output image</dd><dt><var class=Va>columns</var></dt><dd>number of pixels in a row (width) in output image</dd><dt><var class=Va>frames</var></dt><dd>number of frames in buffer. Should be 1, unless using the multi-framed synchronous capture mode (<code class=Dv>METEORCAPFRM</code>) which REQUIRES frames to be larger than 1. <p class=Pp>Note: if <var class=Va>rows</var>, <var class=Va>columns</var> or <var class=Va>frames</var> is not changed, then the existing values are used. The system defaults is 640x480x1.</p></dd><dt><var class=Va>oformat</var></dt><dd>you may choose one of the following output format: <dl class=Bl-tag><dt><a class=permalink href=#METEOR_GEO_RGB16><code class=Dv id=METEOR_GEO_RGB16>METEOR_GEO_RGB16</code></a></dt><dd>(RGB 16 bits xrrrrrgg gggbbbbb default)</dd><dt><a class=permalink href=#METEOR_GEO_RGB24><code class=Dv id=METEOR_GEO_RGB24>METEOR_GEO_RGB24</code></a></dt><dd>(RGB 24 bits packed in 32 bits: 00000000 rrrrrrrr gggggggg bbbbbbbb)</dd><dt><a class=permalink href=#METEOR_GEO_YUV_PACKED><code class=Dv id=METEOR_GEO_YUV_PACKED>METEOR_GEO_YUV_PACKED</code></a></dt><dd>(4-2-2 YUV 16 bits packed byte format: u0 y0 v0 y1 u1 y2 v1 y3 ...)</dd><dt><a class=permalink href=#METEOR_GEO_YUV_PLANER><code class=Dv id=METEOR_GEO_YUV_PLANER>METEOR_GEO_YUV_PLANER</code></a></dt><dd>(4-2-2 YUV 16 bits planer format: rows * columns bytes of y rows * column / 4 bytes of even u rows * column / 4 bytes of even v rows * column / 4 bytes of odd u rows * column / 4 bytes of odd v)</dd></dl></dd></dl><p class=Pp>The <code class=Dv>METEORSETGEO</code><a class=Xr href=ioctl.2.html>ioctl(2)</a> will fail if more than one entry from a category is selected. It is highly recommended that a <code class=Dv>METEORSETGEO</code> is done before capturing data because you cannot guarantee the initial mode the card.</p><p class=Pp>The <code class=Dv>METEORSETGEO</code> will also attempt to reallocate a new contiguous kernel buffer if the new geometry exceeds the old geometry. On the other hand, if the new geometry will fit in the existing buffer, the existing buffer is used.</p><p class=Pp>If <code class=Dv>METEORSETGEO</code> fails the <a class=Xr href=ioctl.2.html>ioctl(2)</a> will return a value of -1 and the external variable <var class=Va>errno</var> will be set to:</p><dl class=Bl-tag><dt>[<code class=Er>EINVAL</code>]</dt><dd>invalid <var class=Va>meteor_geomet</var> structure pointer, <var class=Va>rows</var>, <var class=Va>columns</var>, <var class=Va>frames</var> were invalid.</dd><dt>[<code class=Er>ENOMEM</code>]</dt><dd>could not allocate the contiguous block.</dd></dl></li><li><a class=Xr href=ioctl.2.html>ioctl(2)</a> requests <code class=Dv>METEORSFMT</code> and <code class=Dv>METEORGFMT</code><p class=Pp><code class=Dv>METEORSFMT</code> and <code class=Dv>METEORGFMT</code> are used to set and read the camera input standard format.</p><p class=Pp>Possible formats are:</p><p class=Pp></p><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#METEOR_FMT_NTSC><code class=Dv id=METEOR_FMT_NTSC>METEOR_FMT_NTSC</code></a></dt><dd>NTSC (default mode)</dd><dt><a class=permalink href=#METEOR_FMT_PAL><code class=Dv id=METEOR_FMT_PAL>METEOR_FMT_PAL</code></a></dt><dd>PAL</dd><dt><a class=permalink href=#METEOR_FMT_SECAM><code class=Dv id=METEOR_FMT_SECAM>METEOR_FMT_SECAM</code></a></dt><dd>SECAM</dd><dt><a class=permalink href=#METEOR_FMT_AUTOMODE><code class=Dv id=METEOR_FMT_AUTOMODE>METEOR_FMT_AUTOMODE</code></a></dt><dd>Autodetect.</dd></dl></li><li><a class=Xr href=ioctl.2.html>ioctl(2)</a> requests <code class=Dv>METEORSINPUT</code> and <code class=Dv>METEORGINPUT</code><p class=Pp><code class=Dv>METEORSINPUT</code> and <code class=Dv>METEORGINPUT</code> are used to set and read the camera input device. Using the DB9 connector on the Meteor card, 4 input devices can be connected and an input camera can be selected with this <a class=Xr href=ioctl.2.html>ioctl(2)</a>.</p><p class=Pp>Possible formats are:</p><p class=Pp></p><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#METEOR_INPUT_DEV0><code class=Dv id=METEOR_INPUT_DEV0>METEOR_INPUT_DEV0</code></a></dt><dd>(default if none specified)</dd><dt><a class=permalink href=#METEOR_INPUT_DEV_RCA><code class=Dv id=METEOR_INPUT_DEV_RCA>METEOR_INPUT_DEV_RCA</code></a></dt><dd>(same as METEOR_INPUT_DEV0)</dd><dt><a class=permalink href=#METEOR_INPUT_DEV1><code class=Dv id=METEOR_INPUT_DEV1>METEOR_INPUT_DEV1</code></a></dt><dd style="width: auto;"> </dd><dt><a class=permalink href=#METEOR_INPUT_DEV2><code class=Dv id=METEOR_INPUT_DEV2>METEOR_INPUT_DEV2</code></a></dt><dd style="width: auto;"> </dd><dt><a class=permalink href=#METEOR_INPUT_DEV_SVIDEO><code class=Dv id=METEOR_INPUT_DEV_SVIDEO>METEOR_INPUT_DEV_SVIDEO</code></a></dt><dd>(same as METEOR_INPUT_DEV2)</dd></dl></li><li><a class=Xr href=ioctl.2.html>ioctl(2)</a> request <code class=Dv>METEORSTATUS</code><p class=Pp><code class=Dv>METEORSTATUS</code> is used to read the status of the Meteor capture card and returns the following information:</p><table class=Bl-column><tr><td><a class=permalink href=#METEOR_STATUS_ID_MASK><code class=Dv id=METEOR_STATUS_ID_MASK>METEOR_STATUS_ID_MASK </code></a></td><td>4 bit ID of the SAA7196 scaler chip. <p class=Pp></p></td></tr><tr><td><a class=permalink href=#METEOR_STATUS_DIR><code class=Dv id=METEOR_STATUS_DIR>METEOR_STATUS_DIR </code></a></td><td>0 =</td><td>scaler uses internal source.</td></tr><tr><td></td><td>1 =</td><td>scaler uses external data of expansion bus. <p class=Pp></p></td></tr><tr><td><a class=permalink href=#METEOR_STATUS_OEF><code class=Dv id=METEOR_STATUS_OEF>METEOR_STATUS_OEF </code></a></td><td>0 =</td><td>even field detected.</td></tr><tr><td></td><td>1 =</td><td>odd field detected. <p class=Pp></p></td></tr><tr><td><a class=permalink href=#METEOR_STATUS_SVP><code class=Dv id=METEOR_STATUS_SVP>METEOR_STATUS_SVP </code></a></td><td>VRAM Port state:</td></tr><tr><td></td><td>0 =</td><td>inputs HFL and INCADDR inactive.</td></tr><tr><td></td><td>1 =</td><td>inputs HFL and INCADDR active. <p class=Pp></p></td></tr><tr><td><a class=permalink href=#METEOR_STATUS_STTC><code class=Dv id=METEOR_STATUS_STTC>METEOR_STATUS_STTC </code></a></td><td>0 =</td><td>TV horizontal time constant (slow).</td></tr><tr><td></td><td>1 =</td><td>VCR horizontal time constant (fast). <p class=Pp></p></td></tr><tr><td><a class=permalink href=#METEOR_STATUS_HCLK><code class=Dv id=METEOR_STATUS_HCLK>METEOR_STATUS_HCLK </code></a></td><td>0 =</td><td>Horizontal Phase Lock Loop locked.</td></tr><tr><td></td><td>1 =</td><td>Horizontal Phase Lock Loop unlocked. <p class=Pp></p></td></tr><tr><td><a class=permalink href=#METEOR_STATUS_FIDT><code class=Dv id=METEOR_STATUS_FIDT>METEOR_STATUS_FIDT </code></a></td><td>0 =</td><td>50 Hz Field detected.</td></tr><tr><td></td><td>1 =</td><td>60 Hz Field detected. <p class=Pp></p></td></tr><tr><td><a class=permalink href=#METEOR_STATUS_ALTD><code class=Dv id=METEOR_STATUS_ALTD>METEOR_STATUS_ALTD </code></a></td><td>0 =</td><td>no line alternating color burst detected.</td></tr><tr><td></td><td>1 =</td><td>line alternating color burst detected (PAL/SECAM). <p class=Pp></p></td></tr><tr><td><a class=permalink href=#METEOR_STATUS_CODE><code class=Dv id=METEOR_STATUS_CODE>METEOR_STATUS_CODE </code></a></td><td>0 =</td><td>no color information detected.</td></tr><tr><td></td><td>1 =</td><td>color information detected.</td></tr></table></li><li><a class=Xr href=ioctl.2.html>ioctl(2)</a> request <code class=Dv>METEORCAPTUR</code><p class=Pp><code class=Dv>METEORCAPTUR</code> is used to single frame capture or unsynchronized continuous capture.</p><p class=Pp>The single frame capture <a class=Xr href=ioctl.2.html>ioctl(2)</a> request will return only after a frame has been captured and transferred to the frame buffer.</p><p class=Pp>The unsynchronized continuous capture will return immediately and data is directly deposited into the buffer when it is available. Since this is unsynchronized, it is possible the data is being written by the kernel while being read by the application.</p><p class=Pp>These <a class=Xr href=ioctl.2.html>ioctl(2)</a> routines use the following settings:</p><p class=Pp></p><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#METEOR_CAP_SINGLE><code class=Dv id=METEOR_CAP_SINGLE>METEOR_CAP_SINGLE</code></a></dt><dd>capture one frame</dd><dt><a class=permalink href=#METEOR_CAP_CONTINOUS><code class=Dv id=METEOR_CAP_CONTINOUS>METEOR_CAP_CONTINOUS</code></a></dt><dd>unsynchronized continuous capture</dd><dt><a class=permalink href=#METEOR_CAP_STOP_CONT><code class=Dv id=METEOR_CAP_STOP_CONT>METEOR_CAP_STOP_CONT</code></a></dt><dd>stop the unsynchronized continuous capture</dd></dl><p class=Pp>If <code class=Dv>METEORCAPTUR</code> fails the <a class=Xr href=ioctl.2.html>ioctl(2)</a> will return a value of -1 and the external variable <var class=Va>errno</var> will be set to:</p><dl class=Bl-tag><dt>[<code class=Er>EINVAL</code>]</dt><dd>invalid capture command value</dd><dt>[<code class=Er>ENXIO</code>]</dt><dd>there is not internal buffer to hold the frame. This indicates the previous set geometry <a class=Xr href=ioctl.2.html>ioctl(2)</a> failed.</dd><dt>[<code class=Er>EIO</code>]</dt><dd>card is already capturing.</dd></dl></li><li><a class=Xr href=ioctl.2.html>ioctl(2)</a> request <code class=Dv>METEORCAPFRM</code><p class=Pp><code class=Dv>METEORCAPFRM</code> is used for synchronous capture of multiple frames.</p><p class=Pp>This <a class=Xr href=ioctl.2.html>ioctl(2)</a> routine uses the <var class=Va>meteor_capture</var> structure that has the following entries:</p><dl class=Bl-tag><dt><var class=Va>command</var></dt><dd>possible values for <var class=Va>command</var> are: <dl class=Bl-tag><dt><a class=permalink href=#METEOR_CAP_STOP_FRAMES><code class=Dv id=METEOR_CAP_STOP_FRAMES>METEOR_CAP_STOP_FRAMES</code></a></dt><dd>stop the capture; does not use the other variable in structure.</dd><dt><a class=permalink href=#METEOR_CAP_N_FRAMES><code class=Dv id=METEOR_CAP_N_FRAMES>METEOR_CAP_N_FRAMES</code></a></dt><dd>start the capture using the other variables in the structure as inputs</dd></dl></dd><dt><var class=Va>signal</var></dt><dd>signal to send to application when a new frame has been captured. This signal will only be raised if the captured frame is saved.</dd><dt><var class=Va>lowat</var></dt><dd>see below</dd><dt><var class=Va>hiwat</var></dt><dd>see below</dd></dl><p class=Pp>When a new frame is completed, the driver checks the current unread frame count stored in shared variable (the shared variable is stored in the <var class=Va>meteor_mem</var> structure) <var class=Va>num_active_buf</var>; if the count is larger than <var class=Va>hiwat</var>, the driver will not store any new frames and will not send capture signal to the user application until the <var class=Va>num_active_buf</var> is lower than <var class=Va>lowat</var>.</p><p class=Pp>If <code class=Dv>METEORCAPFRM</code> fails the <a class=Xr href=ioctl.2.html>ioctl(2)</a> will return a value of -1 and the external variable <var class=Va>errno</var> will be set to:</p><dl class=Bl-tag><dt>[<code class=Er>EINVAL</code>]</dt><dd>invalid meteor_geomet structure pointer or bad command.</dd><dt>[<code class=Er>ENXIO</code>]</dt><dd>there is not internal buffer to hold the frame. This indicates the previous set geometry <a class=Xr href=ioctl.2.html>ioctl(2)</a> failed.</dd><dt>[<code class=Er>EIO</code>]</dt><dd>card is already capturing.</dd></dl></li><li><a class=Xr href=ioctl.2.html>ioctl(2)</a> requests <code class=Dv>METEORSCHCV</code> and <code class=Dv>METEORGCHCV</code><p class=Pp><code class=Dv>METEORSCHCV</code> and <code class=Dv>METEORGCHCV</code> are used to set and get the chrominance gain control and effects the UV output amplitude.</p><p class=Pp>If <code class=Dv>METEORSCHCV</code> or <code class=Dv>METEORGCHCV</code> fails the <a class=Xr href=ioctl.2.html>ioctl(2)</a> will return a value of -1 and the external variable <var class=Va>errno</var> will be set to:</p><dl class=Bl-tag><dt>[<code class=Er>EINVAL</code>]</dt><dd>invalid unsigned char pointer.</dd></dl></li><li><a class=Xr href=ioctl.2.html>ioctl(2)</a> requests <code class=Dv>METEORGHUE</code> and <code class=Dv>METEORSHUE</code><p class=Pp><code class=Dv>METEORGHUE</code> and <code class=Dv>METEORSHUE</code> are used to get and set the hue. The signed character has legal values are from +127 which represent +178.6 degrees to -128 which represents -180 degrees.</p><p class=Pp>If <code class=Dv>METEORGHUE</code> or <code class=Dv>METEORSHUE</code> fails the <a class=Xr href=ioctl.2.html>ioctl(2)</a> will return a value of -1 and the external variable <var class=Va>errno</var> will be set to:</p><dl class=Bl-tag><dt>[<code class=Er>EINVAL</code>]</dt><dd>invalid signed char pointer.</dd></dl></li><li><a class=Xr href=ioctl.2.html>ioctl(2)</a> requests <code class=Dv>METEORSCOUNT</code> and <code class=Dv>METEORGCOUNT</code><p class=Pp><code class=Dv>METEORGCOUNT</code> is used to get the count of frame errors, DMA errors and count of the number of frames captured that have occurred since the device was opened. <code class=Dv>METEORSCOUNT</code> can be used to reinitialize the counters.</p><p class=Pp>This <a class=Xr href=ioctl.2.html>ioctl(2)</a> routines use the <var class=Va>meteor_counts</var> structure that has the following entries:</p><dl class=Bl-tag><dt><var class=Va>fifo_errors</var></dt><dd>number of FIFO errors since device was opened.</dd><dt><var class=Va>dma_errors</var></dt><dd>number of DMA errors since device was opened.</dd><dt><var class=Va>frame_count</var></dt><dd>number of frames captured since device was opened.</dd></dl><p class=Pp>If <code class=Dv>METEORSCOUNT</code> or <code class=Dv>METEORGCOUNT</code> fails the <a class=Xr href=ioctl.2.html>ioctl(2)</a> will return a value of -1 and the external variable <var class=Va>errno</var> will be set to:</p><dl class=Bl-tag><dt>[<code class=Er>EINVAL</code>]</dt><dd>invalid meteor_counts structure pointer.</dd></dl></li></ol></section></section><section class=Sh><h2 class=Sh id=AUTHORS><a class=permalink href=#AUTHORS>AUTHORS</a></h2><span class=An>Jim Lowe</span> &lt;<a class=Mt href=mailto:james@miller.cs.uwm.edu>james@miller.cs.uwm.edu</a>&gt; <br><span class=An>Mark Tinguely</span> &lt;<a class=Mt href=mailto:tinguely@plains.nodak.edu>tinguely@plains.nodak.edu</a>&gt; </section><section class=Sh><h2 class=Sh id=BUGS><a class=permalink href=#BUGS>BUGS</a></h2> The <code class=Nm>meteor</code> driver no longer works at all. </section></div><table class=foot><tr><td class=foot-date>August 15, 1995</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>