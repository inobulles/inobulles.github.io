<!DOCTYPE html>
<html><head><meta charset=utf-8><title>ipfw(8)</title><keywords content=man,ipfw></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>ipfw(8)</h1><table class=head><tr><td class=head-ltitle>IPFW(8)</td><td class=head-vol>FreeBSD System Manager's Manual</td><td class=head-rtitle>IPFW(8)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>ipfw</code>, <code class=Nm>dnctl</code> — <div class=Nd>User interface for firewall, traffic shaper, packet scheduler, in-kernel NAT.</div></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><section class=Ss><h2 class=Ss id=FIREWALL_CONFIGURATION><a class=permalink href=#FIREWALL_CONFIGURATION>FIREWALL CONFIGURATION</a></h2><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Fl>-cq</code>] <code class=Cm>add</code><var class=Ar>rule</var></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Fl>-acdefnNStT</code>] [<code class=Cm>set</code><var class=Ar>N</var>] {<code class=Cm>list</code> | <code class=Cm>show</code>} [<var class=Ar>rule</var> | <var class=Ar>first-last ...</var>]</td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Fl>-f</code> | <code class=Fl>-q</code>] [<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>flush</code></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Fl>-q</code>] [<code class=Cm>set</code><var class=Ar>N</var>] {<code class=Cm>delete</code> | <code class=Cm>zero</code> | <code class=Cm>resetlog</code>} [<var class=Ar>number ...</var>]</td></tr></table><p class=Pp></p><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td><code class=Cm>set</code> [<code class=Cm>disable</code><var class=Ar>number ...</var>] [<code class=Cm>enable</code><var class=Ar>number ...</var>]</td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td><code class=Cm>set move</code> [<code class=Cm>rule</code>] <var class=Ar>number</var><code class=Cm>to</code><var class=Ar>number</var></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td><code class=Cm>set swap</code><var class=Ar>number number</var></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td><code class=Cm>set show</code></td></tr></table></section><section class=Ss><h2 class=Ss id=SYSCTL_SHORTCUTS><a class=permalink href=#SYSCTL_SHORTCUTS>SYSCTL SHORTCUTS</a></h2><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td><code class=Cm>enable</code> {<code class=Cm>firewall</code> | <code class=Cm>altq</code> | <code class=Cm>one_pass</code> | <code class=Cm>debug</code> | <code class=Cm>verbose</code> | <code class=Cm>dyn_keepalive</code>}</td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td><code class=Cm>disable</code> {<code class=Cm>firewall</code> | <code class=Cm>altq</code> | <code class=Cm>one_pass</code> | <code class=Cm>debug</code> | <code class=Cm>verbose</code> | <code class=Cm>dyn_keepalive</code>}</td></tr></table></section><section class=Ss><h2 class=Ss id=LOOKUP_TABLES><a class=permalink href=#LOOKUP_TABLES>LOOKUP TABLES</a></h2><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>table</code><var class=Ar>name</var><code class=Cm>create</code><var class=Ar>create-options</var></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>table</code> {<var class=Ar>name</var> | <var class=Ar>all</var>} <code class=Cm>destroy</code></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>table</code><var class=Ar>name</var><code class=Cm>modify</code><var class=Ar>modify-options</var></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>table</code><var class=Ar>name</var><code class=Cm>swap</code><var class=Ar>name</var></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>table</code><var class=Ar>name</var><code class=Cm>add</code><var class=Ar>table-key</var> [<var class=Ar>value</var>]</td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>table</code><var class=Ar>name</var><code class=Cm>add</code> [<var class=Ar>table-key</var><var class=Ar>value ...</var>]</td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>table</code><var class=Ar>name</var><code class=Cm>atomic add</code> [<var class=Ar>table-key</var><var class=Ar>value ...</var>]</td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>table</code><var class=Ar>name</var><code class=Cm>delete</code> [<var class=Ar>table-key ...</var>]</td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>table</code><var class=Ar>name</var><code class=Cm>lookup</code><var class=Ar>addr</var></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>table</code><var class=Ar>name</var><code class=Cm>lock</code></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>table</code><var class=Ar>name</var><code class=Cm>unlock</code></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>table</code> {<var class=Ar>name</var> | <var class=Ar>all</var>} <code class=Cm>list</code></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>table</code> {<var class=Ar>name</var> | <var class=Ar>all</var>} <code class=Cm>info</code></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>table</code> {<var class=Ar>name</var> | <var class=Ar>all</var>} <code class=Cm>detail</code></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>table</code> {<var class=Ar>name</var> | <var class=Ar>all</var>} <code class=Cm>flush</code></td></tr></table></section><section class=Ss><h2 class=Ss id=DUMMYNET_CONFIGURATION_(TRAFFIC_SHAPER_AND_PACKET_SCHEDULER)><a class=permalink href=#DUMMYNET_CONFIGURATION_(TRAFFIC_SHAPER_AND_PACKET_SCHEDULER)>DUMMYNET CONFIGURATION (TRAFFIC SHAPER AND PACKET SCHEDULER)</a></h2><table class=Nm><tr><td><code class=Nm>dnctl</code></td><td>{<code class=Cm>pipe</code> | <code class=Cm>queue</code> | <code class=Cm>sched</code>} <var class=Ar>number</var><code class=Cm>config</code><var class=Ar>config-options</var></td></tr></table><br><table class=Nm><tr><td><code class=Nm>dnctl</code></td><td>[<code class=Fl>-s</code> [<var class=Ar>field</var>]] {<code class=Cm>pipe</code> | <code class=Cm>queue</code> | <code class=Cm>sched</code>} {<code class=Cm>delete</code> | <code class=Cm>list</code> | <code class=Cm>show</code>} [<var class=Ar>number ...</var>]</td></tr></table></section><section class=Ss><h2 class=Ss id=IN_KERNEL_NAT><a class=permalink href=#IN_KERNEL_NAT>IN-KERNEL NAT</a></h2><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Fl>-q</code>] <code class=Cm>nat</code><var class=Ar>number</var><code class=Cm>config</code><var class=Ar>config-options</var></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td><code class=Cm>nat</code><var class=Ar>number</var><code class=Cm>show</code> {<code class=Cm>config</code> | <code class=Cm>log</code>}</td></tr></table></section><section class=Ss><h2 class=Ss id=STATEFUL_IPv6/IPv4_NETWORK_ADDRESS_AND_PROTOCOL_TRANSLATION><a class=permalink href=#STATEFUL_IPv6/IPv4_NETWORK_ADDRESS_AND_PROTOCOL_TRANSLATION>STATEFUL IPv6/IPv4 NETWORK ADDRESS AND PROTOCOL TRANSLATION</a></h2><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>nat64lsn</code><var class=Ar>name</var><code class=Cm>create</code><var class=Ar>create-options</var></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>nat64lsn</code><var class=Ar>name</var><code class=Cm>config</code><var class=Ar>config-options</var></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>nat64lsn</code> {<var class=Ar>name</var> | <var class=Ar>all</var>} {<code class=Cm>list</code> | <code class=Cm>show</code>} [<code class=Cm>states</code>]</td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>nat64lsn</code> {<var class=Ar>name</var> | <var class=Ar>all</var>} <code class=Cm>destroy</code></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>nat64lsn</code><var class=Ar>name</var><code class=Cm>stats</code> [<code class=Cm>reset</code>]</td></tr></table></section><section class=Ss><h2 class=Ss id=STATELESS_IPv6/IPv4_NETWORK_ADDRESS_AND_PROTOCOL_TRANSLATION><a class=permalink href=#STATELESS_IPv6/IPv4_NETWORK_ADDRESS_AND_PROTOCOL_TRANSLATION>STATELESS IPv6/IPv4 NETWORK ADDRESS AND PROTOCOL TRANSLATION</a></h2><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>nat64stl</code><var class=Ar>name</var><code class=Cm>create</code><var class=Ar>create-options</var></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>nat64stl</code><var class=Ar>name</var><code class=Cm>config</code><var class=Ar>config-options</var></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>nat64stl</code> {<var class=Ar>name</var> | <var class=Ar>all</var>} {<code class=Cm>list</code> | <code class=Cm>show</code>}</td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>nat64stl</code> {<var class=Ar>name</var> | <var class=Ar>all</var>} <code class=Cm>destroy</code></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>nat64stl</code><var class=Ar>name</var><code class=Cm>stats</code> [<code class=Cm>reset</code>]</td></tr></table></section><section class=Ss><h2 class=Ss id=XLAT464_CLAT_IPv6/IPv4_NETWORK_ADDRESS_AND_PROTOCOL_TRANSLATION><a class=permalink href=#XLAT464_CLAT_IPv6/IPv4_NETWORK_ADDRESS_AND_PROTOCOL_TRANSLATION>XLAT464 CLAT IPv6/IPv4 NETWORK ADDRESS AND PROTOCOL TRANSLATION</a></h2><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>nat64clat</code><var class=Ar>name</var><code class=Cm>create</code><var class=Ar>create-options</var></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>nat64clat</code><var class=Ar>name</var><code class=Cm>config</code><var class=Ar>config-options</var></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>nat64clat</code> {<var class=Ar>name</var> | <var class=Ar>all</var>} {<code class=Cm>list</code> | <code class=Cm>show</code>}</td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>nat64clat</code> {<var class=Ar>name</var> | <var class=Ar>all</var>} <code class=Cm>destroy</code></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>nat64clat</code><var class=Ar>name</var><code class=Cm>stats</code> [<code class=Cm>reset</code>]</td></tr></table></section><section class=Ss><h2 class=Ss id=IPv6-to_IPv6_NETWORK_PREFIX_TRANSLATION><a class=permalink href=#IPv6-to_IPv6_NETWORK_PREFIX_TRANSLATION>IPv6-to-IPv6 NETWORK PREFIX TRANSLATION</a></h2><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>nptv6</code><var class=Ar>name</var><code class=Cm>create</code><var class=Ar>create-options</var></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>nptv6</code> {<var class=Ar>name</var> | <var class=Ar>all</var>} {<code class=Cm>list</code> | <code class=Cm>show</code>}</td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>nptv6</code> {<var class=Ar>name</var> | <var class=Ar>all</var>} <code class=Cm>destroy</code></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Cm>set</code><var class=Ar>N</var>] <code class=Cm>nptv6</code><var class=Ar>name</var><code class=Cm>stats</code> [<code class=Cm>reset</code>]</td></tr></table></section><section class=Ss><h2 class=Ss id=INTERNAL_DIAGNOSTICS><a class=permalink href=#INTERNAL_DIAGNOSTICS>INTERNAL DIAGNOSTICS</a></h2><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td><code class=Cm>internal iflist</code></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td><code class=Cm>internal talist</code></td></tr></table><br><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td><code class=Cm>internal vlist</code></td></tr></table></section><section class=Ss><h2 class=Ss id=LIST_OF_RULES_AND_PREPROCESSING><a class=permalink href=#LIST_OF_RULES_AND_PREPROCESSING>LIST OF RULES AND PREPROCESSING</a></h2><table class=Nm><tr><td><code class=Nm>ipfw</code></td><td>[<code class=Fl>-cfnNqS</code>] [<code class=Fl>-p</code><var class=Ar>preproc</var> [<var class=Ar>preproc-flags</var>]] <var class=Ar>pathname</var></td></tr></table></section></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> The <code class=Nm>ipfw</code> utility is the user interface for controlling the <a class=Xr href=ipfw.4.html>ipfw(4)</a> firewall, the <a class=Xr href=dummynet.4.html>dummynet(4)</a> traffic shaper/packet scheduler, and the in-kernel NAT services. <p class=Pp>A firewall configuration, or <i class=Em>ruleset</i>, is made of a list of <i class=Em>rules</i> numbered from 1 to 65535. Packets are passed to the firewall from a number of different places in the protocol stack (depending on the source and destination of the packet, it is possible for the firewall to be invoked multiple times on the same packet). The packet passed to the firewall is compared against each of the rules in the <i class=Em>ruleset</i>, in rule-number order (multiple rules with the same number are permitted, in which case they are processed in order of insertion). When a match is found, the action corresponding to the matching rule is performed.</p><p class=Pp>Depending on the action and certain system settings, packets can be reinjected into the firewall at some rule after the matching one for further processing.</p><p class=Pp>A ruleset always includes a <i class=Em>default</i> rule (numbered 65535) which cannot be modified or deleted, and matches all packets. The action associated with the <i class=Em>default</i> rule can be either <code class=Cm>deny</code> or <code class=Cm>allow</code> depending on how the kernel is configured.</p><p class=Pp>If the ruleset includes one or more rules with the <code class=Cm>keep-state</code>, <code class=Cm>record-state</code>, <code class=Cm>limit</code> or <code class=Cm>set-limit</code> option, the firewall will have a <i class=Em>stateful</i> behaviour, i.e., upon a match it will create <i class=Em>dynamic rules</i>, i.e., rules that match packets with the same 5-tuple (protocol, source and destination addresses and ports) as the packet which caused their creation. Dynamic rules, which have a limited lifetime, are checked at the first occurrence of a <code class=Cm>check-state</code>, <code class=Cm>keep-state</code> or <code class=Cm>limit</code> rule, and are typically used to open the firewall on-demand to legitimate traffic only. Please note, that <code class=Cm>keep-state</code> and <code class=Cm>limit</code> imply implicit <code class=Cm>check-state</code> for all packets (not only these matched by the rule) but <code class=Cm>record-state</code> and <code class=Cm>set-limit</code> have no implicit <code class=Cm>check-state</code>. See the <a class=Sx href=#STATEFUL_FIREWALL>STATEFUL FIREWALL</a> and <a class=Sx href=#EXAMPLES>EXAMPLES</a> Sections below for more information on the stateful behaviour of <code class=Nm>ipfw</code>.</p><p class=Pp>All rules (including dynamic ones) have a few associated counters: a packet count, a byte count, a log count and a timestamp indicating the time of the last match. Counters can be displayed or reset with <code class=Nm>ipfw</code> commands.</p><p class=Pp>Each rule belongs to one of 32 different <i class=Em>sets</i> , and there are <code class=Nm>ipfw</code> commands to atomically manipulate sets, such as enable, disable, swap sets, move all rules in a set to another one, delete all rules in a set. These can be useful to install temporary configurations, or to test them. See Section <a class=Sx href=#SETS_OF_RULES>SETS OF RULES</a> for more information on <i class=Em>sets</i>.</p><p class=Pp>Rules can be added with the <code class=Cm>add</code> command; deleted individually or in groups with the <code class=Cm>delete</code> command, and globally (except those in set 31) with the <code class=Cm>flush</code> command; displayed, optionally with the content of the counters, using the <code class=Cm>show</code> and <code class=Cm>list</code> commands. Finally, counters can be reset with the <code class=Cm>zero</code> and <code class=Cm>resetlog</code> commands.</p><section class=Ss><h2 class=Ss id=COMMAND_OPTIONS><a class=permalink href=#COMMAND_OPTIONS>COMMAND OPTIONS</a></h2> The following general options are available when invoking <code class=Nm>ipfw</code>: <dl class=Bl-tag><dt><a class=permalink href=#a><code class=Fl id=a>-a</code></a></dt><dd>Show counter values when listing rules. The <code class=Cm>show</code> command implies this option.</dd><dt><a class=permalink href=#b><code class=Fl id=b>-b</code></a></dt><dd>Only show the action and the comment, not the body of a rule. Implies <code class=Fl>-c</code>.</dd><dt><a class=permalink href=#c><code class=Fl id=c>-c</code></a></dt><dd>When entering or showing rules, print them in compact form, i.e., omitting the "ip from any to any" string when this does not carry any additional information.</dd><dt><a class=permalink href=#d><code class=Fl id=d>-d</code></a></dt><dd>When listing, show dynamic rules in addition to static ones.</dd><dt><a class=permalink href=#D><code class=Fl id=D>-D</code></a></dt><dd>When listing, show only dynamic states. When deleting, delete only dynamic states.</dd><dt><a class=permalink href=#f><code class=Fl id=f>-f</code></a></dt><dd>Run without prompting for confirmation for commands that can cause problems if misused, i.e., <code class=Cm>flush</code>. If there is no tty associated with the process, this is implied. The <code class=Cm>delete</code> command with this flag ignores possible errors, i.e., nonexistent rule number. And for batched commands execution continues with the next command.</dd><dt><a class=permalink href=#i><code class=Fl id=i>-i</code></a></dt><dd>When listing a table (see the <a class=Sx href=#LOOKUP_TABLES>LOOKUP TABLES</a> section below for more information on lookup tables), format values as IP addresses. By default, values are shown as integers.</dd><dt><a class=permalink href=#n><code class=Fl id=n>-n</code></a></dt><dd>Only check syntax of the command strings, without actually passing them to the kernel.</dd><dt><a class=permalink href=#N><code class=Fl id=N>-N</code></a></dt><dd>Try to resolve addresses and service names in output.</dd><dt><a class=permalink href=#q><code class=Fl id=q>-q</code></a></dt><dd>Be quiet when executing the <code class=Cm>add</code>, <code class=Cm>nat</code>, <code class=Cm>zero</code>, <code class=Cm>resetlog</code> or <code class=Cm>flush</code> commands; (implies <code class=Fl>-f</code>). This is useful when updating rulesets by executing multiple <code class=Nm>ipfw</code> commands in a script (e.g., ‘<code class=Li>sh /etc/rc.firewall</code>’), or by processing a file with many <code class=Nm>ipfw</code> rules across a remote login session. It also stops a table add or delete from failing if the entry already exists or is not present. <p class=Pp>The reason why this option may be important is that for some of these actions, <code class=Nm>ipfw</code> may print a message; if the action results in blocking the traffic to the remote client, the remote login session will be closed and the rest of the ruleset will not be processed. Access to the console would then be required to recover.</p></dd><dt><a class=permalink href=#S><code class=Fl id=S>-S</code></a></dt><dd>When listing rules, show the <i class=Em>set</i> each rule belongs to. If this flag is not specified, disabled rules will not be listed.</dd><dt><a class=permalink href=#s><code class=Fl id=s>-s</code></a> [<var class=Ar>field</var>]</dt><dd>When listing pipes, sort according to one of the four counters (total or current packets or bytes).</dd><dt><a class=permalink href=#t><code class=Fl id=t>-t</code></a></dt><dd>When listing, show last match timestamp converted with <code class=Fn>ctime</code>().</dd><dt><a class=permalink href=#T><code class=Fl id=T>-T</code></a></dt><dd>When listing, show last match timestamp as seconds from the epoch. This form can be more convenient for postprocessing by scripts.</dd></dl></section><section class=Ss><h2 class=Ss id=LIST_OF_RULES_AND_PREPROCESSING_2><a class=permalink href=#LIST_OF_RULES_AND_PREPROCESSING_2>LIST OF RULES AND PREPROCESSING</a></h2> To ease configuration, rules can be put into a file which is processed using <code class=Nm>ipfw</code> as shown in the last synopsis line. An absolute <var class=Ar>pathname</var> must be used. The file will be read line by line and applied as arguments to the <code class=Nm>ipfw</code> utility. <p class=Pp>Optionally, a preprocessor can be specified using <code class=Fl>-p</code><var class=Ar>preproc</var> where <var class=Ar>pathname</var> is to be piped through. Useful preprocessors include <a class=Xr href=cpp.1.html>cpp(1)</a> and <a class=Xr href=m4.1.html>m4(1)</a>. If <var class=Ar>preproc</var> does not start with a slash (‘<code class=Li>/</code>’) as its first character, the usual <code class=Ev>PATH</code> name search is performed. Care should be taken with this in environments where not all file systems are mounted (yet) by the time <code class=Nm>ipfw</code> is being run (e.g. when they are mounted over NFS). Once <code class=Fl>-p</code> has been specified, any additional arguments are passed on to the preprocessor for interpretation. This allows for flexible configuration files (like conditionalizing them on the local hostname) and the use of macros to centralize frequently required arguments like IP addresses.</p></section><section class=Ss><h2 class=Ss id=TRAFFIC_SHAPER_CONFIGURATION><a class=permalink href=#TRAFFIC_SHAPER_CONFIGURATION>TRAFFIC SHAPER CONFIGURATION</a></h2> The <code class=Nm>dnctl</code><code class=Cm>pipe</code>, <code class=Cm>queue</code> and <code class=Cm>sched</code> commands are used to configure the traffic shaper and packet scheduler. See the <a class=Sx href=#TRAFFIC_SHAPER_(DUMMYNET)_CONFIGURATION>TRAFFIC SHAPER (DUMMYNET) CONFIGURATION</a> Section below for details. <p class=Pp>If the world and the kernel get out of sync the <code class=Nm>ipfw</code> ABI may break, preventing you from being able to add any rules. This can adversely affect the booting process. You can use <code class=Nm>ipfw</code><code class=Cm>disable</code><code class=Cm>firewall</code> to temporarily disable the firewall to regain access to the network, allowing you to fix the problem.</p></section></section><section class=Sh><h2 class=Sh id=PACKET_FLOW><a class=permalink href=#PACKET_FLOW>PACKET FLOW</a></h2> A packet is checked against the active ruleset in multiple places in the protocol stack, under control of several sysctl variables. These places and variables are shown below, and it is important to have this picture in mind in order to design a correct ruleset. <div class="Bd Pp Bd-indent"><pre>
       ^    to upper layers    V
       |                       |
       +-----------&gt;-----------+
       ^                       V
 [ip(6)_input]           [ip(6)_output]     net.inet(6).ip(6).fw.enable=1
       |                       |
       ^                       V
 [ether_demux]        [ether_output_frame]  net.link.ether.ipfw=1
       |                       |
       +--&gt;--[bdg_forward]--&gt;--+            net.link.bridge.ipfw=1
       ^                       V
       |      to devices       |
</pre></div><p class=Pp>The number of times the same packet goes through the firewall can vary between 0 and 4 depending on packet source and destination, and system configuration.</p><p class=Pp>Note that as packets flow through the stack, headers can be stripped or added to it, and so they may or may not be available for inspection. E.g., incoming packets will include the MAC header when <code class=Nm>ipfw</code> is invoked from <code class=Cm>ether_demux()</code>, but the same packets will have the MAC header stripped off when <code class=Nm>ipfw</code> is invoked from <code class=Cm>ip_input()</code> or <code class=Cm>ip6_input()</code>.</p><p class=Pp>Also note that each packet is always checked against the complete ruleset, irrespective of the place where the check occurs, or the source of the packet. If a rule contains some match patterns or actions which are not valid for the place of invocation (e.g. trying to match a MAC header within <code class=Cm>ip_input</code> or <code class=Cm>ip6_input ),</code> the match pattern will not match, but a <code class=Cm>not</code> operator in front of such patterns <i class=Em>will</i> cause the pattern to <i class=Em>always</i> match on those packets. It is thus the responsibility of the programmer, if necessary, to write a suitable ruleset to differentiate among the possible places. <code class=Cm>skipto</code> rules can be useful here, as an example:</p><div class="Bd Pp Bd-indent"><pre>
# packets from ether_demux or bdg_forward
ipfw add 10 skipto 1000 all from any to any layer2 in
# packets from ip_input
ipfw add 10 skipto 2000 all from any to any not layer2 in
# packets from ip_output
ipfw add 10 skipto 3000 all from any to any not layer2 out
# packets from ether_output_frame
ipfw add 10 skipto 4000 all from any to any layer2 out
</pre></div><p class=Pp>(yes, at the moment there is no way to differentiate between ether_demux and bdg_forward).</p><p class=Pp>Also note that only actions <code class=Cm>allow</code>, <code class=Cm>deny</code>, <code class=Cm>netgraph</code>, <code class=Cm>ngtee</code> and related to <code class=Cm>dummynet</code> are processed for <code class=Cm>layer2</code> frames and all other actions act as if they were <code class=Cm>allow</code> for such frames. Full set of actions is supported for IP packets without <code class=Cm>layer2</code> headers only. For example, <code class=Cm>divert</code> action does not divert <code class=Cm>layer2</code> frames.</p></section><section class=Sh><h2 class=Sh id=SYNTAX><a class=permalink href=#SYNTAX>SYNTAX</a></h2> In general, each keyword or argument must be provided as a separate command line argument, with no leading or trailing spaces. Keywords are case-sensitive, whereas arguments may or may not be case-sensitive depending on their nature (e.g. uid's are, hostnames are not). <p class=Pp>Some arguments (e.g., port or address lists) are comma-separated lists of values. In this case, spaces after commas ',' are allowed to make the line more readable. You can also put the entire command (including flags) into a single argument. E.g., the following forms are equivalent:</p><div class="Bd Pp Bd-indent"><pre>
ipfw -q add deny src-ip 10.0.0.0/24,127.0.0.1/8
ipfw -q add deny src-ip 10.0.0.0/24, 127.0.0.1/8
ipfw "-q add deny src-ip 10.0.0.0/24, 127.0.0.1/8"
</pre></div></section><section class=Sh><h2 class=Sh id=RULE_FORMAT><a class=permalink href=#RULE_FORMAT>RULE FORMAT</a></h2> The format of firewall rules is the following: <div class="Bd Pp Bd-indent">[<var class=Ar>rule_number</var>] [<code class=Cm>set</code> <var class=Ar>set_number</var>] [<code class=Cm>prob</code> <var class=Ar>match_probability</var>] <var class=Ar>action</var> [<code class=Cm>log</code> [<code class=Cm>logamount</code> <var class=Ar>number</var>]] [<code class=Cm>altq</code> <var class=Ar>queue</var>] [{<code class=Cm>tag</code> | <code class=Cm>untag</code>} <var class=Ar>number</var>] <var class=Ar>body</var></div><p class=Pp>where the body of the rule specifies which information is used for filtering packets, among the following:</p><p class=Pp></p><div class=Bd-indent><dl class="Bl-tag Bl-compact"><dt>Layer2 header fields</dt><dd>When available</dd><dt>IPv4 and IPv6 Protocol</dt><dd>SCTP, TCP, UDP, ICMP, etc.</dd><dt>Source and dest. addresses and ports</dt><dd style="width: auto;"> </dd><dt>Direction</dt><dd>See Section <a class=Sx href=#PACKET_FLOW>PACKET FLOW</a></dd><dt>Transmit and receive interface</dt><dd>By name or address</dd><dt>Misc. IP header fields</dt><dd>Version, type of service, datagram length, identification, fragmentation flags, Time To Live</dd><dt>IP options</dt><dd style="width: auto;"> </dd><dt>IPv6 Extension headers</dt><dd>Fragmentation, Hop-by-Hop options, Routing Headers, Source routing rthdr0, Mobile IPv6 rthdr2, IPSec options.</dd><dt>IPv6 Flow-ID</dt><dd style="width: auto;"> </dd><dt>Misc. TCP header fields</dt><dd>TCP flags (SYN, FIN, ACK, RST, etc.), sequence number, acknowledgment number, window</dd><dt>TCP options</dt><dd style="width: auto;"> </dd><dt>ICMP types</dt><dd>for ICMP packets</dd><dt>ICMP6 types</dt><dd>for ICMP6 packets</dd><dt>User/group ID</dt><dd>When the packet can be associated with a local socket.</dd><dt>Divert status</dt><dd>Whether a packet came from a divert socket (e.g., <a class=Xr href=natd.8.html>natd(8)</a>).</dd><dt>Fib annotation state</dt><dd>Whether a packet has been tagged for using a specific FIB (routing table) in future forwarding decisions.</dd></dl></div><p class=Pp>Note that some of the above information, e.g. source MAC or IP addresses and TCP/UDP ports, can be easily spoofed, so filtering on those fields alone might not guarantee the desired results.</p><dl class=Bl-tag><dt><var class=Ar>rule_number</var></dt><dd>Each rule is associated with a <var class=Ar>rule_number</var> in the range 1..65535, with the latter reserved for the <i class=Em>default</i> rule. Rules are checked sequentially by rule number. Multiple rules can have the same number, in which case they are checked (and listed) according to the order in which they have been added. If a rule is entered without specifying a number, the kernel will assign one in such a way that the rule becomes the last one before the <i class=Em>default</i> rule. Automatic rule numbers are assigned by incrementing the last non-default rule number by the value of the sysctl variable <var class=Ar>net.inet.ip.fw.autoinc_step</var> which defaults to 100. If this is not possible (e.g. because we would go beyond the maximum allowed rule number), the number of the last non-default value is used instead.</dd><dt><a class=permalink href=#set><code class=Cm id=set>set</code></a><var class=Ar>set_number</var></dt><dd>Each rule is associated with a <var class=Ar>set_number</var> in the range 0..31. Sets can be individually disabled and enabled, so this parameter is of fundamental importance for atomic ruleset manipulation. It can be also used to simplify deletion of groups of rules. If a rule is entered without specifying a set number, set 0 will be used. <br> Set 31 is special in that it cannot be disabled, and rules in set 31 are not deleted by the <code class=Nm>ipfw flush</code> command (but you can delete them with the <code class=Nm>ipfw delete set 31</code> command). Set 31 is also used for the <i class=Em>default</i> rule.</dd><dt><a class=permalink href=#prob><code class=Cm id=prob>prob</code></a><var class=Ar>match_probability</var></dt><dd>A match is only declared with the specified probability (floating point number between 0 and 1). This can be useful for a number of applications such as random packet drop or (in conjunction with <code class=Nm>dummynet</code>) to simulate the effect of multiple paths leading to out-of-order packet delivery. <p class=Pp>Note: this condition is checked before any other condition, including ones such as <code class=Cm>keep-state</code> or <code class=Cm>check-state</code> which might have side effects.</p></dd><dt><a class=permalink href=#log><code class=Cm id=log>log</code></a> [<code class=Cm>logamount</code><var class=Ar>number</var>]</dt><dd>Packets matching a rule with the <code class=Cm>log</code> keyword will be made available for logging in two ways: if the sysctl variable <var class=Va>net.inet.ip.fw.verbose</var> is set to 0 (default), one can use <a class=Xr href=bpf.4.html>bpf(4)</a> attached to the <code class=Li>ipfw0</code> pseudo interface. This pseudo interface can be created manually after a system boot by using the following command: <div class="Bd Pp Bd-indent"><pre>
# ifconfig ipfw0 create
    </pre></div><p class=Pp>Or, automatically at boot time by adding the following line to the <a class=Xr href=rc.conf.5.html>rc.conf(5)</a> file:</p><div class="Bd Pp Bd-indent"><pre>
firewall_logif="YES"
    </pre></div><p class=Pp>There is zero overhead when no <a class=Xr href=bpf.4.html>bpf(4)</a> is attached to the pseudo interface.</p><p class=Pp>If <var class=Va>net.inet.ip.fw.verbose</var> is set to 1, packets will be logged to <a class=Xr href=syslogd.8.html>syslogd(8)</a> with a <code class=Dv>LOG_SECURITY</code> facility up to a maximum of <code class=Cm>logamount</code> packets. If no <code class=Cm>logamount</code> is specified, the limit is taken from the sysctl variable <var class=Va>net.inet.ip.fw.verbose_limit</var>. In both cases, a value of 0 means unlimited logging.</p><p class=Pp>Once the limit is reached, logging can be re-enabled by clearing the logging counter or the packet counter for that entry, see the <code class=Cm>resetlog</code> command.</p><p class=Pp>Note: logging is done after all other packet matching conditions have been successfully verified, and before performing the final action (accept, deny, etc.) on the packet.</p></dd><dt><a class=permalink href=#tag><code class=Cm id=tag>tag</code></a><var class=Ar>number</var></dt><dd>When a packet matches a rule with the <code class=Cm>tag</code> keyword, the numeric tag for the given <var class=Ar>number</var> in the range 1..65534 will be attached to the packet. The tag acts as an internal marker (it is not sent out over the wire) that can be used to identify these packets later on. This can be used, for example, to provide trust between interfaces and to start doing policy-based filtering. A packet can have multiple tags at the same time. Tags are "sticky", meaning once a tag is applied to a packet by a matching rule it exists until explicit removal. Tags are kept with the packet everywhere within the kernel, but are lost when packet leaves the kernel, for example, on transmitting packet out to the network or sending packet to a <a class=Xr href=divert.4.html>divert(4)</a> socket. <p class=Pp>To check for previously applied tags, use the <code class=Cm>tagged</code> rule option. To delete previously applied tag, use the <code class=Cm>untag</code> keyword.</p><p class=Pp>Note: since tags are kept with the packet everywhere in kernelspace, they can be set and unset anywhere in the kernel network subsystem (using the <a class=Xr href=mbuf_tags.9.html>mbuf_tags(9)</a> facility), not only by means of the <a class=Xr href=ipfw.4.html>ipfw(4)</a><code class=Cm>tag</code> and <code class=Cm>untag</code> keywords. For example, there can be a specialized <a class=Xr href=netgraph.4.html>netgraph(4)</a> node doing traffic analyzing and tagging for later inspecting in firewall.</p></dd><dt><a class=permalink href=#untag><code class=Cm id=untag>untag</code></a><var class=Ar>number</var></dt><dd>When a packet matches a rule with the <code class=Cm>untag</code> keyword, the tag with the number <var class=Ar>number</var> is searched among the tags attached to this packet and, if found, removed from it. Other tags bound to packet, if present, are left untouched.</dd><dt><a class=permalink href=#altq><code class=Cm id=altq>altq</code></a><var class=Ar>queue</var></dt><dd>When a packet matches a rule with the <code class=Cm>altq</code> keyword, the ALTQ identifier for the given <var class=Ar>queue</var> (see <a class=Xr href=altq.4.html>altq(4)</a>) will be attached. Note that this ALTQ tag is only meaningful for packets going "out" of IPFW, and not being rejected or going to divert sockets. Note that if there is insufficient memory at the time the packet is processed, it will not be tagged, so it is wise to make your ALTQ "default" queue policy account for this. If multiple <code class=Cm>altq</code> rules match a single packet, only the first one adds the ALTQ classification tag. In doing so, traffic may be shaped by using <code class=Cm>count</code><code class=Cm>altq</code><var class=Ar>queue</var> rules for classification early in the ruleset, then later applying the filtering decision. For example, <code class=Cm>check-state</code> and <code class=Cm>keep-state</code> rules may come later and provide the actual filtering decisions in addition to the fallback ALTQ tag. <p class=Pp>You must run <a class=Xr href=pfctl.8.html>pfctl(8)</a> to set up the queues before IPFW will be able to look them up by name, and if the ALTQ disciplines are rearranged, the rules in containing the queue identifiers in the kernel will likely have gone stale and need to be reloaded. Stale queue identifiers will probably result in misclassification.</p><p class=Pp>All system ALTQ processing can be turned on or off via <code class=Nm>ipfw</code><code class=Cm>enable</code><var class=Ar>altq</var> and <code class=Nm>ipfw</code><code class=Cm>disable</code><var class=Ar>altq</var>. The usage of <var class=Va>net.inet.ip.fw.one_pass</var> is irrelevant to ALTQ traffic shaping, as the actual rule action is followed always after adding an ALTQ tag.</p></dd></dl><section class=Ss><h2 class=Ss id=RULE_ACTIONS><a class=permalink href=#RULE_ACTIONS>RULE ACTIONS</a></h2> A rule can be associated with one of the following actions, which will be executed when the packet matches the body of the rule. <dl class=Bl-tag><dt><a class=permalink href=#allow><code class=Cm id=allow>allow</code></a> | <a class=permalink href=#accept><code class=Cm id=accept>accept</code></a> | <a class=permalink href=#pass><code class=Cm id=pass>pass</code></a> | <a class=permalink href=#permit><code class=Cm id=permit>permit</code></a></dt><dd>Allow packets that match rule. The search terminates.</dd><dt><a class=permalink href=#check-state><code class=Cm id=check-state>check-state</code></a> [<var class=Ar>:flowname</var> | <code class=Cm>:any</code>]</dt><dd>Checks the packet against the dynamic ruleset. If a match is found, execute the action associated with the rule which generated this dynamic rule, otherwise move to the next rule. <br><code class=Cm>Check-state</code> rules do not have a body. If no <code class=Cm>check-state</code> rule is found, the dynamic ruleset is checked at the first <code class=Cm>keep-state</code> or <code class=Cm>limit</code> rule. The <var class=Ar>:flowname</var> is symbolic name assigned to dynamic rule by <code class=Cm>keep-state</code> opcode. The special flowname <code class=Cm>:any</code> can be used to ignore states flowname when matching. The <code class=Cm>:default</code> keyword is special name used for compatibility with old rulesets.</dd><dt><a class=permalink href=#count><code class=Cm id=count>count</code></a></dt><dd>Update counters for all packets that match rule. The search continues with the next rule.</dd><dt><a class=permalink href=#deny><code class=Cm id=deny>deny</code></a> | <a class=permalink href=#drop><code class=Cm id=drop>drop</code></a></dt><dd>Discard packets that match this rule. The search terminates.</dd><dt><a class=permalink href=#divert><code class=Cm id=divert>divert</code></a><var class=Ar>port</var></dt><dd>Divert packets that match this rule to the <a class=Xr href=divert.4.html>divert(4)</a> socket bound to port <var class=Ar>port</var>. The search terminates.</dd><dt><a class=permalink href=#fwd><code class=Cm id=fwd>fwd</code></a> | <a class=permalink href=#forward><code class=Cm id=forward>forward</code></a><var class=Ar>ipaddr</var> | <var class=Ar>tablearg</var>[,<var class=Ar>port</var>]</dt><dd>Change the next-hop on matching packets to <var class=Ar>ipaddr</var>, which can be an IP address or a host name. The next hop can also be supplied by the last table looked up for the packet by using the <code class=Cm>tablearg</code> keyword instead of an explicit address. The search terminates if this rule matches. <p class=Pp>If <var class=Ar>ipaddr</var> is a local address, then matching packets will be forwarded to <var class=Ar>port</var> (or the port number in the packet if one is not specified in the rule) on the local machine. <br> If <var class=Ar>ipaddr</var> is not a local address, then the port number (if specified) is ignored, and the packet will be forwarded to the remote address, using the route as found in the local routing table for that IP. <br> A <var class=Ar>fwd</var> rule will not match layer2 packets (those received on ether_input, ether_output, or bridged). <br> The <code class=Cm>fwd</code> action does not change the contents of the packet at all. In particular, the destination address remains unmodified, so packets forwarded to another system will usually be rejected by that system unless there is a matching rule on that system to capture them. For packets forwarded locally, the local address of the socket will be set to the original destination address of the packet. This makes the <a class=Xr href=netstat.1.html>netstat(1)</a> entry look rather weird but is intended for use with transparent proxy servers.</p></dd><dt><a class=permalink href=#nat><code class=Cm id=nat>nat</code></a><var class=Ar>nat_nr</var> | <var class=Ar>global</var> | <var class=Ar>tablearg</var></dt><dd>Pass packet to a nat instance (for network address translation, address redirect, etc.): see the <a class=Sx href=#NETWORK_ADDRESS_TRANSLATION_(NAT)>NETWORK ADDRESS TRANSLATION (NAT)</a> Section for further information.</dd><dt><a class=permalink href=#nat64lsn><code class=Cm id=nat64lsn>nat64lsn</code></a><var class=Ar>name</var></dt><dd>Pass packet to a stateful NAT64 instance (for IPv6/IPv4 network address and protocol translation): see the <a class=Sx href=#IPv6/IPv4_NETWORK_ADDRESS_AND_PROTOCOL_TRANSLATION>IPv6/IPv4 NETWORK ADDRESS AND PROTOCOL TRANSLATION</a> Section for further information.</dd><dt><a class=permalink href=#nat64stl><code class=Cm id=nat64stl>nat64stl</code></a><var class=Ar>name</var></dt><dd>Pass packet to a stateless NAT64 instance (for IPv6/IPv4 network address and protocol translation): see the <a class=Sx href=#IPv6/IPv4_NETWORK_ADDRESS_AND_PROTOCOL_TRANSLATION>IPv6/IPv4 NETWORK ADDRESS AND PROTOCOL TRANSLATION</a> Section for further information.</dd><dt><a class=permalink href=#nat64clat><code class=Cm id=nat64clat>nat64clat</code></a><var class=Ar>name</var></dt><dd>Pass packet to a CLAT NAT64 instance (for client-side IPv6/IPv4 network address and protocol translation): see the <a class=Sx href=#IPv6/IPv4_NETWORK_ADDRESS_AND_PROTOCOL_TRANSLATION>IPv6/IPv4 NETWORK ADDRESS AND PROTOCOL TRANSLATION</a> Section for further information.</dd><dt><a class=permalink href=#nptv6><code class=Cm id=nptv6>nptv6</code></a><var class=Ar>name</var></dt><dd>Pass packet to a NPTv6 instance (for IPv6-to-IPv6 network prefix translation): see the <a class=Sx href=#IPv6-to_IPv6_NETWORK_PREFIX_TRANSLATION_(NPTv6)>IPv6-to-IPv6 NETWORK PREFIX TRANSLATION (NPTv6)</a> Section for further information.</dd><dt><a class=permalink href=#pipe><code class=Cm id=pipe>pipe</code></a><var class=Ar>pipe_nr</var></dt><dd>Pass packet to a <code class=Nm>dummynet</code> “pipe” (for bandwidth limitation, delay, etc.). See the <a class=Sx href=#TRAFFIC_SHAPER_(DUMMYNET)_CONFIGURATION>TRAFFIC SHAPER (DUMMYNET) CONFIGURATION</a> Section for further information. The search terminates; however, on exit from the pipe and if the <a class=Xr href=sysctl.8.html>sysctl(8)</a> variable <var class=Va>net.inet.ip.fw.one_pass</var> is not set, the packet is passed again to the firewall code starting from the next rule.</dd><dt><a class=permalink href=#queue><code class=Cm id=queue>queue</code></a><var class=Ar>queue_nr</var></dt><dd>Pass packet to a <code class=Nm>dummynet</code> “queue” (for bandwidth limitation using WF2Q+).</dd><dt><a class=permalink href=#reject><code class=Cm id=reject>reject</code></a></dt><dd>(Deprecated). Synonym for <code class=Cm>unreach host</code>.</dd><dt><a class=permalink href=#reset><code class=Cm id=reset>reset</code></a></dt><dd>Discard packets that match this rule, and if the packet is a TCP packet, try to send a TCP reset (RST) notice. The search terminates.</dd><dt><a class=permalink href=#reset6><code class=Cm id=reset6>reset6</code></a></dt><dd>Discard packets that match this rule, and if the packet is a TCP packet, try to send a TCP reset (RST) notice. The search terminates.</dd><dt><a class=permalink href=#skipto><code class=Cm id=skipto>skipto</code></a><var class=Ar>number</var> | <var class=Ar>tablearg</var></dt><dd>Skip all subsequent rules numbered less than <var class=Ar>number</var>. The search continues with the first rule numbered <var class=Ar>number</var> or higher. It is possible to use the <code class=Cm>tablearg</code> keyword with a skipto for a <i class=Em>computed</i> skipto. Skipto may work either in O(log(N)) or in O(1) depending on amount of memory and/or sysctl variables. See the <a class=Sx href=#SYSCTL_VARIABLES>SYSCTL VARIABLES</a> section for more details.</dd><dt><a class=permalink href=#call><code class=Cm id=call>call</code></a><var class=Ar>number</var> | <var class=Ar>tablearg</var></dt><dd>The current rule number is saved in the internal stack and ruleset processing continues with the first rule numbered <var class=Ar>number</var> or higher. If later a rule with the <code class=Cm>return</code> action is encountered, the processing returns to the first rule with number of this <code class=Cm>call</code> rule plus one or higher (the same behaviour as with packets returning from <a class=Xr href=divert.4.html>divert(4)</a> socket after a <code class=Cm>divert</code> action). This could be used to make somewhat like an assembly language “subroutine” calls to rules with common checks for different interfaces, etc. <p class=Pp>Rule with any number could be called, not just forward jumps as with <code class=Cm>skipto</code>. So, to prevent endless loops in case of mistakes, both <code class=Cm>call</code> and <code class=Cm>return</code> actions don't do any jumps and simply go to the next rule if memory cannot be allocated or stack overflowed/underflowed.</p><p class=Pp>Internally stack for rule numbers is implemented using <a class=Xr href=mbuf_tags.9.html>mbuf_tags(9)</a> facility and currently has size of 16 entries. As mbuf tags are lost when packet leaves the kernel, <code class=Cm>divert</code> should not be used in subroutines to avoid endless loops and other undesired effects.</p></dd><dt><a class=permalink href=#return><code class=Cm id=return>return</code></a></dt><dd>Takes rule number saved to internal stack by the last <code class=Cm>call</code> action and returns ruleset processing to the first rule with number greater than number of corresponding <code class=Cm>call</code> rule. See description of the <code class=Cm>call</code> action for more details. <p class=Pp>Note that <code class=Cm>return</code> rules usually end a “subroutine” and thus are unconditional, but <code class=Nm>ipfw</code> command-line utility currently requires every action except <code class=Cm>check-state</code> to have body. While it is sometimes useful to return only on some packets, usually you want to print just “return” for readability. A workaround for this is to use new syntax and <code class=Fl>-c</code> switch:</p><div class="Bd Pp Bd-indent"><pre>
# Add a rule without actual body
ipfw add 2999 return via any

# List rules without "from any to any" part
ipfw -c list
    </pre></div><p class=Pp>This cosmetic annoyance may be fixed in future releases.</p></dd><dt><a class=permalink href=#tee><code class=Cm id=tee>tee</code></a><var class=Ar>port</var></dt><dd>Send a copy of packets matching this rule to the <a class=Xr href=divert.4.html>divert(4)</a> socket bound to port <var class=Ar>port</var>. The search continues with the next rule.</dd><dt><a class=permalink href=#unreach><code class=Cm id=unreach>unreach</code></a><var class=Ar>code</var> [mtu]</dt><dd>Discard packets that match this rule, and try to send an ICMP unreachable notice with code <var class=Ar>code</var>, where <var class=Ar>code</var> is a number from 0 to 255, or one of these aliases: <code class=Cm>net</code>, <code class=Cm>host</code>, <code class=Cm>protocol</code>, <code class=Cm>port</code>, <code class=Cm>needfrag</code>, <code class=Cm>srcfail</code>, <code class=Cm>net-unknown</code>, <code class=Cm>host-unknown</code>, <code class=Cm>isolated</code>, <code class=Cm>net-prohib</code>, <code class=Cm>host-prohib</code>, <code class=Cm>tosnet</code>, <code class=Cm>toshost</code>, <code class=Cm>filter-prohib</code>, <code class=Cm>host-precedence</code> or <code class=Cm>precedence-cutoff</code>. The <code class=Cm>needfrag</code> code may have an optional <var class=Ar>mtu</var> parameter. If specified, the MTU value will be put into generated ICMP packet. The search terminates.</dd><dt><a class=permalink href=#unreach6><code class=Cm id=unreach6>unreach6</code></a><var class=Ar>code</var></dt><dd>Discard packets that match this rule, and try to send an ICMPv6 unreachable notice with code <var class=Ar>code</var>, where <var class=Ar>code</var> is a number from 0, 1, 3 or 4, or one of these aliases: <code class=Cm>no-route, admin-prohib, address</code> or <code class=Cm>port</code>. The search terminates.</dd><dt><a class=permalink href=#netgraph><code class=Cm id=netgraph>netgraph</code></a><var class=Ar>cookie</var></dt><dd>Divert packet into netgraph with given <var class=Ar>cookie</var>. The search terminates. If packet is later returned from netgraph it is either accepted or continues with the next rule, depending on <var class=Va>net.inet.ip.fw.one_pass</var> sysctl variable.</dd><dt><a class=permalink href=#ngtee><code class=Cm id=ngtee>ngtee</code></a><var class=Ar>cookie</var></dt><dd>A copy of packet is diverted into netgraph, original packet continues with the next rule. See <a class=Xr href=ng_ipfw.4.html>ng_ipfw(4)</a> for more information on <code class=Cm>netgraph</code> and <code class=Cm>ngtee</code> actions.</dd><dt><a class=permalink href=#setfib><code class=Cm id=setfib>setfib</code></a><var class=Ar>fibnum</var> | <var class=Ar>tablearg</var></dt><dd>The packet is tagged so as to use the FIB (routing table) <var class=Ar>fibnum</var> in any subsequent forwarding decisions. In the current implementation, this is limited to the values 0 through 15, see <a class=Xr href=setfib.2.html>setfib(2)</a>. Processing continues at the next rule. It is possible to use the <code class=Cm>tablearg</code> keyword with setfib. If the tablearg value is not within the compiled range of fibs, the packet's fib is set to 0.</dd><dt><a class=permalink href=#setdscp><code class=Cm id=setdscp>setdscp</code></a><var class=Ar>DSCP</var> | <var class=Ar>number</var> | <var class=Ar>tablearg</var></dt><dd>Set specified DiffServ codepoint for an IPv4/IPv6 packet. Processing continues at the next rule. Supported values are: <p class=Pp><code class=Cm>cs0</code> (<code class=Dv>000000</code>), <code class=Cm>cs1</code> (<code class=Dv>001000</code>), <code class=Cm>cs2</code> (<code class=Dv>010000</code>), <code class=Cm>cs3</code> (<code class=Dv>011000</code>), <code class=Cm>cs4</code> (<code class=Dv>100000</code>), <code class=Cm>cs5</code> (<code class=Dv>101000</code>), <code class=Cm>cs6</code> (<code class=Dv>110000</code>), <code class=Cm>cs7</code> (<code class=Dv>111000</code>), <code class=Cm>af11</code> (<code class=Dv>001010</code>), <code class=Cm>af12</code> (<code class=Dv>001100</code>), <code class=Cm>af13</code> (<code class=Dv>001110</code>), <code class=Cm>af21</code> (<code class=Dv>010010</code>), <code class=Cm>af22</code> (<code class=Dv>010100</code>), <code class=Cm>af23</code> (<code class=Dv>010110</code>), <code class=Cm>af31</code> (<code class=Dv>011010</code>), <code class=Cm>af32</code> (<code class=Dv>011100</code>), <code class=Cm>af33</code> (<code class=Dv>011110</code>), <code class=Cm>af41</code> (<code class=Dv>100010</code>), <code class=Cm>af42</code> (<code class=Dv>100100</code>), <code class=Cm>af43</code> (<code class=Dv>100110</code>), <code class=Cm>ef</code> (<code class=Dv>101110</code>), <code class=Cm>be</code> (<code class=Dv>000000</code>). Additionally, DSCP value can be specified by number (0..63). It is also possible to use the <code class=Cm>tablearg</code> keyword with setdscp. If the tablearg value is not within the 0..63 range, lower 6 bits of supplied value are used.</p></dd><dt><a class=permalink href=#tcp-setmss><code class=Cm id=tcp-setmss>tcp-setmss</code></a><var class=Ar>mss</var></dt><dd>Set the Maximum Segment Size (MSS) in the TCP segment to value <var class=Ar>mss</var>. The kernel module <code class=Cm>ipfw_pmod</code> should be loaded or kernel should have <code class=Cm>options IPFIREWALL_PMOD</code> to be able use this action. This command does not change a packet if original MSS value is lower than specified value. Both TCP over IPv4 and over IPv6 are supported. Regardless of matched a packet or not by the <code class=Cm>tcp-setmss</code> rule, the search continues with the next rule.</dd><dt><a class=permalink href=#reass><code class=Cm id=reass>reass</code></a></dt><dd>Queue and reassemble IPv4 fragments. If the packet is not fragmented, counters are updated and processing continues with the next rule. If the packet is the last logical fragment, the packet is reassembled and, if <var class=Va>net.inet.ip.fw.one_pass</var> is set to 0, processing continues with the next rule. Otherwise, the packet is allowed to pass and the search terminates. If the packet is a fragment in the middle of a logical group of fragments, it is consumed and processing stops immediately. <p class=Pp>Fragment handling can be tuned via <var class=Va>net.inet.ip.maxfragpackets</var> and <var class=Va>net.inet.ip.maxfragsperpacket</var> which limit, respectively, the maximum number of processable fragments (default: 800) and the maximum number of fragments per packet (default: 16).</p><p class=Pp>NOTA BENE: since fragments do not contain port numbers, they should be avoided with the <code class=Nm>reass</code> rule. Alternatively, direction-based (like <code class=Nm>in</code> / <code class=Nm>out</code> ) and source-based (like <code class=Nm>via</code> ) match patterns can be used to select fragments.</p><p class=Pp>Usually a simple rule like:</p><div class="Bd Pp Bd-indent"><pre>
# reassemble incoming fragments
ipfw add reass all from any to any in
    </pre></div><p class=Pp>is all you need at the beginning of your ruleset.</p></dd><dt><a class=permalink href=#abort><code class=Cm id=abort>abort</code></a></dt><dd>Discard packets that match this rule, and if the packet is an SCTP packet, try to send an SCTP packet containing an ABORT chunk. The search terminates.</dd><dt><a class=permalink href=#abort6><code class=Cm id=abort6>abort6</code></a></dt><dd>Discard packets that match this rule, and if the packet is an SCTP packet, try to send an SCTP packet containing an ABORT chunk. The search terminates.</dd></dl></section><section class=Ss><h2 class=Ss id=RULE_BODY><a class=permalink href=#RULE_BODY>RULE BODY</a></h2> The body of a rule contains zero or more patterns (such as specific source and destination addresses or ports, protocol options, incoming or outgoing interfaces, etc.) that the packet must match in order to be recognised. In general, the patterns are connected by (implicit) <code class=Cm>and</code> operators -- i.e., all must match in order for the rule to match. Individual patterns can be prefixed by the <code class=Cm>not</code> operator to reverse the result of the match, as in <p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add 100 allow ip from not 1.2.3.4 to any</code></div><p class=Pp>Additionally, sets of alternative match patterns (<i class=Em>or-blocks</i>) can be constructed by putting the patterns in lists enclosed between parentheses ( ) or braces { }, and using the <code class=Cm>or</code> operator as follows:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add 100 allow ip from { x or not y or z } to any</code></div><p class=Pp>Only one level of parentheses is allowed. Beware that most shells have special meanings for parentheses or braces, so it is advisable to put a backslash \ in front of them to prevent such interpretations.</p><p class=Pp>The body of a rule must in general include a source and destination address specifier. The keyword <var class=Ar>any</var> can be used in various places to specify that the content of a required field is irrelevant.</p><p class=Pp>The rule body has the following format:</p><div class="Bd Pp Bd-indent">[<var class=Ar>proto</var><code class=Cm>from</code><var class=Ar>src</var><code class=Cm>to</code><var class=Ar>dst</var>] [<var class=Ar>options</var>]</div><p class=Pp>The first part (proto from src to dst) is for backward compatibility with earlier versions of <span class=Ux>FreeBSD</span>. In modern <span class=Ux>FreeBSD</span> any match pattern (including MAC headers, IP protocols, addresses and ports) can be specified in the <var class=Ar>options</var> section.</p><p class=Pp>Rule fields have the following meaning:</p><dl class=Bl-tag><dt><var class=Ar>proto</var>: <var class=Ar>protocol</var> | <a class=permalink href=#_><code class=Cm id=_>{</code></a><var class=Ar>protocol</var><code class=Cm>or ... }</code></dt><dd style="width: auto;"> </dd><dt><var class=Ar>protocol</var>: [<code class=Cm>not</code>] <var class=Ar>protocol-name</var> | <var class=Ar>protocol-number</var></dt><dd>An IP protocol specified by number or name (for a complete list see <span class=Pa>/etc/protocols</span>), or one of the following keywords: <dl class=Bl-tag><dt><a class=permalink href=#ip4><code class=Cm id=ip4>ip4</code></a> | <a class=permalink href=#ipv4><code class=Cm id=ipv4>ipv4</code></a></dt><dd>Matches IPv4 packets.</dd><dt><a class=permalink href=#ip6><code class=Cm id=ip6>ip6</code></a> | <a class=permalink href=#ipv6><code class=Cm id=ipv6>ipv6</code></a></dt><dd>Matches IPv6 packets.</dd><dt><a class=permalink href=#ip><code class=Cm id=ip>ip</code></a> | <a class=permalink href=#all><code class=Cm id=all>all</code></a></dt><dd>Matches any packet.</dd></dl><p class=Pp>The <code class=Cm>ipv6</code> in <code class=Cm>proto</code> option will be treated as inner protocol. And, the <code class=Cm>ipv4</code> is not available in <code class=Cm>proto</code> option.</p><p class=Pp>The <code class=Cm>{</code><var class=Ar>protocol</var><code class=Cm>or ... }</code> format (an <i class=Em>or-block</i>) is provided for convenience only but its use is deprecated.</p></dd><dt><var class=Ar>src</var><span class=No>and</span><var class=Ar>dst</var>: {<code class=Cm>addr</code> | <code class=Cm>{</code><var class=Ar>addr</var><code class=Cm>or ... }</code>} [[<code class=Cm>not</code>] <var class=Ar>ports</var>]</dt><dd>An address (or a list, see below) optionally followed by <var class=Ar>ports</var> specifiers. <p class=Pp>The second format (<i class=Em>or-block</i> with multiple addresses) is provided for convenience only and its use is discouraged.</p></dd><dt><var class=Ar>addr</var>: [<code class=Cm>not</code>] {<code class=Cm>any</code> | <code class=Cm>me</code> | <code class=Cm>me6</code> | <code class=Cm>table</code>(<var class=Ar>name</var>[,<var class=Ar>value</var>]) | <var class=Ar>addr-list</var> | <var class=Ar>addr-set</var>}</dt><dd><dl class=Bl-tag><dt><a class=permalink href=#any><code class=Cm id=any>any</code></a></dt><dd>Matches any IP address.</dd><dt><a class=permalink href=#me><code class=Cm id=me>me</code></a></dt><dd>Matches any IP address configured on an interface in the system.</dd><dt><a class=permalink href=#me6><code class=Cm id=me6>me6</code></a></dt><dd>Matches any IPv6 address configured on an interface in the system. The address list is evaluated at the time the packet is analysed.</dd><dt><a class=permalink href=#table><code class=Cm id=table>table</code></a>(<var class=Ar>name</var>[,<var class=Ar>value</var>])</dt><dd>Matches any IPv4 or IPv6 address for which an entry exists in the lookup table <var class=Ar>number</var>. If an optional 32-bit unsigned <var class=Ar>value</var> is also specified, an entry will match only if it has this value. See the <a class=Sx href=#LOOKUP_TABLES>LOOKUP TABLES</a> section below for more information on lookup tables.</dd></dl></dd><dt><var class=Ar>addr-list</var>: <var class=Ar>ip-addr</var>[,<var class=Ar>addr-list</var>]</dt><dd style="width: auto;"> </dd><dt><var class=Ar>ip-addr</var>:</dt><dd>A host or subnet address specified in one of the following ways: <dl class=Bl-tag><dt><var class=Ar>numeric-ip</var> | <var class=Ar>hostname</var></dt><dd>Matches a single IPv4 address, specified as dotted-quad or a hostname. Hostnames are resolved at the time the rule is added to the firewall list.</dd><dt><var class=Ar>addr</var>/<var class=Ar>masklen</var></dt><dd>Matches all addresses with base <var class=Ar>addr</var> (specified as an IP address, a network number, or a hostname) and mask width of <code class=Cm>masklen</code> bits. As an example, 1.2.3.4/25 or 1.2.3.0/25 will match all IP numbers from 1.2.3.0 to 1.2.3.127 .</dd><dt><var class=Ar>addr</var>:<var class=Ar>mask</var></dt><dd>Matches all addresses with base <var class=Ar>addr</var> (specified as an IP address, a network number, or a hostname) and the mask of <var class=Ar>mask</var>, specified as a dotted quad. As an example, 1.2.3.4:255.0.255.0 or 1.0.3.0:255.0.255.0 will match 1.*.3.*. This form is advised only for non-contiguous masks. It is better to resort to the <var class=Ar>addr</var>/<var class=Ar>masklen</var> format for contiguous masks, which is more compact and less error-prone.</dd></dl></dd><dt><var class=Ar>addr-set</var>: <var class=Ar>addr</var>[/<var class=Ar>masklen</var>]<code class=Cm>{</code><var class=Ar>list</var><code class=Cm>}</code></dt><dd style="width: auto;"> </dd><dt><var class=Ar>list</var>: {<var class=Ar>num</var> | <var class=Ar>num-num</var>}[,<var class=Ar>list</var>]</dt><dd>Matches all addresses with base address <var class=Ar>addr</var> (specified as an IP address, a network number, or a hostname) and whose last byte is in the list between braces { } . Note that there must be no spaces between braces and numbers (spaces after commas are allowed). Elements of the list can be specified as single entries or ranges. The <var class=Ar>masklen</var> field is used to limit the size of the set of addresses, and can have any value between 24 and 32. If not specified, it will be assumed as 24. <br> This format is particularly useful to handle sparse address sets within a single rule. Because the matching occurs using a bitmask, it takes constant time and dramatically reduces the complexity of rulesets. <br> As an example, an address specified as 1.2.3.4/24{128,35-55,89} or 1.2.3.0/24{128,35-55,89} will match the following IP addresses: <br> 1.2.3.128, 1.2.3.35 to 1.2.3.55, 1.2.3.89 .</dd><dt><var class=Ar>addr6-list</var>: <var class=Ar>ip6-addr</var>[,<var class=Ar>addr6-list</var>]</dt><dd style="width: auto;"> </dd><dt><var class=Ar>ip6-addr</var>:</dt><dd>A host or subnet specified one of the following ways: <dl class=Bl-tag><dt><var class=Ar>numeric-ip</var> | <var class=Ar>hostname</var></dt><dd>Matches a single IPv6 address as allowed by <a class=Xr href=inet_pton.3.html>inet_pton(3)</a> or a hostname. Hostnames are resolved at the time the rule is added to the firewall list.</dd><dt><var class=Ar>addr</var>/<var class=Ar>masklen</var></dt><dd>Matches all IPv6 addresses with base <var class=Ar>addr</var> (specified as allowed by <a class=Xr href=inet_pton.3.html>inet_pton(3)</a> or a hostname) and mask width of <code class=Cm>masklen</code> bits.</dd><dt><var class=Ar>addr</var>/<var class=Ar>mask</var></dt><dd>Matches all IPv6 addresses with base <var class=Ar>addr</var> (specified as allowed by <a class=Xr href=inet_pton.3.html>inet_pton(3)</a> or a hostname) and the mask of <var class=Ar>mask</var>, specified as allowed by <a class=Xr href=inet_pton.3.html>inet_pton(3)</a>. As an example, fe::640:0:0/ffff::ffff:ffff:0:0 will match fe:*:*:*:0:640:*:*. This form is advised only for non-contiguous masks. It is better to resort to the <var class=Ar>addr</var>/<var class=Ar>masklen</var> format for contiguous masks, which is more compact and less error-prone.</dd></dl><p class=Pp>No support for sets of IPv6 addresses is provided because IPv6 addresses are typically random past the initial prefix.</p></dd><dt><var class=Ar>ports</var>: {<var class=Ar>port</var> | <var class=Ar>port</var>-<var class=Ar>port</var>}[,<var class=Ar>ports</var>]</dt><dd>For protocols which support port numbers (such as SCTP, TCP and UDP), optional <code class=Cm>ports</code> may be specified as one or more ports or port ranges, separated by commas but no spaces, and an optional <code class=Cm>not</code> operator. The ‘<code class=Li>-</code>’ notation specifies a range of ports (including boundaries). <p class=Pp>Service names (from <span class=Pa>/etc/services</span>) may be used instead of numeric port values. The length of the port list is limited to 30 ports or ranges, though one can specify larger ranges by using an <i class=Em>or-block</i> in the <code class=Cm>options</code> section of the rule.</p><p class=Pp>A backslash (‘<code class=Li>\</code>’) can be used to escape the dash (‘<code class=Li>-</code>’) character in a service name (from a shell, the backslash must be typed twice to avoid the shell itself interpreting it as an escape character).</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add count tcp from any ftp\\-data-ftp to any</code></div><p class=Pp>Fragmented packets which have a non-zero offset (i.e., not the first fragment) will never match a rule which has one or more port specifications. See the <code class=Cm>frag</code> option for details on matching fragmented packets.</p></dd></dl></section><section class=Ss><h2 class=Ss id=RULE_OPTIONS_(MATCH_PATTERNS)><a class=permalink href=#RULE_OPTIONS_(MATCH_PATTERNS)>RULE OPTIONS (MATCH PATTERNS)</a></h2> Additional match patterns can be used within rules. Zero or more of these so-called <i class=Em>options</i> can be present in a rule, optionally prefixed by the <code class=Cm>not</code> operand, and possibly grouped into <i class=Em>or-blocks</i>. <p class=Pp>The following match patterns can be used (listed in alphabetical order):</p><dl class=Bl-tag><dt><a class=permalink href=#//_this_is_a_comment><code class=Cm id=//_this_is_a_comment>// this is a comment</code></a>.</dt><dd>Inserts the specified text as a comment in the rule. Everything following // is considered as a comment and stored in the rule. You can have comment-only rules, which are listed as having a <code class=Cm>count</code> action followed by the comment.</dd><dt><a class=permalink href=#bridged><code class=Cm id=bridged>bridged</code></a></dt><dd>Alias for <code class=Cm>layer2</code>.</dd><dt><a class=permalink href=#defer-immediate-action><code class=Cm id=defer-immediate-action>defer-immediate-action</code></a> | <a class=permalink href=#defer-action><code class=Cm id=defer-action>defer-action</code></a></dt><dd>A rule with this option will not perform normal action upon a match. This option is intended to be used with <code class=Cm>record-state</code> or <code class=Cm>keep-state</code> as the dynamic rule, created but ignored on match, will work as intended. Rules with both <code class=Cm>record-state</code> and <code class=Cm>defer-immediate-action</code> create a dynamic rule and continue with the next rule without actually performing the action part of this rule. When the rule is later activated via the state table, the action is performed as usual.</dd><dt><a class=permalink href=#diverted><code class=Cm id=diverted>diverted</code></a></dt><dd>Matches only packets generated by a divert socket.</dd><dt><a class=permalink href=#diverted-loopback><code class=Cm id=diverted-loopback>diverted-loopback</code></a></dt><dd>Matches only packets coming from a divert socket back into the IP stack input for delivery.</dd><dt><a class=permalink href=#diverted-output><code class=Cm id=diverted-output>diverted-output</code></a></dt><dd>Matches only packets going from a divert socket back outward to the IP stack output for delivery.</dd><dt><a class=permalink href=#dst-ip><code class=Cm id=dst-ip>dst-ip</code></a><var class=Ar>ip-address</var></dt><dd>Matches IPv4 packets whose destination IP is one of the address(es) specified as argument.</dd><dt>{<code class=Cm>dst-ip6</code> | <code class=Cm>dst-ipv6</code>} <var class=Ar>ip6-address</var></dt><dd>Matches IPv6 packets whose destination IP is one of the address(es) specified as argument.</dd><dt><a class=permalink href=#dst-port><code class=Cm id=dst-port>dst-port</code></a><var class=Ar>ports</var></dt><dd>Matches IP packets whose destination port is one of the port(s) specified as argument.</dd><dt><a class=permalink href=#established><code class=Cm id=established>established</code></a></dt><dd>Matches TCP packets that have the RST or ACK bits set.</dd><dt><a class=permalink href=#ext6hdr><code class=Cm id=ext6hdr>ext6hdr</code></a><var class=Ar>header</var></dt><dd>Matches IPv6 packets containing the extended header given by <var class=Ar>header</var>. Supported headers are: <p class=Pp>Fragment, (<code class=Cm>frag</code>), Hop-to-hop options (<code class=Cm>hopopt</code>), any type of Routing Header (<code class=Cm>route</code>), Source routing Routing Header Type 0 (<code class=Cm>rthdr0</code>), Mobile IPv6 Routing Header Type 2 (<code class=Cm>rthdr2</code>), Destination options (<code class=Cm>dstopt</code>), IPSec authentication headers (<code class=Cm>ah</code>), and IPsec encapsulated security payload headers (<code class=Cm>esp</code>).</p></dd><dt><a class=permalink href=#fib><code class=Cm id=fib>fib</code></a><var class=Ar>fibnum</var></dt><dd>Matches a packet that has been tagged to use the given FIB (routing table) number.</dd><dt><a class=permalink href=#flow><code class=Cm id=flow>flow</code></a><var class=Ar>table</var>(<var class=Ar>name</var>[,<var class=Ar>value</var>])</dt><dd>Search for the flow entry in lookup table <var class=Ar>name</var>. If not found, the match fails. Otherwise, the match succeeds and <code class=Cm>tablearg</code> is set to the value extracted from the table. <p class=Pp>This option can be useful to quickly dispatch traffic based on certain packet fields. See the <a class=Sx href=#LOOKUP_TABLES>LOOKUP TABLES</a> section below for more information on lookup tables.</p></dd><dt><a class=permalink href=#flow-id><code class=Cm id=flow-id>flow-id</code></a><var class=Ar>labels</var></dt><dd>Matches IPv6 packets containing any of the flow labels given in <var class=Ar>labels</var>. <var class=Ar>labels</var> is a comma separated list of numeric flow labels.</dd><dt><a class=permalink href=#dst-mac><code class=Cm id=dst-mac>dst-mac</code></a><var class=Ar>table</var>(<var class=Ar>name</var>[,<var class=Ar>value</var>])</dt><dd>Search for the destination MAC address entry in lookup table <var class=Ar>name</var>. If not found, the match fails. Otherwise, the match succeeds and <code class=Cm>tablearg</code> is set to the value extracted from the table.</dd><dt><a class=permalink href=#src-mac><code class=Cm id=src-mac>src-mac</code></a><var class=Ar>table</var>(<var class=Ar>name</var>[,<var class=Ar>value</var>])</dt><dd>Search for the source MAC address entry in lookup table <var class=Ar>name</var>. If not found, the match fails. Otherwise, the match succeeds and <code class=Cm>tablearg</code> is set to the value extracted from the table.</dd><dt><a class=permalink href=#frag><code class=Cm id=frag>frag</code></a><var class=Ar>spec</var></dt><dd>Matches IPv4 packets whose <code class=Cm>ip_off</code> field contains the comma separated list of IPv4 fragmentation options specified in <var class=Ar>spec</var>. The recognized options are: <code class=Cm>df</code> (<code class=Dv>don't fragment</code>), <code class=Cm>mf</code> (<code class=Dv>more fragments</code>), <code class=Cm>rf</code> (<code class=Dv>reserved fragment bit</code>) <code class=Cm>offset</code> (<code class=Dv>non-zero fragment offset</code>). The absence of a particular options may be denoted with a ‘<code class=Li>!</code>’. <p class=Pp>Empty list of options defaults to matching on non-zero fragment offset. Such rule would match all not the first fragment datagrams, both IPv4 and IPv6. This is a backward compatibility with older rulesets.</p></dd><dt><a class=permalink href=#gid><code class=Cm id=gid>gid</code></a><var class=Ar>group</var></dt><dd>Matches all TCP or UDP packets sent by or received for a <var class=Ar>group</var>. A <var class=Ar>group</var> may be specified by name or number.</dd><dt><a class=permalink href=#jail><code class=Cm id=jail>jail</code></a><var class=Ar>jail</var></dt><dd>Matches all TCP or UDP packets sent by or received for the jail whose ID or name is <var class=Ar>jail</var>.</dd><dt><a class=permalink href=#icmptypes><code class=Cm id=icmptypes>icmptypes</code></a><var class=Ar>types</var></dt><dd>Matches ICMP packets whose ICMP type is in the list <var class=Ar>types</var>. The list may be specified as any combination of individual types (numeric) separated by commas. <i class=Em>Ranges are not allowed</i>. The supported ICMP types are: <p class=Pp>echo reply (<code class=Cm>0</code>), destination unreachable (<code class=Cm>3</code>), source quench (<code class=Cm>4</code>), redirect (<code class=Cm>5</code>), echo request (<code class=Cm>8</code>), router advertisement (<code class=Cm>9</code>), router solicitation (<code class=Cm>10</code>), time-to-live exceeded (<code class=Cm>11</code>), IP header bad (<code class=Cm>12</code>), timestamp request (<code class=Cm>13</code>), timestamp reply (<code class=Cm>14</code>), information request (<code class=Cm>15</code>), information reply (<code class=Cm>16</code>), address mask request (<code class=Cm>17</code>) and address mask reply (<code class=Cm>18</code>).</p></dd><dt><a class=permalink href=#icmp6types><code class=Cm id=icmp6types>icmp6types</code></a><var class=Ar>types</var></dt><dd>Matches ICMP6 packets whose ICMP6 type is in the list of <var class=Ar>types</var>. The list may be specified as any combination of individual types (numeric) separated by commas. <i class=Em>Ranges are not allowed</i>.</dd><dt><a class=permalink href=#in><code class=Cm id=in>in</code></a> | <a class=permalink href=#out><code class=Cm id=out>out</code></a></dt><dd>Matches incoming or outgoing packets, respectively. <code class=Cm>in</code> and <code class=Cm>out</code> are mutually exclusive (in fact, <code class=Cm>out</code> is implemented as <code class=Cm>not in</code><span class=No>).</span></dd><dt><a class=permalink href=#ipid><code class=Cm id=ipid>ipid</code></a><var class=Ar>id-list</var></dt><dd>Matches IPv4 packets whose <code class=Cm>ip_id</code> field has value included in <var class=Ar>id-list</var>, which is either a single value or a list of values or ranges specified in the same way as <var class=Ar>ports</var>.</dd><dt><a class=permalink href=#iplen><code class=Cm id=iplen>iplen</code></a><var class=Ar>len-list</var></dt><dd>Matches IP packets whose total length, including header and data, is in the set <var class=Ar>len-list</var>, which is either a single value or a list of values or ranges specified in the same way as <var class=Ar>ports</var>.</dd><dt><a class=permalink href=#ipoptions><code class=Cm id=ipoptions>ipoptions</code></a><var class=Ar>spec</var></dt><dd>Matches packets whose IPv4 header contains the comma separated list of options specified in <var class=Ar>spec</var>. The supported IP options are: <p class=Pp><code class=Cm>ssrr</code> (strict source route), <code class=Cm>lsrr</code> (loose source route), <code class=Cm>rr</code> (record packet route) and <code class=Cm>ts</code> (timestamp). The absence of a particular option may be denoted with a ‘<code class=Li>!</code>’.</p></dd><dt><a class=permalink href=#ipprecedence><code class=Cm id=ipprecedence>ipprecedence</code></a><var class=Ar>precedence</var></dt><dd>Matches IPv4 packets whose precedence field is equal to <var class=Ar>precedence</var>.</dd><dt><a class=permalink href=#ipsec><code class=Cm id=ipsec>ipsec</code></a></dt><dd>Matches packets that have IPSEC history associated with them (i.e., the packet comes encapsulated in IPSEC, the kernel has IPSEC support, and can correctly decapsulate it). <p class=Pp>Note that specifying <code class=Cm>ipsec</code> is different from specifying <code class=Cm>proto</code><var class=Ar>ipsec</var> as the latter will only look at the specific IP protocol field, irrespective of IPSEC kernel support and the validity of the IPSEC data.</p><p class=Pp>Further note that this flag is silently ignored in kernels without IPSEC support. It does not affect rule processing when given and the rules are handled as if with no <code class=Cm>ipsec</code> flag.</p></dd><dt><a class=permalink href=#iptos><code class=Cm id=iptos>iptos</code></a><var class=Ar>spec</var></dt><dd>Matches IPv4 packets whose <code class=Cm>tos</code> field contains the comma separated list of service types specified in <var class=Ar>spec</var>. The supported IP types of service are: <p class=Pp><code class=Cm>lowdelay</code> (<code class=Dv>IPTOS_LOWDELAY</code>), <code class=Cm>throughput</code> (<code class=Dv>IPTOS_THROUGHPUT</code>), <code class=Cm>reliability</code> (<code class=Dv>IPTOS_RELIABILITY</code>), <code class=Cm>mincost</code> (<code class=Dv>IPTOS_MINCOST</code>), <code class=Cm>congestion</code> (<code class=Dv>IPTOS_ECN_CE</code>). The absence of a particular type may be denoted with a ‘<code class=Li>!</code>’.</p></dd><dt><a class=permalink href=#dscp_spec><code class=Cm id=dscp_spec>dscp spec</code></a>[,<var class=Ar>spec</var>]</dt><dd>Matches IPv4/IPv6 packets whose <code class=Cm>DS</code> field value is contained in <var class=Ar>spec</var> mask. Multiple values can be specified via the comma separated list. Value can be one of keywords used in <code class=Cm>setdscp</code> action or exact number.</dd><dt><a class=permalink href=#ipttl><code class=Cm id=ipttl>ipttl</code></a><var class=Ar>ttl-list</var></dt><dd>Matches IPv4 packets whose time to live is included in <var class=Ar>ttl-list</var>, which is either a single value or a list of values or ranges specified in the same way as <var class=Ar>ports</var>.</dd><dt><a class=permalink href=#ipversion><code class=Cm id=ipversion>ipversion</code></a><var class=Ar>ver</var></dt><dd>Matches IP packets whose IP version field is <var class=Ar>ver</var>.</dd><dt><a class=permalink href=#keep-state><code class=Cm id=keep-state>keep-state</code></a> [<var class=Ar>:flowname</var>]</dt><dd>Upon a match, the firewall will create a dynamic rule, whose default behaviour is to match bidirectional traffic between source and destination IP/port using the same protocol. The rule has a limited lifetime (controlled by a set of <a class=Xr href=sysctl.8.html>sysctl(8)</a> variables), and the lifetime is refreshed every time a matching packet is found. The <var class=Ar>:flowname</var> is used to assign additional to addresses, ports and protocol parameter to dynamic rule. It can be used for more accurate matching by <code class=Cm>check-state</code> rule. The <code class=Cm>:default</code> keyword is special name used for compatibility with old rulesets.</dd><dt><a class=permalink href=#layer2><code class=Cm id=layer2>layer2</code></a></dt><dd>Matches only layer2 packets, i.e., those passed to <code class=Nm>ipfw</code> from <code class=Fn>ether_demux</code>() and <code class=Fn>ether_output_frame</code>().</dd><dt><a class=permalink href=#limit><code class=Cm id=limit>limit</code></a> {<code class=Cm>src-addr</code> | <code class=Cm>src-port</code> | <code class=Cm>dst-addr</code> | <code class=Cm>dst-port</code>} <var class=Ar>N</var> [<var class=Ar>:flowname</var>]</dt><dd>The firewall will only allow <var class=Ar>N</var> connections with the same set of parameters as specified in the rule. One or more of source and destination addresses and ports can be specified.</dd><dt><a class=permalink href=#lookup><code class=Cm id=lookup>lookup</code></a> {<code class=Cm>dst-ip</code> | <code class=Cm>dst-port</code> | <code class=Cm>dst-mac</code> | <code class=Cm>src-ip</code> | <code class=Cm>src-port</code> | <code class=Cm>src-mac</code> | <code class=Cm>uid</code> | <code class=Cm>jail</code>} <var class=Ar>name</var></dt><dd>Search an entry in lookup table <var class=Ar>name</var> that matches the field specified as argument. If not found, the match fails. Otherwise, the match succeeds and <code class=Cm>tablearg</code> is set to the value extracted from the table. <p class=Pp>This option can be useful to quickly dispatch traffic based on certain packet fields. See the <a class=Sx href=#LOOKUP_TABLES>LOOKUP TABLES</a> section below for more information on lookup tables.</p></dd><dt><a class=permalink href=#__MAC><code class=Cm id=__MAC>{ MAC</code></a> | <a class=permalink href=#mac__><code class=Cm id=mac__>mac }</code></a><var class=Ar>dst-mac src-mac</var></dt><dd>Match packets with a given <var class=Ar>dst-mac</var> and <var class=Ar>src-mac</var> addresses, specified as the <code class=Cm>any</code> keyword (matching any MAC address), or six groups of hex digits separated by colons, and optionally followed by a mask indicating the significant bits. The mask may be specified using either of the following methods: <ol class=Bl-enum><li>A slash (/) followed by the number of significant bits. For example, an address with 33 significant bits could be specified as: <p class=Pp></p><div class="Bd Bd-indent"><code class=Li>MAC 10:20:30:40:50:60/33 any</code></div></li><li>An ampersand (&amp;) followed by a bitmask specified as six groups of hex digits separated by colons. For example, an address in which the last 16 bits are significant could be specified as: <p class=Pp></p><div class="Bd Bd-indent"><code class=Li>MAC 10:20:30:40:50:60&amp;00:00:00:00:ff:ff any</code></div><p class=Pp>Note that the ampersand character has a special meaning in many shells and should generally be escaped.</p></li></ol> Note that the order of MAC addresses (destination first, source second) is the same as on the wire, but the opposite of the one used for IP addresses.</dd><dt><a class=permalink href=#mac-type><code class=Cm id=mac-type>mac-type</code></a><var class=Ar>mac-type</var></dt><dd>Matches packets whose Ethernet Type field corresponds to one of those specified as argument. <var class=Ar>mac-type</var> is specified in the same way as <code class=Cm>port numbers</code> (i.e., one or more comma-separated single values or ranges). You can use symbolic names for known values such as <i class=Em>vlan</i>, <i class=Em>ipv4, ipv6</i>. Values can be entered as decimal or hexadecimal (if prefixed by 0x), and they are always printed as hexadecimal (unless the <code class=Cm>-N</code> option is used, in which case symbolic resolution will be attempted).</dd><dt><a class=permalink href=#proto><code class=Cm id=proto>proto</code></a><var class=Ar>protocol</var></dt><dd>Matches packets with the corresponding IP protocol.</dd><dt><a class=permalink href=#record-state><code class=Cm id=record-state>record-state</code></a></dt><dd>Upon a match, the firewall will create a dynamic rule as if <code class=Cm>keep-state</code> was specified. However, this option doesn't imply an implicit <code class=Cm>check-state</code> in contrast to <code class=Cm>keep-state</code>.</dd><dt><a class=permalink href=#recv><code class=Cm id=recv>recv</code></a> | <a class=permalink href=#xmit><code class=Cm id=xmit>xmit</code></a> | <a class=permalink href=#via><code class=Cm id=via>via</code></a> {<var class=Ar>ifX</var> | <var class=Ar>if</var><code class=Cm>*</code> | <var class=Ar>table</var>(<var class=Ar>name</var>[,<var class=Ar>value</var>]) | <var class=Ar>ipno</var> | <var class=Ar>any</var>}</dt><dd>Matches packets received, transmitted or going through, respectively, the interface specified by exact name (<var class=Ar>ifX</var>), by device name (<var class=Ar>if*</var>), by IP address, or through some interface. Table <var class=Ar>name</var> may be used to match interface by its kernel ifindex. See the <a class=Sx href=#LOOKUP_TABLES>LOOKUP TABLES</a> section below for more information on lookup tables. <p class=Pp>The <code class=Cm>via</code> keyword causes the interface to always be checked. If <code class=Cm>recv</code> or <code class=Cm>xmit</code> is used instead of <code class=Cm>via</code>, then only the receive or transmit interface (respectively) is checked. By specifying both, it is possible to match packets based on both receive and transmit interface, e.g.:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add deny ip from any to any out recv ed0 xmit ed1</code></div><p class=Pp>The <code class=Cm>recv</code> interface can be tested on either incoming or outgoing packets, while the <code class=Cm>xmit</code> interface can only be tested on outgoing packets. So <code class=Cm>out</code> is required (and <code class=Cm>in</code> is invalid) whenever <code class=Cm>xmit</code> is used.</p><p class=Pp>A packet might not have a receive or transmit interface: packets originating from the local host have no receive interface, while packets destined for the local host have no transmit interface.</p></dd><dt><a class=permalink href=#set-limit><code class=Cm id=set-limit>set-limit</code></a> {<code class=Cm>src-addr</code> | <code class=Cm>src-port</code> | <code class=Cm>dst-addr</code> | <code class=Cm>dst-port</code>} <var class=Ar>N</var></dt><dd>Works like <code class=Cm>limit</code> but does not have an implicit <code class=Cm>check-state</code> attached to it.</dd><dt><a class=permalink href=#setup><code class=Cm id=setup>setup</code></a></dt><dd>Matches TCP packets that have the SYN bit set but no ACK bit. This is the short form of “<code class=Li>tcpflags syn,!ack</code>”.</dd><dt><a class=permalink href=#sockarg><code class=Cm id=sockarg>sockarg</code></a></dt><dd>Matches packets that are associated to a local socket and for which the SO_USER_COOKIE socket option has been set to a non-zero value. As a side effect, the value of the option is made available as <code class=Cm>tablearg</code> value, which in turn can be used as <code class=Cm>skipto</code> or <code class=Cm>pipe</code> number.</dd><dt><a class=permalink href=#src-ip><code class=Cm id=src-ip>src-ip</code></a><var class=Ar>ip-address</var></dt><dd>Matches IPv4 packets whose source IP is one of the address(es) specified as an argument.</dd><dt><a class=permalink href=#src-ip6><code class=Cm id=src-ip6>src-ip6</code></a><var class=Ar>ip6-address</var></dt><dd>Matches IPv6 packets whose source IP is one of the address(es) specified as an argument.</dd><dt><a class=permalink href=#src-port><code class=Cm id=src-port>src-port</code></a><var class=Ar>ports</var></dt><dd>Matches IP packets whose source port is one of the port(s) specified as argument.</dd><dt><a class=permalink href=#tagged><code class=Cm id=tagged>tagged</code></a><var class=Ar>tag-list</var></dt><dd>Matches packets whose tags are included in <var class=Ar>tag-list</var>, which is either a single value or a list of values or ranges specified in the same way as <var class=Ar>ports</var>. Tags can be applied to the packet using <code class=Cm>tag</code> rule action parameter (see it's description for details on tags).</dd><dt><a class=permalink href=#tcpack><code class=Cm id=tcpack>tcpack</code></a><var class=Ar>ack</var></dt><dd>TCP packets only. Match if the TCP header acknowledgment number field is set to <var class=Ar>ack</var>.</dd><dt><a class=permalink href=#tcpdatalen><code class=Cm id=tcpdatalen>tcpdatalen</code></a><var class=Ar>tcpdatalen-list</var></dt><dd>Matches TCP packets whose length of TCP data is <var class=Ar>tcpdatalen-list</var>, which is either a single value or a list of values or ranges specified in the same way as <var class=Ar>ports</var>.</dd><dt><a class=permalink href=#tcpflags><code class=Cm id=tcpflags>tcpflags</code></a><var class=Ar>spec</var></dt><dd>TCP packets only. Match if the TCP header contains the comma separated list of flags specified in <var class=Ar>spec</var>. The supported TCP flags are: <p class=Pp><code class=Cm>fin</code>, <code class=Cm>syn</code>, <code class=Cm>rst</code>, <code class=Cm>psh</code>, <code class=Cm>ack</code> and <code class=Cm>urg</code>. The absence of a particular flag may be denoted with a ‘<code class=Li>!</code>’. A rule which contains a <code class=Cm>tcpflags</code> specification can never match a fragmented packet which has a non-zero offset. See the <code class=Cm>frag</code> option for details on matching fragmented packets.</p></dd><dt><a class=permalink href=#tcpmss><code class=Cm id=tcpmss>tcpmss</code></a><var class=Ar>tcpmss-list</var></dt><dd>Matches TCP packets whose MSS (maximum segment size) value is set to <var class=Ar>tcpmss-list</var>, which is either a single value or a list of values or ranges specified in the same way as <var class=Ar>ports</var>.</dd><dt><a class=permalink href=#tcpseq><code class=Cm id=tcpseq>tcpseq</code></a><var class=Ar>seq</var></dt><dd>TCP packets only. Match if the TCP header sequence number field is set to <var class=Ar>seq</var>.</dd><dt><a class=permalink href=#tcpwin><code class=Cm id=tcpwin>tcpwin</code></a><var class=Ar>tcpwin-list</var></dt><dd>Matches TCP packets whose header window field is set to <var class=Ar>tcpwin-list</var>, which is either a single value or a list of values or ranges specified in the same way as <var class=Ar>ports</var>.</dd><dt><a class=permalink href=#tcpoptions><code class=Cm id=tcpoptions>tcpoptions</code></a><var class=Ar>spec</var></dt><dd>TCP packets only. Match if the TCP header contains the comma separated list of options specified in <var class=Ar>spec</var>. The supported TCP options are: <p class=Pp><code class=Cm>mss</code> (maximum segment size), <code class=Cm>window</code> (tcp window advertisement), <code class=Cm>sack</code> (selective ack), <code class=Cm>ts</code> (rfc1323 timestamp) and <code class=Cm>cc</code> (rfc1644 t/tcp connection count). The absence of a particular option may be denoted with a ‘<code class=Li>!</code>’.</p></dd><dt><a class=permalink href=#uid><code class=Cm id=uid>uid</code></a><var class=Ar>user</var></dt><dd>Match all TCP or UDP packets sent by or received for a <var class=Ar>user</var>. A <var class=Ar>user</var> may be matched by name or identification number.</dd><dt><a class=permalink href=#verrevpath><code class=Cm id=verrevpath>verrevpath</code></a></dt><dd>For incoming packets, a routing table lookup is done on the packet's source address. If the interface on which the packet entered the system matches the outgoing interface for the route, the packet matches. If the interfaces do not match up, the packet does not match. All outgoing packets or packets with no incoming interface match. <p class=Pp>The name and functionality of the option is intentionally similar to the Cisco IOS command:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ip verify unicast reverse-path</code></div><p class=Pp>This option can be used to make anti-spoofing rules to reject all packets with source addresses not from this interface. See also the option <code class=Cm>antispoof</code>.</p></dd><dt><a class=permalink href=#versrcreach><code class=Cm id=versrcreach>versrcreach</code></a></dt><dd>For incoming packets, a routing table lookup is done on the packet's source address. If a route to the source address exists, but not the default route or a blackhole/reject route, the packet matches. Otherwise, the packet does not match. All outgoing packets match. <p class=Pp>The name and functionality of the option is intentionally similar to the Cisco IOS command:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ip verify unicast source reachable-via any</code></div><p class=Pp>This option can be used to make anti-spoofing rules to reject all packets whose source address is unreachable.</p></dd><dt><a class=permalink href=#antispoof><code class=Cm id=antispoof>antispoof</code></a></dt><dd>For incoming packets, the packet's source address is checked if it belongs to a directly connected network. If the network is directly connected, then the interface the packet came on in is compared to the interface the network is connected to. When incoming interface and directly connected interface are not the same, the packet does not match. Otherwise, the packet does match. All outgoing packets match. <p class=Pp>This option can be used to make anti-spoofing rules to reject all packets that pretend to be from a directly connected network but do not come in through that interface. This option is similar to but more restricted than <code class=Cm>verrevpath</code> because it engages only on packets with source addresses of directly connected networks instead of all source addresses.</p></dd></dl></section></section><section class=Sh><h2 class=Sh id=LOOKUP_TABLES_2><a class=permalink href=#LOOKUP_TABLES_2>LOOKUP TABLES</a></h2> Lookup tables are useful to handle large sparse sets of addresses or other search keys (e.g., ports, jail IDs, interface names). In the rest of this section we will use the term ``key''. Table name needs to match the following spec: <var class=Ar>table-name</var>. Tables with the same name can be created in different <var class=Ar>sets</var>. However, rule links to the tables in <var class=Ar>set 0</var> by default. This behavior can be controlled by <var class=Va>net.inet.ip.fw.tables_sets</var> variable. See the <a class=Sx href=#SETS_OF_RULES>SETS OF RULES</a> section for more information. There may be up to 65535 different lookup tables. <p class=Pp>The following table types are supported:</p><dl class=Bl-tag><dt><var class=Ar>table-type</var>: <var class=Ar>addr</var> | <var class=Ar>iface</var> | <var class=Ar>number</var> | <var class=Ar>flow</var> | <var class=Ar>mac</var></dt><dd style="width: auto;"> </dd><dt><var class=Ar>table-key</var>: <var class=Ar>addr</var>[/<var class=Ar>masklen</var>] | iface-name | number | flow-spec</dt><dd style="width: auto;"> </dd><dt><var class=Ar>flow-spec</var>: <var class=Ar>flow-field</var>[,<var class=Ar>flow-spec</var>]</dt><dd style="width: auto;"> </dd><dt><var class=Ar>flow-field</var>: <var class=Ar>src-ip</var> | <var class=Ar>proto</var> | <var class=Ar>src-port</var> | <var class=Ar>dst-ip</var> | <var class=Ar>dst-port</var></dt><dd style="width: auto;"> </dd><dt><a class=permalink href=#addr><code class=Cm id=addr>addr</code></a></dt><dd>Matches IPv4 or IPv6 address. Each entry is represented by an <var class=Ar>addr</var>[/<var class=Ar>masklen</var>] and will match all addresses with base <var class=Ar>addr</var> (specified as an IPv4/IPv6 address, or a hostname) and mask width of <var class=Ar>masklen</var> bits. If <var class=Ar>masklen</var> is not specified, it defaults to 32 for IPv4 and 128 for IPv6. When looking up an IP address in a table, the most specific entry will match.</dd><dt><a class=permalink href=#iface><code class=Cm id=iface>iface</code></a></dt><dd>Matches interface names. Each entry is represented by string treated as interface name. Wildcards are not supported.</dd><dt><a class=permalink href=#number><code class=Cm id=number>number</code></a></dt><dd>Matches protocol ports, uids/gids or jail IDs. Each entry is represented by 32-bit unsigned integer. Ranges are not supported.</dd><dt><a class=permalink href=#flow_2><code class=Cm id=flow_2>flow</code></a></dt><dd>Matches packet fields specified by <var class=Ar>flow</var> type suboptions with table entries.</dd><dt><a class=permalink href=#mac><code class=Cm id=mac>mac</code></a></dt><dd>Matches MAC address. Each entry is represented by an <var class=Ar>addr</var>[/<var class=Ar>masklen</var>] and will match all addresses with base <var class=Ar>addr</var> and mask width of <var class=Ar>masklen</var> bits. If <var class=Ar>masklen</var> is not specified, it defaults to 48. When looking up an MAC address in a table, the most specific entry will match.</dd></dl><p class=Pp>Tables require explicit creation via <code class=Cm>create</code> before use.</p><p class=Pp>The following creation options are supported:</p><dl class=Bl-tag><dt><var class=Ar>create-options</var>: <var class=Ar>create-option</var> | <var class=Ar>create-options</var></dt><dd style="width: auto;"> </dd><dt><var class=Ar>create-option</var>: <code class=Cm>type</code><var class=Ar>table-type</var> | <a class=permalink href=#valtype><code class=Cm id=valtype>valtype</code></a><var class=Ar>value-mask</var> | <a class=permalink href=#algo><code class=Cm id=algo>algo</code></a><var class=Ar>algo-desc</var> |</dt><dd><a class=permalink href=#limit_2><code class=Cm id=limit_2>limit</code></a><var class=Ar>number</var> | <a class=permalink href=#locked><code class=Cm id=locked>locked</code></a> | <a class=permalink href=#missing><code class=Cm id=missing>missing</code></a> | <a class=permalink href=#or-flush><code class=Cm id=or-flush>or-flush</code></a></dd><dt><a class=permalink href=#type><code class=Cm id=type>type</code></a></dt><dd>Table key type.</dd><dt><a class=permalink href=#valtype_2><code class=Cm id=valtype_2>valtype</code></a></dt><dd>Table value mask.</dd><dt><a class=permalink href=#algo_2><code class=Cm id=algo_2>algo</code></a></dt><dd>Table algorithm to use (see below).</dd><dt><a class=permalink href=#limit_3><code class=Cm id=limit_3>limit</code></a></dt><dd>Maximum number of items that may be inserted into table.</dd><dt><a class=permalink href=#locked_2><code class=Cm id=locked_2>locked</code></a></dt><dd>Restrict any table modifications.</dd><dt><a class=permalink href=#missing_2><code class=Cm id=missing_2>missing</code></a></dt><dd>Do not fail if table already exists and has exactly same options as new one.</dd><dt><a class=permalink href=#or-flush_2><code class=Cm id=or-flush_2>or-flush</code></a></dt><dd>Flush existing table with same name instead of returning error. Implies <code class=Cm>missing</code> so existing table must be compatible with new one.</dd></dl><p class=Pp>Some of these options may be modified later via <code class=Cm>modify</code> keyword. The following options can be changed:</p><dl class=Bl-tag><dt><var class=Ar>modify-options</var>: <var class=Ar>modify-option</var> | <var class=Ar>modify-options</var></dt><dd style="width: auto;"> </dd><dt><var class=Ar>modify-option</var>: <code class=Cm>limit</code><var class=Ar>number</var></dt><dd style="width: auto;"> </dd><dt><a class=permalink href=#limit_4><code class=Cm id=limit_4>limit</code></a></dt><dd>Alter maximum number of items that may be inserted into table.</dd></dl><p class=Pp>Additionally, table can be locked or unlocked using <code class=Cm>lock</code> or <code class=Cm>unlock</code> commands.</p><p class=Pp>Tables of the same <var class=Ar>type</var> can be swapped with each other using <code class=Cm>swap</code><var class=Ar>name</var> command. Swap may fail if tables limits are set and data exchange would result in limits hit. Operation is performed atomically.</p><p class=Pp>One or more entries can be added to a table at once using <code class=Cm>add</code> command. Addition of all items are performed atomically. By default, error in addition of one entry does not influence addition of other entries. However, non-zero error code is returned in that case. Special <code class=Cm>atomic</code> keyword may be specified before <code class=Cm>add</code> to indicate all-or-none add request.</p><p class=Pp>One or more entries can be removed from a table at once using <code class=Cm>delete</code> command. By default, error in removal of one entry does not influence removing of other entries. However, non-zero error code is returned in that case.</p><p class=Pp>It may be possible to check what entry will be found on particular <var class=Ar>table-key</var> using <code class=Cm>lookup</code><var class=Ar>table-key</var> command. This functionality is optional and may be unsupported in some algorithms.</p><p class=Pp>The following operations can be performed on <var class=Ar>one</var> or <code class=Cm>all</code> tables:</p><dl class=Bl-tag><dt><a class=permalink href=#list><code class=Cm id=list>list</code></a></dt><dd>List all entries.</dd><dt><a class=permalink href=#flush><code class=Cm id=flush>flush</code></a></dt><dd>Removes all entries.</dd><dt><a class=permalink href=#info><code class=Cm id=info>info</code></a></dt><dd>Shows generic table information.</dd><dt><a class=permalink href=#detail><code class=Cm id=detail>detail</code></a></dt><dd>Shows generic table information and algo-specific data.</dd></dl><p class=Pp>The following lookup algorithms are supported:</p><dl class=Bl-tag><dt><var class=Ar>algo-desc</var>: <var class=Ar>algo-name</var> | <var class=Ar>algo-name algo-data</var></dt><dd style="width: auto;"> </dd><dt><var class=Ar>algo-name</var>: <var class=Ar>addr: radix</var> | <var class=Ar>addr: hash</var> | <var class=Ar>iface: array</var> | <var class=Ar>number: array</var> | <var class=Ar>flow: hash</var> | <var class=Ar>mac: radix</var></dt><dd style="width: auto;"> </dd><dt><a class=permalink href=#addr:_radix><code class=Cm id=addr:_radix>addr: radix</code></a></dt><dd>Separate Radix trees for IPv4 and IPv6, the same way as the routing table (see <a class=Xr href=route.4.html>route(4)</a>). Default choice for <var class=Ar>addr</var> type.</dd><dt><a class=permalink href=#addr:hash><code class=Cm id=addr:hash>addr:hash</code></a></dt><dd>Separate auto-growing hashes for IPv4 and IPv6. Accepts entries with the same mask length specified initially via <code class=Cm>addr:hash masks=/v4,/v6</code> algorithm creation options. Assume /32 and /128 masks by default. Search removes host bits (according to mask) from supplied address and checks resulting key in appropriate hash. Mostly optimized for /64 and byte-ranged IPv6 masks.</dd><dt><a class=permalink href=#iface:array><code class=Cm id=iface:array>iface:array</code></a></dt><dd>Array storing sorted indexes for entries which are presented in the system. Optimized for very fast lookup.</dd><dt><a class=permalink href=#number:array><code class=Cm id=number:array>number:array</code></a></dt><dd>Array storing sorted u32 numbers.</dd><dt><a class=permalink href=#flow:hash><code class=Cm id=flow:hash>flow:hash</code></a></dt><dd>Auto-growing hash storing flow entries. Search calculates hash on required packet fields and searches for matching entries in selected bucket.</dd><dt><a class=permalink href=#mac:_radix><code class=Cm id=mac:_radix>mac: radix</code></a></dt><dd>Radix tree for MAC address</dd></dl><p class=Pp>The <code class=Cm>tablearg</code> feature provides the ability to use a value, looked up in the table, as the argument for a rule action, action parameter or rule option. This can significantly reduce number of rules in some configurations. If two tables are used in a rule, the result of the second (destination) is used.</p><p class=Pp>Each record may hold one or more values according to <var class=Ar>value-mask</var>. This mask is set on table creation via <code class=Cm>valtype</code> option. The following value types are supported:</p><dl class=Bl-tag><dt><var class=Ar>value-mask</var>: <var class=Ar>value-type</var>[,<var class=Ar>value-mask</var>]</dt><dd style="width: auto;"> </dd><dt><var class=Ar>value-type</var>: <var class=Ar>skipto</var> | <var class=Ar>pipe</var> | <var class=Ar>fib</var> | <var class=Ar>nat</var> | <var class=Ar>dscp</var> | <var class=Ar>tag</var> | <var class=Ar>divert</var> |</dt><dd><var class=Ar>netgraph</var> | <var class=Ar>limit</var> | <var class=Ar>ipv4</var></dd><dt><a class=permalink href=#skipto_2><code class=Cm id=skipto_2>skipto</code></a></dt><dd>rule number to jump to.</dd><dt><a class=permalink href=#pipe_2><code class=Cm id=pipe_2>pipe</code></a></dt><dd>Pipe number to use.</dd><dt><a class=permalink href=#fib_2><code class=Cm id=fib_2>fib</code></a></dt><dd>fib number to match/set.</dd><dt><a class=permalink href=#nat_2><code class=Cm id=nat_2>nat</code></a></dt><dd>nat number to jump to.</dd><dt><a class=permalink href=#dscp><code class=Cm id=dscp>dscp</code></a></dt><dd>dscp value to match/set.</dd><dt><a class=permalink href=#tag_2><code class=Cm id=tag_2>tag</code></a></dt><dd>tag number to match/set.</dd><dt><a class=permalink href=#divert_2><code class=Cm id=divert_2>divert</code></a></dt><dd>port number to divert traffic to.</dd><dt><a class=permalink href=#netgraph_2><code class=Cm id=netgraph_2>netgraph</code></a></dt><dd>hook number to move packet to.</dd><dt><a class=permalink href=#limit_5><code class=Cm id=limit_5>limit</code></a></dt><dd>maximum number of connections.</dd><dt><a class=permalink href=#ipv4_2><code class=Cm id=ipv4_2>ipv4</code></a></dt><dd>IPv4 nexthop to fwd packets to.</dd><dt><a class=permalink href=#ipv6_2><code class=Cm id=ipv6_2>ipv6</code></a></dt><dd>IPv6 nexthop to fwd packets to.</dd></dl><p class=Pp>The <code class=Cm>tablearg</code> argument can be used with the following actions: <code class=Cm>nat, pipe, queue, divert, tee, netgraph, ngtee, fwd, skipto, setfib</code>, action parameters: <code class=Cm>tag, untag</code>, rule options: <code class=Cm>limit, tagged</code>.</p><p class=Pp>When used with the <code class=Cm>skipto</code> action, the user should be aware that the code will walk the ruleset up to a rule equal to, or past, the given number.</p><p class=Pp>See the <a class=Sx href=#EXAMPLES>EXAMPLES</a> Section for example usage of tables and the tablearg keyword.</p></section><section class=Sh><h2 class=Sh id=SETS_OF_RULES><a class=permalink href=#SETS_OF_RULES>SETS OF RULES</a></h2> Each rule or table belongs to one of 32 different <i class=Em>sets</i> , numbered 0 to 31. Set 31 is reserved for the default rule. <p class=Pp>By default, rules or tables are put in set 0, unless you use the <code class=Cm>set N</code> attribute when adding a new rule or table. Sets can be individually and atomically enabled or disabled, so this mechanism permits an easy way to store multiple configurations of the firewall and quickly (and atomically) switch between them.</p><p class=Pp>By default, tables from set 0 are referenced when adding rule with table opcodes regardless of rule set. This behavior can be changed by setting <var class=Va>net.inet.ip.fw.tables_sets</var> variable to 1. Rule's set will then be used for table references.</p><p class=Pp>The command to enable/disable sets is</p><div class="Bd Pp Bd-indent"><code class=Nm>ipfw</code><code class=Cm>set</code> [<code class=Cm>disable</code><var class=Ar>number ...</var>] [<code class=Cm>enable</code><var class=Ar>number ...</var>]</div><p class=Pp>where multiple <code class=Cm>enable</code> or <code class=Cm>disable</code> sections can be specified. Command execution is atomic on all the sets specified in the command. By default, all sets are enabled.</p><p class=Pp>When you disable a set, its rules behave as if they do not exist in the firewall configuration, with only one exception:</p><div class="Bd Pp Bd-indent">dynamic rules created from a rule before it had been disabled will still be active until they expire. In order to delete dynamic rules you have to explicitly delete the parent rule which generated them.</div><p class=Pp>The set number of rules can be changed with the command</p><div class="Bd Pp Bd-indent"><code class=Nm>ipfw</code><code class=Cm>set move</code> {<code class=Cm>rule</code><var class=Ar>rule-number</var> | <var class=Ar>old-set</var>} <code class=Cm>to</code><var class=Ar>new-set</var></div><p class=Pp>Also, you can atomically swap two rulesets with the command</p><div class="Bd Pp Bd-indent"><code class=Nm>ipfw</code><code class=Cm>set swap</code><var class=Ar>first-set second-set</var></div><p class=Pp>See the <a class=Sx href=#EXAMPLES>EXAMPLES</a> Section on some possible uses of sets of rules.</p></section><section class=Sh><h2 class=Sh id=STATEFUL_FIREWALL><a class=permalink href=#STATEFUL_FIREWALL>STATEFUL FIREWALL</a></h2> Stateful operation is a way for the firewall to dynamically create rules for specific flows when packets that match a given pattern are detected. Support for stateful operation comes through the <code class=Cm>check-state</code>, <code class=Cm>keep-state</code>, <code class=Cm>record-state</code>, <code class=Cm>limit</code> and <code class=Cm>set-limit</code> options of <code class=Nm>rules</code>. <p class=Pp>Dynamic rules are created when a packet matches a <code class=Cm>keep-state</code>, <code class=Cm>record-state</code>, <code class=Cm>limit</code> or <code class=Cm>set-limit</code> rule, causing the creation of a <i class=Em>dynamic</i> rule which will match all and only packets with a given <i class=Em>protocol</i> between a <i class=Em>src-ip/src-port dst-ip/dst-port</i> pair of addresses (<i class=Em>src</i> and <i class=Em>dst</i> are used here only to denote the initial match addresses, but they are completely equivalent afterwards). Rules created by <code class=Cm>keep-state</code> option also have a <var class=Ar>:flowname</var> taken from it. This name is used in matching together with addresses, ports and protocol. Dynamic rules will be checked at the first <code class=Cm>check-state, keep-state</code> or <code class=Cm>limit</code> occurrence, and the action performed upon a match will be the same as in the parent rule.</p><p class=Pp>Note that no additional attributes other than protocol and IP addresses and ports and :flowname are checked on dynamic rules.</p><p class=Pp>The typical use of dynamic rules is to keep a closed firewall configuration, but let the first TCP SYN packet from the inside network install a dynamic rule for the flow so that packets belonging to that session will be allowed through the firewall:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add check-state :OUTBOUND</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add allow tcp from my-subnet to any setup keep-state :OUTBOUND</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add deny tcp from any to any</code></div><p class=Pp>A similar approach can be used for UDP, where an UDP packet coming from the inside will install a dynamic rule to let the response through the firewall:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add check-state :OUTBOUND</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add allow udp from my-subnet to any keep-state :OUTBOUND</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add deny udp from any to any</code></div><p class=Pp>Dynamic rules expire after some time, which depends on the status of the flow and the setting of some <code class=Cm>sysctl</code> variables. See Section <a class=Sx href=#SYSCTL_VARIABLES>SYSCTL VARIABLES</a> for more details. For TCP sessions, dynamic rules can be instructed to periodically send keepalive packets to refresh the state of the rule when it is about to expire.</p><p class=Pp>See Section <a class=Sx href=#EXAMPLES>EXAMPLES</a> for more examples on how to use dynamic rules.</p></section><section class=Sh><h2 class=Sh id=TRAFFIC_SHAPER_(DUMMYNET)_CONFIGURATION><a class=permalink href=#TRAFFIC_SHAPER_(DUMMYNET)_CONFIGURATION>TRAFFIC SHAPER (DUMMYNET) CONFIGURATION</a></h2><code class=Nm>ipfw</code> is also the user interface for the <code class=Nm>dummynet</code> traffic shaper, packet scheduler and network emulator, a subsystem that can artificially queue, delay or drop packets emulating the behaviour of certain network links or queueing systems. <p class=Pp><code class=Nm>dummynet</code> operates by first using the firewall to select packets using any match pattern that can be used in <code class=Nm>ipfw</code> rules. Matching packets are then passed to either of two different objects, which implement the traffic regulation:</p><dl class="Bl-hang Bd-indent"><dt><i class=Em>pipe</i></dt><dd>A <i class=Em>pipe</i> emulates a <i class=Em>link</i> with given bandwidth and propagation delay, driven by a FIFO scheduler and a single queue with programmable queue size and packet loss rate. Packets are appended to the queue as they come out from <code class=Nm>ipfw</code>, and then transferred in FIFO order to the link at the desired rate.</dd><dt><i class=Em>queue</i></dt><dd>A <i class=Em>queue</i> is an abstraction used to implement packet scheduling using one of several packet scheduling algorithms. Packets sent to a <i class=Em>queue</i> are first grouped into flows according to a mask on the 5-tuple. Flows are then passed to the scheduler associated to the <i class=Em>queue</i>, and each flow uses scheduling parameters (weight and others) as configured in the <i class=Em>queue</i> itself. A scheduler in turn is connected to an emulated link, and arbitrates the link's bandwidth among backlogged flows according to weights and to the features of the scheduling algorithm in use.</dd></dl><p class=Pp>In practice, <i class=Em>pipes</i> can be used to set hard limits to the bandwidth that a flow can use, whereas <i class=Em>queues</i> can be used to determine how different flows share the available bandwidth.</p><p class=Pp>A graphical representation of the binding of queues, flows, schedulers and links is below.</p><div class="Bd Pp Bd-indent"><pre>
                 (flow_mask|sched_mask)  sched_mask
         +---------+   weight Wx  +-------------+
         |         |-&gt;-[flow]--&gt;--|             |-+
    --&gt;--| QUEUE x |   ...        |             | |
         |         |-&gt;-[flow]--&gt;--| SCHEDuler N | |
         +---------+              |             | |
             ...                  |             +--[LINK N]--&gt;--
         +---------+   weight Wy  |             | +--[LINK N]--&gt;--
         |         |-&gt;-[flow]--&gt;--|             | |
    --&gt;--| QUEUE y |   ...        |             | |
         |         |-&gt;-[flow]--&gt;--|             | |
         +---------+              +-------------+ |
                                    +-------------+
</pre></div> It is important to understand the role of the SCHED_MASK and FLOW_MASK, which are configured through the commands <div class="Bd Bd-indent"><code class=Li>ipfw sched N config mask SCHED_MASK ...</code></div> and <div class="Bd Bd-indent"><code class=Li>ipfw queue X config mask FLOW_MASK ....</code></div><p class=Pp>The SCHED_MASK is used to assign flows to one or more scheduler instances, one for each value of the packet's 5-tuple after applying SCHED_MASK. As an example, using ``src-ip 0xffffff00'' creates one instance for each /24 destination subnet.</p><p class=Pp>The FLOW_MASK, together with the SCHED_MASK, is used to split packets into flows. As an example, using ``src-ip 0x000000ff'' together with the previous SCHED_MASK makes a flow for each individual source address. In turn, flows for each /24 subnet will be sent to the same scheduler instance.</p><p class=Pp>The above diagram holds even for the <i class=Em>pipe</i> case, with the only restriction that a <i class=Em>pipe</i> only supports a SCHED_MASK, and forces the use of a FIFO scheduler (these are for backward compatibility reasons; in fact, internally, a <code class=Nm>dummynet's</code> pipe is implemented exactly as above).</p><p class=Pp>There are two modes of <code class=Nm>dummynet</code> operation: “normal” and “fast”. The “normal” mode tries to emulate a real link: the <code class=Nm>dummynet</code> scheduler ensures that the packet will not leave the pipe faster than it would on the real link with a given bandwidth. The “fast” mode allows certain packets to bypass the <code class=Nm>dummynet</code> scheduler (if packet flow does not exceed pipe's bandwidth). This is the reason why the “fast” mode requires less CPU cycles per packet (on average) and packet latency can be significantly lower in comparison to a real link with the same bandwidth. The default mode is “normal”. The “fast” mode can be enabled by setting the <var class=Va>net.inet.ip.dummynet.io_fast</var><a class=Xr href=sysctl.8.html>sysctl(8)</a> variable to a non-zero value.</p><section class=Ss><h2 class=Ss id=PIPE,_QUEUE_AND_SCHEDULER_CONFIGURATION><a class=permalink href=#PIPE,_QUEUE_AND_SCHEDULER_CONFIGURATION>PIPE, QUEUE AND SCHEDULER CONFIGURATION</a></h2> The <i class=Em>pipe</i>, <i class=Em>queue</i> and <i class=Em>scheduler</i> configuration commands are the following: <div class="Bd Pp Bd-indent"><code class=Cm>pipe</code><var class=Ar>number</var><code class=Cm>config</code><var class=Ar>pipe-configuration</var><p class=Pp><code class=Cm>queue</code><var class=Ar>number</var><code class=Cm>config</code><var class=Ar>queue-configuration</var></p><p class=Pp><code class=Cm>sched</code><var class=Ar>number</var><code class=Cm>config</code><var class=Ar>sched-configuration</var></p></div><p class=Pp>The following parameters can be configured for a pipe:</p><p class=Pp></p><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#bw><code class=Cm id=bw>bw</code></a><var class=Ar>bandwidth</var> | <var class=Ar>device</var></dt><dd>Bandwidth, measured in [<code class=Cm>K</code>|<code class=Cm>M</code> | <code class=Cm>G</code>]{<code class=Cm>bit/s</code>|<code class=Cm>Byte/s</code>}. <p class=Pp>A value of 0 (default) means unlimited bandwidth. The unit must immediately follow the number, as in</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>dnctl pipe 1 config bw 300Kbit/s</code></div><p class=Pp>If a device name is specified instead of a numeric value, as in</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>dnctl pipe 1 config bw tun0</code></div><p class=Pp>then the transmit clock is supplied by the specified device. At the moment only the <a class=Xr href=tun.4.html>tun(4)</a> device supports this functionality, for use in conjunction with <a class=Xr href=ppp.8.html>ppp(8)</a>.</p><p class=Pp></p></dd><dt><a class=permalink href=#delay><code class=Cm id=delay>delay</code></a><var class=Ar>ms-delay</var></dt><dd>Propagation delay, measured in milliseconds. The value is rounded to the next multiple of the clock tick (typically 10ms, but it is a good practice to run kernels with “options HZ=1000” to reduce the granularity to 1ms or less). The default value is 0, meaning no delay. <p class=Pp></p></dd><dt><a class=permalink href=#burst><code class=Cm id=burst>burst</code></a><var class=Ar>size</var></dt><dd>If the data to be sent exceeds the pipe's bandwidth limit (and the pipe was previously idle), up to <var class=Ar>size</var> bytes of data are allowed to bypass the <code class=Nm>dummynet</code> scheduler, and will be sent as fast as the physical link allows. Any additional data will be transmitted at the rate specified by the <code class=Nm>pipe</code> bandwidth. The burst size depends on how long the pipe has been idle; the effective burst size is calculated as follows: MAX( <var class=Ar>size</var> , <code class=Nm>bw</code> * pipe_idle_time). <p class=Pp></p></dd><dt><a class=permalink href=#profile><code class=Cm id=profile>profile</code></a><var class=Ar>filename</var></dt><dd>A file specifying the additional overhead incurred in the transmission of a packet on the link. <p class=Pp>Some link types introduce extra delays in the transmission of a packet, e.g., because of MAC level framing, contention on the use of the channel, MAC level retransmissions and so on. From our point of view, the channel is effectively unavailable for this extra time, which is constant or variable depending on the link type. Additionally, packets may be dropped after this time (e.g., on a wireless link after too many retransmissions). We can model the additional delay with an empirical curve that represents its distribution.</p><div class="Bd Pp Bd-indent"><pre>
      cumulative probability
      1.0 ^
          |
      L   +-- loss-level          x
          |                 ******
          |                *
          |           *****
          |          *
          |        **
          |       *
          +-------*-------------------&gt;
                      delay
    </pre></div> The empirical curve may have both vertical and horizontal lines. Vertical lines represent constant delay for a range of probabilities. Horizontal lines correspond to a discontinuity in the delay distribution: the pipe will use the largest delay for a given probability. <p class=Pp>The file format is the following, with whitespace acting as a separator and '#' indicating the beginning a comment:</p><dl class=Bl-tag><dt><a class=permalink href=#name><code class=Cm id=name>name</code></a><var class=Ar>identifier</var></dt><dd>optional name (listed by "dnctl pipe show") to identify the delay distribution;</dd><dt><a class=permalink href=#bw_2><code class=Cm id=bw_2>bw</code></a><var class=Ar>value</var></dt><dd>the bandwidth used for the pipe. If not specified here, it must be present explicitly as a configuration parameter for the pipe;</dd><dt><a class=permalink href=#loss-level><code class=Cm id=loss-level>loss-level</code></a><var class=Ar>L</var></dt><dd>the probability above which packets are lost. (0.0 &lt;= L &lt;= 1.0, default 1.0 i.e., no loss);</dd><dt><a class=permalink href=#samples><code class=Cm id=samples>samples</code></a><var class=Ar>N</var></dt><dd>the number of samples used in the internal representation of the curve (2..1024; default 100);</dd><dt><a class=permalink href=#delay_prob><code class=Cm id=delay_prob>delay prob</code></a> | <a class=permalink href=#prob_delay><code class=Cm id=prob_delay>prob delay</code></a></dt><dd>One of these two lines is mandatory and defines the format of the following lines with data points.</dd><dt><var class=Ar>XXX</var><var class=Ar>YYY</var></dt><dd>2 or more lines representing points in the curve, with either delay or probability first, according to the chosen format. The unit for delay is milliseconds. Data points do not need to be sorted. Also, the number of actual lines can be different from the value of the "samples" parameter: <code class=Nm>ipfw</code> utility will sort and interpolate the curve as needed.</dd></dl><p class=Pp>Example of a profile file:</p><div class="Bd Pp Bd-indent"><pre>
name    bla_bla_bla
samples 100
loss-level    0.86
prob    delay
0       200	# minimum overhead is 200ms
0.5     200
0.5     300
0.8     1000
0.9     1300
1       1300
#configuration file end
    </pre></div></dd></dl><p class=Pp>The following parameters can be configured for a queue:</p><p class=Pp></p><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#pipe_3><code class=Cm id=pipe_3>pipe</code></a><var class=Ar>pipe_nr</var></dt><dd>Connects a queue to the specified pipe. Multiple queues (with the same or different weights) can be connected to the same pipe, which specifies the aggregate rate for the set of queues. <p class=Pp></p></dd><dt><a class=permalink href=#weight><code class=Cm id=weight>weight</code></a><var class=Ar>weight</var></dt><dd>Specifies the weight to be used for flows matching this queue. The weight must be in the range 1..100, and defaults to 1.</dd></dl><p class=Pp>The following case-insensitive parameters can be configured for a scheduler:</p><p class=Pp></p><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#type_2><code class=Cm id=type_2>type</code></a><var class=Ar>{fifo</var> | <var class=Ar>wf2q+</var> | <var class=Ar>rr</var> | <var class=Ar>qfq</var> | <var class=Ar>fq_codel</var> | <var class=Ar>fq_pie}</var></dt><dd>specifies the scheduling algorithm to use. <dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#fifo><code class=Cm id=fifo>fifo</code></a></dt><dd>is just a FIFO scheduler (which means that all packets are stored in the same queue as they arrive to the scheduler). FIFO has O(1) per-packet time complexity, with very low constants (estimate 60-80ns on a 2GHz desktop machine) but gives no service guarantees.</dd><dt><a class=permalink href=#wf2q+><code class=Cm id=wf2q+>wf2q+</code></a></dt><dd>implements the WF2Q+ algorithm, which is a Weighted Fair Queueing algorithm which permits flows to share bandwidth according to their weights. Note that weights are not priorities; even a flow with a minuscule weight will never starve. WF2Q+ has O(log N) per-packet processing cost, where N is the number of flows, and is the default algorithm used by previous versions dummynet's queues.</dd><dt><a class=permalink href=#rr><code class=Cm id=rr>rr</code></a></dt><dd>implements the Deficit Round Robin algorithm, which has O(1) processing costs (roughly, 100-150ns per packet) and permits bandwidth allocation according to weights, but with poor service guarantees.</dd><dt><a class=permalink href=#qfq><code class=Cm id=qfq>qfq</code></a></dt><dd>implements the QFQ algorithm, which is a very fast variant of WF2Q+, with similar service guarantees and O(1) processing costs (roughly, 200-250ns per packet).</dd><dt><a class=permalink href=#fq_codel><code class=Cm id=fq_codel>fq_codel</code></a></dt><dd>implements the FQ-CoDel (FlowQueue-CoDel) scheduler/AQM algorithm, which uses a modified Deficit Round Robin scheduler to manage two lists of sub-queues (old sub-queues and new sub-queues) for providing brief periods of priority to lightweight or short burst flows. By default, the total number of sub-queues is 1024. FQ-CoDel's internal, dynamically created sub-queues are controlled by separate instances of CoDel AQM.</dd><dt><a class=permalink href=#fq_pie><code class=Cm id=fq_pie>fq_pie</code></a></dt><dd>implements the FQ-PIE (FlowQueue-PIE) scheduler/AQM algorithm, which similar to <code class=Cm>fq_codel</code> but uses per sub-queue PIE AQM instance to control the queue delay.</dd></dl><p class=Pp><code class=Cm>fq_codel</code> inherits AQM parameters and options from <code class=Cm>codel</code> (see below), and <code class=Cm>fq_pie</code> inherits AQM parameters and options from <code class=Cm>pie</code> (see below). Additionally, both of <code class=Cm>fq_codel</code> and <code class=Cm>fq_pie</code> have shared scheduler parameters which are:</p><dl class=Bl-tag><dt><a class=permalink href=#quantum><code class=Cm id=quantum>quantum</code></a></dt><dd><var class=Ar>m</var> specifies the quantum (credit) of the scheduler. <var class=Ar>m</var> is the number of bytes a queue can serve before being moved to the tail of old queues list. The default is 1514 bytes, and the maximum acceptable value is 9000 bytes.</dd><dt><a class=permalink href=#limit_6><code class=Cm id=limit_6>limit</code></a></dt><dd><var class=Ar>m</var> specifies the hard size limit (in unit of packets) of all queues managed by an instance of the scheduler. The default value of <var class=Ar>m</var> is 10240 packets, and the maximum acceptable value is 20480 packets.</dd><dt><a class=permalink href=#flows><code class=Cm id=flows>flows</code></a></dt><dd><var class=Ar>m</var> specifies the total number of flow queues (sub-queues) that fq_* creates and manages. By default, 1024 sub-queues are created when an instance of the fq_{codel/pie} scheduler is created. The maximum acceptable value is 65536.</dd></dl><p class=Pp>Note that any token after <code class=Cm>fq_codel</code> or <code class=Cm>fq_pie</code> is considered a parameter for fq_{codel/pie}. So, ensure all scheduler configuration options not related to fq_{codel/pie} are written before <code class=Cm>fq_codel/fq_pie</code> tokens.</p></dd></dl><p class=Pp>In addition to the type, all parameters allowed for a pipe can also be specified for a scheduler.</p><p class=Pp>Finally, the following parameters can be configured for both pipes and queues:</p><p class=Pp></p><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#buckets><code class=Cm id=buckets>buckets</code></a><var class=Ar>hash-table-size</var></dt><dd>Specifies the size of the hash table used for storing the various queues. Default value is 64 controlled by the <a class=Xr href=sysctl.8.html>sysctl(8)</a> variable <var class=Va>net.inet.ip.dummynet.hash_size</var>, allowed range is 16 to 65536. <p class=Pp></p></dd><dt><a class=permalink href=#mask><code class=Cm id=mask>mask</code></a><var class=Ar>mask-specifier</var></dt><dd>Packets sent to a given pipe or queue by an <code class=Nm>ipfw</code> rule can be further classified into multiple flows, each of which is then sent to a different <i class=Em>dynamic</i> pipe or queue. A flow identifier is constructed by masking the IP addresses, ports and protocol types as specified with the <code class=Cm>mask</code> options in the configuration of the pipe or queue. For each different flow identifier, a new pipe or queue is created with the same parameters as the original object, and matching packets are sent to it. <p class=Pp>Thus, when <i class=Em>dynamic pipes</i> are used, each flow will get the same bandwidth as defined by the pipe, whereas when <i class=Em>dynamic queues</i> are used, each flow will share the parent's pipe bandwidth evenly with other flows generated by the same queue (note that other queues with different weights might be connected to the same pipe). <br> Available mask specifiers are a combination of one or more of the following:</p><p class=Pp><code class=Cm>dst-ip</code><var class=Ar>mask</var>, <code class=Cm>dst-ip6</code><var class=Ar>mask</var>, <code class=Cm>src-ip</code><var class=Ar>mask</var>, <code class=Cm>src-ip6</code><var class=Ar>mask</var>, <code class=Cm>dst-port</code><var class=Ar>mask</var>, <code class=Cm>src-port</code><var class=Ar>mask</var>, <code class=Cm>flow-id</code><var class=Ar>mask</var>, <code class=Cm>proto</code><var class=Ar>mask</var> or <code class=Cm>all</code>,</p><p class=Pp>where the latter means all bits in all fields are significant.</p><p class=Pp></p></dd><dt><a class=permalink href=#noerror><code class=Cm id=noerror>noerror</code></a></dt><dd>When a packet is dropped by a <code class=Nm>dummynet</code> queue or pipe, the error is normally reported to the caller routine in the kernel, in the same way as it happens when a device queue fills up. Setting this option reports the packet as successfully delivered, which can be needed for some experimental setups where you want to simulate loss or congestion at a remote router. <p class=Pp></p></dd><dt><a class=permalink href=#plr><code class=Cm id=plr>plr</code></a><var class=Ar>packet-loss-rate</var></dt><dd>Packet loss rate. Argument <var class=Ar>packet-loss-rate</var> is a floating-point number between 0 and 1, with 0 meaning no loss, 1 meaning 100% loss. The loss rate is internally represented on 31 bits. <p class=Pp></p></dd><dt><a class=permalink href=#queue_2><code class=Cm id=queue_2>queue</code></a> {<var class=Ar>slots</var> | <var class=Ar>size</var><code class=Cm>Kbytes</code>}</dt><dd>Queue size, in <var class=Ar>slots</var> or <code class=Cm>KBytes</code>. Default value is 50 slots, which is the typical queue size for Ethernet devices. Note that for slow speed links you should keep the queue size short or your traffic might be affected by a significant queueing delay. E.g., 50 max-sized Ethernet packets (1500 bytes) mean 600Kbit or 20s of queue on a 30Kbit/s pipe. Even worse effects can result if you get packets from an interface with a much larger MTU, e.g. the loopback interface with its 16KB packets. The <a class=Xr href=sysctl.8.html>sysctl(8)</a> variables <i class=Em>net.inet.ip.dummynet.pipe_byte_limit</i> and <i class=Em>net.inet.ip.dummynet.pipe_slot_limit</i> control the maximum lengths that can be specified. <p class=Pp></p></dd><dt><a class=permalink href=#red><code class=Cm id=red>red</code></a> | <a class=permalink href=#gred><code class=Cm id=gred>gred</code></a><var class=Ar>w_q</var>/<var class=Ar>min_th</var>/<var class=Ar>max_th</var>/<var class=Ar>max_p</var></dt><dd>[ecn] Make use of the RED (Random Early Detection) queue management algorithm. <var class=Ar>w_q</var> and <var class=Ar>max_p</var> are floating point numbers between 0 and 1 (inclusive), while <var class=Ar>min_th</var> and <var class=Ar>max_th</var> are integer numbers specifying thresholds for queue management (thresholds are computed in bytes if the queue has been defined in bytes, in slots otherwise). The two parameters can also be of the same value if needed. The <code class=Nm>dummynet</code> also supports the gentle RED variant (gred) and ECN (Explicit Congestion Notification) as optional. Three <a class=Xr href=sysctl.8.html>sysctl(8)</a> variables can be used to control the RED behaviour: <dl class=Bl-tag><dt><var class=Va>net.inet.ip.dummynet.red_lookup_depth</var></dt><dd>specifies the accuracy in computing the average queue when the link is idle (defaults to 256, must be greater than zero)</dd><dt><var class=Va>net.inet.ip.dummynet.red_avg_pkt_size</var></dt><dd>specifies the expected average packet size (defaults to 512, must be greater than zero)</dd><dt><var class=Va>net.inet.ip.dummynet.red_max_pkt_size</var></dt><dd>specifies the expected maximum packet size, only used when queue thresholds are in bytes (defaults to 1500, must be greater than zero).</dd></dl><p class=Pp></p></dd><dt><a class=permalink href=#codel><code class=Cm id=codel>codel</code></a> [<code class=Cm>target</code><var class=Ar>time</var>] [<code class=Cm>interval</code><var class=Ar>time</var>] [<code class=Cm>ecn</code> | <code class=Cm>noecn</code>]</dt><dd>Make use of the CoDel (Controlled-Delay) queue management algorithm. <var class=Ar>time</var> is interpreted as milliseconds by default but seconds (s), milliseconds (ms) or microseconds (us) can be specified instead. CoDel drops or marks (ECN) packets depending on packet sojourn time in the queue. <code class=Cm>target</code><var class=Ar>time</var> (5ms by default) is the minimum acceptable persistent queue delay that CoDel allows. CoDel does not drop packets directly after packets sojourn time becomes higher than <code class=Cm>target</code><var class=Ar>time</var> but waits for <code class=Cm>interval</code><var class=Ar>time</var> (100ms default) before dropping. <code class=Cm>interval</code><var class=Ar>time</var> should be set to maximum RTT for all expected connections. <code class=Cm>ecn</code> enables (disabled by default) packet marking (instead of dropping) for ECN-enabled TCP flows when queue delay becomes high. <p class=Pp>Note that any token after <code class=Cm>codel</code> is considered a parameter for CoDel. So, ensure all pipe/queue configuration options are written before <code class=Cm>codel</code> token.</p><p class=Pp>The <a class=Xr href=sysctl.8.html>sysctl(8)</a> variables <var class=Va>net.inet.ip.dummynet.codel.target</var> and <var class=Va>net.inet.ip.dummynet.codel.interval</var> can be used to set CoDel default parameters.</p><p class=Pp></p></dd><dt><a class=permalink href=#pie><code class=Cm id=pie>pie</code></a> [<code class=Cm>target</code><var class=Ar>time</var>] [<code class=Cm>tupdate</code><var class=Ar>time</var>] [<code class=Cm>alpha</code><var class=Ar>n</var>] [<code class=Cm>beta</code><var class=Ar>n</var>] [<code class=Cm>max_burst</code><var class=Ar>time</var>] [<code class=Cm>max_ecnth</code><var class=Ar>n</var>] [<code class=Cm>ecn</code> | <code class=Cm>noecn</code>] [<code class=Cm>capdrop</code> | <code class=Cm>nocapdrop</code>] [<code class=Cm>drand</code> | <code class=Cm>nodrand</code>] [<code class=Cm>onoff</code>] [<code class=Cm>dre</code> | <code class=Cm>ts</code>]</dt><dd>Make use of the PIE (Proportional Integral controller Enhanced) queue management algorithm. PIE drops or marks packets depending on a calculated drop probability during en-queue process, with the aim of achieving high throughput while keeping queue delay low. At regular time intervals of <code class=Cm>tupdate</code><var class=Ar>time</var> (15ms by default) a background process (re)calculates the probability based on queue delay deviations from <code class=Cm>target</code><var class=Ar>time</var> (15ms by default) and queue delay trends. PIE approximates current queue delay by using a departure rate estimation method, or (optionally) by using a packet timestamp method similar to CoDel. <var class=Ar>time</var> is interpreted as milliseconds by default but seconds (s), milliseconds (ms) or microseconds (us) can be specified instead. The other PIE parameters and options are as follows: <dl class=Bl-tag><dt><a class=permalink href=#alpha><code class=Cm id=alpha>alpha</code></a><var class=Ar>n</var></dt><dd><var class=Ar>n</var> is a floating point number between 0 and 7 which specifies the weight of queue delay deviations that is used in drop probability calculation. 0.125 is the default.</dd><dt><a class=permalink href=#beta><code class=Cm id=beta>beta</code></a><var class=Ar>n</var></dt><dd><var class=Ar>n</var> is a floating point number between 0 and 7 which specifies is the weight of queue delay trend that is used in drop probability calculation. 1.25 is the default.</dd><dt><a class=permalink href=#max_burst><code class=Cm id=max_burst>max_burst</code></a><var class=Ar>time</var></dt><dd>The maximum period of time that PIE does not drop/mark packets. 150ms is the default and 10s is the maximum value.</dd><dt><a class=permalink href=#max_ecnth><code class=Cm id=max_ecnth>max_ecnth</code></a><var class=Ar>n</var></dt><dd>Even when ECN is enabled, PIE drops packets instead of marking them when drop probability becomes higher than ECN probability threshold <code class=Cm>max_ecnth</code><var class=Ar>n</var> , the default is 0.1 (i.e 10%) and 1 is the maximum value.</dd><dt><a class=permalink href=#ecn><code class=Cm id=ecn>ecn</code></a> | <a class=permalink href=#noecn><code class=Cm id=noecn>noecn</code></a></dt><dd>enable or disable ECN marking for ECN-enabled TCP flows. Disabled by default.</dd><dt><a class=permalink href=#capdrop><code class=Cm id=capdrop>capdrop</code></a> | <a class=permalink href=#nocapdrop><code class=Cm id=nocapdrop>nocapdrop</code></a></dt><dd>enable or disable cap drop adjustment. Cap drop adjustment is enabled by default.</dd><dt><a class=permalink href=#drand><code class=Cm id=drand>drand</code></a> | <a class=permalink href=#nodrand><code class=Cm id=nodrand>nodrand</code></a></dt><dd>enable or disable drop probability de-randomisation. De-randomisation eliminates the problem of dropping packets too close or too far. De-randomisation is enabled by default.</dd><dt><a class=permalink href=#onoff><code class=Cm id=onoff>onoff</code></a></dt><dd>enable turning PIE on and off depending on queue load. If this option is enabled, PIE turns on when over 1/3 of queue becomes full. This option is disabled by default.</dd><dt><a class=permalink href=#dre><code class=Cm id=dre>dre</code></a> | <a class=permalink href=#ts><code class=Cm id=ts>ts</code></a></dt><dd>Calculate queue delay using departure rate estimation <code class=Cm>dre</code> or timestamps <code class=Cm>ts</code>. <code class=Cm>dre</code> is used by default.</dd></dl><p class=Pp>Note that any token after <code class=Cm>pie</code> is considered a parameter for PIE. So ensure all pipe/queue the configuration options are written before <code class=Cm>pie</code> token. <a class=Xr href=sysctl.8.html>sysctl(8)</a> variables can be used to control the <code class=Cm>pie</code> default parameters. See the <a class=Sx href=#SYSCTL_VARIABLES>SYSCTL VARIABLES</a> section for more details.</p></dd></dl><p class=Pp>When used with IPv6 data, <code class=Nm>dummynet</code> currently has several limitations. Information necessary to route link-local packets to an interface is not available after processing by <code class=Nm>dummynet</code> so those packets are dropped in the output path. Care should be taken to ensure that link-local packets are not passed to <code class=Nm>dummynet</code>.</p></section></section><section class=Sh><h2 class=Sh id=CHECKLIST><a class=permalink href=#CHECKLIST>CHECKLIST</a></h2> Here are some important points to consider when designing your rules: <ul class=Bl-bullet><li>Remember that you filter both packets going <code class=Cm>in</code> and <code class=Cm>out</code>. Most connections need packets going in both directions.</li><li>Remember to test very carefully. It is a good idea to be near the console when doing this. If you cannot be near the console, use an auto-recovery script such as the one in <span class=Pa>/usr/share/examples/ipfw/change_rules.sh</span>.</li><li>Do not forget the loopback interface.</li></ul></section><section class=Sh><h2 class=Sh id=FINE_POINTS><a class=permalink href=#FINE_POINTS>FINE POINTS</a></h2><ul class=Bl-bullet><li>There are circumstances where fragmented datagrams are unconditionally dropped. TCP packets are dropped if they do not contain at least 20 bytes of TCP header, UDP packets are dropped if they do not contain a full 8 byte UDP header, and ICMP packets are dropped if they do not contain 4 bytes of ICMP header, enough to specify the ICMP type, code, and checksum. These packets are simply logged as “pullup failed” since there may not be enough good data in the packet to produce a meaningful log entry.</li><li>Another type of packet is unconditionally dropped, a TCP packet with a fragment offset of one. This is a valid packet, but it only has one use, to try to circumvent firewalls. When logging is enabled, these packets are reported as being dropped by rule -1.</li><li>If you are logged in over a network, loading the <a class=Xr href=kld.4.html>kld(4)</a> version of <code class=Nm>ipfw</code> is probably not as straightforward as you would think. The following command line is recommended: <div class="Bd Pp Bd-indent"><pre>
kldload ipfw &amp;&amp; \
ipfw add 32000 allow ip from any to any
    </pre></div><p class=Pp>Along the same lines, doing an</p><div class="Bd Pp Bd-indent"><pre>
ipfw flush
    </pre></div><p class=Pp>in similar surroundings is also a bad idea.</p></li><li>The <code class=Nm>ipfw</code> filter list may not be modified if the system security level is set to 3 or higher (see <a class=Xr href=init.8.html>init(8)</a> for information on system security levels).</li></ul></section><section class=Sh><h2 class=Sh id=PACKET_DIVERSION><a class=permalink href=#PACKET_DIVERSION>PACKET DIVERSION</a></h2> A <a class=Xr href=divert.4.html>divert(4)</a> socket bound to the specified port will receive all packets diverted to that port. If no socket is bound to the destination port, or if the divert module is not loaded, or if the kernel was not compiled with divert socket support, the packets are dropped. </section><section class=Sh><h2 class=Sh id=NETWORK_ADDRESS_TRANSLATION_(NAT)><a class=permalink href=#NETWORK_ADDRESS_TRANSLATION_(NAT)>NETWORK ADDRESS TRANSLATION (NAT)</a></h2><code class=Nm>ipfw</code> support in-kernel NAT using the kernel version of <a class=Xr href=libalias.3.html>libalias(3)</a>. The kernel module <code class=Cm>ipfw_nat</code> should be loaded or kernel should have <code class=Cm>options IPFIREWALL_NAT</code> to be able use NAT. <p class=Pp>The nat configuration command is the following:</p><div class="Bd Pp Bd-indent"><code class=Cm>nat</code><var class=Ar>nat_number</var><code class=Cm>config</code><var class=Ar>nat-configuration</var></div><p class=Pp>The following parameters can be configured:</p><dl class=Bl-tag><dt><a class=permalink href=#ip_2><code class=Cm id=ip_2>ip</code></a><var class=Ar>ip_address</var></dt><dd>Define an ip address to use for aliasing.</dd><dt><a class=permalink href=#if><code class=Cm id=if>if</code></a><var class=Ar>nic</var></dt><dd>Use ip address of NIC for aliasing, dynamically changing it if NIC's ip address changes.</dd><dt><a class=permalink href=#log_2><code class=Cm id=log_2>log</code></a></dt><dd>Enable logging on this nat instance.</dd><dt><a class=permalink href=#deny_in><code class=Cm id=deny_in>deny_in</code></a></dt><dd>Deny any incoming connection from outside world.</dd><dt><a class=permalink href=#same_ports><code class=Cm id=same_ports>same_ports</code></a></dt><dd>Try to leave the alias port numbers unchanged from the actual local port numbers.</dd><dt><a class=permalink href=#unreg_only><code class=Cm id=unreg_only>unreg_only</code></a></dt><dd>Traffic on the local network not originating from a RFC 1918 unregistered address spaces will be ignored.</dd><dt><a class=permalink href=#unreg_cgn><code class=Cm id=unreg_cgn>unreg_cgn</code></a></dt><dd>Like unreg_only, but includes the RFC 6598 (Carrier Grade NAT) address range.</dd><dt><a class=permalink href=#reset_2><code class=Cm id=reset_2>reset</code></a></dt><dd>Reset table of the packet aliasing engine on address change.</dd><dt><a class=permalink href=#reverse><code class=Cm id=reverse>reverse</code></a></dt><dd>Reverse the way libalias handles aliasing.</dd><dt><a class=permalink href=#proxy_only><code class=Cm id=proxy_only>proxy_only</code></a></dt><dd>Obey transparent proxy rules only, packet aliasing is not performed.</dd><dt><a class=permalink href=#skip_global><code class=Cm id=skip_global>skip_global</code></a></dt><dd>Skip instance in case of global state lookup (see below).</dd><dt><a class=permalink href=#port_range><code class=Cm id=port_range>port_range</code></a><var class=Ar>lower-upper</var></dt><dd>Set the aliasing ports between the ranges given. Upper port has to be greater than lower.</dd></dl><p class=Pp>Some special values can be supplied instead of <var class=Va>nat_number</var> in nat rule actions:</p><dl class=Bl-tag><dt><a class=permalink href=#global><code class=Cm id=global>global</code></a></dt><dd>Looks up translation state in all configured nat instances. If an entry is found, packet is aliased according to that entry. If no entry was found in any of the instances, packet is passed unchanged, and no new entry will be created. See section <a class=Sx href=#MULTIPLE_INSTANCES>MULTIPLE INSTANCES</a> in <a class=Xr href=natd.8.html>natd(8)</a> for more information.</dd><dt><a class=permalink href=#tablearg><code class=Cm id=tablearg>tablearg</code></a></dt><dd>Uses argument supplied in lookup table. See <a class=Sx href=#LOOKUP_TABLES>LOOKUP TABLES</a> section below for more information on lookup tables.</dd></dl><p class=Pp>To let the packet continue after being (de)aliased, set the sysctl variable <var class=Va>net.inet.ip.fw.one_pass</var> to 0. For more information about aliasing modes, refer to <a class=Xr href=libalias.3.html>libalias(3)</a>. See Section <a class=Sx href=#EXAMPLES>EXAMPLES</a> for some examples of nat usage.</p><section class=Ss><h2 class=Ss id=REDIRECT_AND_LSNAT_SUPPORT_IN_IPFW><a class=permalink href=#REDIRECT_AND_LSNAT_SUPPORT_IN_IPFW>REDIRECT AND LSNAT SUPPORT IN IPFW</a></h2> Redirect and LSNAT support follow closely the syntax used in <a class=Xr href=natd.8.html>natd(8)</a>. See Section <a class=Sx href=#EXAMPLES>EXAMPLES</a> for some examples on how to do redirect and lsnat. </section><section class=Ss><h2 class=Ss id=SCTP_NAT_SUPPORT><a class=permalink href=#SCTP_NAT_SUPPORT>SCTP NAT SUPPORT</a></h2> SCTP nat can be configured in a similar manner to TCP through the <code class=Nm>ipfw</code> command line tool. The main difference is that <code class=Nm>sctp nat</code> does not do port translation. Since the local and global side ports will be the same, there is no need to specify both. Ports are redirected as follows: <div class="Bd Pp Bd-indent"><code class=Cm>nat</code><var class=Ar>nat_number</var><code class=Cm>config if</code> <var class=Ar>nic</var><code class=Cm>redirect_port sctp</code> <var class=Ar>ip_address [,addr_list] {[port</var> | <var class=Ar>port-port] [,ports]}</var></div><p class=Pp>Most <code class=Nm>sctp nat</code> configuration can be done in real-time through the <a class=Xr href=sysctl.8.html>sysctl(8)</a> interface. All may be changed dynamically, though the hash_table size will only change for new <code class=Nm>nat</code> instances. See <a class=Sx href=#SYSCTL_VARIABLES>SYSCTL VARIABLES</a> for more info.</p></section></section><section class=Sh><h2 class=Sh id=IPv6/IPv4_NETWORK_ADDRESS_AND_PROTOCOL_TRANSLATION><a class=permalink href=#IPv6/IPv4_NETWORK_ADDRESS_AND_PROTOCOL_TRANSLATION>IPv6/IPv4 NETWORK ADDRESS AND PROTOCOL TRANSLATION</a></h2><section class=Ss><h2 class=Ss id=Stateful_translation><a class=permalink href=#Stateful_translation>Stateful translation</a></h2><code class=Nm>ipfw</code> supports in-kernel IPv6/IPv4 network address and protocol translation. Stateful NAT64 translation allows IPv6-only clients to contact IPv4 servers using unicast TCP, UDP or ICMP protocols. One or more IPv4 addresses assigned to a stateful NAT64 translator are shared among several IPv6-only clients. When stateful NAT64 is used in conjunction with DNS64, no changes are usually required in the IPv6 client or the IPv4 server. The kernel module <code class=Cm>ipfw_nat64</code> should be loaded or kernel should have <code class=Cm>options IPFIREWALL_NAT64</code> to be able use stateful NAT64 translator. <p class=Pp>Stateful NAT64 uses a bunch of memory for several types of objects. When IPv6 client initiates connection, NAT64 translator creates a host entry in the states table. Each host entry uses preallocated IPv4 alias entry. Each alias entry has a number of ports group entries allocated on demand. Ports group entries contains connection state entries. There are several options to control limits and lifetime for these objects.</p><p class=Pp>NAT64 translator follows RFC7915 when does ICMPv6/ICMP translation, unsupported message types will be silently dropped. IPv6 needs several ICMPv6 message types to be explicitly allowed for correct operation. Make sure that ND6 neighbor solicitation (ICMPv6 type 135) and neighbor advertisement (ICMPv6 type 136) messages will not be handled by translation rules.</p><p class=Pp>After translation NAT64 translator by default sends packets through corresponding netisr queue. Thus translator host should be configured as IPv4 and IPv6 router. Also this means, that a packet is handled by firewall twice. First time an original packet is handled and consumed by translator, and then it is handled again as translated packet. This behavior can be changed by sysctl variable <var class=Va>net.inet.ip.fw.nat64_direct_output</var>. Also translated packet can be tagged using <code class=Cm>tag</code> rule action, and then matched by <code class=Cm>tagged</code> opcode to avoid loops and extra overhead.</p><p class=Pp>The stateful NAT64 configuration command is the following:</p><div class="Bd Pp Bd-indent"><code class=Cm>nat64lsn</code><var class=Ar>name</var><code class=Cm>create</code><var class=Ar>create-options</var></div><p class=Pp>The following parameters can be configured:</p><dl class=Bl-tag><dt><a class=permalink href=#prefix4><code class=Cm id=prefix4>prefix4</code></a><var class=Ar>ipv4_prefix/plen</var></dt><dd>The IPv4 prefix with mask defines the pool of IPv4 addresses used as source address after translation. Stateful NAT64 module translates IPv6 source address of client to one IPv4 address from this pool. Note that incoming IPv4 packets that don't have corresponding state entry in the states table will be dropped by translator. Make sure that translation rules handle packets, destined to configured prefix.</dd><dt><a class=permalink href=#prefix6><code class=Cm id=prefix6>prefix6</code></a><var class=Ar>ipv6_prefix/length</var></dt><dd>The IPv6 prefix defines IPv4-embedded IPv6 addresses used by translator to represent IPv4 addresses. This IPv6 prefix should be configured in DNS64. The translator implementation follows RFC6052, that restricts the length of prefixes to one of following: 32, 40, 48, 56, 64, or 96. The Well-Known IPv6 Prefix 64:ff9b:: must be 96 bits long. The special <var class=Ar>::/length</var> prefix can be used to handle several IPv6 prefixes with one NAT64 instance. The NAT64 instance will determine a destination IPv4 address from prefix <var class=Ar>length</var>.</dd><dt><a class=permalink href=#states_chunks><code class=Cm id=states_chunks>states_chunks</code></a><var class=Ar>number</var></dt><dd>The number of states chunks in single ports group. Each ports group by default can keep 64 state entries in single chunk. The above value affects the maximum number of states that can be associated with single IPv4 alias address and port. The value must be power of 2, and up to 128.</dd><dt><a class=permalink href=#host_del_age><code class=Cm id=host_del_age>host_del_age</code></a><var class=Ar>seconds</var></dt><dd>The number of seconds until the host entry for a IPv6 client will be deleted and all its resources will be released due to inactivity. Default value is <var class=Ar>3600</var>.</dd><dt><a class=permalink href=#pg_del_age><code class=Cm id=pg_del_age>pg_del_age</code></a><var class=Ar>seconds</var></dt><dd>The number of seconds until a ports group with unused state entries will be released. Default value is <var class=Ar>900</var>.</dd><dt><a class=permalink href=#tcp_syn_age><code class=Cm id=tcp_syn_age>tcp_syn_age</code></a><var class=Ar>seconds</var></dt><dd>The number of seconds while a state entry for TCP connection with only SYN sent will be kept. If TCP connection establishing will not be finished, state entry will be deleted. Default value is <var class=Ar>10</var>.</dd><dt><a class=permalink href=#tcp_est_age><code class=Cm id=tcp_est_age>tcp_est_age</code></a><var class=Ar>seconds</var></dt><dd>The number of seconds while a state entry for established TCP connection will be kept. Default value is <var class=Ar>7200</var>.</dd><dt><a class=permalink href=#tcp_close_age><code class=Cm id=tcp_close_age>tcp_close_age</code></a><var class=Ar>seconds</var></dt><dd>The number of seconds while a state entry for closed TCP connection will be kept. Keeping state entries for closed connections is needed, because IPv4 servers typically keep closed connections in a TIME_WAIT state for a several minutes. Since translator's IPv4 addresses are shared among all IPv6 clients, new connections from the same addresses and ports may be rejected by server, because these connections are still in a TIME_WAIT state. Keeping them in translator's state table protects from such rejects. Default value is <var class=Ar>180</var>.</dd><dt><a class=permalink href=#udp_age><code class=Cm id=udp_age>udp_age</code></a><var class=Ar>seconds</var></dt><dd>The number of seconds while translator keeps state entry in a waiting for reply to the sent UDP datagram. Default value is <var class=Ar>120</var>.</dd><dt><a class=permalink href=#icmp_age><code class=Cm id=icmp_age>icmp_age</code></a><var class=Ar>seconds</var></dt><dd>The number of seconds while translator keeps state entry in a waiting for reply to the sent ICMP message. Default value is <var class=Ar>60</var>.</dd><dt><a class=permalink href=#log_3><code class=Cm id=log_3>log</code></a></dt><dd>Turn on logging of all handled packets via BPF through <var class=Ar>ipfwlog0</var> interface. <var class=Ar>ipfwlog0</var> is a pseudo interface and can be created after a boot manually with <code class=Cm>ifconfig</code> command. Note that it has different purpose than <var class=Ar>ipfw0</var> interface. Translators sends to BPF an additional information with each packet. With <code class=Cm>tcpdump</code> you are able to see each handled packet before and after translation.</dd><dt><a class=permalink href=#-log><code class=Cm id=-log>-log</code></a></dt><dd>Turn off logging of all handled packets via BPF.</dd><dt><a class=permalink href=#allow_private><code class=Cm id=allow_private>allow_private</code></a></dt><dd>Turn on processing private IPv4 addresses. By default IPv6 packets with destinations mapped to private address ranges defined by RFC1918 are not processed.</dd><dt><a class=permalink href=#-allow_private><code class=Cm id=-allow_private>-allow_private</code></a></dt><dd>Turn off private address handling in <code class=Nm>nat64</code> instance.</dd></dl><p class=Pp>To inspect a states table of stateful NAT64 the following command can be used:</p><div class="Bd Pp Bd-indent"><code class=Cm>nat64lsn</code><var class=Ar>name</var><code class=Cm>show</code><code class=Cm>states</code></div><p class=Pp>Stateless NAT64 translator doesn't use a states table for translation and converts IPv4 addresses to IPv6 and vice versa solely based on the mappings taken from configured lookup tables. Since a states table doesn't used by stateless translator, it can be configured to pass IPv4 clients to IPv6-only servers.</p><p class=Pp>The stateless NAT64 configuration command is the following:</p><div class="Bd Pp Bd-indent"><code class=Cm>nat64stl</code><var class=Ar>name</var><code class=Cm>create</code><var class=Ar>create-options</var></div><p class=Pp>The following parameters can be configured:</p><dl class=Bl-tag><dt><a class=permalink href=#prefix6_2><code class=Cm id=prefix6_2>prefix6</code></a><var class=Ar>ipv6_prefix/length</var></dt><dd>The IPv6 prefix defines IPv4-embedded IPv6 addresses used by translator to represent IPv4 addresses. This IPv6 prefix should be configured in DNS64.</dd><dt><a class=permalink href=#table4><code class=Cm id=table4>table4</code></a><var class=Ar>table46</var></dt><dd>The lookup table <var class=Ar>table46</var> contains mapping how IPv4 addresses should be translated to IPv6 addresses.</dd><dt><a class=permalink href=#table6><code class=Cm id=table6>table6</code></a><var class=Ar>table64</var></dt><dd>The lookup table <var class=Ar>table64</var> contains mapping how IPv6 addresses should be translated to IPv4 addresses.</dd><dt><a class=permalink href=#log_4><code class=Cm id=log_4>log</code></a></dt><dd>Turn on logging of all handled packets via BPF through <var class=Ar>ipfwlog0</var> interface.</dd><dt><a class=permalink href=#-log_2><code class=Cm id=-log_2>-log</code></a></dt><dd>Turn off logging of all handled packets via BPF.</dd><dt><a class=permalink href=#allow_private_2><code class=Cm id=allow_private_2>allow_private</code></a></dt><dd>Turn on processing private IPv4 addresses. By default IPv6 packets with destinations mapped to private address ranges defined by RFC1918 are not processed.</dd><dt><a class=permalink href=#-allow_private_2><code class=Cm id=-allow_private_2>-allow_private</code></a></dt><dd>Turn off private address handling in <code class=Nm>nat64</code> instance.</dd></dl><p class=Pp>Note that the behavior of stateless translator with respect to not matched packets differs from stateful translator. If corresponding addresses was not found in the lookup tables, the packet will not be dropped and the search continues.</p></section><section class=Ss><h2 class=Ss id=XLAT464_CLAT_translation><a class=permalink href=#XLAT464_CLAT_translation>XLAT464 CLAT translation</a></h2> XLAT464 CLAT NAT64 translator implements client-side stateless translation as defined in RFC6877 and is very similar to statless NAT64 translator explained above. Instead of lookup tables it uses one-to-one mapping between IPv4 and IPv6 addresses using configured prefixes. This mode can be used as a replacement of DNS64 service for applications that are not using it (e.g. VoIP) allowing them to access IPv4-only Internet over IPv6-only networks with help of remote NAT64 translator. <p class=Pp>The CLAT NAT64 configuration command is the following:</p><div class="Bd Pp Bd-indent"><code class=Cm>nat64clat</code><var class=Ar>name</var><code class=Cm>create</code><var class=Ar>create-options</var></div><p class=Pp>The following parameters can be configured:</p><dl class=Bl-tag><dt><a class=permalink href=#clat_prefix><code class=Cm id=clat_prefix>clat_prefix</code></a><var class=Ar>ipv6_prefix/length</var></dt><dd>The IPv6 prefix defines IPv4-embedded IPv6 addresses used by translator to represent source IPv4 addresses.</dd><dt><a class=permalink href=#plat_prefix><code class=Cm id=plat_prefix>plat_prefix</code></a><var class=Ar>ipv6_prefix/length</var></dt><dd>The IPv6 prefix defines IPv4-embedded IPv6 addresses used by translator to represent destination IPv4 addresses. This IPv6 prefix should be configured on a remote NAT64 translator.</dd><dt><a class=permalink href=#log_5><code class=Cm id=log_5>log</code></a></dt><dd>Turn on logging of all handled packets via BPF through <var class=Ar>ipfwlog0</var> interface.</dd><dt><a class=permalink href=#-log_3><code class=Cm id=-log_3>-log</code></a></dt><dd>Turn off logging of all handled packets via BPF.</dd><dt><a class=permalink href=#allow_private_3><code class=Cm id=allow_private_3>allow_private</code></a></dt><dd>Turn on processing private IPv4 addresses. By default <code class=Nm>nat64clat</code> instance will not process IPv4 packets with destination address from private ranges as defined in RFC1918.</dd><dt><a class=permalink href=#-allow_private_3><code class=Cm id=-allow_private_3>-allow_private</code></a></dt><dd>Turn off private address handling in <code class=Nm>nat64clat</code> instance.</dd></dl><p class=Pp>Note that the behavior of CLAT translator with respect to not matched packets differs from stateful translator. If corresponding addresses were not matched against prefixes configured, the packet will not be dropped and the search continues.</p></section></section><section class=Sh><h2 class=Sh id=IPv6-to_IPv6_NETWORK_PREFIX_TRANSLATION_(NPTv6)><a class=permalink href=#IPv6-to_IPv6_NETWORK_PREFIX_TRANSLATION_(NPTv6)>IPv6-to-IPv6 NETWORK PREFIX TRANSLATION (NPTv6)</a></h2><code class=Nm>ipfw</code> supports in-kernel IPv6-to-IPv6 network prefix translation as described in RFC6296. The kernel module <code class=Cm>ipfw_nptv6</code> should be loaded or kernel should has <code class=Cm>options IPFIREWALL_NPTV6</code> to be able use NPTv6 translator. <p class=Pp>The NPTv6 configuration command is the following:</p><div class="Bd Pp Bd-indent"><code class=Cm>nptv6</code><var class=Ar>name</var><code class=Cm>create</code><var class=Ar>create-options</var></div><p class=Pp>The following parameters can be configured:</p><dl class=Bl-tag><dt><a class=permalink href=#int_prefix><code class=Cm id=int_prefix>int_prefix</code></a><var class=Ar>ipv6_prefix</var></dt><dd>IPv6 prefix used in internal network. NPTv6 module translates source address when it matches this prefix.</dd><dt><a class=permalink href=#ext_prefix><code class=Cm id=ext_prefix>ext_prefix</code></a><var class=Ar>ipv6_prefix</var></dt><dd>IPv6 prefix used in external network. NPTv6 module translates destination address when it matches this prefix.</dd><dt><a class=permalink href=#ext_if><code class=Cm id=ext_if>ext_if</code></a><var class=Ar>nic</var></dt><dd>The NPTv6 module will use first global IPv6 address from interface <var class=Ar>nic</var> as external prefix. It can be useful when IPv6 prefix of external network is dynamically obtained. <code class=Cm>ext_prefix</code> and <code class=Cm>ext_if</code> options are mutually exclusive.</dd><dt><a class=permalink href=#prefixlen><code class=Cm id=prefixlen>prefixlen</code></a><var class=Ar>length</var></dt><dd>The length of specified IPv6 prefixes. It must be in range from 8 to 64.</dd></dl><p class=Pp>Note that the prefix translation rules are silently ignored when IPv6 packet forwarding is disabled. To enable the packet forwarding, set the sysctl variable <var class=Va>net.inet6.ip6.forwarding</var> to 1.</p><p class=Pp>To let the packet continue after being translated, set the sysctl variable <var class=Va>net.inet.ip.fw.one_pass</var> to 0.</p></section><section class=Sh><h2 class=Sh id=LOADER_TUNABLES><a class=permalink href=#LOADER_TUNABLES>LOADER TUNABLES</a></h2> Tunables can be set in <a class=Xr href=loader.8.html>loader(8)</a> prompt, <a class=Xr href=loader.conf.5.html>loader.conf(5)</a> or <a class=Xr href=kenv.1.html>kenv(1)</a> before ipfw module gets loaded. <dl class=Bl-tag><dt><var class=Va>net.inet.ip.fw.default_to_accept</var>: <span class=No>0</span></dt><dd>Defines ipfw last rule behavior. This value overrides <code class=Cd>options IPFW_DEFAULT_TO_(ACCEPT|DENY)</code> from kernel configuration file.</dd><dt><var class=Va>net.inet.ip.fw.tables_max</var>: <span class=No>128</span></dt><dd>Defines number of tables available in ipfw. Number cannot exceed 65534.</dd></dl></section><section class=Sh><h2 class=Sh id=SYSCTL_VARIABLES><a class=permalink href=#SYSCTL_VARIABLES>SYSCTL VARIABLES</a></h2> A set of <a class=Xr href=sysctl.8.html>sysctl(8)</a> variables controls the behaviour of the firewall and associated modules (<code class=Nm>dummynet</code>, <code class=Nm>bridge</code>, <code class=Nm>sctp nat</code>). These are shown below together with their default value (but always check with the <a class=Xr href=sysctl.8.html>sysctl(8)</a> command what value is actually in use) and meaning: <dl class=Bl-tag><dt><var class=Va>net.inet.ip.alias.sctp.accept_global_ootb_addip</var>: <span class=No>0</span></dt><dd>Defines how the <code class=Nm>nat</code> responds to receipt of global OOTB ASCONF-AddIP: <dl class=Bl-tag><dt><a class=permalink href=#0><code class=Cm id=0>0</code></a></dt><dd>No response (unless a partially matching association exists - ports and vtags match but global address does not)</dd><dt><a class=permalink href=#1><code class=Cm id=1>1</code></a></dt><dd><code class=Nm>nat</code> will accept and process all OOTB global AddIP messages.</dd></dl><p class=Pp>Option 1 should never be selected as this forms a security risk. An attacker can establish multiple fake associations by sending AddIP messages.</p></dd><dt><var class=Va>net.inet.ip.alias.sctp.chunk_proc_limit</var>: <span class=No>5</span></dt><dd>Defines the maximum number of chunks in an SCTP packet that will be parsed for a packet that matches an existing association. This value is enforced to be greater or equal than <code class=Cm>net.inet.ip.alias.sctp.initialising_chunk_proc_limit</code>. A high value is a DoS risk yet setting too low a value may result in important control chunks in the packet not being located and parsed.</dd><dt><var class=Va>net.inet.ip.alias.sctp.error_on_ootb</var>: <span class=No>1</span></dt><dd>Defines when the <code class=Nm>nat</code> responds to any Out-of-the-Blue (OOTB) packets with ErrorM packets. An OOTB packet is a packet that arrives with no existing association registered in the <code class=Nm>nat</code> and is not an INIT or ASCONF-AddIP packet: <dl class=Bl-tag><dt><a class=permalink href=#0_2><code class=Cm id=0_2>0</code></a></dt><dd>ErrorM is never sent in response to OOTB packets.</dd><dt><a class=permalink href=#1_2><code class=Cm id=1_2>1</code></a></dt><dd>ErrorM is only sent to OOTB packets received on the local side.</dd><dt><a class=permalink href=#2><code class=Cm id=2>2</code></a></dt><dd>ErrorM is sent to the local side and on the global side ONLY if there is a partial match (ports and vtags match but the source global IP does not). This value is only useful if the <code class=Nm>nat</code> is tracking global IP addresses.</dd><dt><a class=permalink href=#3><code class=Cm id=3>3</code></a></dt><dd>ErrorM is sent in response to all OOTB packets on both the local and global side (DoS risk).</dd></dl><p class=Pp>At the moment the default is 0, since the ErrorM packet is not yet supported by most SCTP stacks. When it is supported, and if not tracking global addresses, we recommend setting this value to 1 to allow multi-homed local hosts to function with the <code class=Nm>nat</code>. To track global addresses, we recommend setting this value to 2 to allow global hosts to be informed when they need to (re)send an ASCONF-AddIP. Value 3 should never be chosen (except for debugging) as the <code class=Nm>nat</code> will respond to all OOTB global packets (a DoS risk).</p></dd><dt><var class=Va>net.inet.ip.alias.sctp.hashtable_size</var>: <span class=No>2003</span></dt><dd>Size of hash tables used for <code class=Nm>nat</code> lookups (100 &lt; prime_number &gt; 1000001). This value sets the <code class=Nm>hash table</code> size for any future created <code class=Nm>nat</code> instance and therefore must be set prior to creating a <code class=Nm>nat</code> instance. The table sizes may be changed to suit specific needs. If there will be few concurrent associations, and memory is scarce, you may make these smaller. If there will be many thousands (or millions) of concurrent associations, you should make these larger. A prime number is best for the table size. The sysctl update function will adjust your input value to the next highest prime number.</dd><dt><var class=Va>net.inet.ip.alias.sctp.holddown_time</var>: <span class=No>0</span></dt><dd>Hold association in table for this many seconds after receiving a SHUTDOWN-COMPLETE. This allows endpoints to correct shutdown gracefully if a shutdown_complete is lost and retransmissions are required.</dd><dt><var class=Va>net.inet.ip.alias.sctp.init_timer</var>: <span class=No>15</span></dt><dd>Timeout value while waiting for (INIT-ACK|AddIP-ACK). This value cannot be 0.</dd><dt><var class=Va>net.inet.ip.alias.sctp.initialising_chunk_proc_limit</var>: <span class=No>2</span></dt><dd>Defines the maximum number of chunks in an SCTP packet that will be parsed when no existing association exists that matches that packet. Ideally this packet will only be an INIT or ASCONF-AddIP packet. A higher value may become a DoS risk as malformed packets can consume processing resources.</dd><dt><var class=Va>net.inet.ip.alias.sctp.param_proc_limit</var>: <span class=No>25</span></dt><dd>Defines the maximum number of parameters within a chunk that will be parsed in a packet. As for other similar sysctl variables, larger values pose a DoS risk.</dd><dt><var class=Va>net.inet.ip.alias.sctp.log_level</var>: <span class=No>0</span></dt><dd>Level of detail in the system log messages (0 - minimal, 1 - event, 2 - info, 3 - detail, 4 - debug, 5 - max debug). May be a good option in high loss environments.</dd><dt><var class=Va>net.inet.ip.alias.sctp.shutdown_time</var>: <span class=No>15</span></dt><dd>Timeout value while waiting for SHUTDOWN-COMPLETE. This value cannot be 0.</dd><dt><var class=Va>net.inet.ip.alias.sctp.track_global_addresses</var>: <span class=No>0</span></dt><dd>Enables/disables global IP address tracking within the <code class=Nm>nat</code> and places an upper limit on the number of addresses tracked for each association: <dl class=Bl-tag><dt><a class=permalink href=#0_3><code class=Cm id=0_3>0</code></a></dt><dd>Global tracking is disabled</dd><dt><a class=permalink href=#_1><code class=Cm id=_1>&gt;1</code></a></dt><dd>Enables tracking, the maximum number of addresses tracked for each association is limited to this value</dd></dl><p class=Pp>This variable is fully dynamic, the new value will be adopted for all newly arriving associations, existing associations are treated as they were previously. Global tracking will decrease the number of collisions within the <code class=Nm>nat</code> at a cost of increased processing load, memory usage, complexity, and possible <code class=Nm>nat</code> state problems in complex networks with multiple <code class=Nm>nats</code>. We recommend not tracking global IP addresses, this will still result in a fully functional <code class=Nm>nat</code>.</p></dd><dt><var class=Va>net.inet.ip.alias.sctp.up_timer</var>: <span class=No>300</span></dt><dd>Timeout value to keep an association up with no traffic. This value cannot be 0.</dd><dt><var class=Va>net.inet.ip.dummynet.codel.interval</var>: <span class=No>100000</span></dt><dd>Default <code class=Cm>codel</code> AQM interval in microseconds. The value must be in the range 1..5000000.</dd><dt><var class=Va>net.inet.ip.dummynet.codel.target</var>: <span class=No>5000</span></dt><dd>Default <code class=Cm>codel</code> AQM target delay time in microseconds (the minimum acceptable persistent queue delay). The value must be in the range 1..5000000.</dd><dt><var class=Va>net.inet.ip.dummynet.expire</var>: <span class=No>1</span></dt><dd>Lazily delete dynamic pipes/queue once they have no pending traffic. You can disable this by setting the variable to 0, in which case the pipes/queues will only be deleted when the threshold is reached.</dd><dt><var class=Va>net.inet.ip.dummynet.fqcodel.flows</var>: <span class=No>1024</span></dt><dd>Defines the default total number of flow queues (sub-queues) that <code class=Cm>fq_codel</code> creates and manages. The value must be in the range 1..65536.</dd><dt><var class=Va>net.inet.ip.dummynet.fqcodel.interval</var>: <span class=No>100000</span></dt><dd>Default <code class=Cm>fq_codel</code> scheduler/AQM interval in microseconds. The value must be in the range 1..5000000.</dd><dt><var class=Va>net.inet.ip.dummynet.fqcodel.limit</var>: <span class=No>10240</span></dt><dd>The default hard size limit (in unit of packet) of all queues managed by an instance of the <code class=Cm>fq_codel</code> scheduler. The value must be in the range 1..20480.</dd><dt><var class=Va>net.inet.ip.dummynet.fqcodel.quantum</var>: <span class=No>1514</span></dt><dd>The default quantum (credit) of the <code class=Cm>fq_codel</code> in unit of byte. The value must be in the range 1..9000.</dd><dt><var class=Va>net.inet.ip.dummynet.fqcodel.target</var>: <span class=No>5000</span></dt><dd>Default <code class=Cm>fq_codel</code> scheduler/AQM target delay time in microseconds (the minimum acceptable persistent queue delay). The value must be in the range 1..5000000.</dd><dt><var class=Va>net.inet.ip.dummynet.fqpie.alpha</var>: <span class=No>125</span></dt><dd>The default <var class=Ar>alpha</var> parameter (scaled by 1000) for <code class=Cm>fq_pie</code> scheduler/AQM. The value must be in the range 1..7000.</dd><dt><var class=Va>net.inet.ip.dummynet.fqpie.beta</var>: <span class=No>1250</span></dt><dd>The default <var class=Ar>beta</var> parameter (scaled by 1000) for <code class=Cm>fq_pie</code> scheduler/AQM. The value must be in the range 1..7000.</dd><dt><var class=Va>net.inet.ip.dummynet.fqpie.flows</var>: <span class=No>1024</span></dt><dd>Defines the default total number of flow queues (sub-queues) that <code class=Cm>fq_pie</code> creates and manages. The value must be in the range 1..65536.</dd><dt><var class=Va>net.inet.ip.dummynet.fqpie.limit</var>: <span class=No>10240</span></dt><dd>The default hard size limit (in unit of packet) of all queues managed by an instance of the <code class=Cm>fq_pie</code> scheduler. The value must be in the range 1..20480.</dd><dt><var class=Va>net.inet.ip.dummynet.fqpie.max_burst</var>: <span class=No>150000</span></dt><dd>The default maximum period of microseconds that <code class=Cm>fq_pie</code> scheduler/AQM does not drop/mark packets. The value must be in the range 1..10000000.</dd><dt><var class=Va>net.inet.ip.dummynet.fqpie.max_ecnth</var>: <span class=No>99</span></dt><dd>The default maximum ECN probability threshold (scaled by 1000) for <code class=Cm>fq_pie</code> scheduler/AQM. The value must be in the range 1..7000.</dd><dt><var class=Va>net.inet.ip.dummynet.fqpie.quantum</var>: <span class=No>1514</span></dt><dd>The default quantum (credit) of the <code class=Cm>fq_pie</code> in unit of byte. The value must be in the range 1..9000.</dd><dt><var class=Va>net.inet.ip.dummynet.fqpie.target</var>: <span class=No>15000</span></dt><dd>The default <code class=Cm>target</code> delay of the <code class=Cm>fq_pie</code> in unit of microsecond. The value must be in the range 1..5000000.</dd><dt><var class=Va>net.inet.ip.dummynet.fqpie.tupdate</var>: <span class=No>15000</span></dt><dd>The default <code class=Cm>tupdate</code> of the <code class=Cm>fq_pie</code> in unit of microsecond. The value must be in the range 1..5000000.</dd><dt><var class=Va>net.inet.ip.dummynet.hash_size</var>: <span class=No>64</span></dt><dd>Default size of the hash table used for dynamic pipes/queues. This value is used when no <code class=Cm>buckets</code> option is specified when configuring a pipe/queue.</dd><dt><var class=Va>net.inet.ip.dummynet.io_fast</var>: <span class=No>0</span></dt><dd>If set to a non-zero value, the “fast” mode of <code class=Nm>dummynet</code> operation (see above) is enabled.</dd><dt><var class=Va>net.inet.ip.dummynet.io_pkt</var></dt><dd>Number of packets passed to <code class=Nm>dummynet</code>.</dd><dt><var class=Va>net.inet.ip.dummynet.io_pkt_drop</var></dt><dd>Number of packets dropped by <code class=Nm>dummynet</code>.</dd><dt><var class=Va>net.inet.ip.dummynet.io_pkt_fast</var></dt><dd>Number of packets bypassed by the <code class=Nm>dummynet</code> scheduler.</dd><dt><var class=Va>net.inet.ip.dummynet.max_chain_len</var>: <span class=No>16</span></dt><dd>Target value for the maximum number of pipes/queues in a hash bucket. The product <code class=Cm>max_chain_len*hash_size</code> is used to determine the threshold over which empty pipes/queues will be expired even when <code class=Cm>net.inet.ip.dummynet.expire=0</code>.</dd><dt><var class=Va>net.inet.ip.dummynet.red_lookup_depth</var>: <span class=No>256</span></dt><dd style="width: auto;"> </dd><dt><var class=Va>net.inet.ip.dummynet.red_avg_pkt_size</var>: <span class=No>512</span></dt><dd style="width: auto;"> </dd><dt><var class=Va>net.inet.ip.dummynet.red_max_pkt_size</var>: <span class=No>1500</span></dt><dd>Parameters used in the computations of the drop probability for the RED algorithm.</dd><dt><var class=Va>net.inet.ip.dummynet.pie.alpha</var>: <span class=No>125</span></dt><dd>The default <var class=Ar>alpha</var> parameter (scaled by 1000) for <code class=Cm>pie</code> AQM. The value must be in the range 1..7000.</dd><dt><var class=Va>net.inet.ip.dummynet.pie.beta</var>: <span class=No>1250</span></dt><dd>The default <var class=Ar>beta</var> parameter (scaled by 1000) for <code class=Cm>pie</code> AQM. The value must be in the range 1..7000.</dd><dt><var class=Va>net.inet.ip.dummynet.pie.max_burst</var>: <span class=No>150000</span></dt><dd>The default maximum period of microseconds that <code class=Cm>pie</code> AQM does not drop/mark packets. The value must be in the range 1..10000000.</dd><dt><var class=Va>net.inet.ip.dummynet.pie.max_ecnth</var>: <span class=No>99</span></dt><dd>The default maximum ECN probability threshold (scaled by 1000) for <code class=Cm>pie</code> AQM. The value must be in the range 1..7000.</dd><dt><var class=Va>net.inet.ip.dummynet.pie.target</var>: <span class=No>15000</span></dt><dd>The default <code class=Cm>target</code> delay of <code class=Cm>pie</code> AQM in unit of microsecond. The value must be in the range 1..5000000.</dd><dt><var class=Va>net.inet.ip.dummynet.pie.tupdate</var>: <span class=No>15000</span></dt><dd>The default <code class=Cm>tupdate</code> of <code class=Cm>pie</code> AQM in unit of microsecond. The value must be in the range 1..5000000.</dd><dt><var class=Va>net.inet.ip.dummynet.pipe_byte_limit</var>: <span class=No>1048576</span></dt><dd style="width: auto;"> </dd><dt><var class=Va>net.inet.ip.dummynet.pipe_slot_limit</var>: <span class=No>100</span></dt><dd>The maximum queue size that can be specified in bytes or packets. These limits prevent accidental exhaustion of resources such as mbufs. If you raise these limits, you should make sure the system is configured so that sufficient resources are available.</dd><dt><var class=Va>net.inet.ip.fw.autoinc_step</var>: <span class=No>100</span></dt><dd>Delta between rule numbers when auto-generating them. The value must be in the range 1..1000.</dd><dt><var class=Va>net.inet.ip.fw.curr_dyn_buckets</var>: <var class=Va>net.inet.ip.fw.dyn_buckets</var></dt><dd>The current number of buckets in the hash table for dynamic rules (readonly).</dd><dt><var class=Va>net.inet.ip.fw.debug</var>: <span class=No>1</span></dt><dd>Controls debugging messages produced by <code class=Nm>ipfw</code>.</dd><dt><var class=Va>net.inet.ip.fw.default_rule</var>: <span class=No>65535</span></dt><dd>The default rule number (read-only). By the design of <code class=Nm>ipfw</code>, the default rule is the last one, so its number can also serve as the highest number allowed for a rule.</dd><dt><var class=Va>net.inet.ip.fw.dyn_buckets</var>: <span class=No>256</span></dt><dd>The number of buckets in the hash table for dynamic rules. Must be a power of 2, up to 65536. It only takes effect when all dynamic rules have expired, so you are advised to use a <code class=Cm>flush</code> command to make sure that the hash table is resized.</dd><dt><var class=Va>net.inet.ip.fw.dyn_count</var>: <span class=No>3</span></dt><dd>Current number of dynamic rules (read-only).</dd><dt><var class=Va>net.inet.ip.fw.dyn_keepalive</var>: <span class=No>1</span></dt><dd>Enables generation of keepalive packets for <code class=Cm>keep-state</code> rules on TCP sessions. A keepalive is generated to both sides of the connection every 5 seconds for the last 20 seconds of the lifetime of the rule.</dd><dt><var class=Va>net.inet.ip.fw.dyn_max</var>: <span class=No>8192</span></dt><dd>Maximum number of dynamic rules. When you hit this limit, no more dynamic rules can be installed until old ones expire.</dd><dt><var class=Va>net.inet.ip.fw.dyn_ack_lifetime</var>: <span class=No>300</span></dt><dd style="width: auto;"> </dd><dt><var class=Va>net.inet.ip.fw.dyn_syn_lifetime</var>: <span class=No>20</span></dt><dd style="width: auto;"> </dd><dt><var class=Va>net.inet.ip.fw.dyn_fin_lifetime</var>: <span class=No>1</span></dt><dd style="width: auto;"> </dd><dt><var class=Va>net.inet.ip.fw.dyn_rst_lifetime</var>: <span class=No>1</span></dt><dd style="width: auto;"> </dd><dt><var class=Va>net.inet.ip.fw.dyn_udp_lifetime</var>: <span class=No>5</span></dt><dd style="width: auto;"> </dd><dt><var class=Va>net.inet.ip.fw.dyn_short_lifetime</var>: <span class=No>30</span></dt><dd>These variables control the lifetime, in seconds, of dynamic rules. Upon the initial SYN exchange the lifetime is kept short, then increased after both SYN have been seen, then decreased again during the final FIN exchange or when a RST is received. Both <i class=Em>dyn_fin_lifetime</i> and <i class=Em>dyn_rst_lifetime</i> must be strictly lower than 5 seconds, the period of repetition of keepalives. The firewall enforces that.</dd><dt><var class=Va>net.inet.ip.fw.dyn_keep_states</var>: <span class=No>0</span></dt><dd>Keep dynamic states on rule/set deletion. States are relinked to default rule (65535). This can be handly for ruleset reload. Turned off by default.</dd><dt><var class=Va>net.inet.ip.fw.enable</var>: <span class=No>1</span></dt><dd>Enables the firewall. Setting this variable to 0 lets you run your machine without firewall even if compiled in.</dd><dt><var class=Va>net.inet6.ip6.fw.enable</var>: <span class=No>1</span></dt><dd>provides the same functionality as above for the IPv6 case.</dd><dt><var class=Va>net.inet.ip.fw.one_pass</var>: <span class=No>1</span></dt><dd>When set, the packet exiting from the <code class=Nm>dummynet</code> pipe or from <a class=Xr href=ng_ipfw.4.html>ng_ipfw(4)</a> node is not passed though the firewall again. Otherwise, after an action, the packet is reinjected into the firewall at the next rule.</dd><dt><var class=Va>net.inet.ip.fw.tables_max</var>: <span class=No>128</span></dt><dd>Maximum number of tables.</dd><dt><var class=Va>net.inet.ip.fw.verbose</var>: <span class=No>1</span></dt><dd>Enables verbose messages.</dd><dt><var class=Va>net.inet.ip.fw.verbose_limit</var>: <span class=No>0</span></dt><dd>Limits the number of messages produced by a verbose firewall.</dd><dt><var class=Va>net.inet6.ip6.fw.deny_unknown_exthdrs</var>: <span class=No>1</span></dt><dd>If enabled packets with unknown IPv6 Extension Headers will be denied.</dd><dt><var class=Va>net.link.ether.ipfw</var>: <span class=No>0</span></dt><dd>Controls whether layer2 packets are passed to <code class=Nm>ipfw</code>. Default is no.</dd><dt><var class=Va>net.link.bridge.ipfw</var>: <span class=No>0</span></dt><dd>Controls whether bridged packets are passed to <code class=Nm>ipfw</code>. Default is no.</dd><dt><var class=Va>net.inet.ip.fw.nat64_debug</var>: <span class=No>0</span></dt><dd>Controls debugging messages produced by <code class=Nm>ipfw_nat64</code> module.</dd><dt><var class=Va>net.inet.ip.fw.nat64_direct_output</var>: <span class=No>0</span></dt><dd>Controls the output method used by <code class=Nm>ipfw_nat64</code> module: <dl class=Bl-tag><dt><a class=permalink href=#0_4><code class=Cm id=0_4>0</code></a></dt><dd>A packet is handled by <code class=Nm>ipfw</code> twice. First time an original packet is handled by <code class=Nm>ipfw</code> and consumed by <code class=Nm>ipfw_nat64</code> translator. Then translated packet is queued via netisr to input processing again.</dd><dt><a class=permalink href=#1_3><code class=Cm id=1_3>1</code></a></dt><dd>A packet is handled by <code class=Nm>ipfw</code> only once, and after translation it will be pushed directly to outgoing interface.</dd></dl></dd></dl></section><section class=Sh><h2 class=Sh id=INTERNAL_DIAGNOSTICS_2><a class=permalink href=#INTERNAL_DIAGNOSTICS_2>INTERNAL DIAGNOSTICS</a></h2> There are some commands that may be useful to understand current state of certain subsystems inside kernel module. These commands provide debugging output which may change without notice. <p class=Pp>Currently the following commands are available as <code class=Cm>internal</code> sub-options:</p><dl class=Bl-tag><dt><a class=permalink href=#iflist><code class=Cm id=iflist>iflist</code></a></dt><dd>Lists all interface which are currently tracked by <code class=Nm>ipfw</code> with their in-kernel status.</dd><dt><a class=permalink href=#talist><code class=Cm id=talist>talist</code></a></dt><dd>List all table lookup algorithms currently available.</dd></dl></section><section class=Sh><h2 class=Sh id=EXAMPLES><a class=permalink href=#EXAMPLES>EXAMPLES</a></h2> There are far too many possible uses of <code class=Nm>ipfw</code> so this Section will only give a small set of examples. <section class=Ss><h2 class=Ss id=BASIC_PACKET_FILTERING><a class=permalink href=#BASIC_PACKET_FILTERING>BASIC PACKET FILTERING</a></h2> This command adds an entry which denies all tcp packets from <i class=Em>cracker.evil.org</i> to the telnet port of <i class=Em>wolf.tambov.su</i> from being forwarded by the host: <p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add deny tcp from cracker.evil.org to wolf.tambov.su telnet</code></div><p class=Pp>This one disallows any connection from the entire cracker's network to my host:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add deny ip from 123.45.67.0/24 to my.host.org</code></div><p class=Pp>A first and efficient way to limit access (not using dynamic rules) is the use of the following rules:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add allow tcp from any to any established</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add allow tcp from net1 portlist1 to net2 portlist2 setup</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add allow tcp from net3 portlist3 to net3 portlist3 setup</code></div><div class="Bd Bd-indent"><code class=Li>...</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add deny tcp from any to any</code></div><p class=Pp>The first rule will be a quick match for normal TCP packets, but it will not match the initial SYN packet, which will be matched by the <code class=Cm>setup</code> rules only for selected source/destination pairs. All other SYN packets will be rejected by the final <code class=Cm>deny</code> rule.</p><p class=Pp>If you administer one or more subnets, you can take advantage of the address sets and or-blocks and write extremely compact rulesets which selectively enable services to blocks of clients, as below:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>goodguys="{ 10.1.2.0/24{20,35,66,18} or 10.2.3.0/28{6,3,11} }"</code></div><div class="Bd Bd-indent"><code class=Li>badguys="10.1.2.0/24{8,38,60}"</code></div><div class="Bd Bd-indent"><code class=Li></code></div><div class="Bd Bd-indent"><code class=Li>ipfw add allow ip from ${goodguys} to any</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add deny ip from ${badguys} to any</code></div><div class="Bd Bd-indent"><code class=Li>... normal policies ...</code></div><p class=Pp>The <code class=Cm>verrevpath</code> option could be used to do automated anti-spoofing by adding the following to the top of a ruleset:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add deny ip from any to any not verrevpath in</code></div><p class=Pp>This rule drops all incoming packets that appear to be coming to the system on the wrong interface. For example, a packet with a source address belonging to a host on a protected internal network would be dropped if it tried to enter the system from an external interface.</p><p class=Pp>The <code class=Cm>antispoof</code> option could be used to do similar but more restricted anti-spoofing by adding the following to the top of a ruleset:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add deny ip from any to any not antispoof in</code></div><p class=Pp>This rule drops all incoming packets that appear to be coming from another directly connected system but on the wrong interface. For example, a packet with a source address of <code class=Li>192.168.0.0/24</code>, configured on <code class=Li>fxp0</code>, but coming in on <code class=Li>fxp1</code> would be dropped.</p><p class=Pp>The <code class=Cm>setdscp</code> option could be used to (re)mark user traffic, by adding the following to the appropriate place in ruleset:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add setdscp be ip from any to any dscp af11,af21</code></div></section><section class=Ss><h2 class=Ss id=SELECTIVE_MIRRORING><a class=permalink href=#SELECTIVE_MIRRORING>SELECTIVE MIRRORING</a></h2> If your network has network traffic analyzer connected to your host directly via dedicated interface or remotely via RSPAN vlan, you can selectively mirror some Ethernet layer2 frames to the analyzer. <p class=Pp>First, make sure your firewall is already configured and runs. Then, enable layer2 processing if not already enabled:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>sysctl net.link.ether.ipfw=1</code></div><p class=Pp>Next, load needed additional kernel modules:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>kldload ng_ether ng_ipfw</code></div><p class=Pp>Optionally, make system load these modules automatically at startup:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>sysrc kld_list+="ng_ether ng_ipfw"</code></div><p class=Pp>Next, configure <a class=Xr href=ng_ipfw.4.html>ng_ipfw(4)</a> kernel module to transmit mirrored copies of layer2 frames out via vlan900 interface:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ngctl connect ipfw: vlan900: 1 lower</code></div><p class=Pp>Think of "1" here as of "mirroring instance index" and vlan900 is its destination. You can have arbitrary number of instances. Refer to <a class=Xr href=ng_ipfw.4.html>ng_ipfw(4)</a> for details.</p><p class=Pp>At last, actually start mirroring of selected frames using "instance 1". For frames incoming from em0 interface:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add ngtee 1 ip from any to 192.168.0.1 layer2 in recv em0</code></div><p class=Pp>For frames outgoing to em0 interface:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add ngtee 1 ip from any to 192.168.0.1 layer2 out xmit em0</code></div><p class=Pp>For both incoming and outgoing frames while flowing through em0:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add ngtee 1 ip from any to 192.168.0.1 layer2 via em0</code></div><p class=Pp>Make sure you do not perform mirroring for already duplicated frames or kernel may hang as there is no safety net.</p></section><section class=Ss><h2 class=Ss id=DYNAMIC_RULES><a class=permalink href=#DYNAMIC_RULES>DYNAMIC RULES</a></h2> In order to protect a site from flood attacks involving fake TCP packets, it is safer to use dynamic rules: <p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add check-state</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add deny tcp from any to any established</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add allow tcp from my-net to any setup keep-state</code></div><p class=Pp>This will let the firewall install dynamic rules only for those connection which start with a regular SYN packet coming from the inside of our network. Dynamic rules are checked when encountering the first occurrence of a <code class=Cm>check-state</code>, <code class=Cm>keep-state</code> or <code class=Cm>limit</code> rule. A <code class=Cm>check-state</code> rule should usually be placed near the beginning of the ruleset to minimize the amount of work scanning the ruleset. Your mileage may vary.</p><p class=Pp>For more complex scenarios with dynamic rules <code class=Cm>record-state</code> and <code class=Cm>defer-action</code> can be used to precisely control creation and checking of dynamic rules. Example of usage of these options are provided in <a class=Sx href=#NETWORK_ADDRESS_TRANSLATION_(NAT)>NETWORK ADDRESS TRANSLATION (NAT)</a> Section.</p><p class=Pp>To limit the number of connections a user can open you can use the following type of rules:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add allow tcp from my-net/24 to any setup limit src-addr 10</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add allow tcp from any to me setup limit src-addr 4</code></div><p class=Pp>The former (assuming it runs on a gateway) will allow each host on a /24 network to open at most 10 TCP connections. The latter can be placed on a server to make sure that a single client does not use more than 4 simultaneous connections.</p><p class=Pp><i class=Em>BEWARE</i>: stateful rules can be subject to denial-of-service attacks by a SYN-flood which opens a huge number of dynamic rules. The effects of such attacks can be partially limited by acting on a set of <a class=Xr href=sysctl.8.html>sysctl(8)</a> variables which control the operation of the firewall.</p><p class=Pp>Here is a good usage of the <code class=Cm>list</code> command to see accounting records and timestamp information:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw -at list</code></div><p class=Pp>or in short form without timestamps:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw -a list</code></div><p class=Pp>which is equivalent to:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw show</code></div><p class=Pp>Next rule diverts all incoming packets from 192.168.2.0/24 to divert port 5000:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw divert 5000 ip from 192.168.2.0/24 to any in</code></div></section><section class=Ss><h2 class=Ss id=TRAFFIC_SHAPING><a class=permalink href=#TRAFFIC_SHAPING>TRAFFIC SHAPING</a></h2> The following rules show some of the applications of <code class=Nm>ipfw</code> and <code class=Nm>dummynet</code> for simulations and the like. <p class=Pp>This rule drops random incoming packets with a probability of 5%:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add prob 0.05 deny ip from any to any in</code></div><p class=Pp>A similar effect can be achieved making use of <code class=Nm>dummynet</code> pipes:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>dnctl add pipe 10 ip from any to any</code></div><div class="Bd Bd-indent"><code class=Li>dnctl pipe 10 config plr 0.05</code></div><p class=Pp>We can use pipes to artificially limit bandwidth, e.g. on a machine acting as a router, if we want to limit traffic from local clients on 192.168.2.0/24 we do:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add pipe 1 ip from 192.168.2.0/24 to any out</code></div><div class="Bd Bd-indent"><code class=Li>dnctl pipe 1 config bw 300Kbit/s queue 50KBytes</code></div><p class=Pp>note that we use the <code class=Cm>out</code> modifier so that the rule is not used twice. Remember in fact that <code class=Nm>ipfw</code> rules are checked both on incoming and outgoing packets.</p><p class=Pp>Should we want to simulate a bidirectional link with bandwidth limitations, the correct way is the following:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add pipe 1 ip from any to any out</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add pipe 2 ip from any to any in</code></div><div class="Bd Bd-indent"><code class=Li>dnctl pipe 1 config bw 64Kbit/s queue 10Kbytes</code></div><div class="Bd Bd-indent"><code class=Li>dnctl pipe 2 config bw 64Kbit/s queue 10Kbytes</code></div><p class=Pp>The above can be very useful, e.g. if you want to see how your fancy Web page will look for a residential user who is connected only through a slow link. You should not use only one pipe for both directions, unless you want to simulate a half-duplex medium (e.g. AppleTalk, Ethernet, IRDA). It is not necessary that both pipes have the same configuration, so we can also simulate asymmetric links.</p><p class=Pp>Should we want to verify network performance with the RED queue management algorithm:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add pipe 1 ip from any to any</code></div><div class="Bd Bd-indent"><code class=Li>dnctl pipe 1 config bw 500Kbit/s queue 100 red 0.002/30/80/0.1</code></div><p class=Pp>Another typical application of the traffic shaper is to introduce some delay in the communication. This can significantly affect applications which do a lot of Remote Procedure Calls, and where the round-trip-time of the connection often becomes a limiting factor much more than bandwidth:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add pipe 1 ip from any to any out</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add pipe 2 ip from any to any in</code></div><div class="Bd Bd-indent"><code class=Li>dnctl pipe 1 config delay 250ms bw 1Mbit/s</code></div><div class="Bd Bd-indent"><code class=Li>dnctl pipe 2 config delay 250ms bw 1Mbit/s</code></div><p class=Pp>Per-flow queueing can be useful for a variety of purposes. A very simple one is counting traffic:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add pipe 1 tcp from any to any</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add pipe 1 udp from any to any</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add pipe 1 ip from any to any</code></div><div class="Bd Bd-indent"><code class=Li>dnctl pipe 1 config mask all</code></div><p class=Pp>The above set of rules will create queues (and collect statistics) for all traffic. Because the pipes have no limitations, the only effect is collecting statistics. Note that we need 3 rules, not just the last one, because when <code class=Nm>ipfw</code> tries to match IP packets it will not consider ports, so we would not see connections on separate ports as different ones.</p><p class=Pp>A more sophisticated example is limiting the outbound traffic on a net with per-host limits, rather than per-network limits:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add pipe 1 ip from 192.168.2.0/24 to any out</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add pipe 2 ip from any to 192.168.2.0/24 in</code></div><div class="Bd Bd-indent"><code class=Li>dnctl pipe 1 config mask src-ip 0x000000ff bw 200Kbit/s queue 20Kbytes</code></div><div class="Bd Bd-indent"><code class=Li>dnctl pipe 2 config mask dst-ip 0x000000ff bw 200Kbit/s queue 20Kbytes</code></div></section><section class=Ss><h2 class=Ss id=LOOKUP_TABLES_3><a class=permalink href=#LOOKUP_TABLES_3>LOOKUP TABLES</a></h2> In the following example, we need to create several traffic bandwidth classes and we need different hosts/networks to fall into different classes. We create one pipe for each class and configure them accordingly. Then we create a single table and fill it with IP subnets and addresses. For each subnet/host we set the argument equal to the number of the pipe that it should use. Then we classify traffic using a single rule: <p class=Pp></p><div class="Bd Bd-indent"><code class=Li>dnctl pipe 1 config bw 1000Kbyte/s</code></div><div class="Bd Bd-indent"><code class=Li>dnctl pipe 4 config bw 4000Kbyte/s</code></div><div class="Bd Bd-indent"><code class=Li>...</code></div><div class="Bd Bd-indent"><code class=Li>ipfw table T1 create type addr</code></div><div class="Bd Bd-indent"><code class=Li>ipfw table T1 add 192.168.2.0/24 1</code></div><div class="Bd Bd-indent"><code class=Li>ipfw table T1 add 192.168.0.0/27 4</code></div><div class="Bd Bd-indent"><code class=Li>ipfw table T1 add 192.168.0.2 1</code></div><div class="Bd Bd-indent"><code class=Li>...</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add pipe tablearg ip from 'table(T1)' to any</code></div><p class=Pp>Using the <code class=Cm>fwd</code> action, the table entries may include hostnames and IP addresses.</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw table T2 create type addr valtype ipv4</code></div><div class="Bd Bd-indent"><code class=Li>ipfw table T2 add 192.168.2.0/24 10.23.2.1</code></div><div class="Bd Bd-indent"><code class=Li>ipfw table T2 add 192.168.0.0/27 router1.dmz</code></div><div class="Bd Bd-indent"><code class=Li>...</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add 100 fwd tablearg ip from any to 'table(T2)'</code></div><p class=Pp>In the following example per-interface firewall is created:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw table IN create type iface valtype skipto,fib</code></div><div class="Bd Bd-indent"><code class=Li>ipfw table IN add vlan20 12000,12</code></div><div class="Bd Bd-indent"><code class=Li>ipfw table IN add vlan30 13000,13</code></div><div class="Bd Bd-indent"><code class=Li>ipfw table OUT create type iface valtype skipto</code></div><div class="Bd Bd-indent"><code class=Li>ipfw table OUT add vlan20 22000</code></div><div class="Bd Bd-indent"><code class=Li>ipfw table OUT add vlan30 23000</code></div><div class="Bd Bd-indent"><code class=Li>..</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add 100 setfib tablearg ip from any to any recv 'table(IN)' in</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add 200 skipto tablearg ip from any to any recv 'table(IN)' in</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add 300 skipto tablearg ip from any to any xmit 'table(OUT)' out</code></div><p class=Pp>The following example illustrate usage of flow tables:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw table fl create type flow:src-ip,proto,dst-ip,dst-port</code></div><div class="Bd Bd-indent"><code class=Li>ipfw table fl add 2a02:6b8:77::88,tcp,2a02:6b8:77::99,80 11</code></div><div class="Bd Bd-indent"><code class=Li>ipfw table fl add 10.0.0.1,udp,10.0.0.2,53 12</code></div><div class="Bd Bd-indent"><code class=Li>..</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add 100 allow ip from any to any flow 'table(fl,11)' recv ix0</code></div></section><section class=Ss><h2 class=Ss id=SETS_OF_RULES_2><a class=permalink href=#SETS_OF_RULES_2>SETS OF RULES</a></h2> To add a set of rules atomically, e.g. set 18: <p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw set disable 18</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add NN set 18 ... # repeat as needed</code></div><div class="Bd Bd-indent"><code class=Li>ipfw set enable 18</code></div><p class=Pp>To delete a set of rules atomically the command is simply:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw delete set 18</code></div><p class=Pp>To test a ruleset and disable it and regain control if something goes wrong:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw set disable 18</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add NN set 18 ... # repeat as needed</code></div><div class="Bd Bd-indent"><code class=Li>ipfw set enable 18; echo done; sleep 30 &amp;&amp; ipfw set disable 18</code></div><p class=Pp>Here if everything goes well, you press control-C before the "sleep" terminates, and your ruleset will be left active. Otherwise, e.g. if you cannot access your box, the ruleset will be disabled after the sleep terminates thus restoring the previous situation.</p><p class=Pp>To show rules of the specific set:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw set 18 show</code></div><p class=Pp>To show rules of the disabled set:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw -S set 18 show</code></div><p class=Pp>To clear a specific rule counters of the specific set:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw set 18 zero NN</code></div><p class=Pp>To delete a specific rule of the specific set:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw set 18 delete NN</code></div></section><section class=Ss><h2 class=Ss id=NAT,_REDIRECT_AND_LSNAT><a class=permalink href=#NAT,_REDIRECT_AND_LSNAT>NAT, REDIRECT AND LSNAT</a></h2> First redirect all the traffic to nat instance 123: <p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add nat 123 all from any to any</code></div><p class=Pp>Then to configure nat instance 123 to alias all the outgoing traffic with ip 192.168.0.123, blocking all incoming connections, trying to keep same ports on both sides, clearing aliasing table on address change and keeping a log of traffic/link statistics:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw nat 123 config ip 192.168.0.123 log deny_in reset same_ports</code></div><p class=Pp>Or to change address of instance 123, aliasing table will be cleared (see reset option):</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw nat 123 config ip 10.0.0.1</code></div><p class=Pp>To see configuration of nat instance 123:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw nat 123 show config</code></div><p class=Pp>To show logs of all instances:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw nat show log</code></div><p class=Pp>To see configurations of all instances:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw nat show config</code></div><p class=Pp>Or a redirect rule with mixed modes could looks like:</p><div class="Bd Pp Bd-indent"><pre>
ipfw nat 123 config redirect_addr 10.0.0.1 10.0.0.66
			 redirect_port tcp 192.168.0.1:80 500
			 redirect_proto udp 192.168.1.43 192.168.1.1
			 redirect_addr 192.168.0.10,192.168.0.11
			 	    10.0.0.100	# LSNAT
			 redirect_port tcp 192.168.0.1:80,192.168.0.10:22
			 	    500		# LSNAT
</pre></div><p class=Pp>or it could be split in:</p><div class="Bd Pp Bd-indent"><pre>
ipfw nat 1 config redirect_addr 10.0.0.1 10.0.0.66
ipfw nat 2 config redirect_port tcp 192.168.0.1:80 500
ipfw nat 3 config redirect_proto udp 192.168.1.43 192.168.1.1
ipfw nat 4 config redirect_addr 192.168.0.10,192.168.0.11,192.168.0.12
				         10.0.0.100
ipfw nat 5 config redirect_port tcp
			192.168.0.1:80,192.168.0.10:22,192.168.0.20:25 500
</pre></div><p class=Pp>Sometimes you may want to mix NAT and dynamic rules. It could be achieved with <code class=Cm>record-state</code> and <code class=Cm>defer-action</code> options. Problem is, you need to create dynamic rule before NAT and check it after NAT actions (or vice versa) to have consistent addresses and ports. Rule with <code class=Cm>keep-state</code> option will trigger activation of existing dynamic state, and action of such rule will be performed as soon as rule is matched. In case of NAT and <code class=Cm>allow</code> rule packet need to be passed to NAT, not allowed as soon is possible.</p><p class=Pp>There is example of set of rules to achieve this. Bear in mind that this is example only and it is not very useful by itself.</p><p class=Pp>On way out, after all checks place this rules:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add allow record-state skip-action</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add nat 1</code></div><p class=Pp>And on way in there should be something like this:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>ipfw add nat 1</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add check-state</code></div><p class=Pp>Please note, that first rule on way out doesn't allow packet and doesn't execute existing dynamic rules. All it does, create new dynamic rule with <code class=Cm>allow</code> action, if it is not created yet. Later, this dynamic rule is used on way in by <code class=Cm>check-state</code> rule.</p></section><section class=Ss><h2 class=Ss id=CONFIGURING_CODEL,_PIE,_FQ_CODEL_and_FQ_PIE_AQM><a class=permalink href=#CONFIGURING_CODEL,_PIE,_FQ_CODEL_and_FQ_PIE_AQM>CONFIGURING CODEL, PIE, FQ-CODEL and FQ-PIE AQM</a></h2><code class=Cm>codel</code> and <code class=Cm>pie</code> AQM can be configured for <code class=Nm>dummynet</code><code class=Cm>pipe</code> or <code class=Cm>queue</code>. <p class=Pp>To configure a <code class=Cm>pipe</code> with <code class=Cm>codel</code> AQM using default configuration for traffic from 192.168.0.0/24 and 1Mbits/s rate limit, we do:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>dnctl pipe 1 config bw 1mbits/s codel</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add 100 pipe 1 ip from 192.168.0.0/24 to any</code></div><p class=Pp>To configure a <code class=Cm>queue</code> with <code class=Cm>codel</code> AQM using different configurations parameters for traffic from 192.168.0.0/24 and 1Mbits/s rate limit, we do:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>dnctl pipe 1 config bw 1mbits/s</code></div><div class="Bd Bd-indent"><code class=Li>dnctl queue 1 config pipe 1 codel target 8ms interval 160ms ecn</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add 100 queue 1 ip from 192.168.0.0/24 to any</code></div><p class=Pp>To configure a <code class=Cm>pipe</code> with <code class=Cm>pie</code> AQM using default configuration for traffic from 192.168.0.0/24 and 1Mbits/s rate limit, we do:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>dnctl pipe 1 config bw 1mbits/s pie</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add 100 pipe 1 ip from 192.168.0.0/24 to any</code></div><p class=Pp>To configure a <code class=Cm>queue</code> with <code class=Cm>pie</code> AQM using different configuration parameters for traffic from 192.168.0.0/24 and 1Mbits/s rate limit, we do:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>dnctl pipe 1 config bw 1mbits/s</code></div><div class="Bd Bd-indent"><code class=Li>dnctl queue 1 config pipe 1 pie target 20ms tupdate 30ms ecn</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add 100 queue 1 ip from 192.168.0.0/24 to any</code></div><p class=Pp><code class=Cm>fq_codel</code> and <code class=Cm>fq_pie</code> AQM can be configured for <code class=Nm>dummynet</code> schedulers.</p><p class=Pp>To configure <code class=Cm>fq_codel</code> scheduler using different configurations parameters for traffic from 192.168.0.0/24 and 1Mbits/s rate limit, we do:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>dnctl pipe 1 config bw 1mbits/s</code></div><div class="Bd Bd-indent"><code class=Li>dnctl sched 1 config pipe 1 type fq_codel</code></div><div class="Bd Bd-indent"><code class=Li>dnctl queue 1 config sched 1</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add 100 queue 1 ip from 192.168.0.0/24 to any</code></div><p class=Pp>To change <code class=Cm>fq_codel</code> default configuration for a <code class=Cm>sched</code> such as disable ECN and change the <var class=Ar>target</var> to 10ms, we do:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>dnctl sched 1 config pipe 1 type fq_codel target 10ms noecn</code></div><p class=Pp>Similar to <code class=Cm>fq_codel</code>, to configure <code class=Cm>fq_pie</code> scheduler using different configurations parameters for traffic from 192.168.0.0/24 and 1Mbits/s rate limit, we do:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>dnctl pipe 1 config bw 1mbits/s</code></div><div class="Bd Bd-indent"><code class=Li>dnctl sched 1 config pipe 1 type fq_pie</code></div><div class="Bd Bd-indent"><code class=Li>dnctl queue 1 config sched 1</code></div><div class="Bd Bd-indent"><code class=Li>ipfw add 100 queue 1 ip from 192.168.0.0/24 to any</code></div><p class=Pp>The configurations of <code class=Cm>fq_pie</code><code class=Cm>sched</code> can be changed in a similar way as for <code class=Cm>fq_codel</code></p></section></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=cpp.1.html>cpp(1)</a>, <a class=Xr href=m4.1.html>m4(1)</a>, <a class=Xr href=altq.4.html>altq(4)</a>, <a class=Xr href=divert.4.html>divert(4)</a>, <a class=Xr href=dummynet.4.html>dummynet(4)</a>, <a class=Xr href=if_bridge.4.html>if_bridge(4)</a>, <a class=Xr href=ip.4.html>ip(4)</a>, <a class=Xr href=ipfirewall.4.html>ipfirewall(4)</a>, <a class=Xr href=ng_ether.4.html>ng_ether(4)</a>, <a class=Xr href=ng_ipfw.4.html>ng_ipfw(4)</a>, <a class=Xr href=protocols.5.html>protocols(5)</a>, <a class=Xr href=services.5.html>services(5)</a>, <a class=Xr href=init.8.html>init(8)</a>, <a class=Xr href=kldload.8.html>kldload(8)</a>, <a class=Xr href=reboot.8.html>reboot(8)</a>, <a class=Xr href=sysctl.8.html>sysctl(8)</a>, <a class=Xr href=syslogd.8.html>syslogd(8)</a>, <a class=Xr href=sysrc.8.html>sysrc(8)</a></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> The <code class=Nm>ipfw</code> utility first appeared in <span class=Ux>FreeBSD 2.0</span>. <code class=Nm>dummynet</code> was introduced in <span class=Ux>FreeBSD 2.2.8</span>. Stateful extensions were introduced in <span class=Ux>FreeBSD 4.0</span>. <code class=Nm>ipfw2</code> was introduced in Summer 2002. </section><section class=Sh><h2 class=Sh id=AUTHORS><a class=permalink href=#AUTHORS>AUTHORS</a></h2><span class=An>Ugen J. S. Antsilevich</span>, <br><span class=An>Poul-Henning Kamp</span>, <br><span class=An>Alex Nash</span>, <br><span class=An>Archie Cobbs</span>, <br><span class=An>Luigi Rizzo</span>, <br><span class=An>Rasool Al-Saadi</span>. <p class=Pp>API based upon code written by <span class=An>Daniel Boulet</span> for BSDI.</p><p class=Pp>Dummynet has been introduced by Luigi Rizzo in 1997-1998.</p><p class=Pp>Some early work (1999-2000) on the <code class=Nm>dummynet</code> traffic shaper supported by Akamba Corp.</p><p class=Pp>The ipfw core (ipfw2) has been completely redesigned and reimplemented by Luigi Rizzo in summer 2002. Further actions and options have been added by various developers over the years.</p><p class=Pp>In-kernel NAT support written by <span class=An>Paolo Pisati</span> &lt;<a class=Mt href=mailto:piso@FreeBSD.org>piso@FreeBSD.org</a>&gt; as part of a Summer of Code 2005 project.</p><p class=Pp>SCTP <code class=Nm>nat</code> support has been developed by <span class=An>The Centre for Advanced Internet Architectures (CAIA)</span> ⟨http://www.caia.swin.edu.au⟩. The primary developers and maintainers are David Hayes and Jason But. For further information visit: ⟨http://www.caia.swin.edu.au/urp/SONATA⟩</p><p class=Pp>Delay profiles have been developed by Alessandro Cerri and Luigi Rizzo, supported by the European Commission within Projects Onelab and Onelab2.</p><p class=Pp>CoDel, PIE, FQ-CoDel and FQ-PIE AQM for Dummynet have been implemented by <span class=An>The Centre for Advanced Internet Architectures (CAIA)</span> in 2016, supported by The Comcast Innovation Fund. The primary developer is Rasool Al-Saadi.</p></section><section class=Sh><h2 class=Sh id=BUGS><a class=permalink href=#BUGS>BUGS</a></h2> The syntax has grown over the years and sometimes it might be confusing. Unfortunately, backward compatibility prevents cleaning up mistakes made in the definition of the syntax. <p class=Pp><i class=Em>!!! WARNING !!!</i></p><p class=Pp>Misconfiguring the firewall can put your computer in an unusable state, possibly shutting down network services and requiring console access to regain control of it.</p><p class=Pp>Incoming packet fragments diverted by <code class=Cm>divert</code> are reassembled before delivery to the socket. The action used on those packet is the one from the rule which matches the first fragment of the packet.</p><p class=Pp>Packets diverted to userland, and then reinserted by a userland process may lose various packet attributes. The packet source interface name will be preserved if it is shorter than 8 bytes and the userland process saves and reuses the sockaddr_in (as does <a class=Xr href=natd.8.html>natd(8)</a>); otherwise, it may be lost. If a packet is reinserted in this manner, later rules may be incorrectly applied, making the order of <code class=Cm>divert</code> rules in the rule sequence very important.</p><p class=Pp>Dummynet drops all packets with IPv6 link-local addresses.</p><p class=Pp>Rules using <code class=Cm>uid</code> or <code class=Cm>gid</code> may not behave as expected. In particular, incoming SYN packets may have no uid or gid associated with them since they do not yet belong to a TCP connection, and the uid/gid associated with a packet may not be as expected if the associated process calls <a class=Xr href=setuid.2.html>setuid(2)</a> or similar system calls.</p><p class=Pp>Rule syntax is subject to the command line environment and some patterns may need to be escaped with the backslash character or quoted appropriately.</p><p class=Pp>Due to the architecture of <a class=Xr href=libalias.3.html>libalias(3)</a>, ipfw nat is not compatible with the TCP segmentation offloading (TSO). Thus, to reliably nat your network traffic, please disable TSO on your NICs using <a class=Xr href=ifconfig.8.html>ifconfig(8)</a>.</p><p class=Pp>ICMP error messages are not implicitly matched by dynamic rules for the respective conversations. To avoid failures of network error detection and path MTU discovery, ICMP error messages may need to be allowed explicitly through static rules.</p><p class=Pp>Rules using <code class=Cm>call</code> and <code class=Cm>return</code> actions may lead to confusing behaviour if ruleset has mistakes, and/or interaction with other subsystems (netgraph, dummynet, etc.) is used. One possible case for this is packet leaving <code class=Nm>ipfw</code> in subroutine on the input pass, while later on output encountering unpaired <code class=Cm>return</code> first. As the call stack is kept intact after input pass, packet will suddenly return to the rule number used on input pass, not on output one. Order of processing should be checked carefully to avoid such mistakes.</p></section></div><table class=foot><tr><td class=foot-date>August 17, 2022</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>