<!DOCTYPE html>
<html><head><meta charset=utf-8><title>memstat_mtl_next(3)</title><keywords content=man,memstat_mtl_next></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>memstat_mtl_next(3)</h1><table class=head><tr><td class=head-ltitle>LIBMEMSTAT(3)</td><td class=head-vol>FreeBSD Library Functions Manual</td><td class=head-rtitle>LIBMEMSTAT(3)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>libmemstat</code> — <div class=Nd>library interface to retrieve kernel memory allocator statistics</div></section><section class=Sh><h2 class=Sh id=LIBRARY><a class=permalink href=#LIBRARY>LIBRARY</a></h2><span class=Lb>Kernel Memory Allocator Statistics Library (libmemstat, -lmemstat)</span></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/sys/types.h.html>sys/types.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/memstat.h.html>memstat.h</a>&gt;</code><section class=Ss><h2 class=Ss id=General_Functions><a class=permalink href=#General_Functions>General Functions</a></h2><var class=Ft>const char *</var><br><code class=Fn>memstat_strerror</code>(<var class=Fa style="white-space: nowrap;">int error</var>); </section><section class=Ss><h2 class=Ss id=Memory_Type_List_Management_Functions><a class=permalink href=#Memory_Type_List_Management_Functions>Memory Type List Management Functions</a></h2><var class=Ft>struct memory_type_list *</var><br><code class=Fn>memstat_mtl_alloc</code>(<var class=Fa style="white-space: nowrap;">void</var>); <p class=Pp><var class=Ft>struct memory_type *</var><br><code class=Fn>memstat_mtl_first</code>(<var class=Fa style="white-space: nowrap;">struct memory_type_list *list</var>);</p><p class=Pp><var class=Ft>struct memory_type *</var><br><code class=Fn>memstat_mtl_next</code>(<var class=Fa style="white-space: nowrap;">struct memory_type *mtp</var>);</p><p class=Pp><var class=Ft>struct memory_type *</var><br><code class=Fn>memstat_mtl_find</code>(<var class=Fa>struct memory_type_list *list</var>, <var class=Fa>int allocator</var>, <var class=Fa>const char *name</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>memstat_mtl_free</code>(<var class=Fa style="white-space: nowrap;">struct memory_type_list *list</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>memstat_mtl_geterror</code>(<var class=Fa style="white-space: nowrap;">struct memory_type_list *list</var>);</p></section><section class=Ss><h2 class=Ss id=Allocator_Query_Functions><a class=permalink href=#Allocator_Query_Functions>Allocator Query Functions</a></h2><var class=Ft>int</var><br><code class=Fn>memstat_kvm_all</code>(<var class=Fa style="white-space: nowrap;">struct memory_type_list *list</var>, <var class=Fa style="white-space: nowrap;">void *kvm_handle</var>); <p class=Pp><var class=Ft>int</var><br><code class=Fn>memstat_kvm_malloc</code>(<var class=Fa style="white-space: nowrap;">struct memory_type_list *list</var>, <var class=Fa style="white-space: nowrap;">void *kvm_handle</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>memstat_kvm_uma</code>(<var class=Fa style="white-space: nowrap;">struct memory_type_list *list</var>, <var class=Fa style="white-space: nowrap;">void *kvm_handle</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>memstat_sysctl_all</code>(<var class=Fa style="white-space: nowrap;">struct memory_type_list *list</var>, <var class=Fa style="white-space: nowrap;">int flags</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>memstat_sysctl_malloc</code>(<var class=Fa style="white-space: nowrap;">struct memory_type_list *list</var>, <var class=Fa style="white-space: nowrap;">int flags</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>memstat_sysctl_uma</code>(<var class=Fa style="white-space: nowrap;">struct memory_type_list *list</var>, <var class=Fa style="white-space: nowrap;">int flags</var>);</p></section><section class=Ss><h2 class=Ss id=Memory_Type_Accessor_Methods><a class=permalink href=#Memory_Type_Accessor_Methods>Memory Type Accessor Methods</a></h2><var class=Ft>const char *</var><br><code class=Fn>memstat_get_name</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>); <p class=Pp><var class=Ft>int</var><br><code class=Fn>memstat_get_allocator</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>memstat_get_countlimit</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>memstat_get_byteslimit</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>memstat_get_sizemask</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>memstat_get_size</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>memstat_get_rsize</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>memstat_get_memalloced</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>memstat_get_memfreed</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>memstat_get_numallocs</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>memstat_get_numfrees</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>memstat_get_bytes</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>memstat_get_count</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>memstat_get_free</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>memstat_get_failures</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>);</p><p class=Pp><var class=Ft>void *</var><br><code class=Fn>memstat_get_caller_pointer</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>, <var class=Fa style="white-space: nowrap;">int index</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>memstat_set_caller_pointer</code>(<var class=Fa>struct memory_type *mtp</var>, <var class=Fa>int index</var>, <var class=Fa>void *value</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>memstat_get_caller_uint64</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>, <var class=Fa style="white-space: nowrap;">int index</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>memstat_set_caller_uint64</code>(<var class=Fa>struct memory_type *mtp</var>, <var class=Fa>int index</var>, <var class=Fa>uint64_t value</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>memstat_get_zonefree</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>memstat_get_kegfree</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>memstat_get_percpu_memalloced</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>, <var class=Fa style="white-space: nowrap;">int cpu</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>memstat_get_percpu_memfreed</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>, <var class=Fa style="white-space: nowrap;">int cpu</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>memstat_get_percpu_numallocs</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>, <var class=Fa style="white-space: nowrap;">int cpu</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>memstat_get_percpu_numfrees</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>, <var class=Fa style="white-space: nowrap;">int cpu</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>memstat_get_percpu_sizemask</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>, <var class=Fa style="white-space: nowrap;">int cpu</var>);</p><p class=Pp><var class=Ft>void *</var><br><code class=Fn>memstat_get_percpu_caller_pointer</code>(<var class=Fa>const struct memory_type *mtp</var>, <var class=Fa>int cpu</var>, <var class=Fa>int index</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>memstat_set_percpu_caller_pointer</code>(<var class=Fa>struct memory_type *mtp</var>, <var class=Fa>int cpu</var>, <var class=Fa>int index</var>, <var class=Fa>void *value</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>memstat_get_percpu_caller_uint64</code>(<var class=Fa>const struct memory_type *mtp</var>, <var class=Fa>int cpu</var>, <var class=Fa>int index</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>memstat_set_percpu_caller_uint64</code>(<var class=Fa>struct memory_type *mtp</var>, <var class=Fa>int cpu</var>, <var class=Fa>int index</var>, <var class=Fa>uint64_t value</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>memstat_get_percpu_free</code>(<var class=Fa style="white-space: nowrap;">const struct memory_type *mtp</var>, <var class=Fa style="white-space: nowrap;">int cpu</var>);</p></section></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2><code class=Nm>libmemstat</code> provides an interface to retrieve kernel memory allocator statistics, for the purposes of debugging and system monitoring, insulating applications from implementation details of the allocators, and allowing a tool to transparently support multiple allocators. <code class=Nm>libmemstat</code> supports both retrieving a single statistics snapshot, as well as incrementally updating statistics for long-term monitoring. <p class=Pp><code class=Nm>libmemstat</code> describes each memory type using a <var class=Vt>struct memory_type</var>, an opaque memory type accessed by the application using accessor functions in the library. <code class=Nm>libmemstat</code> returns and updates chains of <var class=Vt>struct memory_type</var> via a <var class=Vt>struct memory_type_list</var>, which will be allocated by calling <code class=Fn>memstat_mtl_alloc</code>(), and freed on completion using <code class=Fn>memstat_mtl_free</code>(). Lists of memory types are populated via calls that query the kernel for statistics information; currently: <code class=Fn>memstat_kvm_all</code>(), <code class=Fn>memstat_kvm_malloc</code>(), <code class=Fn>memstat_kvm_uma</code>(), <code class=Fn>memstat_sysctl_all</code>(), <code class=Fn>memstat_sysctl_uma</code>(), and <code class=Fn>memstat_sysctl_malloc</code>(). Repeated calls will incrementally update the list of memory types, permitting tracking over time without recreating all list state. If an error is detected during a query call, error condition information may be retrieved using <code class=Fn>memstat_mtl_geterror</code>(), and converted to a user-readable string using <code class=Fn>memstat_strerror</code>().</p><p class=Pp>Freeing the list will free all memory type data in the list, and so invalidates any outstanding pointers to entries in the list. <var class=Vt>struct memory_type</var> entries in the list may be iterated over using <code class=Fn>memstat_mtl_first</code>() and <code class=Fn>memstat_mtl_next</code>(), which respectively return the first entry in a list, and the next entry in a list. <code class=Fn>memstat_mtl_find</code>(), which will return a pointer to the first entry matching the passed parameters.</p><p class=Pp>A series of accessor methods is provided to access fields of the structure, including retrieving statistics and properties, as well as setting of caller owned fields. Direct application access to the data structure fields is not supported.</p><section class=Ss><h2 class=Ss>Library <var class=Vt>memory_type Ss Fields</var></h2> Each <var class=Vt>struct memory_type</var> holds a description of the memory type, including its name and the allocator it is managed by, as well as current statistics on use. Some statistics are directly measured, others are derived from directly measured statistics. Certain high level statistics are present across all available allocators, such as the number of allocation and free operations; other measurements, such as the quantity of free items in per-CPU caches, or administrative limit on the number of allocations, is available only for specific allocators. </section><section class=Ss><h2 class=Ss>Caller <var class=Vt>memory_type Ss Fields</var></h2><var class=Vt>struct memory_type</var> includes fields to allow the application to store data, in the form of pointers and 64-bit integers, with memory types. For example, the application author might make use of one of the caller pointers to reference a more complex data structure tracking long-term behavior of the memory type, or a window system object that is used to render the state of the memory type. General and per-CPU storage is provided with each <var class=Vt>struct memory_type</var> in the form of an array of pointers and integers. The array entries are accessed via the <var class=Fa>index</var> argument to the get and set accessor methods. Possible values of <var class=Fa>index</var> range between 0 and <code class=Dv>MEMSTAT_MAXCALLER</code>. <p class=Pp>Caller-owned fields are initialized to 0 or <code class=Dv>NULL</code> when a new <var class=Vt>struct memory_type</var> is allocated and attached to a memory type list; these fields retain their values across queries that update library-owned fields.</p></section><section class=Ss><h2 class=Ss id=Allocator_Types><a class=permalink href=#Allocator_Types>Allocator Types</a></h2> Currently, <code class=Nm>libmemstat</code> supports two kernel allocators: <code class=Dv>ALLOCATOR_UMA</code> for <a class=Xr href=uma.9.html>uma(9)</a>, and <code class=Dv>ALLOCATOR_MALLOC</code> for <a class=Xr href=malloc.9.html>malloc(9)</a>. These values may be passed to <code class=Fn>memstat_mtl_find</code>(), and will be returned by <code class=Fn>memstat_get_allocator</code>(). Two additional constants in the allocator name space are defined: <code class=Dv>ALLOCATOR_UNKNOWN</code>, which will only be returned as a result of a library error, and <code class=Dv>ALLOCATOR_ANY</code>, which can be used to specify that returning types matching any allocator is permittable from <code class=Fn>memstat_mtl_find</code>(). </section><section class=Ss><h2 class=Ss id=Access_Method_List><a class=permalink href=#Access_Method_List>Access Method List</a></h2> The following accessor methods are defined, of which some will be valid for a given memory type: <dl class=Bl-tag><dt><code class=Fn>memstat_get_name</code>()</dt><dd>Return a pointer to the name of the memory type. Memory for the name is owned by <code class=Nm>libmemstat</code> and will be valid through a call to <code class=Fn>memstat_mtl_free</code>(). Note that names will be unique with respect to a single allocator, but that the same name might be used by different memory types owned by different memory allocators.</dd><dt><code class=Fn>memstat_get_allocator</code>()</dt><dd>Return an integer identifier for the memory allocator that owns the memory type.</dd><dt><code class=Fn>memstat_get_countlimit</code>()</dt><dd>If the memory type has an administrative limit on the number of simultaneous allocations, return it.</dd><dt><code class=Fn>memstat_get_byteslimit</code>()</dt><dd>If the memory type has an administrative limit on the number of bytes of memory that may be simultaneously allocated for the memory type, return it.</dd><dt><code class=Fn>memstat_get_sizemask</code>()</dt><dd>If the memory type supports variable allocation sizes, return a bitmask of sizes allocated for the memory type.</dd><dt><code class=Fn>memstat_get_size</code>()</dt><dd>If the memory type supports a fixed allocation size, return that size.</dd><dt><code class=Fn>memstat_get_rsize</code>()</dt><dd>If the memory type supports a fixed allocation size, return real size of an allocation. Real size can exceed requested size due to alignment constraints or implicit padding.</dd><dt><code class=Fn>memstat_get_memalloced</code>()</dt><dd>Return the total number of bytes allocated for the memory type over its lifetime.</dd><dt><code class=Fn>memstat_get_memfreed</code>()</dt><dd>Return the total number of bytes freed for the memory type over its lifetime.</dd><dt><code class=Fn>memstat_get_numallocs</code>()</dt><dd>Return the total number of allocations for the memory type over its lifetime.</dd><dt><code class=Fn>memstat_get_numfrees</code>()</dt><dd>Return the total number of frees for the memory type over its lifetime.</dd><dt><code class=Fn>memstat_get_bytes</code>()</dt><dd>Return the current number of bytes allocated to the memory type.</dd><dt><code class=Fn>memstat_get_count</code>()</dt><dd>Return the current number of allocations for the memory type.</dd><dt><code class=Fn>memstat_get_free</code>()</dt><dd>If the memory allocator supports a cache, return the number of items in the cache.</dd><dt><code class=Fn>memstat_get_failures</code>()</dt><dd>If the memory allocator and type permit allocation failures, return the number of allocation failures measured.</dd><dt><code class=Fn>memstat_get_caller_pointer</code>()</dt><dd>Return a caller-owned pointer for the memory type.</dd><dt><code class=Fn>memstat_set_caller_pointer</code>()</dt><dd>Set a caller-owned pointer for the memory type.</dd><dt><code class=Fn>memstat_get_caller_uint64</code>()</dt><dd>Return a caller-owned integer for the memory type.</dd><dt><code class=Fn>memstat_set_caller_uint64</code>()</dt><dd>Set a caller-owned integer for the memory type.</dd><dt><code class=Fn>memstat_get_zonefree</code>()</dt><dd>If the memory allocator supports a multi-level allocation structure, return the number of cached items in the zone. These items will be in a fully constructed state available for immediate use.</dd><dt><code class=Fn>memstat_get_kegfree</code>()</dt><dd>If the memory allocator supports a multi-level allocation structure, return the number of cached items in the keg. These items may be in a partially constructed state, and may require further processing before they can be made available for use.</dd><dt><code class=Fn>memstat_get_percpu_memalloced</code>()</dt><dd>If the memory allocator supports per-CPU statistics, return the number of bytes of memory allocated for the memory type on the CPU over its lifetime.</dd><dt><code class=Fn>memstat_get_percpu_memfreed</code>()</dt><dd>If the memory allocator supports per-CPU statistics, return the number of bytes of memory freed from the memory type on the CPU over its lifetime.</dd><dt><code class=Fn>memstat_get_percpu_numallocs</code>()</dt><dd>If the memory allocator supports per-CPU statistics, return the number of allocations for the memory type on the CPU over its lifetime.</dd><dt><code class=Fn>memstat_get_percpu_numfrees</code>()</dt><dd>If the memory allocator supports per-CPU statistics, return the number of frees for the memory type on the CPU over its lifetime.</dd><dt><code class=Fn>memstat_get_percpu_sizemask</code>()</dt><dd>If the memory allocator supports variable size memory allocation and per-CPU statistics, return the size bitmask for the memory type on the CPU.</dd><dt><code class=Fn>memstat_get_percpu_caller_pointer</code>()</dt><dd>Return a caller-owned per-CPU pointer for the memory type.</dd><dt><code class=Fn>memstat_set_percpu_caller_pointer</code>()</dt><dd>Set a caller-owned per-CPU pointer for the memory type.</dd><dt><code class=Fn>memstat_get_percpu_caller_uint64</code>()</dt><dd>Return a caller-owned per-CPU integer for the memory type.</dd><dt><code class=Fn>memstat_set_percpu_caller_uint64</code>()</dt><dd>Set a caller-owned per-CPU integer for the memory type.</dd><dt><code class=Fn>memstat_get_percpu_free</code>()</dt><dd>If the memory allocator supports a per-CPU cache, return the number of free items in the per-CPU cache of the designated CPU.</dd></dl></section></section><section class=Sh><h2 class=Sh id=RETURN_VALUES><a class=permalink href=#RETURN_VALUES>RETURN VALUES</a></h2><code class=Nm>libmemstat</code> functions fall into three categories: functions returning a pointer to an object, functions returning an integer return value, and functions implementing accessor methods returning data from a <var class=Vt>struct memory_type</var>. <p class=Pp>Functions returning a pointer to an object will generally return <code class=Dv>NULL</code> on failure. <code class=Fn>memstat_mtl_alloc</code>() will return an error value via <var class=Va>errno</var>, which will consist of the value <code class=Er>ENOMEM</code>. Functions <code class=Fn>memstat_mtl_first</code>(), <code class=Fn>memstat_mtl_next</code>(), and <code class=Fn>memstat_mtl_find</code>() will return <code class=Dv>NULL</code> when there is no entry or match in the list; however, this is not considered a failure mode and no error value is available.</p><p class=Pp>Functions returning an integer success value will return 0 on success, or -1 on failure. If a failure is returned, the list error access method, <code class=Fn>memstat_mtl_geterror</code>(), may be used to retrieve the error state. The string representation of the error may be retrieved using <code class=Fn>memstat_strerror</code>(). Possible error values are:</p><dl class=Bl-tag><dt><a class=permalink href=#MEMSTAT_ERROR_UNDEFINED><code class=Dv id=MEMSTAT_ERROR_UNDEFINED>MEMSTAT_ERROR_UNDEFINED</code></a></dt><dd>Undefined error. Occurs if <code class=Fn>memstat_mtl_geterror</code>() is called on a list before an error associated with the list has occurred.</dd><dt><a class=permalink href=#MEMSTAT_ERROR_NOMEMORY><code class=Dv id=MEMSTAT_ERROR_NOMEMORY>MEMSTAT_ERROR_NOMEMORY</code></a></dt><dd>Insufficient memory. Occurs if library calls to <a class=Xr href=malloc.3.html>malloc(3)</a> fail, or if a system call to retrieve kernel statistics fails with <code class=Er>ENOMEM</code>.</dd><dt><a class=permalink href=#MEMSTAT_ERROR_VERSION><code class=Dv id=MEMSTAT_ERROR_VERSION>MEMSTAT_ERROR_VERSION</code></a></dt><dd>Returned if the current version of <code class=Nm>libmemstat</code> is unable to interpret the statistics data returned by the kernel due to an explicit version mismatch, or to differences in data structures that cannot be reconciled.</dd><dt><a class=permalink href=#MEMSTAT_ERROR_PERMISSION><code class=Dv id=MEMSTAT_ERROR_PERMISSION>MEMSTAT_ERROR_PERMISSION</code></a></dt><dd>Returned if a statistics source returns <var class=Va>errno</var> values of <code class=Er>EACCES</code> or <code class=Er>EPERM</code>.</dd><dt><a class=permalink href=#MEMSTAT_ERROR_DATAERROR><code class=Dv id=MEMSTAT_ERROR_DATAERROR>MEMSTAT_ERROR_DATAERROR</code></a></dt><dd>Returned if <code class=Nm>libmemstat</code> is unable to interpret statistics data returned by the data source, even though there does not appear to be a version problem.</dd><dt><a class=permalink href=#MEMSTAT_ERROR_KVM><code class=Dv id=MEMSTAT_ERROR_KVM>MEMSTAT_ERROR_KVM</code></a></dt><dd>Returned if <code class=Nm>libmemstat</code> experiences an error while using <a class=Xr href=kvm.3.html>kvm(3)</a> interfaces to query statistics data. Use <a class=Xr href=kvm_geterr.3.html>kvm_geterr(3)</a> to retrieve the error.</dd><dt><a class=permalink href=#MEMSTAT_ERROR_KVM_NOSYMBOL><code class=Dv id=MEMSTAT_ERROR_KVM_NOSYMBOL>MEMSTAT_ERROR_KVM_NOSYMBOL</code></a></dt><dd>Returned if <code class=Nm>libmemstat</code> is unable to read a required symbol from the kernel being operated on.</dd><dt><a class=permalink href=#MEMSTAT_ERROR_KVM_SHORTREAD><code class=Dv id=MEMSTAT_ERROR_KVM_SHORTREAD>MEMSTAT_ERROR_KVM_SHORTREAD</code></a></dt><dd>Returned if <code class=Nm>libmemstat</code> attempts to read data from a live memory image or kernel core dump and insufficient data is returned.</dd></dl><p class=Pp>Finally, functions returning data from a <var class=Vt>struct memory_type</var> pointer are not permitted to fail, and directly return either a statistic or pointer to a string.</p></section><section class=Sh><h2 class=Sh id=EXAMPLES><a class=permalink href=#EXAMPLES>EXAMPLES</a></h2> Create a memory type list, query the <a class=Xr href=uma.9.html>uma(9)</a> memory allocator for available statistics, and print out the number of allocations performed by the <code class=Dv>mbuf</code> zone. <div class="Bd Pp Bd-indent"><pre>
struct memory_type_list *mtlp;
struct memory_type *mtp;
uint64_t mbuf_count;

mtlp = memstat_mtl_alloc();
if (mtlp == NULL)
    err(-1, "memstat_mtl_alloc");
if (memstat_sysctl_uma(mtlp, 0) &lt; 0)
    err(-1, "memstat_sysctl_uma");
mtp = memstat_mtl_find(mtlp, ALLOCATOR_UMA, "mbuf");
if (mtp == NULL)
    errx(-1, "memstat_mtl_find: mbuf not found");
mbuf_count = memstat_get_count(mtp);
memstat_mtl_free(mtlp);

printf("mbufs: %llu\n", (unsigned long long)mbuf_count);
</pre></div></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=malloc.9.html>malloc(9)</a>, <a class=Xr href=uma.9.html>uma(9)</a></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> The <code class=Nm>libmemstat</code> library appeared in <span class=Ux>FreeBSD 6.0</span>. </section><section class=Sh><h2 class=Sh id=AUTHORS><a class=permalink href=#AUTHORS>AUTHORS</a></h2> The kernel memory allocator changes necessary to support a general purpose monitoring library, along with the library, were written by <span class=An>Robert Watson</span> &lt;<a class=Mt href=mailto:rwatson@FreeBSD.org>rwatson@FreeBSD.org</a>&gt;. </section><section class=Sh><h2 class=Sh id=BUGS><a class=permalink href=#BUGS>BUGS</a></h2> There are memory allocators in the kernel, such as the VM page allocator and <code class=Nm>sf_buf</code> allocator, which are not currently supported by <code class=Nm>libmemstat</code>. <p class=Pp>Once a memory type is present on a memory type list, it will not be removed even if the kernel no longer presents information on the type via its monitoring interfaces. In order to flush removed memory types, it is necessary to free the entire list and allocate a new one.</p></section></div><table class=foot><tr><td class=foot-date>February 11, 2014</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>