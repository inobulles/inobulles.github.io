<!DOCTYPE html>
<html><head><meta charset=utf-8><title>tuning(7)</title><keywords content=man,tuning></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>tuning(7)</h1><table class=head><tr><td class=head-ltitle>TUNING(7)</td><td class=head-vol>FreeBSD Miscellaneous Information Manual</td><td class=head-rtitle>TUNING(7)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>tuning</code> — <div class=Nd>performance tuning under FreeBSD</div></section><section class=Sh><h2 class=Sh id=SYSTEM_SETUP_-_DISKLABEL,_NEWFS,_TUNEFS,_SWAP><a class=permalink href=#SYSTEM_SETUP_-_DISKLABEL,_NEWFS,_TUNEFS,_SWAP>SYSTEM SETUP - DISKLABEL, NEWFS, TUNEFS, SWAP</a></h2> The swap partition should typically be approximately 2x the size of main memory for systems with less than 4GB of RAM, or approximately equal to the size of main memory if you have more. Keep in mind future memory expansion when sizing the swap partition. Configuring too little swap can lead to inefficiencies in the VM page scanning code as well as create issues later on if you add more memory to your machine. On larger systems with multiple disks, configure swap on each drive. The swap partitions on the drives should be approximately the same size. The kernel can handle arbitrary sizes but internal data structures scale to 4 times the largest swap partition. Keeping the swap partitions near the same size will allow the kernel to optimally stripe swap space across the N disks. Do not worry about overdoing it a little, swap space is the saving grace of <span class=Ux>UNIX</span> and even if you do not normally use much swap, it can give you more time to recover from a runaway program before being forced to reboot. <p class=Pp>It is not a good idea to make one large partition. First, each partition has different operational characteristics and separating them allows the file system to tune itself to those characteristics. For example, the root and <span class=Pa>/usr</span> partitions are read-mostly, with very little writing, while a lot of reading and writing could occur in <span class=Pa>/var/tmp</span>. By properly partitioning your system fragmentation introduced in the smaller more heavily write-loaded partitions will not bleed over into the mostly-read partitions.</p><p class=Pp>Properly partitioning your system also allows you to tune <a class=Xr href=newfs.8.html>newfs(8)</a>, and <a class=Xr href=tunefs.8.html>tunefs(8)</a> parameters. The only <a class=Xr href=tunefs.8.html>tunefs(8)</a> option worthwhile turning on is <i class=Em>softupdates</i> with “<code class=Li>tunefs -n enable /filesystem</code>”. Softupdates drastically improves meta-data performance, mainly file creation and deletion. We recommend enabling softupdates on most file systems; however, there are two limitations to softupdates that you should be aware of when determining whether to use it on a file system. First, softupdates guarantees file system consistency in the case of a crash but could very easily be several seconds (even a minute!) behind on pending write to the physical disk. If you crash you may lose more work than otherwise. Secondly, softupdates delays the freeing of file system blocks. If you have a file system (such as the root file system) which is close to full, doing a major update of it, e.g., “<code class=Li>make installworld</code>”, can run it out of space and cause the update to fail. For this reason, softupdates will not be enabled on the root file system during a typical install. There is no loss of performance since the root file system is rarely written to.</p><p class=Pp>A number of run-time <a class=Xr href=mount.8.html>mount(8)</a> options exist that can help you tune the system. The most obvious and most dangerous one is <code class=Cm>async</code>. Only use this option in conjunction with <a class=Xr href=gjournal.8.html>gjournal(8)</a>, as it is far too dangerous on a normal file system. A less dangerous and more useful <a class=Xr href=mount.8.html>mount(8)</a> option is called <code class=Cm>noatime</code>. <span class=Ux>UNIX</span> file systems normally update the last-accessed time of a file or directory whenever it is accessed. This operation is handled in <span class=Ux>FreeBSD</span> with a delayed write and normally does not create a burden on the system. However, if your system is accessing a huge number of files on a continuing basis the buffer cache can wind up getting polluted with atime updates, creating a burden on the system. For example, if you are running a heavily loaded web site, or a news server with lots of readers, you might want to consider turning off atime updates on your larger partitions with this <a class=Xr href=mount.8.html>mount(8)</a> option. However, you should not gratuitously turn off atime updates everywhere. For example, the <span class=Pa>/var</span> file system customarily holds mailboxes, and atime (in combination with mtime) is used to determine whether a mailbox has new mail. You might as well leave atime turned on for mostly read-only partitions such as <span class=Pa>/</span> and <span class=Pa>/usr</span> as well. This is especially useful for <span class=Pa>/</span> since some system utilities use the atime field for reporting.</p></section><section class=Sh><h2 class=Sh id=STRIPING_DISKS><a class=permalink href=#STRIPING_DISKS>STRIPING DISKS</a></h2> In larger systems you can stripe partitions from several drives together to create a much larger overall partition. Striping can also improve the performance of a file system by splitting I/O operations across two or more disks. The <a class=Xr href=gstripe.8.html>gstripe(8)</a>, <a class=Xr href=gvinum.8.html>gvinum(8)</a>, and <a class=Xr href=ccdconfig.8.html>ccdconfig(8)</a> utilities may be used to create simple striped file systems. Generally speaking, striping smaller partitions such as the root and <span class=Pa>/var/tmp</span>, or essentially read-only partitions such as <span class=Pa>/usr</span> is a complete waste of time. You should only stripe partitions that require serious I/O performance, typically <span class=Pa>/var</span>, <span class=Pa>/home</span>, or custom partitions used to hold databases and web pages. Choosing the proper stripe size is also important. File systems tend to store meta-data on power-of-2 boundaries and you usually want to reduce seeking rather than increase seeking. This means you want to use a large off-center stripe size such as 1152 sectors so sequential I/O does not seek both disks and so meta-data is distributed across both disks rather than concentrated on a single disk. </section><section class=Sh><h2 class=Sh id=SYSCTL_TUNING><a class=permalink href=#SYSCTL_TUNING>SYSCTL TUNING</a></h2><a class=Xr href=sysctl.8.html>sysctl(8)</a> variables permit system behavior to be monitored and controlled at run-time. Some sysctls simply report on the behavior of the system; others allow the system behavior to be modified; some may be set at boot time using <a class=Xr href=rc.conf.5.html>rc.conf(5)</a>, but most will be set via <a class=Xr href=sysctl.conf.5.html>sysctl.conf(5)</a>. There are several hundred sysctls in the system, including many that appear to be candidates for tuning but actually are not. In this document we will only cover the ones that have the greatest effect on the system. <p class=Pp>The <var class=Va>vm.overcommit</var> sysctl defines the overcommit behaviour of the vm subsystem. The virtual memory system always does accounting of the swap space reservation, both total for system and per-user. Corresponding values are available through sysctl <var class=Va>vm.swap_total</var>, that gives the total bytes available for swapping, and <var class=Va>vm.swap_reserved</var>, that gives number of bytes that may be needed to back all currently allocated anonymous memory.</p><p class=Pp>Setting bit 0 of the <var class=Va>vm.overcommit</var> sysctl causes the virtual memory system to return failure to the process when allocation of memory causes <var class=Va>vm.swap_reserved</var> to exceed <var class=Va>vm.swap_total</var>. Bit 1 of the sysctl enforces <code class=Dv>RLIMIT_SWAP</code> limit (see <a class=Xr href=getrlimit.2.html>getrlimit(2)</a>). Root is exempt from this limit. Bit 2 allows to count most of the physical memory as allocatable, except wired and free reserved pages (accounted by <var class=Va>vm.stats.vm.v_free_target</var> and <var class=Va>vm.stats.vm.v_wire_count</var> sysctls, respectively).</p><p class=Pp>The <var class=Va>kern.ipc.maxpipekva</var> loader tunable is used to set a hard limit on the amount of kernel address space allocated to mapping of pipe buffers. Use of the mapping allows the kernel to eliminate a copy of the data from writer address space into the kernel, directly copying the content of mapped buffer to the reader. Increasing this value to a higher setting, such as `25165824' might improve performance on systems where space for mapping pipe buffers is quickly exhausted. This exhaustion is not fatal; however, and it will only cause pipes to fall back to using double-copy.</p><p class=Pp>The <var class=Va>kern.ipc.shm_use_phys</var> sysctl defaults to 0 (off) and may be set to 0 (off) or 1 (on). Setting this parameter to 1 will cause all System V shared memory segments to be mapped to unpageable physical RAM. This feature only has an effect if you are either (A) mapping small amounts of shared memory across many (hundreds) of processes, or (B) mapping large amounts of shared memory across any number of processes. This feature allows the kernel to remove a great deal of internal memory management page-tracking overhead at the cost of wiring the shared memory into core, making it unswappable.</p><p class=Pp>The <var class=Va>vfs.vmiodirenable</var> sysctl defaults to 1 (on). This parameter controls how directories are cached by the system. Most directories are small and use but a single fragment (typically 2K) in the file system and even less (typically 512 bytes) in the buffer cache. However, when operating in the default mode the buffer cache will only cache a fixed number of directories even if you have a huge amount of memory. Turning on this sysctl allows the buffer cache to use the VM Page Cache to cache the directories. The advantage is that all of memory is now available for caching directories. The disadvantage is that the minimum in-core memory used to cache a directory is the physical page size (typically 4K) rather than 512 bytes. We recommend turning this option off in memory-constrained environments; however, when on, it will substantially improve the performance of services that manipulate a large number of files. Such services can include web caches, large mail systems, and news systems. Turning on this option will generally not reduce performance even with the wasted memory but you should experiment to find out.</p><p class=Pp>The <var class=Va>vfs.write_behind</var> sysctl defaults to 1 (on). This tells the file system to issue media writes as full clusters are collected, which typically occurs when writing large sequential files. The idea is to avoid saturating the buffer cache with dirty buffers when it would not benefit I/O performance. However, this may stall processes and under certain circumstances you may wish to turn it off.</p><p class=Pp>The <var class=Va>vfs.hirunningspace</var> sysctl determines how much outstanding write I/O may be queued to disk controllers system-wide at any given time. It is used by the UFS file system. The default is self-tuned and usually sufficient but on machines with advanced controllers and lots of disks this may be tuned up to match what the controllers buffer. Configuring this setting to match tagged queuing capabilities of controllers or drives with average IO size used in production works best (for example: 16 MiB will use 128 tags with IO requests of 128 KiB). Note that setting too high a value (exceeding the buffer cache's write threshold) can lead to extremely bad clustering performance. Do not set this value arbitrarily high! Higher write queuing values may also add latency to reads occurring at the same time.</p><p class=Pp>The <var class=Va>vfs.read_max</var> sysctl governs VFS read-ahead and is expressed as the number of blocks to pre-read if the heuristics algorithm decides that the reads are issued sequentially. It is used by the UFS, ext2fs and msdosfs file systems. With the default UFS block size of 32 KiB, a setting of 64 will allow speculatively reading up to 2 MiB. This setting may be increased to get around disk I/O latencies, especially where these latencies are large such as in virtual machine emulated environments. It may be tuned down in specific cases where the I/O load is such that read-ahead adversely affects performance or where system memory is really low.</p><p class=Pp>The <var class=Va>vfs.ncsizefactor</var> sysctl defines how large VFS namecache may grow. The number of currently allocated entries in namecache is provided by <var class=Va>debug.numcache</var> sysctl and the condition debug.numcache &lt; kern.maxvnodes * vfs.ncsizefactor is adhered to.</p><p class=Pp>The <var class=Va>vfs.ncnegfactor</var> sysctl defines how many negative entries VFS namecache is allowed to create. The number of currently allocated negative entries is provided by <var class=Va>debug.numneg</var> sysctl and the condition vfs.ncnegfactor * debug.numneg &lt; debug.numcache is adhered to.</p><p class=Pp>There are various other buffer-cache and VM page cache related sysctls. We do not recommend modifying these values.</p><p class=Pp>The <var class=Va>net.inet.tcp.sendspace</var> and <var class=Va>net.inet.tcp.recvspace</var> sysctls are of particular interest if you are running network intensive applications. They control the amount of send and receive buffer space allowed for any given TCP connection. The default sending buffer is 32K; the default receiving buffer is 64K. You can often improve bandwidth utilization by increasing the default at the cost of eating up more kernel memory for each connection. We do not recommend increasing the defaults if you are serving hundreds or thousands of simultaneous connections because it is possible to quickly run the system out of memory due to stalled connections building up. But if you need high bandwidth over a fewer number of connections, especially if you have gigabit Ethernet, increasing these defaults can make a huge difference. You can adjust the buffer size for incoming and outgoing data separately. For example, if your machine is primarily doing web serving you may want to decrease the recvspace in order to be able to increase the sendspace without eating too much kernel memory. Note that the routing table (see <a class=Xr href=route.8.html>route(8)</a>) can be used to introduce route-specific send and receive buffer size defaults.</p><p class=Pp>As an additional management tool you can use pipes in your firewall rules (see <a class=Xr href=ipfw.8.html>ipfw(8)</a>) to limit the bandwidth going to or from particular IP blocks or ports. For example, if you have a T1 you might want to limit your web traffic to 70% of the T1's bandwidth in order to leave the remainder available for mail and interactive use. Normally a heavily loaded web server will not introduce significant latencies into other services even if the network link is maxed out, but enforcing a limit can smooth things out and lead to longer term stability. Many people also enforce artificial bandwidth limitations in order to ensure that they are not charged for using too much bandwidth.</p><p class=Pp>Setting the send or receive TCP buffer to values larger than 65535 will result in a marginal performance improvement unless both hosts support the window scaling extension of the TCP protocol, which is controlled by the <var class=Va>net.inet.tcp.rfc1323</var> sysctl. These extensions should be enabled and the TCP buffer size should be set to a value larger than 65536 in order to obtain good performance from certain types of network links; specifically, gigabit WAN links and high-latency satellite links. RFC1323 support is enabled by default.</p><p class=Pp>The <var class=Va>net.inet.tcp.always_keepalive</var> sysctl determines whether or not the TCP implementation should attempt to detect dead TCP connections by intermittently delivering “keepalives” on the connection. By default, this is enabled for all applications; by setting this sysctl to 0, only applications that specifically request keepalives will use them. In most environments, TCP keepalives will improve the management of system state by expiring dead TCP connections, particularly for systems serving dialup users who may not always terminate individual TCP connections before disconnecting from the network. However, in some environments, temporary network outages may be incorrectly identified as dead sessions, resulting in unexpectedly terminated TCP connections. In such environments, setting the sysctl to 0 may reduce the occurrence of TCP session disconnections.</p><p class=Pp>The <var class=Va>net.inet.tcp.delayed_ack</var> TCP feature is largely misunderstood. Historically speaking, this feature was designed to allow the acknowledgement to transmitted data to be returned along with the response. For example, when you type over a remote shell, the acknowledgement to the character you send can be returned along with the data representing the echo of the character. With delayed acks turned off, the acknowledgement may be sent in its own packet, before the remote service has a chance to echo the data it just received. This same concept also applies to any interactive protocol (e.g., SMTP, WWW, POP3), and can cut the number of tiny packets flowing across the network in half. The <span class=Ux>FreeBSD</span> delayed ACK implementation also follows the TCP protocol rule that at least every other packet be acknowledged even if the standard 40ms timeout has not yet passed. Normally the worst a delayed ACK can do is slightly delay the teardown of a connection, or slightly delay the ramp-up of a slow-start TCP connection. While we are not sure we believe that the several FAQs related to packages such as SAMBA and SQUID which advise turning off delayed acks may be referring to the slow-start issue.</p><p class=Pp>The <var class=Va>net.inet.ip.portrange.*</var> sysctls control the port number ranges automatically bound to TCP and UDP sockets. There are three ranges: a low range, a default range, and a high range, selectable via the <code class=Dv>IP_PORTRANGE</code><a class=Xr href=setsockopt.2.html>setsockopt(2)</a> call. Most network programs use the default range which is controlled by <var class=Va>net.inet.ip.portrange.first</var> and <var class=Va>net.inet.ip.portrange.last</var>, which default to 49152 and 65535, respectively. Bound port ranges are used for outgoing connections, and it is possible to run the system out of ports under certain circumstances. This most commonly occurs when you are running a heavily loaded web proxy. The port range is not an issue when running a server which handles mainly incoming connections, such as a normal web server, or has a limited number of outgoing connections, such as a mail relay. For situations where you may run out of ports, we recommend decreasing <var class=Va>net.inet.ip.portrange.first</var> modestly. A range of 10000 to 30000 ports may be reasonable. You should also consider firewall effects when changing the port range. Some firewalls may block large ranges of ports (usually low-numbered ports) and expect systems to use higher ranges of ports for outgoing connections. By default <var class=Va>net.inet.ip.portrange.last</var> is set at the maximum allowable port number.</p><p class=Pp>The <var class=Va>kern.ipc.somaxconn</var> sysctl limits the size of the listen queue for accepting new TCP connections. The default value of 128 is typically too low for robust handling of new connections in a heavily loaded web server environment. For such environments, we recommend increasing this value to 1024 or higher. The service daemon may itself limit the listen queue size (e.g., <a class=Xr href=sendmail.8.html>sendmail(8)</a>, apache) but will often have a directive in its configuration file to adjust the queue size up. Larger listen queues also do a better job of fending off denial of service attacks.</p><p class=Pp>The <var class=Va>kern.maxfiles</var> sysctl determines how many open files the system supports. The default is typically a few thousand but you may need to bump this up to ten or twenty thousand if you are running databases or large descriptor-heavy daemons. The read-only <var class=Va>kern.openfiles</var> sysctl may be interrogated to determine the current number of open files on the system.</p><p class=Pp>The <var class=Va>vm.swap_idle_enabled</var> sysctl is useful in large multi-user systems where you have lots of users entering and leaving the system and lots of idle processes. Such systems tend to generate a great deal of continuous pressure on free memory reserves. Turning this feature on and adjusting the swapout hysteresis (in idle seconds) via <var class=Va>vm.swap_idle_threshold1</var> and <var class=Va>vm.swap_idle_threshold2</var> allows you to depress the priority of pages associated with idle processes more quickly then the normal pageout algorithm. This gives a helping hand to the pageout daemon. Do not turn this option on unless you need it, because the tradeoff you are making is to essentially pre-page memory sooner rather than later, eating more swap and disk bandwidth. In a small system this option will have a detrimental effect but in a large system that is already doing moderate paging this option allows the VM system to stage whole processes into and out of memory more easily.</p></section><section class=Sh><h2 class=Sh id=LOADER_TUNABLES><a class=permalink href=#LOADER_TUNABLES>LOADER TUNABLES</a></h2> Some aspects of the system behavior may not be tunable at runtime because memory allocations they perform must occur early in the boot process. To change loader tunables, you must set their values in <a class=Xr href=loader.conf.5.html>loader.conf(5)</a> and reboot the system. <p class=Pp><var class=Va>kern.maxusers</var> controls the scaling of a number of static system tables, including defaults for the maximum number of open files, sizing of network memory resources, etc. <var class=Va>kern.maxusers</var> is automatically sized at boot based on the amount of memory available in the system, and may be determined at run-time by inspecting the value of the read-only <var class=Va>kern.maxusers</var> sysctl.</p><p class=Pp>The <var class=Va>kern.dfldsiz</var> and <var class=Va>kern.dflssiz</var> tunables set the default soft limits for process data and stack size respectively. Processes may increase these up to the hard limits by calling <a class=Xr href=setrlimit.2.html>setrlimit(2)</a>. The <var class=Va>kern.maxdsiz</var>, <var class=Va>kern.maxssiz</var>, and <var class=Va>kern.maxtsiz</var> tunables set the hard limits for process data, stack, and text size respectively; processes may not exceed these limits. The <var class=Va>kern.sgrowsiz</var> tunable controls how much the stack segment will grow when a process needs to allocate more stack.</p><p class=Pp><var class=Va>kern.ipc.nmbclusters</var> may be adjusted to increase the number of network mbufs the system is willing to allocate. Each cluster represents approximately 2K of memory, so a value of 1024 represents 2M of kernel memory reserved for network buffers. You can do a simple calculation to figure out how many you need. If you have a web server which maxes out at 1000 simultaneous connections, and each connection eats a 16K receive and 16K send buffer, you need approximately 32MB worth of network buffers to deal with it. A good rule of thumb is to multiply by 2, so 32MBx2 = 64MB/2K = 32768. So for this case you would want to set <var class=Va>kern.ipc.nmbclusters</var> to 32768. We recommend values between 1024 and 4096 for machines with moderates amount of memory, and between 4096 and 32768 for machines with greater amounts of memory. Under no circumstances should you specify an arbitrarily high value for this parameter, it could lead to a boot-time crash. The <code class=Fl>-m</code> option to <a class=Xr href=netstat.1.html>netstat(1)</a> may be used to observe network cluster use.</p><p class=Pp>More and more programs are using the <a class=Xr href=sendfile.2.html>sendfile(2)</a> system call to transmit files over the network. The <var class=Va>kern.ipc.nsfbufs</var> sysctl controls the number of file system buffers <a class=Xr href=sendfile.2.html>sendfile(2)</a> is allowed to use to perform its work. This parameter nominally scales with <var class=Va>kern.maxusers</var> so you should not need to modify this parameter except under extreme circumstances. See the <a class=Sx href=#TUNING>TUNING</a> section in the <a class=Xr href=sendfile.2.html>sendfile(2)</a> manual page for details.</p></section><section class=Sh><h2 class=Sh id=KERNEL_CONFIG_TUNING><a class=permalink href=#KERNEL_CONFIG_TUNING>KERNEL CONFIG TUNING</a></h2> There are a number of kernel options that you may have to fiddle with in a large-scale system. In order to change these options you need to be able to compile a new kernel from source. The <a class=Xr href=config.8.html>config(8)</a> manual page and the handbook are good starting points for learning how to do this. Generally the first thing you do when creating your own custom kernel is to strip out all the drivers and services you do not use. Removing things like <code class=Dv>INET6</code> and drivers you do not have will reduce the size of your kernel, sometimes by a megabyte or more, leaving more memory available for applications. <p class=Pp><code class=Dv>SCSI_DELAY</code> may be used to reduce system boot times. The defaults are fairly high and can be responsible for 5+ seconds of delay in the boot process. Reducing <code class=Dv>SCSI_DELAY</code> to something below 5 seconds could work (especially with modern drives).</p><p class=Pp>There are a number of <code class=Dv>*_CPU</code> options that can be commented out. If you only want the kernel to run on a Pentium class CPU, you can easily remove <code class=Dv>I486_CPU</code>, but only remove <code class=Dv>I586_CPU</code> if you are sure your CPU is being recognized as a Pentium II or better. Some clones may be recognized as a Pentium or even a 486 and not be able to boot without those options. If it works, great! The operating system will be able to better use higher-end CPU features for MMU, task switching, timebase, and even device operations. Additionally, higher-end CPUs support 4MB MMU pages, which the kernel uses to map the kernel itself into memory, increasing its efficiency under heavy syscall loads.</p></section><section class=Sh><h2 class=Sh id=CPU,_MEMORY,_DISK,_NETWORK><a class=permalink href=#CPU,_MEMORY,_DISK,_NETWORK>CPU, MEMORY, DISK, NETWORK</a></h2> The type of tuning you do depends heavily on where your system begins to bottleneck as load increases. If your system runs out of CPU (idle times are perpetually 0%) then you need to consider upgrading the CPU or perhaps you need to revisit the programs that are causing the load and try to optimize them. If your system is paging to swap a lot you need to consider adding more memory. If your system is saturating the disk you typically see high CPU idle times and total disk saturation. <a class=Xr href=systat.1.html>systat(1)</a> can be used to monitor this. There are many solutions to saturated disks: increasing memory for caching, mirroring disks, distributing operations across several machines, and so forth. <p class=Pp>Finally, you might run out of network suds. Optimize the network path as much as possible. For example, in <a class=Xr href=firewall.7.html>firewall(7)</a> we describe a firewall protecting internal hosts with a topology where the externally visible hosts are not routed through it. Most bottlenecks occur at the WAN link. If expanding the link is not an option it may be possible to use the <a class=Xr href=dummynet.4.html>dummynet(4)</a> feature to implement peak shaving or other forms of traffic shaping to prevent the overloaded service (such as web services) from affecting other services (such as email), or vice versa. In home installations this could be used to give interactive traffic (your browser, <a class=Xr href=ssh.1.html>ssh(1)</a> logins) priority over services you export from your box (web services, email).</p></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=netstat.1.html>netstat(1)</a>, <a class=Xr href=systat.1.html>systat(1)</a>, <a class=Xr href=sendfile.2.html>sendfile(2)</a>, <a class=Xr href=ata.4.html>ata(4)</a>, <a class=Xr href=dummynet.4.html>dummynet(4)</a>, <a class=Xr href=eventtimers.4.html>eventtimers(4)</a>, <a class=Xr href=login.conf.5.html>login.conf(5)</a>, <a class=Xr href=rc.conf.5.html>rc.conf(5)</a>, <a class=Xr href=sysctl.conf.5.html>sysctl.conf(5)</a>, <a class=Xr href=firewall.7.html>firewall(7)</a>, <a class=Xr href=hier.7.html>hier(7)</a>, <a class=Xr href=ports.7.html>ports(7)</a>, <a class=Xr href=boot.8.html>boot(8)</a>, <a class=Xr href=bsdinstall.8.html>bsdinstall(8)</a>, <a class=Xr href=ccdconfig.8.html>ccdconfig(8)</a>, <a class=Xr href=config.8.html>config(8)</a>, <a class=Xr href=fsck.8.html>fsck(8)</a>, <a class=Xr href=gjournal.8.html>gjournal(8)</a>, <a class=Xr href=gpart.8.html>gpart(8)</a>, <a class=Xr href=gstripe.8.html>gstripe(8)</a>, <a class=Xr href=gvinum.8.html>gvinum(8)</a>, <a class=Xr href=ifconfig.8.html>ifconfig(8)</a>, <a class=Xr href=ipfw.8.html>ipfw(8)</a>, <a class=Xr href=loader.8.html>loader(8)</a>, <a class=Xr href=mount.8.html>mount(8)</a>, <a class=Xr href=newfs.8.html>newfs(8)</a>, <a class=Xr href=route.8.html>route(8)</a>, <a class=Xr href=sysctl.8.html>sysctl(8)</a>, <a class=Xr href=tunefs.8.html>tunefs(8)</a></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> The <code class=Nm>tuning</code> manual page was originally written by <span class=An>Matthew Dillon</span> and first appeared in <span class=Ux>FreeBSD 4.3</span>, May 2001. The manual page was greatly modified by <span class=An>Eitan Adler</span> &lt;<a class=Mt href=mailto:eadler@FreeBSD.org>eadler@FreeBSD.org</a>&gt;. </section></div><table class=foot><tr><td class=foot-date>April 16, 2020</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>