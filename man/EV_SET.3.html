<!DOCTYPE html>
<html><head><meta charset=utf-8><title>EV_SET(3)</title><keywords content=man,EV_SET></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>EV_SET(3)</h1><table class=head><tr><td class=head-ltitle>KQUEUE(2)</td><td class=head-vol>FreeBSD System Calls Manual</td><td class=head-rtitle>KQUEUE(2)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>kqueue</code>, <code class=Nm>kevent</code> — <div class=Nd>kernel event notification mechanism</div></section><section class=Sh><h2 class=Sh id=LIBRARY><a class=permalink href=#LIBRARY>LIBRARY</a></h2><span class=Lb>Standard C Library (libc, -lc)</span></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/sys/event.h.html>sys/event.h</a>&gt;</code><p class=Pp><var class=Ft>int</var><br><code class=Fn>kqueue</code>(<var class=Fa style="white-space: nowrap;">void</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>kevent</code>(<var class=Fa style="white-space: nowrap;">int kq</var>, <var class=Fa style="white-space: nowrap;">const struct kevent *changelist</var>, <var class=Fa style="white-space: nowrap;">int nchanges</var>, <var class=Fa style="white-space: nowrap;">struct kevent *eventlist</var>, <var class=Fa style="white-space: nowrap;">int nevents</var>, <var class=Fa style="white-space: nowrap;">const struct timespec *timeout</var>);</p><p class=Pp><code class=Fn>EV_SET</code>(<var class=Fa style="white-space: nowrap;">kev</var>, <var class=Fa style="white-space: nowrap;">ident</var>, <var class=Fa style="white-space: nowrap;">filter</var>, <var class=Fa style="white-space: nowrap;">flags</var>, <var class=Fa style="white-space: nowrap;">fflags</var>, <var class=Fa style="white-space: nowrap;">data</var>, <var class=Fa style="white-space: nowrap;">udata</var>);</p></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> The <code class=Fn>kqueue</code>() system call provides a generic method of notifying the user when an event happens or a condition holds, based on the results of small pieces of kernel code termed filters. A kevent is identified by the (ident, filter) pair; there may only be one unique kevent per kqueue. <p class=Pp>The filter is executed upon the initial registration of a kevent in order to detect whether a preexisting condition is present, and is also executed whenever an event is passed to the filter for evaluation. If the filter determines that the condition should be reported, then the kevent is placed on the kqueue for the user to retrieve.</p><p class=Pp>The filter is also run when the user attempts to retrieve the kevent from the kqueue. If the filter indicates that the condition that triggered the event no longer holds, the kevent is removed from the kqueue and is not returned.</p><p class=Pp>Multiple events which trigger the filter do not result in multiple kevents being placed on the kqueue; instead, the filter will aggregate the events into a single struct kevent. Calling <code class=Fn>close</code>() on a file descriptor will remove any kevents that reference the descriptor.</p><p class=Pp>The <code class=Fn>kqueue</code>() system call creates a new kernel event queue and returns a descriptor. The queue is not inherited by a child created with <a class=Xr href=fork.2.html>fork(2)</a>. However, if <a class=Xr href=rfork.2.html>rfork(2)</a> is called without the <code class=Dv>RFFDG</code> flag, then the descriptor table is shared, which will allow sharing of the kqueue between two processes.</p><p class=Pp>The <code class=Fn>kevent</code>() system call is used to register events with the queue, and return any pending events to the user. The <var class=Fa>changelist</var> argument is a pointer to an array of <var class=Va>kevent</var> structures, as defined in <code class=In>&lt;<a class=In href=../src/sys/event.h.html>sys/event.h</a>&gt;</code>. All changes contained in the <var class=Fa>changelist</var> are applied before any pending events are read from the queue. The <var class=Fa>nchanges</var> argument gives the size of <var class=Fa>changelist</var>. The <var class=Fa>eventlist</var> argument is a pointer to an array of kevent structures. The <var class=Fa>nevents</var> argument determines the size of <var class=Fa>eventlist</var>. When <var class=Fa>nevents</var> is zero, <code class=Fn>kevent</code>() will return immediately even if there is a <var class=Fa>timeout</var> specified unlike <a class=Xr href=select.2.html>select(2)</a>. If <var class=Fa>timeout</var> is a non-NULL pointer, it specifies a maximum interval to wait for an event, which will be interpreted as a struct timespec. If <var class=Fa>timeout</var> is a NULL pointer, <code class=Fn>kevent</code>() waits indefinitely. To effect a poll, the <var class=Fa>timeout</var> argument should be non-NULL, pointing to a zero-valued <var class=Va>timespec</var> structure. The same array may be used for the <var class=Fa>changelist</var> and <var class=Fa>eventlist</var>.</p><p class=Pp>The <code class=Fn>EV_SET</code>() macro is provided for ease of initializing a kevent structure.</p><p class=Pp>The <var class=Va>kevent</var> structure is defined as:</p><div class="Bd Pp"><pre>
struct kevent {
	uintptr_t  ident;	/* identifier for this event */
	short	  filter;	/* filter for event */
	u_short	  flags;	/* action flags for kqueue */
	u_int	  fflags;	/* filter flag value */
	int64_t   data;		/* filter data value */
	void	  *udata;	/* opaque user data identifier */
	uint64_t  ext[4];	/* extensions */
};
</pre></div><p class=Pp>The fields of <var class=Fa>struct kevent</var> are:</p><dl class=Bl-tag><dt><var class=Fa>ident</var></dt><dd>Value used to identify this event. The exact interpretation is determined by the attached filter, but often is a file descriptor.</dd><dt><var class=Fa>filter</var></dt><dd>Identifies the kernel filter used to process this event. The pre-defined system filters are described below.</dd><dt><var class=Fa>flags</var></dt><dd>Actions to perform on the event.</dd><dt><var class=Fa>fflags</var></dt><dd>Filter-specific flags.</dd><dt><var class=Fa>data</var></dt><dd>Filter-specific data value.</dd><dt><var class=Fa>udata</var></dt><dd>Opaque user-defined value passed through the kernel unchanged.</dd><dt><var class=Fa>ext</var></dt><dd>Extended data passed to and from kernel. The <var class=Fa>ext[0]</var> and <var class=Fa>ext[1]</var> members use is defined by the filter. If the filter does not use them, the members are copied unchanged. The <var class=Fa>ext[2]</var> and <var class=Fa>ext[3]</var> members are always passed through the kernel as-is, making additional context available to application.</dd></dl><p class=Pp>The <var class=Va>flags</var> field can contain the following values:</p><dl class=Bl-tag><dt><a class=permalink href=#EV_ADD><code class=Dv id=EV_ADD>EV_ADD</code></a></dt><dd>Adds the event to the kqueue. Re-adding an existing event will modify the parameters of the original event, and not result in a duplicate entry. Adding an event automatically enables it, unless overridden by the EV_DISABLE flag.</dd><dt><a class=permalink href=#EV_ENABLE><code class=Dv id=EV_ENABLE>EV_ENABLE</code></a></dt><dd>Permit <code class=Fn>kevent</code>() to return the event if it is triggered.</dd><dt><a class=permalink href=#EV_DISABLE><code class=Dv id=EV_DISABLE>EV_DISABLE</code></a></dt><dd>Disable the event so <code class=Fn>kevent</code>() will not return it. The filter itself is not disabled.</dd><dt><a class=permalink href=#EV_DISPATCH><code class=Dv id=EV_DISPATCH>EV_DISPATCH</code></a></dt><dd>Disable the event source immediately after delivery of an event. See <code class=Dv>EV_DISABLE</code> above.</dd><dt><a class=permalink href=#EV_DELETE><code class=Dv id=EV_DELETE>EV_DELETE</code></a></dt><dd>Removes the event from the kqueue. Events which are attached to file descriptors are automatically deleted on the last close of the descriptor.</dd><dt><a class=permalink href=#EV_RECEIPT><code class=Dv id=EV_RECEIPT>EV_RECEIPT</code></a></dt><dd>This flag is useful for making bulk changes to a kqueue without draining any pending events. When passed as input, it forces <code class=Dv>EV_ERROR</code> to always be returned. When a filter is successfully added the <var class=Va>data</var> field will be zero. Note that if this flag is encountered and there is no remaining space in <var class=Fa>eventlist</var> to hold the <code class=Dv>EV_ERROR</code> event, then subsequent changes will not get processed.</dd><dt><a class=permalink href=#EV_ONESHOT><code class=Dv id=EV_ONESHOT>EV_ONESHOT</code></a></dt><dd>Causes the event to return only the first occurrence of the filter being triggered. After the user retrieves the event from the kqueue, it is deleted.</dd><dt><a class=permalink href=#EV_CLEAR><code class=Dv id=EV_CLEAR>EV_CLEAR</code></a></dt><dd>After the event is retrieved by the user, its state is reset. This is useful for filters which report state transitions instead of the current state. Note that some filters may automatically set this flag internally.</dd><dt><a class=permalink href=#EV_EOF><code class=Dv id=EV_EOF>EV_EOF</code></a></dt><dd>Filters may set this flag to indicate filter-specific EOF condition.</dd><dt><a class=permalink href=#EV_ERROR><code class=Dv id=EV_ERROR>EV_ERROR</code></a></dt><dd>See <a class=Sx href=#RETURN_VALUES>RETURN VALUES</a> below.</dd></dl><p class=Pp>The predefined system filters are listed below. Arguments may be passed to and from the filter via the <var class=Va>fflags</var> and <var class=Va>data</var> fields in the kevent structure.</p><dl class=Bl-tag><dt><a class=permalink href=#EVFILT_READ><code class=Dv id=EVFILT_READ>EVFILT_READ</code></a></dt><dd>Takes a descriptor as the identifier, and returns whenever there is data available to read. The behavior of the filter is slightly different depending on the descriptor type. <dl class=Bl-tag><dt>Sockets</dt><dd>Sockets which have previously been passed to <code class=Fn>listen</code>() return when there is an incoming connection pending. <var class=Va>data</var> contains the size of the listen backlog. <p class=Pp>Other socket descriptors return when there is data to be read, subject to the <code class=Dv>SO_RCVLOWAT</code> value of the socket buffer. This may be overridden with a per-filter low water mark at the time the filter is added by setting the <code class=Dv>NOTE_LOWAT</code> flag in <var class=Va>fflags</var>, and specifying the new low water mark in <var class=Va>data</var>. On return, <var class=Va>data</var> contains the number of bytes of protocol data available to read.</p><p class=Pp>If the read direction of the socket has shutdown, then the filter also sets <code class=Dv>EV_EOF</code> in <var class=Va>flags</var>, and returns the socket error (if any) in <var class=Va>fflags</var>. It is possible for EOF to be returned (indicating the connection is gone) while there is still data pending in the socket buffer.</p></dd><dt>Vnodes</dt><dd>Returns when the file pointer is not at the end of file. <var class=Va>data</var> contains the offset from current position to end of file, and may be negative. <p class=Pp>This behavior is different from <a class=Xr href=poll.2.html>poll(2)</a>, where read events are triggered for regular files unconditionally. This event can be triggered unconditionally by setting the <code class=Dv>NOTE_FILE_POLL</code> flag in <var class=Va>fflags</var>.</p></dd><dt>Fifos, Pipes</dt><dd>Returns when the there is data to read; <var class=Va>data</var> contains the number of bytes available. <p class=Pp>When the last writer disconnects, the filter will set <code class=Dv>EV_EOF</code> in <var class=Va>flags</var>. This will be cleared by the filter when a new writer connects, at which point the filter will resume waiting for data to become available before returning.</p></dd><dt>BPF devices</dt><dd>Returns when the BPF buffer is full, the BPF timeout has expired, or when the BPF has “immediate mode” enabled and there is any data to read; <var class=Va>data</var> contains the number of bytes available.</dd></dl></dd><dt><a class=permalink href=#EVFILT_WRITE><code class=Dv id=EVFILT_WRITE>EVFILT_WRITE</code></a></dt><dd>Takes a descriptor as the identifier, and returns whenever it is possible to write to the descriptor. For sockets, pipes and fifos, <var class=Va>data</var> will contain the amount of space remaining in the write buffer. The filter will set <code class=Dv>EV_EOF</code> when the reader disconnects, and for the fifo case, this will be cleared when a new reader connects. Note that this filter is not supported for vnodes or BPF devices. <p class=Pp>For sockets, the low water mark and socket error handling is identical to the <code class=Dv>EVFILT_READ</code> case.</p></dd><dt><a class=permalink href=#EVFILT_EMPTY><code class=Dv id=EVFILT_EMPTY>EVFILT_EMPTY</code></a></dt><dd>Takes a descriptor as the identifier, and returns whenever there is no remaining data in the write buffer.</dd><dt><a class=permalink href=#EVFILT_AIO><code class=Dv id=EVFILT_AIO>EVFILT_AIO</code></a></dt><dd>Events for this filter are not registered with <code class=Fn>kevent</code>() directly but are registered via the <var class=Va>aio_sigevent</var> member of an asynchronous I/O request when it is scheduled via an asynchronous I/O system call such as <code class=Fn>aio_read</code>(). The filter returns under the same conditions as <code class=Fn>aio_error</code>(). For more details on this filter see <a class=Xr href=sigevent.3.html>sigevent(3)</a> and <a class=Xr href=aio.4.html>aio(4)</a>.</dd><dt><a class=permalink href=#EVFILT_VNODE><code class=Dv id=EVFILT_VNODE>EVFILT_VNODE</code></a></dt><dd>Takes a file descriptor as the identifier and the events to watch for in <var class=Va>fflags</var>, and returns when one or more of the requested events occurs on the descriptor. The events to monitor are: <dl class=Bl-tag><dt><a class=permalink href=#NOTE_ATTRIB><code class=Dv id=NOTE_ATTRIB>NOTE_ATTRIB</code></a></dt><dd>The file referenced by the descriptor had its attributes changed.</dd><dt><a class=permalink href=#NOTE_CLOSE><code class=Dv id=NOTE_CLOSE>NOTE_CLOSE</code></a></dt><dd>A file descriptor referencing the monitored file, was closed. The closed file descriptor did not have write access.</dd><dt><a class=permalink href=#NOTE_CLOSE_WRITE><code class=Dv id=NOTE_CLOSE_WRITE>NOTE_CLOSE_WRITE</code></a></dt><dd>A file descriptor referencing the monitored file, was closed. The closed file descriptor had write access. <p class=Pp>This note, as well as <code class=Dv>NOTE_CLOSE</code>, are not activated when files are closed forcibly by <a class=Xr href=unmount.2.html>unmount(2)</a> or <a class=Xr href=revoke.2.html>revoke(2)</a>. Instead, <code class=Dv>NOTE_REVOKE</code> is sent for such events.</p></dd><dt><a class=permalink href=#NOTE_DELETE><code class=Dv id=NOTE_DELETE>NOTE_DELETE</code></a></dt><dd>The <code class=Fn>unlink</code>() system call was called on the file referenced by the descriptor.</dd><dt><a class=permalink href=#NOTE_EXTEND><code class=Dv id=NOTE_EXTEND>NOTE_EXTEND</code></a></dt><dd>For regular file, the file referenced by the descriptor was extended. <p class=Pp>For directory, reports that a directory entry was added or removed, as the result of rename operation. The <code class=Dv>NOTE_EXTEND</code> event is not reported when a name is changed inside the directory.</p></dd><dt><a class=permalink href=#NOTE_LINK><code class=Dv id=NOTE_LINK>NOTE_LINK</code></a></dt><dd>The link count on the file changed. In particular, the <code class=Dv>NOTE_LINK</code> event is reported if a subdirectory was created or deleted inside the directory referenced by the descriptor.</dd><dt><a class=permalink href=#NOTE_OPEN><code class=Dv id=NOTE_OPEN>NOTE_OPEN</code></a></dt><dd>The file referenced by the descriptor was opened.</dd><dt><a class=permalink href=#NOTE_READ><code class=Dv id=NOTE_READ>NOTE_READ</code></a></dt><dd>A read occurred on the file referenced by the descriptor.</dd><dt><a class=permalink href=#NOTE_RENAME><code class=Dv id=NOTE_RENAME>NOTE_RENAME</code></a></dt><dd>The file referenced by the descriptor was renamed.</dd><dt><a class=permalink href=#NOTE_REVOKE><code class=Dv id=NOTE_REVOKE>NOTE_REVOKE</code></a></dt><dd>Access to the file was revoked via <a class=Xr href=revoke.2.html>revoke(2)</a> or the underlying file system was unmounted.</dd><dt><a class=permalink href=#NOTE_WRITE><code class=Dv id=NOTE_WRITE>NOTE_WRITE</code></a></dt><dd>A write occurred on the file referenced by the descriptor.</dd></dl><p class=Pp>On return, <var class=Va>fflags</var> contains the events which triggered the filter.</p></dd><dt><a class=permalink href=#EVFILT_PROC><code class=Dv id=EVFILT_PROC>EVFILT_PROC</code></a></dt><dd>Takes the process ID to monitor as the identifier and the events to watch for in <var class=Va>fflags</var>, and returns when the process performs one or more of the requested events. If a process can normally see another process, it can attach an event to it. The events to monitor are: <dl class=Bl-tag><dt><a class=permalink href=#NOTE_EXIT><code class=Dv id=NOTE_EXIT>NOTE_EXIT</code></a></dt><dd>The process has exited. The exit status will be stored in <var class=Va>data</var>.</dd><dt><a class=permalink href=#NOTE_FORK><code class=Dv id=NOTE_FORK>NOTE_FORK</code></a></dt><dd>The process has called <code class=Fn>fork</code>().</dd><dt><a class=permalink href=#NOTE_EXEC><code class=Dv id=NOTE_EXEC>NOTE_EXEC</code></a></dt><dd>The process has executed a new process via <a class=Xr href=execve.2.html>execve(2)</a> or a similar call.</dd><dt><a class=permalink href=#NOTE_TRACK><code class=Dv id=NOTE_TRACK>NOTE_TRACK</code></a></dt><dd>Follow a process across <code class=Fn>fork</code>() calls. The parent process registers a new kevent to monitor the child process using the same <var class=Va>fflags</var> as the original event. The child process will signal an event with <code class=Dv>NOTE_CHILD</code> set in <var class=Va>fflags</var> and the parent PID in <var class=Va>data</var>. <p class=Pp>If the parent process fails to register a new kevent (usually due to resource limitations), it will signal an event with <code class=Dv>NOTE_TRACKERR</code> set in <var class=Va>fflags</var>, and the child process will not signal a <code class=Dv>NOTE_CHILD</code> event.</p></dd></dl><p class=Pp>On return, <var class=Va>fflags</var> contains the events which triggered the filter.</p></dd><dt><a class=permalink href=#EVFILT_PROCDESC><code class=Dv id=EVFILT_PROCDESC>EVFILT_PROCDESC</code></a></dt><dd>Takes the process descriptor created by <a class=Xr href=pdfork.2.html>pdfork(2)</a> to monitor as the identifier and the events to watch for in <var class=Va>fflags</var>, and returns when the associated process performs one or more of the requested events. The events to monitor are: <dl class=Bl-tag><dt><a class=permalink href=#NOTE_EXIT_2><code class=Dv id=NOTE_EXIT_2>NOTE_EXIT</code></a></dt><dd>The process has exited. The exit status will be stored in <var class=Va>data</var>.</dd></dl><p class=Pp>On return, <var class=Va>fflags</var> contains the events which triggered the filter.</p></dd><dt><a class=permalink href=#EVFILT_SIGNAL><code class=Dv id=EVFILT_SIGNAL>EVFILT_SIGNAL</code></a></dt><dd>Takes the signal number to monitor as the identifier and returns when the given signal is delivered to the process. This coexists with the <code class=Fn>signal</code>() and <code class=Fn>sigaction</code>() facilities, and has a lower precedence. The filter will record all attempts to deliver a signal to a process, even if the signal has been marked as <code class=Dv>SIG_IGN</code>, except for the <code class=Dv>SIGCHLD</code> signal, which, if ignored, will not be recorded by the filter. Event notification happens after normal signal delivery processing. <var class=Va>data</var> returns the number of times the signal has occurred since the last call to <code class=Fn>kevent</code>(). This filter automatically sets the <code class=Dv>EV_CLEAR</code> flag internally.</dd><dt><a class=permalink href=#EVFILT_TIMER><code class=Dv id=EVFILT_TIMER>EVFILT_TIMER</code></a></dt><dd>Establishes an arbitrary timer identified by <var class=Va>ident</var>. When adding a timer, <var class=Va>data</var> specifies the moment to fire the timer (for <code class=Dv>NOTE_ABSTIME</code>) or the timeout period. The timer will be periodic unless <code class=Dv>EV_ONESHOT</code> or <code class=Dv>NOTE_ABSTIME</code> is specified. On return, <var class=Va>data</var> contains the number of times the timeout has expired since the last call to <code class=Fn>kevent</code>(). For non-monotonic timers, this filter automatically sets the <code class=Dv>EV_CLEAR</code> flag internally. <p class=Pp>The filter accepts the following flags in the <var class=Va>fflags</var> argument:</p><dl class=Bl-tag><dt><a class=permalink href=#NOTE_SECONDS><code class=Dv id=NOTE_SECONDS>NOTE_SECONDS</code></a></dt><dd><var class=Va>data</var> is in seconds.</dd><dt><a class=permalink href=#NOTE_MSECONDS><code class=Dv id=NOTE_MSECONDS>NOTE_MSECONDS</code></a></dt><dd><var class=Va>data</var> is in milliseconds.</dd><dt><a class=permalink href=#NOTE_USECONDS><code class=Dv id=NOTE_USECONDS>NOTE_USECONDS</code></a></dt><dd><var class=Va>data</var> is in microseconds.</dd><dt><a class=permalink href=#NOTE_NSECONDS><code class=Dv id=NOTE_NSECONDS>NOTE_NSECONDS</code></a></dt><dd><var class=Va>data</var> is in nanoseconds.</dd><dt><a class=permalink href=#NOTE_ABSTIME><code class=Dv id=NOTE_ABSTIME>NOTE_ABSTIME</code></a></dt><dd>The specified expiration time is absolute.</dd></dl><p class=Pp>If <var class=Va>fflags</var> is not set, the default is milliseconds. On return, <var class=Va>fflags</var> contains the events which triggered the filter.</p><p class=Pp>If an existing timer is re-added, the existing timer will be effectively canceled (throwing away any undelivered record of previous timer expiration) and re-started using the new parameters contained in <var class=Va>data</var> and <var class=Va>fflags</var>.</p><p class=Pp>There is a system wide limit on the number of timers which is controlled by the <var class=Va>kern.kq_calloutmax</var> sysctl.</p></dd><dt><a class=permalink href=#EVFILT_USER><code class=Dv id=EVFILT_USER>EVFILT_USER</code></a></dt><dd>Establishes a user event identified by <var class=Va>ident</var> which is not associated with any kernel mechanism but is triggered by user level code. The lower 24 bits of the <var class=Va>fflags</var> may be used for user defined flags and manipulated using the following: <dl class=Bl-tag><dt><a class=permalink href=#NOTE_FFNOP><code class=Dv id=NOTE_FFNOP>NOTE_FFNOP</code></a></dt><dd>Ignore the input <var class=Va>fflags</var>.</dd><dt><a class=permalink href=#NOTE_FFAND><code class=Dv id=NOTE_FFAND>NOTE_FFAND</code></a></dt><dd>Bitwise AND <var class=Va>fflags</var>.</dd><dt><a class=permalink href=#NOTE_FFOR><code class=Dv id=NOTE_FFOR>NOTE_FFOR</code></a></dt><dd>Bitwise OR <var class=Va>fflags</var>.</dd><dt><a class=permalink href=#NOTE_FFCOPY><code class=Dv id=NOTE_FFCOPY>NOTE_FFCOPY</code></a></dt><dd>Copy <var class=Va>fflags</var>.</dd><dt><a class=permalink href=#NOTE_FFCTRLMASK><code class=Dv id=NOTE_FFCTRLMASK>NOTE_FFCTRLMASK</code></a></dt><dd>Control mask for <var class=Va>fflags</var>.</dd><dt><a class=permalink href=#NOTE_FFLAGSMASK><code class=Dv id=NOTE_FFLAGSMASK>NOTE_FFLAGSMASK</code></a></dt><dd>User defined flag mask for <var class=Va>fflags</var>.</dd></dl><p class=Pp>A user event is triggered for output with the following:</p><dl class=Bl-tag><dt><a class=permalink href=#NOTE_TRIGGER><code class=Dv id=NOTE_TRIGGER>NOTE_TRIGGER</code></a></dt><dd>Cause the event to be triggered.</dd></dl><p class=Pp>On return, <var class=Va>fflags</var> contains the users defined flags in the lower 24 bits.</p></dd></dl></section><section class=Sh><h2 class=Sh id=CANCELLATION_BEHAVIOUR><a class=permalink href=#CANCELLATION_BEHAVIOUR>CANCELLATION BEHAVIOUR</a></h2> If <var class=Fa>nevents</var> is non-zero, i.e., the function is potentially blocking, the call is a cancellation point. Otherwise, i.e., if <var class=Fa>nevents</var> is zero, the call is not cancellable. Cancellation can only occur before any changes are made to the kqueue, or when the call was blocked and no changes to the queue were requested. </section><section class=Sh><h2 class=Sh id=RETURN_VALUES><a class=permalink href=#RETURN_VALUES>RETURN VALUES</a></h2> The <code class=Fn>kqueue</code>() system call creates a new kernel event queue and returns a file descriptor. If there was an error creating the kernel event queue, a value of -1 is returned and errno set. <p class=Pp>The <code class=Fn>kevent</code>() system call returns the number of events placed in the <var class=Fa>eventlist</var>, up to the value given by <var class=Fa>nevents</var>. If an error occurs while processing an element of the <var class=Fa>changelist</var> and there is enough room in the <var class=Fa>eventlist</var>, then the event will be placed in the <var class=Fa>eventlist</var> with <code class=Dv>EV_ERROR</code> set in <var class=Va>flags</var> and the system error in <var class=Va>data</var>. Otherwise, <code class=Dv>-1</code> will be returned, and <code class=Dv>errno</code> will be set to indicate the error condition. If the time limit expires, then <code class=Fn>kevent</code>() returns 0.</p></section><section class=Sh><h2 class=Sh id=EXAMPLES><a class=permalink href=#EXAMPLES>EXAMPLES</a></h2><div class=Bd><pre>
#include &lt;sys/event.h&gt;
#include &lt;err.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int
main(int argc, char **argv)
{
    struct kevent event;    /* Event we want to monitor */
    struct kevent tevent;   /* Event triggered */
    int kq, fd, ret;

    if (argc != 2)
	err(EXIT_FAILURE, "Usage: %s path\n", argv[0]);
    fd = open(argv[1], O_RDONLY);
    if (fd == -1)
	err(EXIT_FAILURE, "Failed to open '%s'", argv[1]);

    /* Create kqueue. */
    kq = kqueue();
    if (kq == -1)
	err(EXIT_FAILURE, "kqueue() failed");

    /* Initialize kevent structure. */
    EV_SET(&amp;event, fd, EVFILT_VNODE, EV_ADD | EV_CLEAR, NOTE_WRITE,
	0, NULL);
    /* Attach event to the kqueue. */
    ret = kevent(kq, &amp;event, 1, NULL, 0, NULL);
    if (ret == -1)
	err(EXIT_FAILURE, "kevent register");
    if (event.flags &amp; EV_ERROR)
	errx(EXIT_FAILURE, "Event error: %s", strerror(event.data));

    for (;;) {
	/* Sleep until something happens. */
	ret = kevent(kq, NULL, 0, &amp;tevent, 1, NULL);
	if (ret == -1) {
	    err(EXIT_FAILURE, "kevent wait");
	} else if (ret &gt; 0) {
	    printf("Something was written in '%s'\n", argv[1]);
	}
    }
}
</pre></div></section><section class=Sh><h2 class=Sh id=ERRORS><a class=permalink href=#ERRORS>ERRORS</a></h2> The <code class=Fn>kqueue</code>() system call fails if: <dl class=Bl-tag><dt>[<a class=permalink href=#ENOMEM><code class=Er id=ENOMEM>ENOMEM</code></a>]</dt><dd>The kernel failed to allocate enough memory for the kernel queue.</dd><dt>[<a class=permalink href=#ENOMEM_2><code class=Er id=ENOMEM_2>ENOMEM</code></a>]</dt><dd>The <code class=Dv>RLIMIT_KQUEUES</code> rlimit (see <a class=Xr href=getrlimit.2.html>getrlimit(2)</a>) for the current user would be exceeded.</dd><dt>[<a class=permalink href=#EMFILE><code class=Er id=EMFILE>EMFILE</code></a>]</dt><dd>The per-process descriptor table is full.</dd><dt>[<a class=permalink href=#ENFILE><code class=Er id=ENFILE>ENFILE</code></a>]</dt><dd>The system file table is full.</dd></dl><p class=Pp>The <code class=Fn>kevent</code>() system call fails if:</p><dl class=Bl-tag><dt>[<a class=permalink href=#EACCES><code class=Er id=EACCES>EACCES</code></a>]</dt><dd>The process does not have permission to register a filter.</dd><dt>[<a class=permalink href=#EFAULT><code class=Er id=EFAULT>EFAULT</code></a>]</dt><dd>There was an error reading or writing the <var class=Va>kevent</var> structure.</dd><dt>[<a class=permalink href=#EBADF><code class=Er id=EBADF>EBADF</code></a>]</dt><dd>The specified descriptor is invalid.</dd><dt>[<a class=permalink href=#EINTR><code class=Er id=EINTR>EINTR</code></a>]</dt><dd>A signal was delivered before the timeout expired and before any events were placed on the kqueue for return.</dd><dt>[<a class=permalink href=#EINTR_2><code class=Er id=EINTR_2>EINTR</code></a>]</dt><dd>A cancellation request was delivered to the thread, but not yet handled.</dd><dt>[<a class=permalink href=#EINVAL><code class=Er id=EINVAL>EINVAL</code></a>]</dt><dd>The specified time limit or filter is invalid.</dd><dt>[<a class=permalink href=#ENOENT><code class=Er id=ENOENT>ENOENT</code></a>]</dt><dd>The event could not be found to be modified or deleted.</dd><dt>[<a class=permalink href=#ENOMEM_3><code class=Er id=ENOMEM_3>ENOMEM</code></a>]</dt><dd>No memory was available to register the event or, in the special case of a timer, the maximum number of timers has been exceeded. This maximum is configurable via the <var class=Va>kern.kq_calloutmax</var> sysctl.</dd><dt>[<a class=permalink href=#ESRCH><code class=Er id=ESRCH>ESRCH</code></a>]</dt><dd>The specified process to attach to does not exist.</dd></dl><p class=Pp>When <code class=Fn>kevent</code>() call fails with <code class=Er>EINTR</code> error, all changes in the <var class=Fa>changelist</var> have been applied.</p></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=aio_error.2.html>aio_error(2)</a>, <a class=Xr href=aio_read.2.html>aio_read(2)</a>, <a class=Xr href=aio_return.2.html>aio_return(2)</a>, <a class=Xr href=poll.2.html>poll(2)</a>, <a class=Xr href=read.2.html>read(2)</a>, <a class=Xr href=select.2.html>select(2)</a>, <a class=Xr href=sigaction.2.html>sigaction(2)</a>, <a class=Xr href=write.2.html>write(2)</a>, <a class=Xr href=pthread_setcancelstate.3.html>pthread_setcancelstate(3)</a>, <a class=Xr href=signal.3.html>signal(3)</a><p class=Pp><cite class=Rs><span class=RsA>Jonathan Lemon</span>, <span class=RsT>Kqueue: A Generic and Scalable Event Notification Facility</span>, <i class=RsB>Proceedings of the FREENIX Track: 2001 USENIX Annual Technical Conference</i>, <i class=RsI>USENIX Association</i>, <span class=RsD>June 25-30, 2001</span>.</cite></p></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> The <code class=Fn>kqueue</code>() and <code class=Fn>kevent</code>() system calls first appeared in <span class=Ux>FreeBSD 4.1</span>. </section><section class=Sh><h2 class=Sh id=AUTHORS><a class=permalink href=#AUTHORS>AUTHORS</a></h2> The <code class=Fn>kqueue</code>() system and this manual page were written by <span class=An>Jonathan Lemon</span> &lt;<a class=Mt href=mailto:jlemon@FreeBSD.org>jlemon@FreeBSD.org</a>&gt;. </section><section class=Sh><h2 class=Sh id=BUGS><a class=permalink href=#BUGS>BUGS</a></h2> The <var class=Fa>timeout</var> value is limited to 24 hours; longer timeouts will be silently reinterpreted as 24 hours. <p class=Pp>In versions older than <span class=Ux>FreeBSD 12.0</span>, <code class=In>&lt;<a class=In href=../src/sys/event.h.html>sys/event.h</a>&gt;</code> failed to parse without including <code class=In>&lt;<a class=In href=../src/sys/types.h.html>sys/types.h</a>&gt;</code> manually.</p></section></div><table class=foot><tr><td class=foot-date>May 1, 2020</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>