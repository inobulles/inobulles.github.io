<!DOCTYPE html>
<html><head><meta charset=utf-8><title>microseq(9)</title><keywords content=man,microseq></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>microseq(9)</h1><table class=head><tr><td class=head-ltitle>MICROSEQ(9)</td><td class=head-vol>FreeBSD Kernel Developer's Manual</td><td class=head-rtitle>MICROSEQ(9)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>microseq</code> — <div class=Nd>ppbus microsequencer developer's guide</div></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/sys/types.h.html>sys/types.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/dev/ppbus/ppbconf.h.html>dev/ppbus/ppbconf.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/dev/ppbus/ppb_msq.h.html>dev/ppbus/ppb_msq.h</a>&gt;</code></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> See <a class=Xr href=ppbus.4.html>ppbus(4)</a> for ppbus description and general info about the microsequencer. <p class=Pp>The purpose of this document is to encourage developers to use the microsequencer mechanism in order to have:</p><ol class="Bl-enum Bd-indent"><li>a uniform programming model</li><li>efficient code</li></ol><p class=Pp>Before using microsequences, you are encouraged to look at <a class=Xr href=ppc.4.html>ppc(4)</a> microsequencer implementation and an example of how using it in <a class=Xr href=ppi.4.html>ppi(4)</a>.</p></section><section class=Sh><h2 class=Sh id=PPBUS_register_model><a class=permalink href=#PPBUS_register_model>PPBUS register model</a></h2><section class=Ss><h2 class=Ss id=Background><a class=permalink href=#Background>Background</a></h2> The parallel port model chosen for ppbus is the PC parallel port model. Thus, any register described later has the same semantic than its counterpart in a PC parallel port. For more info about ISA/ECP programming, get the Microsoft standard referenced as "Extended Capabilities Port Protocol and ISA interface Standard". Registers described later are standard parallel port registers. <p class=Pp>Mask macros are defined in the standard ppbus include files for each valid bit of parallel port registers.</p></section><section class=Ss><h2 class=Ss id=Data_register><a class=permalink href=#Data_register>Data register</a></h2> In compatible or nibble mode, writing to this register will drive data to the parallel port data lines. In any other mode, drivers may be tri-stated by setting the direction bit (PCD) in the control register. Reads to this register return the value on the data lines. </section><section class=Ss><h2 class=Ss id=Device_status_register><a class=permalink href=#Device_status_register>Device status register</a></h2> This read-only register reflects the inputs on the parallel port interface. <p class=Pp></p><table class="Bl-column Bl-compact"><tr><td><i class=Em>Bit</i></td><td><i class=Em>Name</i></td><td><i class=Em>Description</i></td></tr><tr><td>7</td><td>nBUSY</td><td>inverted version of parallel port Busy signal</td></tr><tr><td>6</td><td>nACK</td><td>version of parallel port nAck signal</td></tr><tr><td>5</td><td>PERROR</td><td>version of parallel port PERROR signal</td></tr><tr><td>4</td><td>SELECT</td><td>version of parallel port Select signal</td></tr><tr><td>3</td><td>nFAULT</td><td>version of parallel port nFault signal</td></tr></table><p class=Pp>Others are reserved and return undefined result when read.</p></section><section class=Ss><h2 class=Ss id=Device_control_register><a class=permalink href=#Device_control_register>Device control register</a></h2> This register directly controls several output signals as well as enabling some functions. <p class=Pp></p><table class="Bl-column Bl-compact"><tr><td><i class=Em>Bit</i></td><td><i class=Em>Name</i></td><td><i class=Em>Description</i></td></tr><tr><td>5</td><td>PCD</td><td>direction bit in extended modes</td></tr><tr><td>4</td><td>IRQENABLE</td><td>1 enables an interrupt on the rising edge of nAck</td></tr><tr><td>3</td><td>SELECTIN</td><td>inverted and driven as parallel port nSelectin signal</td></tr><tr><td>2</td><td>nINIT</td><td>driven as parallel port nInit signal</td></tr><tr><td>1</td><td>AUTOFEED</td><td>inverted and driven as parallel port nAutoFd signal</td></tr><tr><td>0</td><td>STROBE</td><td>inverted and driven as parallel port nStrobe signal</td></tr></table></section></section><section class=Sh><h2 class=Sh id=MICROINSTRUCTIONS><a class=permalink href=#MICROINSTRUCTIONS>MICROINSTRUCTIONS</a></h2><section class=Ss><h2 class=Ss id=Description><a class=permalink href=#Description>Description</a></h2><i class=Em>Microinstructions</i> are either parallel port accesses, program iterations, submicrosequence or C calls. The parallel port must be considered as the logical model described in <a class=Xr href=ppbus.4.html>ppbus(4)</a>. <p class=Pp>Available microinstructions are:</p><div class="Bd Pp"><pre>
#define MS_OP_GET       0	/* get &lt;ptr&gt;, &lt;len&gt;			*/
#define MS_OP_PUT       1	/* put &lt;ptr&gt;, &lt;len&gt;			*/
#define MS_OP_RFETCH	2	/* rfetch &lt;reg&gt;, &lt;mask&gt;, &lt;ptr&gt;		*/
#define MS_OP_RSET	3	/* rset &lt;reg&gt;, &lt;mask&gt;, &lt;mask&gt;		*/
#define MS_OP_RASSERT	4	/* rassert &lt;reg&gt;, &lt;mask&gt;		*/
#define MS_OP_DELAY     5	/* delay &lt;val&gt;				*/
#define MS_OP_SET       6	/* set &lt;val&gt;				*/
#define MS_OP_DBRA      7	/* dbra &lt;offset&gt;			*/
#define MS_OP_BRSET     8	/* brset &lt;mask&gt;, &lt;offset&gt;		*/
#define MS_OP_BRCLEAR   9	/* brclear &lt;mask&gt;, &lt;offset&gt;		*/
#define MS_OP_RET       10	/* ret &lt;retcode&gt;			*/
#define MS_OP_C_CALL	11	/* c_call &lt;function&gt;, &lt;parameter&gt;	*/
#define MS_OP_PTR	12	/* ptr &lt;pointer&gt;			*/
#define MS_OP_ADELAY	13	/* adelay &lt;val&gt;				*/
#define MS_OP_BRSTAT	14	/* brstat &lt;mask&gt;, &lt;mask&gt;, &lt;offset&gt;	*/
#define MS_OP_SUBRET	15	/* subret &lt;code&gt;			*/
#define MS_OP_CALL	16	/* call &lt;microsequence&gt;			*/
#define MS_OP_RASSERT_P	17	/* rassert_p &lt;iter&gt;, &lt;reg&gt;		*/
#define MS_OP_RFETCH_P	18	/* rfetch_p &lt;iter&gt;, &lt;reg&gt;, &lt;mask&gt;	*/
#define MS_OP_TRIG	19	/* trigger &lt;reg&gt;, &lt;len&gt;, &lt;array&gt;	*/
</pre></div></section><section class=Ss><h2 class=Ss id=Execution_context><a class=permalink href=#Execution_context>Execution context</a></h2> The <i class=Em>execution context</i> of microinstructions is: <ul class="Bl-bullet Bd-indent"><li>the <i class=Em>program counter</i> which points to the next microinstruction to execute either in the main microsequence or in a subcall</li><li>the current value of <i class=Em>ptr</i> which points to the next char to send/receive</li><li>the current value of the internal <i class=Em>branch register</i></li></ul><p class=Pp>This data is modified by some of the microinstructions, not all.</p></section><section class=Ss><h2 class=Ss id=MS_OP_GET_and_MS_OP_PUT><a class=permalink href=#MS_OP_GET_and_MS_OP_PUT>MS_OP_GET and MS_OP_PUT</a></h2> are microinstructions used to do either predefined standard IEEE1284-1994 transfers or programmed non-standard io. </section><section class=Ss><h2 class=Ss id=MS_OP_RFETCH_-_Register_FETCH><a class=permalink href=#MS_OP_RFETCH_-_Register_FETCH>MS_OP_RFETCH - Register FETCH</a></h2> is used to retrieve the current value of a parallel port register, apply a mask and save it in a buffer. <p class=Pp>Parameters:</p><ol class="Bl-enum Bd-indent"><li>register</li><li>character mask</li><li>pointer to the buffer</li></ol><p class=Pp>Predefined macro: MS_RFETCH(reg,mask,ptr)</p></section><section class=Ss><h2 class=Ss id=MS_OP_RSET_-_Register_SET><a class=permalink href=#MS_OP_RSET_-_Register_SET>MS_OP_RSET - Register SET</a></h2> is used to assert/clear some bits of a particular parallel port register, two masks are applied. <p class=Pp>Parameters:</p><ol class="Bl-enum Bd-indent"><li>register</li><li>mask of bits to assert</li><li>mask of bits to clear</li></ol><p class=Pp>Predefined macro: MS_RSET(reg,assert,clear)</p></section><section class=Ss><h2 class=Ss id=MS_OP_RASSERT_-_Register_ASSERT><a class=permalink href=#MS_OP_RASSERT_-_Register_ASSERT>MS_OP_RASSERT - Register ASSERT</a></h2> is used to assert all bits of a particular parallel port register. <p class=Pp>Parameters:</p><ol class="Bl-enum Bd-indent"><li>register</li><li>byte to assert</li></ol><p class=Pp>Predefined macro: MS_RASSERT(reg,byte)</p></section><section class=Ss><h2 class=Ss id=MS_OP_DELAY_-_microsecond_DELAY><a class=permalink href=#MS_OP_DELAY_-_microsecond_DELAY>MS_OP_DELAY - microsecond DELAY</a></h2> is used to delay the execution of the microsequence. <p class=Pp>Parameter:</p><ol class="Bl-enum Bd-indent"><li>delay in microseconds</li></ol><p class=Pp>Predefined macro: MS_DELAY(delay)</p></section><section class=Ss><h2 class=Ss id=MS_OP_SET_-_SET_internal_branch_register><a class=permalink href=#MS_OP_SET_-_SET_internal_branch_register>MS_OP_SET - SET internal branch register</a></h2> is used to set the value of the internal branch register. <p class=Pp>Parameter:</p><ol class="Bl-enum Bd-indent"><li>integer value</li></ol><p class=Pp>Predefined macro: MS_SET(accum)</p></section><section class=Ss><h2 class=Ss id=MS_OP_DBRA_-__&Do_BRAnch><a class=permalink href=#MS_OP_DBRA_-__&Do_BRAnch>MS_OP_DBRA - Do BRAnch</a></h2> is used to branch if internal branch register decremented by one result value is positive. <p class=Pp>Parameter:</p><ol class="Bl-enum Bd-indent"><li>integer offset in the current executed (sub)microsequence. Offset is added to the index of the next microinstruction to execute.</li></ol><p class=Pp>Predefined macro: MS_DBRA(offset)</p></section><section class=Ss><h2 class=Ss id=MS_OP_BRSET_-_BRanch_on_SET><a class=permalink href=#MS_OP_BRSET_-_BRanch_on_SET>MS_OP_BRSET - BRanch on SET</a></h2> is used to branch if some of the status register bits of the parallel port are set. <p class=Pp>Parameter:</p><ol class="Bl-enum Bd-indent"><li>bits of the status register</li><li>integer offset in the current executed (sub)microsequence. Offset is added to the index of the next microinstruction to execute.</li></ol><p class=Pp>Predefined macro: MS_BRSET(mask,offset)</p></section><section class=Ss><h2 class=Ss id=MS_OP_BRCLEAR_-_BRanch_on_CLEAR><a class=permalink href=#MS_OP_BRCLEAR_-_BRanch_on_CLEAR>MS_OP_BRCLEAR - BRanch on CLEAR</a></h2> is used to branch if some of the status register bits of the parallel port are cleared. <p class=Pp>Parameter:</p><ol class="Bl-enum Bd-indent"><li>bits of the status register</li><li>integer offset in the current executed (sub)microsequence. Offset is added to the index of the next microinstruction to execute.</li></ol><p class=Pp>Predefined macro: MS_BRCLEAR(mask,offset)</p></section><section class=Ss><h2 class=Ss id=MS_OP_RET_-_RETurn><a class=permalink href=#MS_OP_RET_-_RETurn>MS_OP_RET - RETurn</a></h2> is used to return from a microsequence. This instruction is mandatory. This is the only way for the microsequencer to detect the end of the microsequence. The return code is returned in the integer pointed by the (int *) parameter of the ppb_MS_microseq(). <p class=Pp>Parameter:</p><ol class="Bl-enum Bd-indent"><li>integer return code</li></ol><p class=Pp>Predefined macro: MS_RET(code)</p></section><section class=Ss><h2 class=Ss id=MS_OP_C_CALL_-_C_function_CALL><a class=permalink href=#MS_OP_C_CALL_-_C_function_CALL>MS_OP_C_CALL - C function CALL</a></h2> is used to call C functions from microsequence execution. This may be useful when a non-standard i/o is performed to retrieve a data character from the parallel port. <p class=Pp>Parameter:</p><ol class="Bl-enum Bd-indent"><li>the C function to call</li><li>the parameter to pass to the function call</li></ol><p class=Pp>The C function shall be declared as a <var class=Ft>int(*)(void *p, char *ptr)</var>. The ptr parameter is the current position in the buffer currently scanned.</p><p class=Pp>Predefined macro: MS_C_CALL(func,param)</p></section><section class=Ss><h2 class=Ss id=MS_OP_PTR_-_initialize_internal_PTR><a class=permalink href=#MS_OP_PTR_-_initialize_internal_PTR>MS_OP_PTR - initialize internal PTR</a></h2> is used to initialize the internal pointer to the currently scanned buffer. This pointer is passed to any C call (see above). <p class=Pp>Parameter:</p><ol class="Bl-enum Bd-indent"><li>pointer to the buffer that shall be accessed by xxx_P() microsequence calls. Note that this pointer is automatically incremented during xxx_P() calls</li></ol><p class=Pp>Predefined macro: MS_PTR(ptr)</p></section><section class=Ss><h2 class=Ss id=MS_OP_ADELAY_-_do_an_Asynchronous_DELAY><a class=permalink href=#MS_OP_ADELAY_-_do_an_Asynchronous_DELAY>MS_OP_ADELAY - do an Asynchronous DELAY</a></h2> is used to make a tsleep() during microsequence execution. The tsleep is executed at PPBPRI level. <p class=Pp>Parameter:</p><ol class="Bl-enum Bd-indent"><li>delay in ms</li></ol><p class=Pp>Predefined macro: MS_ADELAY(delay)</p></section><section class=Ss><h2 class=Ss id=MS_OP_BRSTAT_-_BRanch_on_STATe><a class=permalink href=#MS_OP_BRSTAT_-_BRanch_on_STATe>MS_OP_BRSTAT - BRanch on STATe</a></h2> is used to branch on status register state condition. <p class=Pp>Parameter:</p><ol class="Bl-enum Bd-indent"><li>mask of asserted bits. Bits that shall be asserted in the status register are set in the mask</li><li>mask of cleared bits. Bits that shall be cleared in the status register are set in the mask</li><li>integer offset in the current executed (sub)microsequence. Offset is added to the index of the next microinstruction to execute.</li></ol><p class=Pp>Predefined macro: MS_BRSTAT(asserted_bits,clear_bits,offset)</p></section><section class=Ss><h2 class=Ss id=MS_OP_SUBRET_-_SUBmicrosequence_RETurn><a class=permalink href=#MS_OP_SUBRET_-_SUBmicrosequence_RETurn>MS_OP_SUBRET - SUBmicrosequence RETurn</a></h2> is used to return from the submicrosequence call. This action is mandatory before a RET call. Some microinstructions (PUT, GET) may not be callable within a submicrosequence. <p class=Pp>No parameter.</p><p class=Pp>Predefined macro: MS_SUBRET()</p></section><section class=Ss><h2 class=Ss id=MS_OP_CALL_-_submicrosequence_CALL><a class=permalink href=#MS_OP_CALL_-_submicrosequence_CALL>MS_OP_CALL - submicrosequence CALL</a></h2> is used to call a submicrosequence. A submicrosequence is a microsequence with a SUBRET call. Parameter: <ol class="Bl-enum Bd-indent"><li>the submicrosequence to execute</li></ol><p class=Pp>Predefined macro: MS_CALL(microseq)</p></section><section class=Ss><h2 class=Ss id=MS_OP_RASSERT_P_-_Register_ASSERT_from_internal_PTR><a class=permalink href=#MS_OP_RASSERT_P_-_Register_ASSERT_from_internal_PTR>MS_OP_RASSERT_P - Register ASSERT from internal PTR</a></h2> is used to assert a register with data currently pointed by the internal PTR pointer. Parameter: <ol class="Bl-enum Bd-indent"><li>amount of data to write to the register</li><li>register</li></ol><p class=Pp>Predefined macro: MS_RASSERT_P(iter,reg)</p></section><section class=Ss><h2 class=Ss id=MS_OP_RFETCH_P_-_Register_FETCH_to_internal_PTR><a class=permalink href=#MS_OP_RFETCH_P_-_Register_FETCH_to_internal_PTR>MS_OP_RFETCH_P - Register FETCH to internal PTR</a></h2> is used to fetch data from a register. Data is stored in the buffer currently pointed by the internal PTR pointer. Parameter: <ol class="Bl-enum Bd-indent"><li>amount of data to read from the register</li><li>register</li><li>mask applied to fetched data</li></ol><p class=Pp>Predefined macro: MS_RFETCH_P(iter,reg,mask)</p></section><section class=Ss><h2 class=Ss id=MS_OP_TRIG_-_TRIG_register><a class=permalink href=#MS_OP_TRIG_-_TRIG_register>MS_OP_TRIG - TRIG register</a></h2> is used to trigger the parallel port. This microinstruction is intended to provide a very efficient control of the parallel port. Triggering a register is writing data, wait a while, write data, wait a while... This allows to write magic sequences to the port. Parameter: <ol class="Bl-enum Bd-indent"><li>amount of data to read from the register</li><li>register</li><li>size of the array</li><li>array of unsigned chars. Each couple of u_chars define the data to write to the register and the delay in us to wait. The delay is limited to 255 us to simplify and reduce the size of the array.</li></ol><p class=Pp>Predefined macro: MS_TRIG(reg,len,array)</p></section></section><section class=Sh><h2 class=Sh id=MICROSEQUENCES><a class=permalink href=#MICROSEQUENCES>MICROSEQUENCES</a></h2><section class=Ss><h2 class=Ss id=C_structures><a class=permalink href=#C_structures>C structures</a></h2><div class=Bd><pre>
union ppb_insarg {
     int     i;
     char    c;
     void    *p;
     int     (* f)(void *, char *);
};

struct ppb_microseq {
     int                     opcode;         /* microins. opcode */
     union ppb_insarg        arg[PPB_MS_MAXARGS];    /* arguments */
};
</pre></div></section><section class=Ss><h2 class=Ss id=Using_microsequences><a class=permalink href=#Using_microsequences>Using microsequences</a></h2> To instantiate a microsequence, just declare an array of ppb_microseq structures and initialize it as needed. You may either use predefined macros or code directly your microinstructions according to the ppb_microseq definition. For example, <div class="Bd Pp"><pre>
     struct ppb_microseq select_microseq[] = {

	     /* parameter list
	      */
	     #define SELECT_TARGET    MS_PARAM(0, 1, MS_TYP_INT)
	     #define SELECT_INITIATOR MS_PARAM(3, 1, MS_TYP_INT)

	     /* send the select command to the drive */
	     MS_DASS(MS_UNKNOWN),
	     MS_CASS(H_nAUTO | H_nSELIN |  H_INIT | H_STROBE),
	     MS_CASS( H_AUTO | H_nSELIN |  H_INIT | H_STROBE),
	     MS_DASS(MS_UNKNOWN),
	     MS_CASS( H_AUTO | H_nSELIN | H_nINIT | H_STROBE),

	     /* now, wait until the drive is ready */
	     MS_SET(VP0_SELTMO),
/* loop: */     MS_BRSET(H_ACK, 2 /* ready */),
	     MS_DBRA(-2 /* loop */),
/* error: */    MS_RET(1),
/* ready: */    MS_RET(0)
     };
</pre></div><p class=Pp>Here, some parameters are undefined and must be filled before executing the microsequence. In order to initialize each microsequence, one should use the ppb_MS_init_msq() function like this:</p><div class="Bd Pp"><pre>
     ppb_MS_init_msq(select_microseq, 2,
		     SELECT_TARGET, 1 &lt;&lt; target,
		     SELECT_INITIATOR, 1 &lt;&lt; initiator);
</pre></div><p class=Pp>and then execute the microsequence.</p></section><section class=Ss><h2 class=Ss id=The_microsequencer><a class=permalink href=#The_microsequencer>The microsequencer</a></h2> The microsequencer is executed either at ppbus or adapter level (see <a class=Xr href=ppbus.4.html>ppbus(4)</a> for info about ppbus system layers). Most of the microsequencer is executed at ppc level to avoid ppbus to adapter function call overhead. But some actions like deciding whereas the transfer is IEEE1284-1994 compliant are executed at ppbus layer. </section></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=ppbus.4.html>ppbus(4)</a>, <a class=Xr href=ppc.4.html>ppc(4)</a>, <a class=Xr href=ppi.4.html>ppi(4)</a></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> The <code class=Nm>microseq</code> manual page first appeared in <span class=Ux>FreeBSD 3.0</span>. </section><section class=Sh><h2 class=Sh id=AUTHORS><a class=permalink href=#AUTHORS>AUTHORS</a></h2> This manual page was written by <span class=An>Nicolas Souchu</span>. </section><section class=Sh><h2 class=Sh id=BUGS><a class=permalink href=#BUGS>BUGS</a></h2> Only one level of submicrosequences is allowed. <p class=Pp>When triggering the port, maximum delay allowed is 255 us.</p></section></div><table class=foot><tr><td class=foot-date>June 6, 1998</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>