<!DOCTYPE html>
<html><head><meta charset=utf-8><title>nvlist_create(9)</title><keywords content=man,nvlist_create></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>nvlist_create(9)</h1><table class=head><tr><td class=head-ltitle>NV(9)</td><td class=head-vol>FreeBSD Kernel Developer's Manual</td><td class=head-rtitle>NV(9)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>nvlist_create</code>, <code class=Nm>nvlist_destroy</code>, <code class=Nm>nvlist_error</code>, <code class=Nm>nvlist_set_error</code>, <code class=Nm>nvlist_empty</code>, <code class=Nm>nvlist_flags</code>, <code class=Nm>nvlist_exists</code>, <code class=Nm>nvlist_free</code>, <code class=Nm>nvlist_clone</code>, <code class=Nm>nvlist_dump</code>, <code class=Nm>nvlist_fdump</code>, <code class=Nm>nvlist_size</code>, <code class=Nm>nvlist_pack</code>, <code class=Nm>nvlist_unpack</code>, <code class=Nm>nvlist_send</code>, <code class=Nm>nvlist_recv</code>, <code class=Nm>nvlist_xfer</code>, <code class=Nm>nvlist_in_array</code>, <code class=Nm>nvlist_next</code>, <code class=Nm>nvlist_add</code>, <code class=Nm>nvlist_move</code>, <code class=Nm>nvlist_get</code>, <code class=Nm>nvlist_take</code>, <code class=Nm>nvlist_append</code> — <div class=Nd>library for name/value pairs</div></section><section class=Sh><h2 class=Sh id=LIBRARY><a class=permalink href=#LIBRARY>LIBRARY</a></h2><span class=Lb>Name/value pairs library (libnv, -lnv)</span></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/sys/nv.h.html>sys/nv.h</a>&gt;</code><p class=Pp><var class=Ft>nvlist_t *</var><br><code class=Fn>nvlist_create</code>(<var class=Fa style="white-space: nowrap;">int flags</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_destroy</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>nvlist_error</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_set_error</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">int error</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>nvlist_empty</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>nvlist_flags</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>nvlist_in_array</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>);</p><p class=Pp><var class=Ft>nvlist_t *</var><br><code class=Fn>nvlist_clone</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_dump</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">int fd</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_fdump</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">FILE *fp</var>);</p><p class=Pp><var class=Ft>size_t</var><br><code class=Fn>nvlist_size</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>);</p><p class=Pp><var class=Ft>void *</var><br><code class=Fn>nvlist_pack</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">size_t *sizep</var>);</p><p class=Pp><var class=Ft>nvlist_t *</var><br><code class=Fn>nvlist_unpack</code>(<var class=Fa style="white-space: nowrap;">const void *buf</var>, <var class=Fa style="white-space: nowrap;">size_t size</var>, <var class=Fa style="white-space: nowrap;">int flags</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>nvlist_send</code>(<var class=Fa style="white-space: nowrap;">int sock</var>, <var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>);</p><p class=Pp><var class=Ft>nvlist_t *</var><br><code class=Fn>nvlist_recv</code>(<var class=Fa style="white-space: nowrap;">int sock</var>, <var class=Fa style="white-space: nowrap;">int flags</var>);</p><p class=Pp><var class=Ft>nvlist_t *</var><br><code class=Fn>nvlist_xfer</code>(<var class=Fa style="white-space: nowrap;">int sock</var>, <var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">int flags</var>);</p><p class=Pp><var class=Ft>const char *</var><br><code class=Fn>nvlist_next</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">int *typep</var>, <var class=Fa style="white-space: nowrap;">void **cookiep</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>nvlist_exists</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>nvlist_exists_type</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">int type</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>nvlist_exists_null</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>nvlist_exists_bool</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>nvlist_exists_number</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>nvlist_exists_string</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>nvlist_exists_nvlist</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>nvlist_exists_descriptor</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>nvlist_exists_binary</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>nvlist_exists_bool_array</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>nvlist_exists_number_array</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>nvlist_exists_string_array</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>nvlist_exists_nvlist_array</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>nvlist_exists_descriptor_array</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_add_null</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_add_bool</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">bool value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_add_number</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">uint64_t value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_add_string</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">const char *value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_add_stringf</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">const char *valuefmt</var>, <var class=Fa style="white-space: nowrap;">...</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_add_stringv</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">const char *valuefmt</var>, <var class=Fa style="white-space: nowrap;">va_list valueap</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_add_nvlist</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">const nvlist_t *value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_add_descriptor</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">int value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_add_binary</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">const void *value</var>, <var class=Fa style="white-space: nowrap;">size_t size</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_add_bool_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">const bool *value</var>, <var class=Fa style="white-space: nowrap;">size_t nitems</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_add_number_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">const uint64_t *value</var>, <var class=Fa style="white-space: nowrap;">size_t nitems</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_add_string_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">const char * const * value</var>, <var class=Fa style="white-space: nowrap;">size_t nitems</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_add_nvlist_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">const nvlist_t * const * value</var>, <var class=Fa style="white-space: nowrap;">size_t nitems</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_add_descriptor_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">const int *value</var>, <var class=Fa style="white-space: nowrap;">size_t nitems</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_move_string</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">char *value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_move_nvlist</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">nvlist_t *value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_move_descriptor</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">int value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_move_binary</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">void *value</var>, <var class=Fa style="white-space: nowrap;">size_t size</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_move_bool_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">bool *value</var>, <var class=Fa style="white-space: nowrap;">size_t nitems</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_move_number_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">uint64_t *value</var>, <var class=Fa style="white-space: nowrap;">size_t nitems</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_move_string_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">char **value</var>, <var class=Fa style="white-space: nowrap;">size_t nitems</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_move_nvlist_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">nvlist_t **value</var>, <var class=Fa style="white-space: nowrap;">size_t nitems</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_move_descriptor_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">int *value</var>, <var class=Fa style="white-space: nowrap;">size_t nitems</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>nvlist_get_bool</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>nvlist_get_number</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>const char *</var><br><code class=Fn>nvlist_get_string</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>const nvlist_t *</var><br><code class=Fn>nvlist_get_nvlist</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>nvlist_get_descriptor</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>const void *</var><br><code class=Fn>nvlist_get_binary</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">size_t *sizep</var>);</p><p class=Pp><var class=Ft>const bool *</var><br><code class=Fn>nvlist_get_bool_array</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">size_t *nitems</var>);</p><p class=Pp><var class=Ft>const uint64_t *</var><br><code class=Fn>nvlist_get_number_array</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">size_t *nitems</var>);</p><p class=Pp><var class=Ft>const char * const *</var><br><code class=Fn>nvlist_get_string_array</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">size_t *nitems</var>);</p><p class=Pp><var class=Ft>const nvlist_t * const *</var><br><code class=Fn>nvlist_get_nvlist_array</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">size_t *nitems</var>);</p><p class=Pp><var class=Ft>const int *</var><br><code class=Fn>nvlist_get_descriptor_array</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">size_t *nitems</var>);</p><p class=Pp><var class=Ft>const nvlist_t *</var><br><code class=Fn>nvlist_get_parent</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">void **cookiep</var>);</p><p class=Pp><var class=Ft>const nvlist_t *</var><br><code class=Fn>nvlist_get_array_next</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>);</p><p class=Pp><var class=Ft>const nvlist_t *</var><br><code class=Fn>nvlist_get_pararr</code>(<var class=Fa style="white-space: nowrap;">const nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">void **cookiep</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>nvlist_take_bool</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>nvlist_take_number</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>char *</var><br><code class=Fn>nvlist_take_string</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>nvlist_t *</var><br><code class=Fn>nvlist_take_nvlist</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>nvlist_take_descriptor</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>void *</var><br><code class=Fn>nvlist_take_binary</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">size_t *sizep</var>);</p><p class=Pp><var class=Ft>bool *</var><br><code class=Fn>nvlist_take_bool_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">size_t *nitems</var>);</p><p class=Pp><var class=Ft>uint64_t **</var><br><code class=Fn>nvlist_take_number_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">size_t *nitems</var>);</p><p class=Pp><var class=Ft>char **</var><br><code class=Fn>nvlist_take_string_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">size_t *nitems</var>);</p><p class=Pp><var class=Ft>nvlist_t **</var><br><code class=Fn>nvlist_take_nvlist_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">size_t *nitems</var>);</p><p class=Pp><var class=Ft>int *</var><br><code class=Fn>nvlist_take_descriptor_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">size_t *nitems</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_append_bool_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">const bool value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_append_number_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">const uint64_t value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_append_string_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">const char * const value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_append_nvlist_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">const nvlist_t * const value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_append_descriptor_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">int value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_free</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_free_type</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">int type</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_free_null</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_free_bool</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_free_number</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_free_string</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_free_nvlist</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_free_descriptor</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_free_binary</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_free_bool_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_free_number_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_free_string_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_free_nvlist_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>nvlist_free_descriptor_array</code>(<var class=Fa style="white-space: nowrap;">nvlist_t *nvl</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>);</p></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> The <code class=Nm>libnv</code> library allows to easily manage name value pairs as well as send and receive them over sockets. A group (list) of name value pairs is called an <code class=Nm>nvlist</code>. The API supports the following data types: <dl class="Bl-ohang Bd-indent"><dt><b class=Sy>null</b> (<b class=Sy>NV_TYPE_NULL</b>)</dt><dd>There is no data associated with the name.</dd><dt><b class=Sy>bool</b> (<b class=Sy>NV_TYPE_BOOL</b>)</dt><dd>The value can be either <code class=Dv>true</code> or <code class=Dv>false</code>.</dd><dt><b class=Sy>number</b> (<b class=Sy>NV_TYPE_NUMBER</b>)</dt><dd>The value is a number stored as <var class=Vt>uint64_t</var>.</dd><dt><b class=Sy>string</b> (<b class=Sy>NV_TYPE_STRING</b>)</dt><dd>The value is a C string.</dd><dt><b class=Sy>nvlist</b> (<b class=Sy>NV_TYPE_NVLIST</b>)</dt><dd>The value is a nested nvlist.</dd><dt><b class=Sy>descriptor</b> (<b class=Sy>NV_TYPE_DESCRIPTOR</b>)</dt><dd>The value is a file descriptor. Note that file descriptors can be sent only over <a class=Xr href=unix.4.html>unix(4)</a> domain sockets.</dd><dt><b class=Sy>binary</b> (<b class=Sy>NV_TYPE_BINARY</b>)</dt><dd>The value is a binary buffer.</dd><dt><b class=Sy>bool array</b> (<b class=Sy>NV_TYPE_BOOL_ARRAY</b>)</dt><dd>The value is an array of boolean values.</dd><dt><b class=Sy>number array</b> (<b class=Sy>NV_TYPE_NUMBER_ARRAY</b>)</dt><dd>The value is an array of numbers, each stored as <var class=Vt>uint64_t</var>.</dd><dt><b class=Sy>string array</b> (<b class=Sy>NV_TYPE_STRING_ARRAY</b>)</dt><dd>The value is an array of C strings.</dd><dt><b class=Sy>nvlist array</b> (<b class=Sy>NV_TYPE_NVLIST_ARRAY</b>)</dt><dd>The value is an array of nvlists. When an nvlist is added to an array, it becomes part of the primary nvlist. Traversing these arrays can be done using the <code class=Fn>nvlist_get_array_next</code>() and <code class=Fn>nvlist_get_pararr</code>() functions.</dd><dt><b class=Sy>descriptor array</b> (<b class=Sy>NV_TYPE_DESCRIPTOR_ARRAY</b>)</dt><dd>The value is an array of files descriptors.</dd></dl><p class=Pp>The <code class=Fn>nvlist_create</code>() function allocates memory and initializes an nvlist.</p><p class=Pp>The following flag can be provided:</p><p class=Pp></p><div class=Bd-indent><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#NV_FLAG_IGNORE_CASE><code class=Dv id=NV_FLAG_IGNORE_CASE>NV_FLAG_IGNORE_CASE</code></a></dt><dd>Perform case-insensitive lookups of provided names.</dd><dt><a class=permalink href=#NV_FLAG_NO_UNIQUE><code class=Dv id=NV_FLAG_NO_UNIQUE>NV_FLAG_NO_UNIQUE</code></a></dt><dd>Names in the nvlist do not have to be unique.</dd></dl></div><p class=Pp>The <code class=Fn>nvlist_destroy</code>() function destroys the given nvlist. Function does nothing if <code class=Dv>NULL</code> nvlist is provided. Function never modifies the <var class=Va>errno</var> global variable.</p><p class=Pp>The <code class=Fn>nvlist_error</code>() function returns any error value that the nvlist accumulated. If the given nvlist is <code class=Dv>NULL</code> the <code class=Er>ENOMEM</code> error will be returned.</p><p class=Pp>The <code class=Fn>nvlist_set_error</code>() function sets an nvlist to be in the error state. Subsequent calls to <code class=Fn>nvlist_error</code>() will return the given error value. This function cannot be used to clear the error state from an nvlist. This function does nothing if the nvlist is already in the error state.</p><p class=Pp>The <code class=Fn>nvlist_empty</code>() function returns <code class=Dv>true</code> if the given nvlist is empty and <code class=Dv>false</code> otherwise. The nvlist must not be in error state.</p><p class=Pp>The <code class=Fn>nvlist_flags</code>() function returns flags used to create the nvlist with the <code class=Fn>nvlist_create</code>() function.</p><p class=Pp>The <code class=Fn>nvlist_in_array</code>() function returns <code class=Dv>true</code> if <var class=Fa>nvl</var> is part of an array that is a member of another nvlist.</p><p class=Pp>The <code class=Fn>nvlist_clone</code>() functions clones the given nvlist. The clone shares no resources with its origin. This also means that all file descriptors that are part of the nvlist will be duplicated with the <a class=Xr href=dup.2.html>dup(2)</a> system call before placing them in the clone.</p><p class=Pp>The <code class=Fn>nvlist_dump</code>() dumps nvlist content for debugging purposes to the given file descriptor <var class=Fa>fd</var>.</p><p class=Pp>The <code class=Fn>nvlist_fdump</code>() dumps nvlist content for debugging purposes to the given file stream <var class=Fa>fp</var>.</p><p class=Pp>The <code class=Fn>nvlist_size</code>() function returns the size of the given nvlist after converting it to binary buffer with the <code class=Fn>nvlist_pack</code>() function.</p><p class=Pp>The <code class=Fn>nvlist_pack</code>() function converts the given nvlist to a binary buffer. The function allocates memory for the buffer, which should be freed with the <a class=Xr href=free.3.html>free(3)</a> function. If the <var class=Fa>sizep</var> argument is not <code class=Dv>NULL</code>, the size of the buffer will be stored there. The function returns <code class=Dv>NULL</code> in case of an error (allocation failure). If the nvlist contains any file descriptors <code class=Dv>NULL</code> will be returned. The nvlist must not be in error state.</p><p class=Pp>The <code class=Fn>nvlist_unpack</code>() function converts the given buffer to the nvlist. The <var class=Fa>flags</var> argument defines what type of the top level nvlist is expected to be. Flags are set up using the <code class=Fn>nvlist_create</code>() function. If the nvlist flags do not match the flags passed to <code class=Fn>nvlist_unpack</code>(), the nvlist will not be returned. Every nested nvlist list should be checked using <code class=Fn>nvlist_flags</code>() function. The function returns <code class=Dv>NULL</code> in case of an error.</p><p class=Pp>The <code class=Fn>nvlist_send</code>() function sends the given nvlist over the socket given by the <var class=Fa>sock</var> argument. Note that nvlist that contains file descriptors can only be send over <a class=Xr href=unix.4.html>unix(4)</a> domain sockets.</p><p class=Pp>The <code class=Fn>nvlist_recv</code>() function receives nvlist over the socket given by the <var class=Fa>sock</var> argument. The <var class=Fa>flags</var> argument defines what type of the top level nvlist is expected to be. Flags are set up using the <code class=Fn>nvlist_create</code>() function. If the nvlist flags do not match the flags passed to <code class=Fn>nvlist_recv</code>(), the nvlist will not be returned. Every nested nvlist list should be checked using <code class=Fn>nvlist_flags</code>() function.</p><p class=Pp>The <code class=Fn>nvlist_xfer</code>() function sends the given nvlist over the socket given by the <var class=Fa>sock</var> argument and receives nvlist over the same socket. The <var class=Fa>flags</var> argument defines what type of the top level nvlist is expected to be. Flags are set up using the <code class=Fn>nvlist_create</code>() function. If the nvlist flags do not match the flags passed to <code class=Fn>nvlist_xfer</code>(), the nvlist will not be returned. Every nested nvlist list should be checked using <code class=Fn>nvlist_flags</code>() function. The given nvlist is always destroyed.</p><p class=Pp>The <code class=Fn>nvlist_next</code>() function iterates over the given nvlist returning names and types of subsequent elements. The <var class=Fa>cookiep</var> argument allows the function to figure out which element should be returned next. The <var class=Va>*cookiep</var> should be set to <code class=Dv>NULL</code> for the first call and should not be changed later. Returning <code class=Dv>NULL</code> means there are no more elements on the nvlist. The <var class=Fa>typep</var> argument can be NULL. Elements may not be removed from the nvlist while traversing it. The nvlist must not be in error state. Note that <code class=Fn>nvlist_next</code>() will handle <var class=Va>cookiep</var> being set to <code class=Dv>NULL</code>. In this case first element is returned or <code class=Dv>NULL</code> if nvlist is empty. This behavior simplifies removing the first element from the list.</p><p class=Pp>The <code class=Fn>nvlist_exists</code>() function returns <code class=Dv>true</code> if element of the given name exists (besides of its type) or <code class=Dv>false</code> otherwise. The nvlist must not be in error state.</p><p class=Pp>The <code class=Fn>nvlist_exists_type</code>() function returns <code class=Dv>true</code> if element of the given name and the given type exists or <code class=Dv>false</code> otherwise. The nvlist must not be in error state.</p><p class=Pp>The <code class=Fn>nvlist_exists_null</code>(), <code class=Fn>nvlist_exists_bool</code>(), <code class=Fn>nvlist_exists_number</code>(), <code class=Fn>nvlist_exists_string</code>(), <code class=Fn>nvlist_exists_nvlist</code>(), <code class=Fn>nvlist_exists_descriptor</code>(), <code class=Fn>nvlist_exists_binary</code>(), <code class=Fn>nvlist_exists_bool_array</code>(), <code class=Fn>nvlist_exists_number_array</code>(), <code class=Fn>nvlist_exists_string_array</code>(), <code class=Fn>nvlist_exists_nvlist_array</code>(), <code class=Fn>nvlist_exists_descriptor_array</code>() functions return <code class=Dv>true</code> if element of the given name and the given type determined by the function name exists or <code class=Dv>false</code> otherwise. The nvlist must not be in error state.</p><p class=Pp>The <code class=Fn>nvlist_add_null</code>(), <code class=Fn>nvlist_add_bool</code>(), <code class=Fn>nvlist_add_number</code>(), <code class=Fn>nvlist_add_string</code>(), <code class=Fn>nvlist_add_stringf</code>(), <code class=Fn>nvlist_add_stringv</code>(), <code class=Fn>nvlist_add_nvlist</code>(), <code class=Fn>nvlist_add_descriptor</code>(), <code class=Fn>nvlist_add_binary</code>(), <code class=Fn>nvlist_add_bool_array</code>(), <code class=Fn>nvlist_add_number_array</code>(), <code class=Fn>nvlist_add_string_array</code>(), <code class=Fn>nvlist_add_nvlist_array</code>(), <code class=Fn>nvlist_add_descriptor_array</code>() functions add element to the given nvlist. When adding string or binary buffer the functions will allocate memory and copy the data over. When adding nvlist, the nvlist will be cloned and clone will be added. When adding descriptor, the descriptor will be duplicated using the <a class=Xr href=dup.2.html>dup(2)</a> system call and the new descriptor will be added. The array functions will fail if there are any <code class=Dv>NULL</code> elements in the array, or if the array pointer is <code class=Dv>NULL</code>. If an error occurs while adding new element, internal error is set which can be examined using the <code class=Fn>nvlist_error</code>() function.</p><p class=Pp>The <code class=Fn>nvlist_move_string</code>(), <code class=Fn>nvlist_move_nvlist</code>(), <code class=Fn>nvlist_move_descriptor</code>(), <code class=Fn>nvlist_move_binary</code>(), <code class=Fn>nvlist_move_bool_array</code>(), <code class=Fn>nvlist_move_number_array</code>(), <code class=Fn>nvlist_move_string_array</code>(), <code class=Fn>nvlist_move_nvlist_array</code>(), <code class=Fn>nvlist_move_descriptor_array</code>() functions add new element to the given nvlist, but unlike <code class=Fn>nvlist_add_&lt;type&gt;</code>() functions they will consume the given resource. In the case of strings, descriptors, or nvlists every elements must be unique, or it could cause a double free. The array functions will fail if there are any <code class=Dv>NULL</code> elements, or if the array pointer is <code class=Dv>NULL</code>. If an error occurs while adding new element, the resource is destroyed and internal error is set which can be examined using the <code class=Fn>nvlist_error</code>() function.</p><p class=Pp>The <code class=Fn>nvlist_get_bool</code>(), <code class=Fn>nvlist_get_number</code>(), <code class=Fn>nvlist_get_string</code>(), <code class=Fn>nvlist_get_nvlist</code>(), <code class=Fn>nvlist_get_descriptor</code>(), <code class=Fn>nvlist_get_binary</code>(), <code class=Fn>nvlist_get_bool_array</code>(), <code class=Fn>nvlist_get_number_array</code>(), <code class=Fn>nvlist_get_string_array</code>(), <code class=Fn>nvlist_get_nvlist_array</code>(), <code class=Fn>nvlist_get_descriptor_array</code>() functions return the value that corresponds to the given key name. In the case of strings, nvlists, descriptors, binary, or arrays, the returned resource should not be modified - they still belong to the nvlist. If an element of the given name does not exist, the program will be aborted. To avoid this, the caller should check for the existence of the name before trying to obtain the value, or use the <a class=Xr href=dnvlist.3.html>dnvlist(3)</a> extension, which can provide a default value in the case of a missing element. The nvlist must not be in error state.</p><p class=Pp>The <code class=Fn>nvlist_get_parent</code>() function returns the parent nvlist of the nested nvlist.</p><p class=Pp>The <code class=Fn>nvlist_get_array_next</code>() function returns the next element from the array or <code class=Dv>NULL</code> if the nvlist is not in array or it is the last element. Note that <code class=Fn>nvlist_get_array_next</code>() only works if you added the nvlist array using the <code class=Fn>nvlist_move_nvlist_array</code>() or <code class=Fn>nvlist_add_nvlist_array</code>() functions.</p><p class=Pp>The <code class=Fn>nvlist_get_pararr</code>() function returns the next element in the array, or if not available the parent of the nested nvlist.</p><p class=Pp>The <code class=Fn>nvlist_take_bool</code>(), <code class=Fn>nvlist_take_number</code>(), <code class=Fn>nvlist_take_string</code>(), <code class=Fn>nvlist_take_nvlist</code>(), <code class=Fn>nvlist_take_descriptor</code>(), <code class=Fn>nvlist_take_binary</code>(), <code class=Fn>nvlist_take_bool_array</code>(), <code class=Fn>nvlist_take_number_array</code>(), <code class=Fn>nvlist_take_string_array</code>(), <code class=Fn>nvlist_take_nvlist_array</code>(), <code class=Fn>nvlist_take_descriptor_array</code>() functions return value associated with the given name and remove the element from the nvlist. In case of string and binary values, the caller is responsible for free returned memory using the <a class=Xr href=free.3.html>free(3)</a> function. In case of nvlist, the caller is responsible for destroying returned nvlist using the <code class=Fn>nvlist_destroy</code>() function. In case of descriptor, the caller is responsible for closing returned descriptor using the <code class=Fn>close</code>(<var class=Fa>2</var>) system call. If an element of the given name does not exist, the program will be aborted. To avoid that the caller should check for the existence of the given name before trying to obtain the value, or use the <a class=Xr href=dnvlist.3.html>dnvlist(3)</a> extension, which can provide a default value in the case of a missing element. In the case of an array of strings or binary values, the caller is responsible for freeing every element of the array using the <a class=Xr href=free.3.html>free(3)</a> function. In the case of an array of nvlists, the caller is responsible for destroying every element of array using the <code class=Fn>nvlist_destroy</code>() function. In the case of descriptors, the caller is responsible for closing every element of array using the <code class=Fn>close</code>(<var class=Fa>2</var>) system call. In every case involving an array, the caller must also free the pointer to the array using the <a class=Xr href=free.3.html>free(3)</a> function. The nvlist must not be in error state.</p><p class=Pp>The <code class=Fn>nvlist_append_bool_array</code>(), <code class=Fn>nvlist_append_number_array</code>(), <code class=Fn>nvlist_append_string_array</code>(), <code class=Fn>nvlist_append_nvlist_array</code>(), <code class=Fn>nvlist_append_descriptor_array</code>() functions append an element to the existing array using the same semantics as the add functions (i.e. the element will be copied when applicable). If the array for a given key does not exist, then it will be created as if using the <code class=Fn>nvlist_add_&lt;type&gt;_array</code>() function. The internal error is set on append failure.</p><p class=Pp>The <code class=Fn>nvlist_free</code>() function removes element of the given name from the nvlist (besides of its type) and frees all resources associated with it. If element of the given name does not exist, the program will be aborted. The nvlist must not be in error state.</p><p class=Pp>The <code class=Fn>nvlist_free_type</code>() function removes element of the given name and the given type from the nvlist and frees all resources associated with it. If element of the given name and the given type does not exist, the program will be aborted. The nvlist must not be in error state.</p><p class=Pp>The <code class=Fn>nvlist_free_null</code>(), <code class=Fn>nvlist_free_bool</code>(), <code class=Fn>nvlist_free_number</code>(), <code class=Fn>nvlist_free_string</code>(), <code class=Fn>nvlist_free_nvlist</code>(), <code class=Fn>nvlist_free_descriptor</code>(), <code class=Fn>nvlist_free_binary</code>(), <code class=Fn>nvlist_free_bool_array</code>(), <code class=Fn>nvlist_free_number_array</code>(), <code class=Fn>nvlist_free_string_array</code>(), <code class=Fn>nvlist_free_nvlist_array</code>(), <code class=Fn>nvlist_free_descriptor_array</code>() functions remove element of the given name and the given type determined by the function name from the nvlist and free all resources associated with it. If element of the given name and the given type does not exist, the program will be aborted. The nvlist must not be in error state.</p></section><section class=Sh><h2 class=Sh id=NOTES><a class=permalink href=#NOTES>NOTES</a></h2> The <code class=Fn>nvlist_pack</code>() and <code class=Fn>nvlist_unpack</code>() functions handle the byte-order conversions, so the binary buffer can be packed/unpacked by the hosts with the different endianness. </section><section class=Sh><h2 class=Sh id=EXAMPLES><a class=permalink href=#EXAMPLES>EXAMPLES</a></h2> The following example demonstrates how to prepare an nvlist and send it over <a class=Xr href=unix.4.html>unix(4)</a> domain socket. <div class="Bd Pp"><pre>
nvlist_t *nvl;
int fd;

fd = open("/tmp/foo", O_RDONLY);
if (fd &lt; 0)
        err(1, "open(\"/tmp/foo\") failed");

nvl = nvlist_create(0);
/*
 * There is no need to check if nvlist_create() succeeded,
 * as the nvlist_add_&lt;type&gt;() functions can cope.
 * If it failed, nvlist_send() will fail.
 */
nvlist_add_string(nvl, "filename", "/tmp/foo");
nvlist_add_number(nvl, "flags", O_RDONLY);
/*
 * We just want to send the descriptor, so we can give it
 * for the nvlist to consume (that's why we use nvlist_move
 * not nvlist_add).
 */
nvlist_move_descriptor(nvl, "fd", fd);
if (nvlist_send(sock, nvl) &lt; 0) {
	nvlist_destroy(nvl);
	err(1, "nvlist_send() failed");
}
nvlist_destroy(nvl);
</pre></div><p class=Pp>Receiving nvlist and getting data:</p><div class="Bd Pp"><pre>
nvlist_t *nvl;
const char *command;
char *filename;
int fd;

nvl = nvlist_recv(sock, 0);
if (nvl == NULL)
	err(1, "nvlist_recv() failed");

/* For command we take pointer to nvlist's buffer. */
command = nvlist_get_string(nvl, "command");
/*
 * For filename we remove it from the nvlist and take
 * ownership of the buffer.
 */
filename = nvlist_take_string(nvl, "filename");
/* The same for the descriptor. */
fd = nvlist_take_descriptor(nvl, "fd");

printf("command=%s filename=%s fd=%d0, command, filename, fd);

nvlist_destroy(nvl);
free(filename);
close(fd);
/* command was freed by nvlist_destroy() */
</pre></div><p class=Pp>Iterating over nvlist:</p><div class="Bd Pp"><pre>
nvlist_t *nvl;
const char *name;
void *cookie;
int type;

nvl = nvlist_recv(sock, 0);
if (nvl == NULL)
	err(1, "nvlist_recv() failed");

cookie = NULL;
while ((name = nvlist_next(nvl, &amp;type, &amp;cookie)) != NULL) {
	printf("%s=", name);
	switch (type) {
	case NV_TYPE_NUMBER:
		printf("%ju", (uintmax_t)nvlist_get_number(nvl, name));
		break;
	case NV_TYPE_STRING:
		printf("%s", nvlist_get_string(nvl, name));
		break;
	default:
		printf("N/A");
		break;
	}
	printf("\n");
}
</pre></div><p class=Pp>Iterating over every nested nvlist:</p><div class="Bd Pp"><pre>
nvlist_t *nvl;
const char *name;
void *cookie;
int type;

nvl = nvlist_recv(sock, 0);
if (nvl == NULL)
	err(1, "nvlist_recv() failed");

cookie = NULL;
do {
	while ((name = nvlist_next(nvl, &amp;type, &amp;cookie)) != NULL) {
		if (type == NV_TYPE_NVLIST) {
			nvl = nvlist_get_nvlist(nvl, name);
			cookie = NULL;
		}
	}
} while ((nvl = nvlist_get_parent(nvl, &amp;cookie)) != NULL);
</pre></div><p class=Pp>Iterating over every nested nvlist and every nvlist element:</p><div class="Bd Pp"><pre>
nvlist_t *nvl;
const nvlist_t * const *array;
const char *name;
void *cookie;
int type;

nvl = nvlist_recv(sock, 0);
if (nvl == null)
	err(1, "nvlist_recv() failed");

cookie = null;
do {
	while ((name = nvlist_next(nvl, &amp;type, &amp;cookie)) != NULL) {
		if (type == NV_TYPE_NVLIST) {
			nvl = nvlist_get_nvlist(nvl, name);
			cookie = NULL;
		} else if (type == NV_TYPE_NVLIST_ARRAY) {
			nvl = nvlist_get_nvlist_array(nvl, name, NULL)[0];
			cookie = NULL;
		}
	}
} while ((nvl = nvlist_get_pararr(nvl, &amp;cookie)) != NULL);
</pre></div><p class=Pp>Or alternatively:</p><div class="Bd Pp"><pre>
nvlist_t *nvl, *tmp;
const nvlist_t * const *array;
const char *name;
void *cookie;
int type;

nvl = nvlist_recv(sock, 0);
if (nvl == null)
	err(1, "nvlist_recv() failed");

cooke = NULL;
tmp = nvl;
do {
	do {
		nvl = tmp;
		while ((name = nvlist_next(nvl, &amp;type, &amp;cookie)) != NULL) {
			if (type == NV_TYPE_NVLIST) {
				nvl = nvlist_get_nvlist(nvl,
				    name);
				cookie = NULL;
			} else if (type == NV_TYPE_NVLIST_ARRAY) {
				nvl = nvlist_get_nvlist_array(nvl, name,
				    NULL)[0];
				cookie = NULL;
			}
		}
		cookie = NULL;
	} while ((tmp = nvlist_get_array_next(nvl)) != NULL);
} while ((tmp = nvlist_get_parent(nvl, &amp;cookie)) != NULL);
</pre></div></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=close.2.html>close(2)</a>, <a class=Xr href=dup.2.html>dup(2)</a>, <a class=Xr href=open.2.html>open(2)</a>, <a class=Xr href=err.3.html>err(3)</a>, <a class=Xr href=free.3.html>free(3)</a>, <a class=Xr href=printf.3.html>printf(3)</a>, <a class=Xr href=unix.4.html>unix(4)</a></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> The <code class=Nm>libnv</code> library appeared in <span class=Ux>FreeBSD 11.0</span>. </section><section class=Sh><h2 class=Sh id=AUTHORS><a class=permalink href=#AUTHORS>AUTHORS</a></h2> The <code class=Nm>libnv</code> library was implemented by <span class=An>Pawel Jakub Dawidek</span> &lt;<a class=Mt href=mailto:pawel@dawidek.net>pawel@dawidek.net</a>&gt; under sponsorship from the FreeBSD Foundation. </section></div><table class=foot><tr><td class=foot-date>June 19, 2018</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>