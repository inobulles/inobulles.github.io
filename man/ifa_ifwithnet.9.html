<!DOCTYPE html>
<html><head><meta charset=utf-8><title>ifa_ifwithnet(9)</title><keywords content=man,ifa_ifwithnet></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>ifa_ifwithnet(9)</h1><table class=head><tr><td class=head-ltitle>IFNET(9)</td><td class=head-vol>FreeBSD Kernel Developer's Manual</td><td class=head-rtitle>IFNET(9)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>ifnet</code>, <code class=Nm>ifaddr</code>, <code class=Nm>ifqueue</code>, <code class=Nm>if_data</code> — <div class=Nd>kernel interfaces for manipulating network interfaces</div></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/sys/param.h.html>sys/param.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/sys/time.h.html>sys/time.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/sys/socket.h.html>sys/socket.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/net/if.h.html>net/if.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/net/if_var.h.html>net/if_var.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/net/if_types.h.html>net/if_types.h</a>&gt;</code><section class=Ss><h2 class=Ss id=Interface_Manipulation_Functions><a class=permalink href=#Interface_Manipulation_Functions>Interface Manipulation Functions</a></h2><var class=Ft>struct ifnet *</var><br><code class=Fn>if_alloc</code>(<var class=Fa style="white-space: nowrap;">u_char type</var>); <p class=Pp><var class=Ft>void</var><br><code class=Fn>if_attach</code>(<var class=Fa style="white-space: nowrap;">struct ifnet *ifp</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>if_detach</code>(<var class=Fa style="white-space: nowrap;">struct ifnet *ifp</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>if_free</code>(<var class=Fa style="white-space: nowrap;">struct ifnet *ifp</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>if_free_type</code>(<var class=Fa style="white-space: nowrap;">struct ifnet *ifp</var>, <var class=Fa style="white-space: nowrap;">u_char type</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>if_down</code>(<var class=Fa style="white-space: nowrap;">struct ifnet *ifp</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>ifioctl</code>(<var class=Fa style="white-space: nowrap;">struct socket *so</var>, <var class=Fa style="white-space: nowrap;">u_long cmd</var>, <var class=Fa style="white-space: nowrap;">caddr_t data</var>, <var class=Fa style="white-space: nowrap;">struct thread *td</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>ifpromisc</code>(<var class=Fa style="white-space: nowrap;">struct ifnet *ifp</var>, <var class=Fa style="white-space: nowrap;">int pswitch</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>if_allmulti</code>(<var class=Fa style="white-space: nowrap;">struct ifnet *ifp</var>, <var class=Fa style="white-space: nowrap;">int amswitch</var>);</p><p class=Pp><var class=Ft>struct ifnet *</var><br><code class=Fn>ifunit</code>(<var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>struct ifnet *</var><br><code class=Fn>ifunit_ref</code>(<var class=Fa style="white-space: nowrap;">const char *name</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>if_up</code>(<var class=Fa style="white-space: nowrap;">struct ifnet *ifp</var>);</p></section><section class=Ss><h2 class=Ss id=Interface_Address_Functions><a class=permalink href=#Interface_Address_Functions>Interface Address Functions</a></h2><var class=Ft>struct ifaddr *</var><br><code class=Fn>ifaddr_byindex</code>(<var class=Fa style="white-space: nowrap;">u_short idx</var>); <p class=Pp><var class=Ft>struct ifaddr *</var><br><code class=Fn>ifa_ifwithaddr</code>(<var class=Fa style="white-space: nowrap;">struct sockaddr *addr</var>);</p><p class=Pp><var class=Ft>struct ifaddr *</var><br><code class=Fn>ifa_ifwithdstaddr</code>(<var class=Fa style="white-space: nowrap;">struct sockaddr *addr</var>, <var class=Fa style="white-space: nowrap;">int fib</var>);</p><p class=Pp><var class=Ft>struct ifaddr *</var><br><code class=Fn>ifa_ifwithnet</code>(<var class=Fa style="white-space: nowrap;">struct sockaddr *addr</var>, <var class=Fa style="white-space: nowrap;">int ignore_ptp</var>, <var class=Fa style="white-space: nowrap;">int fib</var>);</p><p class=Pp><var class=Ft>struct ifaddr *</var><br><code class=Fn>ifaof_ifpforaddr</code>(<var class=Fa style="white-space: nowrap;">struct sockaddr *addr</var>, <var class=Fa style="white-space: nowrap;">struct ifnet *ifp</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>ifa_ref</code>(<var class=Fa style="white-space: nowrap;">struct ifaddr *ifa</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>ifa_free</code>(<var class=Fa style="white-space: nowrap;">struct ifaddr *ifa</var>);</p></section><section class=Ss><h2 class=Ss id=Interface_Multicast_Address_Functions><a class=permalink href=#Interface_Multicast_Address_Functions>Interface Multicast Address Functions</a></h2><var class=Ft>int</var><br><code class=Fn>if_addmulti</code>(<var class=Fa style="white-space: nowrap;">struct ifnet *ifp</var>, <var class=Fa style="white-space: nowrap;">struct sockaddr *sa</var>, <var class=Fa style="white-space: nowrap;">struct ifmultiaddr **ifmap</var>); <p class=Pp><var class=Ft>int</var><br><code class=Fn>if_delmulti</code>(<var class=Fa style="white-space: nowrap;">struct ifnet *ifp</var>, <var class=Fa style="white-space: nowrap;">struct sockaddr *sa</var>);</p><p class=Pp><var class=Ft>struct ifmultiaddr *</var><br><code class=Fn>if_findmulti</code>(<var class=Fa style="white-space: nowrap;">struct ifnet *ifp</var>, <var class=Fa style="white-space: nowrap;">struct sockaddr *sa</var>);</p></section><section class=Ss><h2 class=Ss id=Output_queue_macros><a class=permalink href=#Output_queue_macros>Output queue macros</a></h2><code class=Fn>IF_DEQUEUE</code>(<var class=Fa style="white-space: nowrap;">struct ifqueue *ifq</var>, <var class=Fa style="white-space: nowrap;">struct mbuf *m</var>); </section><section class=Ss><h2 class=Ss id=struct_ifnet_Member_Functions><a class=permalink href=#struct_ifnet_Member_Functions>struct ifnet Member Functions</a></h2><var class=Ft>void</var><br><code class=Fn>(*if_input)</code>(<var class=Fa style="white-space: nowrap;">struct ifnet *ifp</var>, <var class=Fa style="white-space: nowrap;">struct mbuf *m</var>); <p class=Pp><var class=Ft>int</var><br><code class=Fn>(*if_output)</code>(<var class=Fa>struct ifnet *ifp</var>, <var class=Fa>struct mbuf *m</var>, <var class=Fa>const struct sockaddr *dst</var>, <var class=Fa>struct route *ro</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>(*if_start)</code>(<var class=Fa style="white-space: nowrap;">struct ifnet *ifp</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>(*if_transmit)</code>(<var class=Fa style="white-space: nowrap;">struct ifnet *ifp</var>, <var class=Fa style="white-space: nowrap;">struct mbuf *m</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>(*if_qflush)</code>(<var class=Fa style="white-space: nowrap;">struct ifnet *ifp</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>(*if_ioctl)</code>(<var class=Fa style="white-space: nowrap;">struct ifnet *ifp</var>, <var class=Fa style="white-space: nowrap;">u_long cmd</var>, <var class=Fa style="white-space: nowrap;">caddr_t data</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>(*if_init)</code>(<var class=Fa style="white-space: nowrap;">void *if_softc</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>(*if_resolvemulti)</code>(<var class=Fa>struct ifnet *ifp</var>, <var class=Fa>struct sockaddr **retsa</var>, <var class=Fa>struct sockaddr *addr</var>);</p></section><section class=Ss><h2 class=Ss id=struct_ifaddr_member_function><a class=permalink href=#struct_ifaddr_member_function>struct ifaddr member function</a></h2><var class=Ft>void</var><br><code class=Fn>(*ifa_rtrequest)</code>(<var class=Fa>int cmd</var>, <var class=Fa>struct rtentry *rt</var>, <var class=Fa>struct rt_addrinfo *info</var>); </section><section class=Ss><h2 class=Ss id=Global_Variables><a class=permalink href=#Global_Variables>Global Variables</a></h2><var class=Vt>extern struct ifnethead ifnet</var>; <br><var class=Vt>extern int if_index</var>; <br><var class=Vt>extern int ifqmaxlen</var>; </section></section><section class=Sh><h2 class=Sh id=DATA_STRUCTURES><a class=permalink href=#DATA_STRUCTURES>DATA STRUCTURES</a></h2> The kernel mechanisms for handling network interfaces reside primarily in the <var class=Vt>ifnet</var>, <var class=Vt>if_data</var>, <var class=Vt>ifaddr</var>, and <var class=Vt>ifmultiaddr</var> structures in <code class=In>&lt;<a class=In href=../src/net/if.h.html>net/if.h</a>&gt;</code> and <code class=In>&lt;<a class=In href=../src/net/if_var.h.html>net/if_var.h</a>&gt;</code> and the functions named above and defined in <span class=Pa>/sys/net/if.c</span>. Those interfaces which are intended to be used by user programs are defined in <code class=In>&lt;<a class=In href=../src/net/if.h.html>net/if.h</a>&gt;</code>; these include the interface flags, the <var class=Vt>if_data</var> structure, and the structures defining the appearance of interface-related messages on the <a class=Xr href=route.4.html>route(4)</a> routing socket and in <a class=Xr href=sysctl.3.html>sysctl(3)</a>. The header file <code class=In>&lt;<a class=In href=../src/net/if_var.h.html>net/if_var.h</a>&gt;</code> defines the kernel-internal interfaces, including the <var class=Vt>ifnet</var>, <var class=Vt>ifaddr</var>, and <var class=Vt>ifmultiaddr</var> structures and the functions which manipulate them. (A few user programs will need <code class=In>&lt;<a class=In href=../src/net/if_var.h.html>net/if_var.h</a>&gt;</code> because it is the prerequisite of some other header file like <code class=In>&lt;<a class=In href=../src/netinet/if_ether.h.html>netinet/if_ether.h</a>&gt;</code>. Most references to those two files in particular can be replaced by <code class=In>&lt;<a class=In href=../src/net/ethernet.h.html>net/ethernet.h</a>&gt;</code>.) <p class=Pp>The system keeps a linked list of interfaces using the <code class=Li>TAILQ</code> macros defined in <a class=Xr href=queue.3.html>queue(3)</a>; this list is headed by a <var class=Vt>struct ifnethead</var> called <var class=Va>ifnet</var>. The elements of this list are of type <var class=Vt>struct ifnet</var>, and most kernel routines which manipulate interface as such accept or return pointers to these structures. Each interface structure contains an <var class=Vt>if_data</var> structure used for statistics and information. Each interface also has a <code class=Li>TAILQ</code> of interface addresses, described by <var class=Vt>ifaddr</var> structures. An <code class=Dv>AF_LINK</code> address (see <a class=Xr href=link_addr.3.html>link_addr(3)</a>) describing the link layer implemented by the interface (if any) is accessed by the <code class=Fn>ifaddr_byindex</code>() function or <var class=Va>if_addr</var> structure. (Some trivial interfaces do not provide any link layer addresses; this structure, while still present, serves only to identify the interface name and index.)</p><p class=Pp>Finally, those interfaces supporting reception of multicast datagrams have a <code class=Li>TAILQ</code> of multicast group memberships, described by <var class=Vt>ifmultiaddr</var> structures. These memberships are reference-counted.</p><p class=Pp>Interfaces are also associated with an output queue, defined as a <var class=Vt>struct ifqueue</var>; this structure is used to hold packets while the interface is in the process of sending another.</p><section class=Ss><h2 class=Ss id=The_ifnet_Structure><a class=permalink href=#The_ifnet_Structure>The ifnet Structure</a></h2> The fields of <var class=Vt>struct ifnet</var> are as follows: <div class=Bd-indent><dl class=Bl-tag><dt><var class=Va>if_softc</var></dt><dd>(<var class=Vt>void *</var>) A pointer to the driver's private state block. (Initialized by driver.)</dd><dt><var class=Va>if_l2com</var></dt><dd>(<var class=Vt>void *</var>) A pointer to the common data for the interface's layer 2 protocol. (Initialized by <code class=Fn>if_alloc</code>().)</dd><dt><var class=Va>if_vnet</var></dt><dd>(<var class=Vt>struct vnet *</var>) A pointer to the virtual network stack instance. (Initialized by <code class=Fn>if_attach</code>().)</dd><dt><var class=Va>if_home_vnet</var></dt><dd>(<var class=Vt>struct vnet *</var>) A pointer to the parent virtual network stack, where this <var class=Vt>struct ifnet</var> originates from. (Initialized by <code class=Fn>if_attach</code>().)</dd><dt><var class=Va>if_link</var></dt><dd>(<code class=Fn>TAILQ_ENTRY</code>(<var class=Fa>ifnet</var>)) <a class=Xr href=queue.3.html>queue(3)</a> macro glue.</dd><dt><var class=Va>if_xname</var></dt><dd>(<var class=Vt>char *</var>) The name of the interface, (e.g., “<code class=Li>fxp0</code>” or “<code class=Li>lo0</code>”). (Initialized by driver (usually via <code class=Fn>if_initname</code>()).)</dd><dt><var class=Va>if_dname</var></dt><dd>(<var class=Vt>const char *</var>) The name of the driver. (Initialized by driver (usually via <code class=Fn>if_initname</code>()).)</dd><dt><var class=Va>if_dunit</var></dt><dd>(<var class=Vt>int</var>) A unique number assigned to each interface managed by a particular driver. Drivers may choose to set this to <code class=Dv>IF_DUNIT_NONE</code> if a unit number is not associated with the device. (Initialized by driver (usually via <code class=Fn>if_initname</code>()).)</dd><dt><var class=Va>if_refcount</var></dt><dd>(<var class=Vt>u_int</var>) The reference count. (Initialized by <code class=Fn>if_alloc</code>().)</dd><dt><var class=Va>if_addrhead</var></dt><dd>(<var class=Vt>struct ifaddrhead</var>) The head of the <a class=Xr href=queue.3.html>queue(3)</a><code class=Li>TAILQ</code> containing the list of addresses assigned to this interface.</dd><dt><var class=Va>if_pcount</var></dt><dd>(<var class=Vt>int</var>) A count of promiscuous listeners on this interface, used to reference-count the <code class=Dv>IFF_PROMISC</code> flag.</dd><dt><var class=Va>if_carp</var></dt><dd>(<var class=Vt>struct carp_if *</var>) A pointer to the CARP interface structure, <a class=Xr href=carp.4.html>carp(4)</a>. (Initialized by the driver-specific <code class=Fn>if_ioctl</code>() routine.)</dd><dt><var class=Va>if_bpf</var></dt><dd>(<var class=Vt>struct bpf_if *</var>) Opaque per-interface data for the packet filter, <a class=Xr href=bpf.4.html>bpf(4)</a>. (Initialized by <code class=Fn>bpf_attach</code>().)</dd><dt><var class=Va>if_index</var></dt><dd>(<var class=Vt>u_short</var>) A unique number assigned to each interface in sequence as it is attached. This number can be used in a <var class=Vt>struct sockaddr_dl</var> to refer to a particular interface by index (see <a class=Xr href=link_addr.3.html>link_addr(3)</a>). (Initialized by <code class=Fn>if_alloc</code>().)</dd><dt><var class=Va>if_vlantrunk</var></dt><dd>(<var class=Vt>struct ifvlantrunk *</var>) A pointer to 802.1Q trunk structure, <a class=Xr href=vlan.4.html>vlan(4)</a>. (Initialized by the driver-specific <code class=Fn>if_ioctl</code>() routine.)</dd><dt><var class=Va>if_flags</var></dt><dd>(<var class=Vt>int</var>) Flags describing operational parameters of this interface (see below). (Manipulated by generic code.)</dd><dt><var class=Va>if_drv_flags</var></dt><dd>(<var class=Vt>int</var>) Flags describing operational status of this interface (see below). (Manipulated by driver.)</dd><dt><var class=Va>if_capabilities</var></dt><dd>(<var class=Vt>int</var>) Flags describing the capabilities the interface supports (see below).</dd><dt><var class=Va>if_capenable</var></dt><dd>(<var class=Vt>int</var>) Flags describing the enabled capabilities of the interface (see below).</dd><dt><var class=Va>if_linkmib</var></dt><dd>(<var class=Vt>void *</var>) A pointer to an interface-specific MIB structure exported by <a class=Xr href=ifmib.4.html>ifmib(4)</a>. (Initialized by driver.)</dd><dt><var class=Va>if_linkmiblen</var></dt><dd>(<var class=Vt>size_t</var>) The size of said structure. (Initialized by driver.)</dd><dt><var class=Va>if_data</var></dt><dd>(<var class=Vt>struct if_data</var>) More statistics and information; see <a class=Sx href=#The_if_data_structure>The if_data structure</a>, below. (Initialized by driver, manipulated by both driver and generic code.)</dd><dt><var class=Va>if_multiaddrs</var></dt><dd>(<var class=Vt>struct ifmultihead</var>) The head of the <a class=Xr href=queue.3.html>queue(3)</a><code class=Li>TAILQ</code> containing the list of multicast addresses assigned to this interface.</dd><dt><var class=Va>if_amcount</var></dt><dd>(<var class=Vt>int</var>) A number of multicast requests on this interface, used to reference-count the <code class=Dv>IFF_ALLMULTI</code> flag.</dd><dt><var class=Va>if_addr</var></dt><dd>(<var class=Vt>struct ifaddr *</var>) A pointer to the link-level interface address. (Initialized by <code class=Fn>if_alloc</code>().)</dd><dt><var class=Va>if_snd</var></dt><dd>(<var class=Vt>struct ifaltq</var>) The output queue. (Manipulated by driver.)</dd><dt><var class=Va>if_broadcastaddr</var></dt><dd>(<var class=Vt>const u_int8_t *</var>) A link-level broadcast bytestring for protocols with variable address length.</dd><dt><var class=Va>if_bridge</var></dt><dd>(<var class=Vt>void *</var>) A pointer to the bridge interface structure, <a class=Xr href=if_bridge.4.html>if_bridge(4)</a>. (Initialized by the driver-specific <code class=Fn>if_ioctl</code>() routine.)</dd><dt><var class=Va>if_label</var></dt><dd>(<var class=Vt>struct label *</var>) A pointer to the MAC Framework label structure, <a class=Xr href=mac.4.html>mac(4)</a>. (Initialized by <code class=Fn>if_alloc</code>().)</dd><dt><var class=Va>if_afdata</var></dt><dd>(<var class=Vt>void *</var>) An address family dependent data region.</dd><dt><var class=Va>if_afdata_initialized</var></dt><dd>(<var class=Vt>int</var>) Used to track the current state of address family initialization.</dd><dt><var class=Va>if_afdata_lock</var></dt><dd>(<var class=Vt>struct rwlock</var>) An <a class=Xr href=rwlock.9.html>rwlock(9)</a> lock used to protect <var class=Va>if_afdata</var> internals.</dd><dt><var class=Va>if_linktask</var></dt><dd>(<var class=Vt>struct task</var>) A <a class=Xr href=taskqueue.9.html>taskqueue(9)</a> task scheduled for link state change events of the interface.</dd><dt><var class=Va>if_addr_lock</var></dt><dd>(<var class=Vt>struct rwlock</var>) An <a class=Xr href=rwlock.9.html>rwlock(9)</a> lock used to protect interface-related address lists.</dd><dt><var class=Va>if_clones</var></dt><dd>(<code class=Fn>LIST_ENTRY</code>(<var class=Fa>ifnet</var>)) <a class=Xr href=queue.3.html>queue(3)</a> macro glue for the list of clonable network interfaces.</dd><dt><var class=Va>if_groups</var></dt><dd>(<code class=Fn>TAILQ_HEAD</code>(<var class=Fa></var>, <var class=Fa>ifg_list</var>)) The head of the <a class=Xr href=queue.3.html>queue(3)</a><code class=Li>TAILQ</code> containing the list of groups per interface.</dd><dt><var class=Va>if_pf_kif</var></dt><dd>(<var class=Vt>void *</var>) A pointer to the structure used for interface abstraction by <a class=Xr href=pf.4.html>pf(4)</a>.</dd><dt><var class=Va>if_lagg</var></dt><dd>(<var class=Vt>void *</var>) A pointer to the <a class=Xr href=lagg.4.html>lagg(4)</a> interface structure.</dd><dt><var class=Va>if_alloctype</var></dt><dd>(<var class=Vt>u_char</var>) The type of the interface as it was at the time of its allocation. It is used to cache the type passed to <code class=Fn>if_alloc</code>(), but unlike <var class=Va>if_type</var>, it would not be changed by drivers.</dd></dl></div><p class=Pp>References to <var class=Vt>ifnet</var> structures are gained by calling the <code class=Fn>if_ref</code>() function and released by calling the <code class=Fn>if_rele</code>() function. They are used to allow kernel code walking global interface lists to release the <var class=Vt>ifnet</var> lock yet keep the <var class=Vt>ifnet</var> structure stable.</p><p class=Pp>There are in addition a number of function pointers which the driver must initialize to complete its interface with the generic interface layer:</p><dl class="Bl-ohang Bd-indent"><dt><code class=Fn>if_input</code>()</dt><dd>Pass a packet to an appropriate upper layer as determined from the link-layer header of the packet. This routine is to be called from an interrupt handler or used to emulate reception of a packet on this interface. A single function implementing <code class=Fn>if_input</code>() can be shared among multiple drivers utilizing the same link-layer framing, e.g., Ethernet.</dd><dt><code class=Fn>if_output</code>()</dt><dd>Output a packet on interface <var class=Fa>ifp</var>, or queue it on the output queue if the interface is already active.</dd><dt><code class=Fn>if_transmit</code>()</dt><dd>Transmit a packet on an interface or queue it if the interface is in use. This function will return <code class=Dv>ENOBUFS</code> if the devices software and hardware queues are both full. This function must be installed after <code class=Fn>if_attach</code>() to override the default implementation. This function is exposed in order to allow drivers to manage their own queues and to reduce the latency caused by a frequently gratuitous enqueue / dequeue pair to ifq. The suggested internal software queuing mechanism is buf_ring.</dd><dt><code class=Fn>if_qflush</code>()</dt><dd>Free mbufs in internally managed queues when the interface is marked down. This function must be installed after <code class=Fn>if_attach</code>() to override the default implementation. This function is exposed in order to allow drivers to manage their own queues and to reduce the latency caused by a frequently gratuitous enqueue / dequeue pair to ifq. The suggested internal software queuing mechanism is buf_ring.</dd><dt><code class=Fn>if_start</code>()</dt><dd>Start queued output on an interface. This function is exposed in order to provide for some interface classes to share a <code class=Fn>if_output</code>() among all drivers. <code class=Fn>if_start</code>() may only be called when the <code class=Dv>IFF_DRV_OACTIVE</code> flag is not set. (Thus, <code class=Dv>IFF_DRV_OACTIVE</code> does not literally mean that output is active, but rather that the device's internal output queue is full.) Please note that this function will soon be deprecated.</dd><dt><code class=Fn>if_ioctl</code>()</dt><dd>Process interface-related <a class=Xr href=ioctl.2.html>ioctl(2)</a> requests (defined in <code class=In>&lt;<a class=In href=../src/sys/sockio.h.html>sys/sockio.h</a>&gt;</code>). Preliminary processing is done by the generic routine <code class=Fn>ifioctl</code>() to check for appropriate privileges, locate the interface being manipulated, and perform certain generic operations like twiddling flags and flushing queues. See the description of <code class=Fn>ifioctl</code>() below for more information.</dd><dt><code class=Fn>if_init</code>()</dt><dd>Initialize and bring up the hardware, e.g., reset the chip and enable the receiver unit. Should mark the interface running, but not active (<code class=Dv>IFF_DRV_RUNNING</code>, <code class=Dv>~IIF_DRV_OACTIVE</code>).</dd><dt><code class=Fn>if_resolvemulti</code>()</dt><dd>Check the requested multicast group membership, <var class=Fa>addr</var>, for validity, and if necessary compute a link-layer group which corresponds to that address which is returned in <var class=Fa>*retsa</var>. Returns zero on success, or an error code on failure.</dd></dl></section><section class=Ss><h2 class=Ss id=Interface_Flags><a class=permalink href=#Interface_Flags>Interface Flags</a></h2> Interface flags are used for a number of different purposes. Some flags simply indicate information about the type of interface and its capabilities; others are dynamically manipulated to reflect the current state of the interface. Flags of the former kind are marked ⟨S⟩ in this table; the latter are marked ⟨D⟩. Flags which begin with “IFF_DRV_” are stored in <var class=Va>if_drv_flags</var>; all other flags are stored in <var class=Va>if_flags</var>. <p class=Pp>The macro <code class=Dv>IFF_CANTCHANGE</code> defines the bits which cannot be set by a user program using the <code class=Dv>SIOCSIFFLAGS</code> command to <a class=Xr href=ioctl.2.html>ioctl(2)</a>; these are indicated by an asterisk (‘<code class=Li>*</code>’) in the following listing.</p><p class=Pp></p><div class=Bd-indent><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#IFF_UP><code class=Dv id=IFF_UP>IFF_UP</code></a></dt><dd>⟨D⟩ The interface has been configured up by the user-level code.</dd><dt><a class=permalink href=#IFF_BROADCAST><code class=Dv id=IFF_BROADCAST>IFF_BROADCAST</code></a></dt><dd>⟨S*⟩ The interface supports broadcast.</dd><dt><a class=permalink href=#IFF_DEBUG><code class=Dv id=IFF_DEBUG>IFF_DEBUG</code></a></dt><dd>⟨D⟩ Used to enable/disable driver debugging code.</dd><dt><a class=permalink href=#IFF_LOOPBACK><code class=Dv id=IFF_LOOPBACK>IFF_LOOPBACK</code></a></dt><dd>⟨S⟩ The interface is a loopback device.</dd><dt><a class=permalink href=#IFF_POINTOPOINT><code class=Dv id=IFF_POINTOPOINT>IFF_POINTOPOINT</code></a></dt><dd>⟨S*⟩ The interface is point-to-point; “broadcast” address is actually the address of the other end.</dd><dt><a class=permalink href=#IFF_DRV_RUNNING><code class=Dv id=IFF_DRV_RUNNING>IFF_DRV_RUNNING</code></a></dt><dd>⟨D*⟩ The interface has been configured and dynamic resources were successfully allocated. Probably only useful internal to the interface.</dd><dt><a class=permalink href=#IFF_NOARP><code class=Dv id=IFF_NOARP>IFF_NOARP</code></a></dt><dd>⟨D⟩ Disable network address resolution on this interface.</dd><dt><a class=permalink href=#IFF_PROMISC><code class=Dv id=IFF_PROMISC>IFF_PROMISC</code></a></dt><dd>⟨D*⟩ This interface is in promiscuous mode.</dd><dt><a class=permalink href=#IFF_PPROMISC><code class=Dv id=IFF_PPROMISC>IFF_PPROMISC</code></a></dt><dd>⟨D⟩ This interface is in the permanently promiscuous mode (implies <code class=Dv>IFF_PROMISC</code>).</dd><dt><a class=permalink href=#IFF_ALLMULTI><code class=Dv id=IFF_ALLMULTI>IFF_ALLMULTI</code></a></dt><dd>⟨D*⟩ This interface is in all-multicasts mode (used by multicast routers).</dd><dt><a class=permalink href=#IFF_DRV_OACTIVE><code class=Dv id=IFF_DRV_OACTIVE>IFF_DRV_OACTIVE</code></a></dt><dd>⟨D*⟩ The interface's hardware output queue (if any) is full; output packets are to be queued.</dd><dt><a class=permalink href=#IFF_SIMPLEX><code class=Dv id=IFF_SIMPLEX>IFF_SIMPLEX</code></a></dt><dd>⟨S*⟩ The interface cannot hear its own transmissions.</dd><dt><a class=permalink href=#IFF_LINK0><code class=Dv id=IFF_LINK0>IFF_LINK0</code></a></dt><dd style="width: auto;"> </dd><dt><a class=permalink href=#IFF_LINK1><code class=Dv id=IFF_LINK1>IFF_LINK1</code></a></dt><dd style="width: auto;"> </dd><dt><a class=permalink href=#IFF_LINK2><code class=Dv id=IFF_LINK2>IFF_LINK2</code></a></dt><dd>⟨D⟩ Control flags for the link layer. (Currently abused to select among multiple physical layers on some devices.)</dd><dt><a class=permalink href=#IFF_MULTICAST><code class=Dv id=IFF_MULTICAST>IFF_MULTICAST</code></a></dt><dd>⟨S*⟩ This interface supports multicast.</dd><dt><a class=permalink href=#IFF_CANTCONFIG><code class=Dv id=IFF_CANTCONFIG>IFF_CANTCONFIG</code></a></dt><dd>⟨S*⟩ The interface is not configurable in a meaningful way. Primarily useful for <code class=Dv>IFT_USB</code> interfaces registered at the interface list.</dd><dt><a class=permalink href=#IFF_MONITOR><code class=Dv id=IFF_MONITOR>IFF_MONITOR</code></a></dt><dd>⟨D⟩ This interface blocks transmission of packets and discards incoming packets after BPF processing. Used to monitor network traffic but not interact with the network in question.</dd><dt><a class=permalink href=#IFF_STATICARP><code class=Dv id=IFF_STATICARP>IFF_STATICARP</code></a></dt><dd>⟨D⟩ Used to enable/disable ARP requests on this interface.</dd><dt><a class=permalink href=#IFF_DYING><code class=Dv id=IFF_DYING>IFF_DYING</code></a></dt><dd>⟨D*⟩ Set when the <var class=Vt>ifnet</var> structure of this interface is being released and still has <var class=Va>if_refcount</var> references.</dd><dt><a class=permalink href=#IFF_RENAMING><code class=Dv id=IFF_RENAMING>IFF_RENAMING</code></a></dt><dd>⟨D⟩ Set when this interface is being renamed.</dd></dl></div></section><section class=Ss><h2 class=Ss id=Interface_Capabilities_Flags><a class=permalink href=#Interface_Capabilities_Flags>Interface Capabilities Flags</a></h2> Interface capabilities are specialized features an interface may or may not support. These capabilities are very hardware-specific and allow, when enabled, to offload specific network processing to the interface or to offer a particular feature for use by other kernel parts. <p class=Pp>It should be stressed that a capability can be completely uncontrolled (i.e., stay always enabled with no way to disable it) or allow limited control over itself (e.g., depend on another capability's state.) Such peculiarities are determined solely by the hardware and driver of a particular interface. Only the driver possesses the knowledge on whether and how the interface capabilities can be controlled. Consequently, capabilities flags in <var class=Va>if_capenable</var> should never be modified directly by kernel code other than the interface driver. The command <code class=Dv>SIOCSIFCAP</code> to <code class=Fn>ifioctl</code>() is the dedicated means to attempt altering <var class=Va>if_capenable</var> on an interface. Userland code shall use <a class=Xr href=ioctl.2.html>ioctl(2)</a>.</p><p class=Pp>The following capabilities are currently supported by the system:</p><div class=Bd-indent><dl class=Bl-tag><dt><a class=permalink href=#IFCAP_RXCSUM><code class=Dv id=IFCAP_RXCSUM>IFCAP_RXCSUM</code></a></dt><dd>This interface can do checksum validation on receiving data. Some interfaces do not have sufficient buffer storage to store frames above a certain MTU-size completely. The driver for the interface might disable hardware checksum validation if the MTU is set above the hardcoded limit.</dd><dt><a class=permalink href=#IFCAP_TXCSUM><code class=Dv id=IFCAP_TXCSUM>IFCAP_TXCSUM</code></a></dt><dd>This interface can do checksum calculation on transmitting data.</dd><dt><a class=permalink href=#IFCAP_HWCSUM><code class=Dv id=IFCAP_HWCSUM>IFCAP_HWCSUM</code></a></dt><dd>A shorthand for (<code class=Dv>IFCAP_RXCSUM</code> | <code class=Dv>IFCAP_TXCSUM</code>).</dd><dt><a class=permalink href=#IFCAP_NETCONS><code class=Dv id=IFCAP_NETCONS>IFCAP_NETCONS</code></a></dt><dd>This interface can be a network console.</dd><dt><a class=permalink href=#IFCAP_VLAN_MTU><code class=Dv id=IFCAP_VLAN_MTU>IFCAP_VLAN_MTU</code></a></dt><dd>The <a class=Xr href=vlan.4.html>vlan(4)</a> driver can operate over this interface in software tagging mode without having to decrease MTU on <a class=Xr href=vlan.4.html>vlan(4)</a> interfaces below 1500 bytes. This implies the ability of this interface to cope with frames somewhat longer than permitted by the Ethernet specification.</dd><dt><a class=permalink href=#IFCAP_VLAN_HWTAGGING><code class=Dv id=IFCAP_VLAN_HWTAGGING>IFCAP_VLAN_HWTAGGING</code></a></dt><dd>This interface can do VLAN tagging on output and demultiplex frames by their VLAN tag on input.</dd><dt><a class=permalink href=#IFCAP_JUMBO_MTU><code class=Dv id=IFCAP_JUMBO_MTU>IFCAP_JUMBO_MTU</code></a></dt><dd>This Ethernet interface can transmit and receive frames up to 9000 bytes long.</dd><dt><a class=permalink href=#IFCAP_POLLING><code class=Dv id=IFCAP_POLLING>IFCAP_POLLING</code></a></dt><dd>This interface supports <a class=Xr href=polling.4.html>polling(4)</a>. See below for details.</dd><dt><a class=permalink href=#IFCAP_VLAN_HWCSUM><code class=Dv id=IFCAP_VLAN_HWCSUM>IFCAP_VLAN_HWCSUM</code></a></dt><dd>This interface can do checksum calculation on both transmitting and receiving data on <a class=Xr href=vlan.4.html>vlan(4)</a> interfaces (implies <code class=Dv>IFCAP_HWCSUM</code>).</dd><dt><a class=permalink href=#IFCAP_TSO4><code class=Dv id=IFCAP_TSO4>IFCAP_TSO4</code></a></dt><dd>This Ethernet interface supports TCP4 Segmentation offloading.</dd><dt><a class=permalink href=#IFCAP_TSO6><code class=Dv id=IFCAP_TSO6>IFCAP_TSO6</code></a></dt><dd>This Ethernet interface supports TCP6 Segmentation offloading.</dd><dt><a class=permalink href=#IFCAP_TSO><code class=Dv id=IFCAP_TSO>IFCAP_TSO</code></a></dt><dd>A shorthand for (<code class=Dv>IFCAP_TSO4</code> | <code class=Dv>IFCAP_TSO6</code>).</dd><dt><a class=permalink href=#IFCAP_TOE4><code class=Dv id=IFCAP_TOE4>IFCAP_TOE4</code></a></dt><dd>This Ethernet interface supports TCP offloading.</dd><dt><a class=permalink href=#IFCAP_TOE6><code class=Dv id=IFCAP_TOE6>IFCAP_TOE6</code></a></dt><dd>This Ethernet interface supports TCP6 offloading.</dd><dt><a class=permalink href=#IFCAP_TOE><code class=Dv id=IFCAP_TOE>IFCAP_TOE</code></a></dt><dd>A shorthand for (<code class=Dv>IFCAP_TOE4</code> | <code class=Dv>IFCAP_TOE6</code>).</dd><dt><a class=permalink href=#IFCAP_WOL_UCAST><code class=Dv id=IFCAP_WOL_UCAST>IFCAP_WOL_UCAST</code></a></dt><dd>This Ethernet interface supports waking up on any Unicast packet.</dd><dt><a class=permalink href=#IFCAP_WOL_MCAST><code class=Dv id=IFCAP_WOL_MCAST>IFCAP_WOL_MCAST</code></a></dt><dd>This Ethernet interface supports waking up on any Multicast packet.</dd><dt><a class=permalink href=#IFCAP_WOL_MAGIC><code class=Dv id=IFCAP_WOL_MAGIC>IFCAP_WOL_MAGIC</code></a></dt><dd>This Ethernet interface supports waking up on any Magic packet such as those sent by <a class=Xr href=wake.8.html>wake(8)</a>.</dd><dt><a class=permalink href=#IFCAP_WOL><code class=Dv id=IFCAP_WOL>IFCAP_WOL</code></a></dt><dd>A shorthand for (<code class=Dv>IFCAP_WOL_UCAST</code> | <code class=Dv>IFCAP_WOL_MCAST</code> | <code class=Dv>IFCAP_WOL_MAGIC</code>).</dd><dt><a class=permalink href=#IFCAP_TOE4_2><code class=Dv id=IFCAP_TOE4_2>IFCAP_TOE4</code></a></dt><dd>This Ethernet interface supports TCP4 Offload Engine.</dd><dt><a class=permalink href=#IFCAP_TOE6_2><code class=Dv id=IFCAP_TOE6_2>IFCAP_TOE6</code></a></dt><dd>This Ethernet interface supports TCP6 Offload Engine.</dd><dt><a class=permalink href=#IFCAP_TOE_2><code class=Dv id=IFCAP_TOE_2>IFCAP_TOE</code></a></dt><dd>A shorthand for (<code class=Dv>IFCAP_TOE4</code> | <code class=Dv>IFCAP_TOE6</code>).</dd><dt><a class=permalink href=#IFCAP_VLAN_HWFILTER><code class=Dv id=IFCAP_VLAN_HWFILTER>IFCAP_VLAN_HWFILTER</code></a></dt><dd>This interface supports frame filtering in hardware on <a class=Xr href=vlan.4.html>vlan(4)</a> interfaces.</dd><dt><a class=permalink href=#IFCAP_VLAN_HWTSO><code class=Dv id=IFCAP_VLAN_HWTSO>IFCAP_VLAN_HWTSO</code></a></dt><dd>This interface supports TCP Segmentation offloading on <a class=Xr href=vlan.4.html>vlan(4)</a> interfaces (implies <code class=Dv>IFCAP_TSO</code>).</dd><dt><a class=permalink href=#IFCAP_LINKSTATE><code class=Dv id=IFCAP_LINKSTATE>IFCAP_LINKSTATE</code></a></dt><dd>This Ethernet interface supports dynamic link state changes.</dd><dt><a class=permalink href=#IFCAP_NETMAP><code class=Dv id=IFCAP_NETMAP>IFCAP_NETMAP</code></a></dt><dd>This Ethernet interface supports <a class=Xr href=netmap.4.html>netmap(4)</a>.</dd></dl></div><p class=Pp>The ability of advanced network interfaces to offload certain computational tasks from the host CPU to the board is limited mostly to TCP/IP. Therefore a separate field associated with an interface (see <var class=Va>ifnet.if_data.ifi_hwassist</var> below) keeps a detailed description of its enabled capabilities specific to TCP/IP processing. The TCP/IP module consults the field to see which tasks can be done on an <i class=Em>outgoing</i> packet by the interface. The flags defined for that field are a superset of those for <var class=Va>mbuf.m_pkthdr.csum_flags</var>, namely:</p><div class=Bd-indent><dl class=Bl-tag><dt><a class=permalink href=#CSUM_IP><code class=Dv id=CSUM_IP>CSUM_IP</code></a></dt><dd>The interface will compute IP checksums.</dd><dt><a class=permalink href=#CSUM_TCP><code class=Dv id=CSUM_TCP>CSUM_TCP</code></a></dt><dd>The interface will compute TCP checksums.</dd><dt><a class=permalink href=#CSUM_UDP><code class=Dv id=CSUM_UDP>CSUM_UDP</code></a></dt><dd>The interface will compute UDP checksums.</dd></dl></div><p class=Pp>An interface notifies the TCP/IP module about the tasks the former has performed on an <i class=Em>incoming</i> packet by setting the corresponding flags in the field <var class=Va>mbuf.m_pkthdr.csum_flags</var> of the <var class=Vt>mbuf chain</var> containing the packet. See <a class=Xr href=mbuf.9.html>mbuf(9)</a> for details.</p><p class=Pp>The capability of a network interface to operate in <a class=Xr href=polling.4.html>polling(4)</a> mode involves several flags in different global variables and per-interface fields. The capability flag <code class=Dv>IFCAP_POLLING</code> set in interface's <var class=Va>if_capabilities</var> indicates support for <a class=Xr href=polling.4.html>polling(4)</a> on the particular interface. If set in <var class=Va>if_capabilities</var>, the same flag can be marked or cleared in the interface's <var class=Va>if_capenable</var> within <code class=Fn>ifioctl</code>(), thus initiating switch of the interface to <a class=Xr href=polling.4.html>polling(4)</a> mode or interrupt mode, respectively. The actual mode change is managed by the driver-specific <code class=Fn>if_ioctl</code>() routine. The <a class=Xr href=polling.4.html>polling(4)</a> handler returns the number of packets processed.</p></section><section class=Ss><h2 class=Ss id=The_if_data_Structure><a class=permalink href=#The_if_data_Structure>The if_data Structure</a></h2> The <var class=Vt>if_data</var> structure contains statistics and identifying information used by management programs, and which is exported to user programs by way of the <a class=Xr href=ifmib.4.html>ifmib(4)</a> branch of the <a class=Xr href=sysctl.3.html>sysctl(3)</a> MIB. The following elements of the <var class=Vt>if_data</var> structure are initialized by the interface and are not expected to change significantly over the course of normal operation: <div class=Bd-indent><dl class=Bl-tag><dt><var class=Va>ifi_type</var></dt><dd>(<var class=Vt>u_char</var>) The type of the interface, as defined in <code class=In>&lt;<a class=In href=../src/net/if_types.h.html>net/if_types.h</a>&gt;</code> and described below in the <a class=Sx href=#Interface_Types>Interface Types</a> section.</dd><dt><var class=Va>ifi_physical</var></dt><dd>(<var class=Vt>u_char</var>) Intended to represent a selection of physical layers on devices which support more than one; never implemented.</dd><dt><var class=Va>ifi_addrlen</var></dt><dd>(<var class=Vt>u_char</var>) Length of a link-layer address on this device, or zero if there are none. Used to initialized the address length field in <var class=Vt>sockaddr_dl</var> structures referring to this interface.</dd><dt><var class=Va>ifi_hdrlen</var></dt><dd>(<var class=Vt>u_char</var>) Maximum length of any link-layer header which might be prepended by the driver to a packet before transmission. The generic code computes the maximum over all interfaces and uses that value to influence the placement of data in <var class=Vt>mbuf</var>s to attempt to ensure that there is always sufficient space to prepend a link-layer header without allocating an additional <var class=Vt>mbuf</var>.</dd><dt><var class=Va>ifi_datalen</var></dt><dd>(<var class=Vt>u_char</var>) Length of the <var class=Vt>if_data</var> structure. Allows some stabilization of the routing socket ABI in the face of increases in the length of <var class=Vt>struct ifdata</var>.</dd><dt><var class=Va>ifi_mtu</var></dt><dd>(<var class=Vt>u_long</var>) The maximum transmission unit of the medium, exclusive of any link-layer overhead.</dd><dt><var class=Va>ifi_metric</var></dt><dd>(<var class=Vt>u_long</var>) A dimensionless metric interpreted by a user-mode routing process.</dd><dt><var class=Va>ifi_baudrate</var></dt><dd>(<var class=Vt>u_long</var>) The line rate of the interface, in bits per second.</dd><dt><var class=Va>ifi_hwassist</var></dt><dd>(<var class=Vt>u_long</var>) A detailed interpretation of the capabilities to offload computational tasks for <i class=Em>outgoing</i> packets. The interface driver must keep this field in accord with the current value of <var class=Va>if_capenable</var>.</dd><dt><var class=Va>ifi_epoch</var></dt><dd>(<var class=Vt>time_t</var>) The system uptime when interface was attached or the statistics below were reset. This is intended to be used to set the SNMP variable <var class=Va>ifCounterDiscontinuityTime</var>. It may also be used to determine if two successive queries for an interface of the same index have returned results for the same interface.</dd></dl></div><p class=Pp>The structure additionally contains generic statistics applicable to a variety of different interface types (except as noted, all members are of type <var class=Vt>u_long</var>):</p><div class=Bd-indent><dl class=Bl-tag><dt><var class=Va>ifi_link_state</var></dt><dd>(<var class=Vt>u_char</var>) The current link state of Ethernet interfaces. See the <a class=Sx href=#Interface_Link_States>Interface Link States</a> section for possible values.</dd><dt><var class=Va>ifi_ipackets</var></dt><dd>Number of packets received.</dd><dt><var class=Va>ifi_ierrors</var></dt><dd>Number of receive errors detected (e.g., FCS errors, DMA overruns, etc.). More detailed breakdowns can often be had by way of a link-specific MIB.</dd><dt><var class=Va>ifi_opackets</var></dt><dd>Number of packets transmitted.</dd><dt><var class=Va>ifi_oerrors</var></dt><dd>Number of output errors detected (e.g., late collisions, DMA overruns, etc.). More detailed breakdowns can often be had by way of a link-specific MIB.</dd><dt><var class=Va>ifi_collisions</var></dt><dd>Total number of collisions detected on output for CSMA interfaces. (This member is sometimes [ab]used by other types of interfaces for other output error counts.)</dd><dt><var class=Va>ifi_ibytes</var></dt><dd>Total traffic received, in bytes.</dd><dt><var class=Va>ifi_obytes</var></dt><dd>Total traffic transmitted, in bytes.</dd><dt><var class=Va>ifi_imcasts</var></dt><dd>Number of packets received which were sent by link-layer multicast.</dd><dt><var class=Va>ifi_omcasts</var></dt><dd>Number of packets sent by link-layer multicast.</dd><dt><var class=Va>ifi_iqdrops</var></dt><dd>Number of packets dropped on input. Rarely implemented.</dd><dt><var class=Va>ifi_oqdrops</var></dt><dd>Number of packets dropped on output.</dd><dt><var class=Va>ifi_noproto</var></dt><dd>Number of packets received for unknown network-layer protocol.</dd><dt><var class=Va>ifi_lastchange</var></dt><dd>(<var class=Vt>struct timeval</var>) The time of the last administrative change to the interface (as required for SNMP).</dd></dl></div></section><section class=Ss><h2 class=Ss id=Interface_Types><a class=permalink href=#Interface_Types>Interface Types</a></h2> The header file <code class=In>&lt;<a class=In href=../src/net/if_types.h.html>net/if_types.h</a>&gt;</code> defines symbolic constants for a number of different types of interfaces. The most common are: <p class=Pp></p><div class=Bd-indent><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#IFT_OTHER><code class=Dv id=IFT_OTHER>IFT_OTHER</code></a></dt><dd>none of the following</dd><dt><a class=permalink href=#IFT_ETHER><code class=Dv id=IFT_ETHER>IFT_ETHER</code></a></dt><dd>Ethernet</dd><dt><a class=permalink href=#IFT_ISO88023><code class=Dv id=IFT_ISO88023>IFT_ISO88023</code></a></dt><dd>ISO 8802-3 CSMA/CD</dd><dt><a class=permalink href=#IFT_ISO88024><code class=Dv id=IFT_ISO88024>IFT_ISO88024</code></a></dt><dd>ISO 8802-4 Token Bus</dd><dt><a class=permalink href=#IFT_ISO88025><code class=Dv id=IFT_ISO88025>IFT_ISO88025</code></a></dt><dd>ISO 8802-5 Token Ring</dd><dt><a class=permalink href=#IFT_ISO88026><code class=Dv id=IFT_ISO88026>IFT_ISO88026</code></a></dt><dd>ISO 8802-6 DQDB MAN</dd><dt><a class=permalink href=#IFT_FDDI><code class=Dv id=IFT_FDDI>IFT_FDDI</code></a></dt><dd>FDDI</dd><dt><a class=permalink href=#IFT_PPP><code class=Dv id=IFT_PPP>IFT_PPP</code></a></dt><dd>Internet Point-to-Point Protocol (<a class=Xr href=ppp.8.html>ppp(8)</a>)</dd><dt><a class=permalink href=#IFT_LOOP><code class=Dv id=IFT_LOOP>IFT_LOOP</code></a></dt><dd>The loopback (<a class=Xr href=lo.4.html>lo(4)</a>) interface</dd><dt><a class=permalink href=#IFT_SLIP><code class=Dv id=IFT_SLIP>IFT_SLIP</code></a></dt><dd>Serial Line IP</dd><dt><a class=permalink href=#IFT_PARA><code class=Dv id=IFT_PARA>IFT_PARA</code></a></dt><dd>Parallel-port IP (“PLIP”)</dd><dt><a class=permalink href=#IFT_ATM><code class=Dv id=IFT_ATM>IFT_ATM</code></a></dt><dd>Asynchronous Transfer Mode</dd><dt><a class=permalink href=#IFT_USB><code class=Dv id=IFT_USB>IFT_USB</code></a></dt><dd>USB Interface</dd></dl></div></section><section class=Ss><h2 class=Ss id=Interface_Link_States><a class=permalink href=#Interface_Link_States>Interface Link States</a></h2> The following link states are currently defined: <p class=Pp></p><div class=Bd-indent><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#LINK_STATE_UNKNOWN><code class=Dv id=LINK_STATE_UNKNOWN>LINK_STATE_UNKNOWN</code></a></dt><dd>The link is in an invalid or unknown state.</dd><dt><a class=permalink href=#LINK_STATE_DOWN><code class=Dv id=LINK_STATE_DOWN>LINK_STATE_DOWN</code></a></dt><dd>The link is down.</dd><dt><a class=permalink href=#LINK_STATE_UP><code class=Dv id=LINK_STATE_UP>LINK_STATE_UP</code></a></dt><dd>The link is up.</dd></dl></div></section><section class=Ss><h2 class=Ss id=The_ifaddr_Structure><a class=permalink href=#The_ifaddr_Structure>The ifaddr Structure</a></h2> Every interface is associated with a list (or, rather, a <code class=Li>TAILQ</code>) of addresses, rooted at the interface structure's <var class=Va>if_addrhead</var> member. The first element in this list is always an <code class=Dv>AF_LINK</code> address representing the interface itself; multi-access network drivers should complete this structure by filling in their link-layer addresses after calling <code class=Fn>if_attach</code>(). Other members of the structure represent network-layer addresses which have been configured by means of the <code class=Dv>SIOCAIFADDR</code> command to <a class=Xr href=ioctl.2.html>ioctl(2)</a>, called on a socket of the appropriate protocol family. The elements of this list consist of <var class=Vt>ifaddr</var> structures. Most protocols will declare their own protocol-specific interface address structures, but all begin with a <var class=Vt>struct ifaddr</var> which provides the most-commonly-needed functionality across all protocols. Interface addresses are reference-counted. <p class=Pp>The members of <var class=Vt>struct ifaddr</var> are as follows:</p><div class=Bd-indent><dl class=Bl-tag><dt><var class=Va>ifa_addr</var></dt><dd>(<var class=Vt>struct sockaddr *</var>) The local address of the interface.</dd><dt><var class=Va>ifa_dstaddr</var></dt><dd>(<var class=Vt>struct sockaddr *</var>) The remote address of point-to-point interfaces, and the broadcast address of broadcast interfaces. (<var class=Va>ifa_broadaddr</var> is a macro for <var class=Va>ifa_dstaddr</var>.)</dd><dt><var class=Va>ifa_netmask</var></dt><dd>(<var class=Vt>struct sockaddr *</var>) The network mask for multi-access interfaces, and the confusion generator for point-to-point interfaces.</dd><dt><var class=Va>ifa_ifp</var></dt><dd>(<var class=Vt>struct ifnet *</var>) A link back to the interface structure.</dd><dt><var class=Va>ifa_link</var></dt><dd>(<code class=Fn>TAILQ_ENTRY</code>(<var class=Fa>ifaddr</var>)) <a class=Xr href=queue.3.html>queue(3)</a> glue for list of addresses on each interface.</dd><dt><var class=Va>ifa_rtrequest</var></dt><dd>See below.</dd><dt><var class=Va>ifa_flags</var></dt><dd>(<var class=Vt>u_short</var>) Some of the flags which would be used for a route representing this address in the route table.</dd><dt><var class=Va>ifa_refcnt</var></dt><dd>(<var class=Vt>short</var>) The reference count.</dd></dl></div><p class=Pp>References to <var class=Vt>ifaddr</var> structures are gained by calling the <code class=Fn>ifa_ref</code>() function and released by calling the <code class=Fn>ifa_free</code>() function.</p><p class=Pp><code class=Fn>ifa_rtrequest</code>() is a pointer to a function which receives callouts from the routing code (<code class=Fn>rtrequest</code>()) to perform link-layer-specific actions upon requests to add, or delete routes. The <var class=Fa>cmd</var> argument indicates the request in question: <code class=Dv>RTM_ADD</code>, or <code class=Dv>RTM_DELETE</code>. The <var class=Fa>rt</var> argument is the route in question; the <var class=Fa>info</var> argument contains the specific destination being manipulated.</p></section></section><section class=Sh><h2 class=Sh id=FUNCTIONS><a class=permalink href=#FUNCTIONS>FUNCTIONS</a></h2> The functions provided by the generic interface code can be divided into two groups: those which manipulate interfaces, and those which manipulate interface addresses. In addition to these functions, there may also be link-layer support routines which are used by a number of drivers implementing a specific link layer over different hardware; see the documentation for that link layer for more details. <section class=Ss><h2 class=Ss id=The_ifmultiaddr_Structure><a class=permalink href=#The_ifmultiaddr_Structure>The ifmultiaddr Structure</a></h2> Every multicast-capable interface is associated with a list of multicast group memberships, which indicate at a low level which link-layer multicast addresses (if any) should be accepted, and at a high level, in which network-layer multicast groups a user process has expressed interest. <p class=Pp>The elements of the structure are as follows:</p><div class=Bd-indent><dl class=Bl-tag><dt><var class=Va>ifma_link</var></dt><dd>(<code class=Fn>LIST_ENTRY</code>(<var class=Fa>ifmultiaddr</var>)) <a class=Xr href=queue.3.html>queue(3)</a> macro glue.</dd><dt><var class=Va>ifma_addr</var></dt><dd>(<var class=Vt>struct sockaddr *</var>) A pointer to the address which this record represents. The memberships for various address families are stored in arbitrary order.</dd><dt><var class=Va>ifma_lladdr</var></dt><dd>(<var class=Vt>struct sockaddr *</var>) A pointer to the link-layer multicast address, if any, to which the network-layer multicast address in <var class=Va>ifma_addr</var> is mapped, else a null pointer. If this element is non-nil, this membership also holds an invisible reference to another membership for that link-layer address.</dd><dt><var class=Va>ifma_refcount</var></dt><dd>(<var class=Vt>u_int</var>) A reference count of requests for this particular membership.</dd></dl></div></section><section class=Ss><h2 class=Ss id=Interface_Manipulation_Functions_2><a class=permalink href=#Interface_Manipulation_Functions_2>Interface Manipulation Functions</a></h2><dl class="Bl-ohang Bd-indent"><dt><code class=Fn>if_alloc</code>()</dt><dd>Allocate and initialize <var class=Vt>struct ifnet</var>. Initialization includes the allocation of an interface index and may include the allocation of a <var class=Fa>type</var> specific structure in <var class=Va>if_l2com</var>.</dd><dt><code class=Fn>if_attach</code>()</dt><dd>Link the specified interface <var class=Fa>ifp</var> into the list of network interfaces. Also initialize the list of addresses on that interface, and create a link-layer <var class=Vt>ifaddr</var> structure to be the first element in that list. (A pointer to this address structure is saved in the <var class=Vt>ifnet</var> structure and is accessed by the <code class=Fn>ifaddr_byindex</code>() function.) The <var class=Fa>ifp</var> must have been allocated by <code class=Fn>if_alloc</code>().</dd><dt><code class=Fn>if_detach</code>()</dt><dd>Shut down and unlink the specified <var class=Fa>ifp</var> from the interface list.</dd><dt><code class=Fn>if_free</code>()</dt><dd>Free the given <var class=Fa>ifp</var> back to the system. The interface must have been previously detached if it was ever attached.</dd><dt><code class=Fn>if_free_type</code>()</dt><dd>Identical to <code class=Fn>if_free</code>() except that the given <var class=Fa>type</var> is used to free <var class=Va>if_l2com</var> instead of the type in <var class=Va>if_type</var>. This is intended for use with drivers that change their interface type.</dd><dt><code class=Fn>if_down</code>()</dt><dd>Mark the interface <var class=Fa>ifp</var> as down (i.e., <code class=Dv>IFF_UP</code> is not set), flush its output queue, notify protocols of the transition, and generate a message from the <a class=Xr href=route.4.html>route(4)</a> routing socket.</dd><dt><code class=Fn>if_up</code>()</dt><dd>Mark the interface <var class=Fa>ifp</var> as up, notify protocols of the transition, and generate a message from the <a class=Xr href=route.4.html>route(4)</a> routing socket.</dd><dt><code class=Fn>ifpromisc</code>()</dt><dd>Add or remove a promiscuous reference to <var class=Fa>ifp</var>. If <var class=Fa>pswitch</var> is true, add a reference; if it is false, remove a reference. On reference count transitions from zero to one and one to zero, set the <code class=Dv>IFF_PROMISC</code> flag appropriately and call <code class=Fn>if_ioctl</code>() to set up the interface in the desired mode.</dd><dt><code class=Fn>if_allmulti</code>()</dt><dd>As <code class=Fn>ifpromisc</code>(), but for the all-multicasts (<code class=Dv>IFF_ALLMULTI</code>) flag instead of the promiscuous flag.</dd><dt><code class=Fn>ifunit</code>()</dt><dd>Return an <var class=Vt>ifnet</var> pointer for the interface named <var class=Fa>name</var>.</dd><dt><code class=Fn>ifunit_ref</code>()</dt><dd>Return a reference-counted (via <code class=Fn>ifa_ref</code>()) <var class=Vt>ifnet</var> pointer for the interface named <var class=Fa>name</var>. This is the preferred function over <code class=Fn>ifunit</code>(). The caller is responsible for releasing the reference with <code class=Fn>if_rele</code>() when it is finished with the ifnet.</dd><dt><code class=Fn>ifioctl</code>()</dt><dd>Process the ioctl request <var class=Fa>cmd</var>, issued on socket <var class=Fa>so</var> by thread <var class=Fa>td</var>, with data parameter <var class=Fa>data</var>. This is the main routine for handling all interface configuration requests from user mode. It is ordinarily only called from the socket-layer <a class=Xr href=ioctl.2.html>ioctl(2)</a> handler, and only for commands with class ‘<code class=Li>i</code>’. Any unrecognized commands will be passed down to socket <var class=Fa>so</var>'s protocol for further interpretation. The following commands are handled by <code class=Fn>ifioctl</code>(): <p class=Pp></p><div class=Bd-indent><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#SIOCGIFCONF><code class=Dv id=SIOCGIFCONF>SIOCGIFCONF</code></a></dt><dd>Get interface configuration. (No call-down to driver.) <p class=Pp></p></dd><dt><a class=permalink href=#SIOCSIFNAME><code class=Dv id=SIOCSIFNAME>SIOCSIFNAME</code></a></dt><dd>Set the interface name. <code class=Dv>RTM_IFANNOUNCE</code> departure and arrival messages are sent so that routing code that relies on the interface name will update its interface list. Caller must have appropriate privilege. (No call-down to driver.)</dd><dt><a class=permalink href=#SIOCGIFCAP><code class=Dv id=SIOCGIFCAP>SIOCGIFCAP</code></a></dt><dd style="width: auto;"> </dd><dt><a class=permalink href=#SIOCGIFFIB><code class=Dv id=SIOCGIFFIB>SIOCGIFFIB</code></a></dt><dd style="width: auto;"> </dd><dt><a class=permalink href=#SIOCGIFFLAGS><code class=Dv id=SIOCGIFFLAGS>SIOCGIFFLAGS</code></a></dt><dd style="width: auto;"> </dd><dt><a class=permalink href=#SIOCGIFMETRIC><code class=Dv id=SIOCGIFMETRIC>SIOCGIFMETRIC</code></a></dt><dd style="width: auto;"> </dd><dt><a class=permalink href=#SIOCGIFMTU><code class=Dv id=SIOCGIFMTU>SIOCGIFMTU</code></a></dt><dd style="width: auto;"> </dd><dt><a class=permalink href=#SIOCGIFPHYS><code class=Dv id=SIOCGIFPHYS>SIOCGIFPHYS</code></a></dt><dd>Get interface capabilities, FIB, flags, metric, MTU, medium selection. (No call-down to driver.) <p class=Pp></p></dd><dt><a class=permalink href=#SIOCSIFCAP><code class=Dv id=SIOCSIFCAP>SIOCSIFCAP</code></a></dt><dd>Enable or disable interface capabilities. Caller must have appropriate privilege. Before a call to the driver-specific <code class=Fn>if_ioctl</code>() routine, the requested mask for enabled capabilities is checked against the mask of capabilities supported by the interface, <var class=Va>if_capabilities</var>. Requesting to enable an unsupported capability is invalid. The rest is supposed to be done by the driver, which includes updating <var class=Va>if_capenable</var> and <var class=Va>if_data.ifi_hwassist</var> appropriately. <p class=Pp></p></dd><dt><a class=permalink href=#SIOCSIFFIB><code class=Dv id=SIOCSIFFIB>SIOCSIFFIB</code></a></dt><dd>Sets interface FIB. Caller must have appropriate privilege. FIB values start at 0 and values greater or equals than <var class=Va>net.fibs</var> are considered invalid.</dd><dt><a class=permalink href=#SIOCSIFFLAGS><code class=Dv id=SIOCSIFFLAGS>SIOCSIFFLAGS</code></a></dt><dd>Change interface flags. Caller must have appropriate privilege. If a change to the <code class=Dv>IFF_UP</code> flag is requested, <code class=Fn>if_up</code>() or <code class=Fn>if_down</code>() is called as appropriate. Flags listed in <code class=Dv>IFF_CANTCHANGE</code> are masked off, and the field <var class=Va>if_flags</var> in the interface structure is updated. Finally, the driver <code class=Fn>if_ioctl</code>() routine is called to perform any setup requested. <p class=Pp></p></dd><dt><a class=permalink href=#SIOCSIFMETRIC><code class=Dv id=SIOCSIFMETRIC>SIOCSIFMETRIC</code></a></dt><dd style="width: auto;"> </dd><dt><a class=permalink href=#SIOCSIFPHYS><code class=Dv id=SIOCSIFPHYS>SIOCSIFPHYS</code></a></dt><dd>Change interface metric or medium. Caller must have appropriate privilege. <p class=Pp></p></dd><dt><a class=permalink href=#SIOCSIFMTU><code class=Dv id=SIOCSIFMTU>SIOCSIFMTU</code></a></dt><dd>Change interface MTU. Caller must have appropriate privilege. MTU values less than 72 or greater than 65535 are considered invalid. The driver <code class=Fn>if_ioctl</code>() routine is called to implement the change; it is responsible for any additional sanity checking and for actually modifying the MTU in the interface structure. <p class=Pp></p></dd><dt><a class=permalink href=#SIOCADDMULTI><code class=Dv id=SIOCADDMULTI>SIOCADDMULTI</code></a></dt><dd style="width: auto;"> </dd><dt><a class=permalink href=#SIOCDELMULTI><code class=Dv id=SIOCDELMULTI>SIOCDELMULTI</code></a></dt><dd>Add or delete permanent multicast group memberships on the interface. Caller must have appropriate privilege. The <code class=Fn>if_addmulti</code>() or <code class=Fn>if_delmulti</code>() function is called to perform the operation; qq.v. <p class=Pp></p></dd><dt><a class=permalink href=#SIOCAIFADDR><code class=Dv id=SIOCAIFADDR>SIOCAIFADDR</code></a></dt><dd style="width: auto;"> </dd><dt><a class=permalink href=#SIOCDIFADDR><code class=Dv id=SIOCDIFADDR>SIOCDIFADDR</code></a></dt><dd>The socket's protocol control routine is called to implement the requested action.</dd></dl></div></dd></dl><p class=Pp><code class=Fn>if_down</code>(), <code class=Fn>ifioctl</code>(), <code class=Fn>ifpromisc</code>(), and <code class=Fn>if_up</code>() must be called at <code class=Fn>splnet</code>() or higher.</p></section><section class=Ss><h2 class=Ss id=Interface_Address_Functions_2><a class=permalink href=#Interface_Address_Functions_2>Interface Address Functions</a></h2> Several functions exist to look up an interface address structure given an address. <code class=Fn>ifa_ifwithaddr</code>() returns an interface address with either a local address or a broadcast address precisely matching the parameter <var class=Fa>addr</var>. <code class=Fn>ifa_ifwithdstaddr</code>() returns an interface address for a point-to-point interface whose remote (“destination”) address is <var class=Fa>addr</var> and a fib is <var class=Fa>fib</var>. If <var class=Fa>fib</var> is <code class=Dv>RT_ALL_FIBS</code>, then the first interface address matching <var class=Fa>addr</var> will be returned. <p class=Pp><code class=Fn>ifa_ifwithnet</code>() returns the most specific interface address which matches the specified address, <var class=Fa>addr</var>, subject to its configured netmask, or a point-to-point interface address whose remote address is <var class=Fa>addr</var> if one is found. If <var class=Fa>ignore_ptp</var> is true, skip point-to-point interface addresses. The <var class=Fa>fib</var> parameter is handled the same way as by <code class=Fn>ifa_ifwithdstaddr</code>().</p><p class=Pp><code class=Fn>ifaof_ifpforaddr</code>() returns the most specific address configured on interface <var class=Fa>ifp</var> which matches address <var class=Fa>addr</var>, subject to its configured netmask. If the interface is point-to-point, only an interface address whose remote address is precisely <var class=Fa>addr</var> will be returned.</p><p class=Pp><code class=Fn>ifaddr_byindex</code>() returns the link-level address of the interface with the given index <var class=Fa>idx</var>.</p><p class=Pp>All of these functions return a null pointer if no such address can be found.</p></section><section class=Ss><h2 class=Ss id=Interface_Multicast_Address_Functions_2><a class=permalink href=#Interface_Multicast_Address_Functions_2>Interface Multicast Address Functions</a></h2> The <code class=Fn>if_addmulti</code>(), <code class=Fn>if_delmulti</code>(), and <code class=Fn>if_findmulti</code>() functions provide support for requesting and relinquishing multicast group memberships, and for querying an interface's membership list, respectively. The <code class=Fn>if_addmulti</code>() function takes a pointer to an interface, <var class=Fa>ifp</var>, and a generic address, <var class=Fa>sa</var>. It also takes a pointer to a <var class=Vt>struct ifmultiaddr *</var> which is filled in on successful return with the address of the group membership control block. The <code class=Fn>if_addmulti</code>() function performs the following four-step process: <ol class="Bl-enum Bd-indent"><li>Call the interface's <code class=Fn>if_resolvemulti</code>() entry point to determine the link-layer address, if any, corresponding to this membership request, and also to give the link layer an opportunity to veto this membership request should it so desire.</li><li>Check the interface's group membership list for a pre-existing membership for this group. If one is not found, allocate a new one; if one is, increment its reference count.</li><li>If the <code class=Fn>if_resolvemulti</code>() routine returned a link-layer address corresponding to the group, repeat the previous step for that address as well.</li><li>If the interface's multicast address filter needs to be changed because a new membership was added, call the interface's <code class=Fn>if_ioctl</code>() routine (with a <var class=Fa>cmd</var> argument of <code class=Dv>SIOCADDMULTI</code>) to request that it do so.</li></ol><p class=Pp>The <code class=Fn>if_delmulti</code>() function, given an interface <var class=Fa>ifp</var> and an address, <var class=Fa>sa</var>, reverses this process. Both functions return zero on success, or a standard error number on failure.</p><p class=Pp>The <code class=Fn>if_findmulti</code>() function examines the membership list of interface <var class=Fa>ifp</var> for an address matching <var class=Fa>sa</var>, and returns a pointer to that <var class=Vt>struct ifmultiaddr</var> if one is found, else it returns a null pointer.</p></section></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=ioctl.2.html>ioctl(2)</a>, <a class=Xr href=link_addr.3.html>link_addr(3)</a>, <a class=Xr href=queue.3.html>queue(3)</a>, <a class=Xr href=sysctl.3.html>sysctl(3)</a>, <a class=Xr href=bpf.4.html>bpf(4)</a>, <a class=Xr href=ifmib.4.html>ifmib(4)</a>, <a class=Xr href=lo.4.html>lo(4)</a>, <a class=Xr href=netintro.4.html>netintro(4)</a>, <a class=Xr href=polling.4.html>polling(4)</a>, <a class=Xr href=config.8.html>config(8)</a>, <a class=Xr href=ppp.8.html>ppp(8)</a>, <a class=Xr href=mbuf.9.html>mbuf(9)</a>, <a class=Xr href=rtentry.9.html>rtentry(9)</a><p class=Pp><cite class=Rs><span class=RsA>Gary R. Wright</span> and <span class=RsA>W. Richard Stevens</span>, <i class=RsB>TCP/IP Illustrated</i>, <span class=RsV>Vol. 2</span>, <span class=RsO>Addison-Wesley, ISBN 0-201-63354-X</span>.</cite></p></section><section class=Sh><h2 class=Sh id=AUTHORS><a class=permalink href=#AUTHORS>AUTHORS</a></h2> This manual page was written by <span class=An>Garrett A. Wollman</span>. </section></div><table class=foot><tr><td class=foot-date>November 14, 2018</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>