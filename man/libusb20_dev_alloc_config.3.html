<!DOCTYPE html>
<html><head><meta charset=utf-8><title>libusb20_dev_alloc_config(3)</title><keywords content=man,libusb20_dev_alloc_config></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>libusb20_dev_alloc_config(3)</h1><table class=head><tr><td class=head-ltitle>LIBUSB20(3)</td><td class=head-vol>FreeBSD Library Functions Manual</td><td class=head-rtitle>LIBUSB20(3)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>libusb20</code> — <div class=Nd>USB access library</div></section><section class=Sh><h2 class=Sh id=LIBRARY><a class=permalink href=#LIBRARY>LIBRARY</a></h2> USB access library (libusb -lusb) </section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/libusb20.h.html>libusb20.h</a>&gt;</code><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_tr_close</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_tr_open</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>, <var class=Fa style="white-space: nowrap;">uint32_t max_buf_size</var>, <var class=Fa style="white-space: nowrap;">uint32_t max_frame_count</var>, <var class=Fa style="white-space: nowrap;">uint8_t ep_no</var>);</p><p class=Pp><code class=Fn>libusb20_tr_open_stream</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>, <var class=Fa style="white-space: nowrap;">uint32_t max_buf_size</var>, <var class=Fa style="white-space: nowrap;">uint32_t max_frame_count</var>, <var class=Fa style="white-space: nowrap;">uint8_t ep_no</var>, <var class=Fa style="white-space: nowrap;">uint16_t stream_id</var>);</p><p class=Pp><var class=Ft>struct libusb20_transfer*</var><br><code class=Fn>libusb20_tr_get_pointer</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>, <var class=Fa style="white-space: nowrap;">uint16_t tr_index</var>);</p><p class=Pp><var class=Ft>uint16_t</var><br><code class=Fn>libusb20_tr_get_time_complete</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>);</p><p class=Pp><var class=Ft>uint32_t</var><br><code class=Fn>libusb20_tr_get_actual_frames</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>);</p><p class=Pp><var class=Ft>uint32_t</var><br><code class=Fn>libusb20_tr_get_actual_length</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>);</p><p class=Pp><var class=Ft>uint32_t</var><br><code class=Fn>libusb20_tr_get_max_frames</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>);</p><p class=Pp><var class=Ft>uint32_t</var><br><code class=Fn>libusb20_tr_get_max_packet_length</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>);</p><p class=Pp><var class=Ft>uint32_t</var><br><code class=Fn>libusb20_tr_get_max_total_length</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>);</p><p class=Pp><var class=Ft>uint8_t</var><br><code class=Fn>libusb20_tr_get_status</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>);</p><p class=Pp><var class=Ft>uint8_t</var><br><code class=Fn>libusb20_tr_pending</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>libusb20_tr_callback_wrapper</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>libusb20_tr_clear_stall_sync</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>libusb20_tr_drain</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>libusb20_tr_set_buffer</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>, <var class=Fa style="white-space: nowrap;">void *buffer</var>, <var class=Fa style="white-space: nowrap;">uint16_t fr_index</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>libusb20_tr_set_callback</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>, <var class=Fa style="white-space: nowrap;">libusb20_tr_callback_t *cb</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>libusb20_tr_set_flags</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>, <var class=Fa style="white-space: nowrap;">uint8_t flags</var>);</p><p class=Pp><var class=Ft>uint32_t</var><br><code class=Fn>libusb20_tr_get_length</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>, <var class=Fa style="white-space: nowrap;">uint16_t fr_index</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>libusb20_tr_set_length</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>, <var class=Fa style="white-space: nowrap;">uint32_t length</var>, <var class=Fa style="white-space: nowrap;">uint16_t fr_index</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>libusb20_tr_set_priv_sc0</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>, <var class=Fa style="white-space: nowrap;">void *sc0</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>libusb20_tr_set_priv_sc1</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>, <var class=Fa style="white-space: nowrap;">void *sc1</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>libusb20_tr_set_timeout</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>, <var class=Fa style="white-space: nowrap;">uint32_t timeout</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>libusb20_tr_set_total_frames</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>, <var class=Fa style="white-space: nowrap;">uint32_t nframes</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>libusb20_tr_setup_bulk</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>, <var class=Fa style="white-space: nowrap;">void *pbuf</var>, <var class=Fa style="white-space: nowrap;">uint32_t length</var>, <var class=Fa style="white-space: nowrap;">uint32_t timeout</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>libusb20_tr_setup_control</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>, <var class=Fa style="white-space: nowrap;">void *psetup</var>, <var class=Fa style="white-space: nowrap;">void *pbuf</var>, <var class=Fa style="white-space: nowrap;">uint32_t timeout</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>libusb20_tr_setup_intr</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>, <var class=Fa style="white-space: nowrap;">void *pbuf</var>, <var class=Fa style="white-space: nowrap;">uint32_t length</var>, <var class=Fa style="white-space: nowrap;">uint32_t timeout</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>libusb20_tr_setup_isoc</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>, <var class=Fa style="white-space: nowrap;">void *pbuf</var>, <var class=Fa style="white-space: nowrap;">uint32_t length</var>, <var class=Fa style="white-space: nowrap;">uint61_t fr_index</var>);</p><p class=Pp><var class=Ft>uint8_t</var><br><code class=Fn>libusb20_tr_bulk_intr_sync</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>, <var class=Fa style="white-space: nowrap;">void *pbuf</var>, <var class=Fa style="white-space: nowrap;">uint32_t length</var>, <var class=Fa style="white-space: nowrap;">uint32_t *pactlen</var>, <var class=Fa style="white-space: nowrap;">uint32_t timeout</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>libusb20_tr_start</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>libusb20_tr_stop</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>libusb20_tr_submit</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>);</p><p class=Pp><var class=Ft>void *</var><br><code class=Fn>libusb20_tr_get_priv_sc0</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>);</p><p class=Pp><var class=Ft>void *</var><br><code class=Fn>libusb20_tr_get_priv_sc1</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_transfer *xfer</var>);</p><p class=Pp><var class=Ft>const char *</var><br><code class=Fn>libusb20_dev_get_backend_name</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_dev_get_port_path</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>, <var class=Fa style="white-space: nowrap;">uint8_t *buf</var>, <var class=Fa style="white-space: nowrap;">uint8_t bufsize</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_dev_get_info</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>, <var class=Fa style="white-space: nowrap;">struct usb_device_info *pinfo</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_dev_get_iface_desc</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>, <var class=Fa style="white-space: nowrap;">uint8_t iface_index</var>, <var class=Fa style="white-space: nowrap;">char *buf</var>, <var class=Fa style="white-space: nowrap;">uint8_t len</var>);</p><p class=Pp><var class=Ft>const char *</var><br><code class=Fn>libusb20_dev_get_desc</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_dev_get_stats</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>, <var class=Fa style="white-space: nowrap;">struct libusb20_device_stats *pstats</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_dev_close</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_dev_detach_kernel_driver</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>, <var class=Fa style="white-space: nowrap;">uint8_t iface_index</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_dev_set_config_index</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>, <var class=Fa style="white-space: nowrap;">uint8_t configIndex</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_dev_get_debug</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_dev_get_fd</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_dev_kernel_driver_active</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>, <var class=Fa style="white-space: nowrap;">uint8_t iface_index</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_dev_open</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>, <var class=Fa style="white-space: nowrap;">uint16_t transfer_max</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_dev_process</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_dev_request_sync</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>, <var class=Fa style="white-space: nowrap;">struct LIBUSB20_CONTROL_SETUP_DECODED *setup</var>, <var class=Fa style="white-space: nowrap;">void *data</var>, <var class=Fa style="white-space: nowrap;">uint16_t *pactlen</var>, <var class=Fa style="white-space: nowrap;">uint32_t timeout</var>, <var class=Fa style="white-space: nowrap;">uint8_t flags</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_dev_req_string_sync</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>, <var class=Fa style="white-space: nowrap;">uint8_t index</var>, <var class=Fa style="white-space: nowrap;">uint16_t langid</var>, <var class=Fa style="white-space: nowrap;">void *ptr</var>, <var class=Fa style="white-space: nowrap;">uint16_t len</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_dev_req_string_simple_sync</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>, <var class=Fa style="white-space: nowrap;">uint8_t index</var>, <var class=Fa style="white-space: nowrap;">void *ptr</var>, <var class=Fa style="white-space: nowrap;">uint16_t len</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_dev_reset</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_dev_check_connected</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_dev_set_power_mode</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>, <var class=Fa style="white-space: nowrap;">uint8_t power_mode</var>);</p><p class=Pp><var class=Ft>uint8_t</var><br><code class=Fn>libusb20_dev_get_power_mode</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>);</p><p class=Pp><var class=Ft>uint16_t</var><br><code class=Fn>libusb20_dev_get_power_usage</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_dev_set_alt_index</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>, <var class=Fa style="white-space: nowrap;">uint8_t iface_index</var>, <var class=Fa style="white-space: nowrap;">uint8_t alt_index</var>);</p><p class=Pp><var class=Ft>struct LIBUSB20_DEVICE_DESC_DECODED *</var><br><code class=Fn>libusb20_dev_get_device_desc</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>);</p><p class=Pp><var class=Ft>struct libusb20_config *</var><br><code class=Fn>libusb20_dev_alloc_config</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>, <var class=Fa style="white-space: nowrap;">uint8_t config_index</var>);</p><p class=Pp><var class=Ft>struct libusb20_device *</var><br><code class=Fn>libusb20_dev_alloc</code>(<var class=Fa style="white-space: nowrap;">void</var>);</p><p class=Pp><var class=Ft>uint8_t</var><br><code class=Fn>libusb20_dev_get_address</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>);</p><p class=Pp><var class=Ft>uint8_t</var><br><code class=Fn>libusb20_dev_get_parent_address</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>);</p><p class=Pp><var class=Ft>uint8_t</var><br><code class=Fn>libusb20_dev_get_parent_port</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>);</p><p class=Pp><var class=Ft>uint8_t</var><br><code class=Fn>libusb20_dev_get_bus_number</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>);</p><p class=Pp><var class=Ft>uint8_t</var><br><code class=Fn>libusb20_dev_get_mode</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>);</p><p class=Pp><var class=Ft>uint8_t</var><br><code class=Fn>libusb20_dev_get_speed</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>);</p><p class=Pp><var class=Ft>uint8_t</var><br><code class=Fn>libusb20_dev_get_config_index</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>libusb20_dev_free</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>libusb20_dev_set_debug</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>, <var class=Fa style="white-space: nowrap;">int debug</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>libusb20_dev_wait_process</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>, <var class=Fa style="white-space: nowrap;">int timeout</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_be_get_template</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_backend *pbe</var>, <var class=Fa style="white-space: nowrap;">int *ptemp</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_be_set_template</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_backend *pbe</var>, <var class=Fa style="white-space: nowrap;">int temp</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_be_get_dev_quirk</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_backend *pber</var>, <var class=Fa style="white-space: nowrap;">uint16_t index</var>, <var class=Fa style="white-space: nowrap;">struct libusb20_quirk *pq</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_be_get_quirk_name</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_backend *pbe</var>, <var class=Fa style="white-space: nowrap;">uint16_t index</var>, <var class=Fa style="white-space: nowrap;">struct libusb20_quirk *pq</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_be_add_dev_quirk</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_backend *pbe</var>, <var class=Fa style="white-space: nowrap;">struct libusb20_quirk *pq</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>libusb20_be_remove_dev_quirk</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_backend *pbe</var>, <var class=Fa style="white-space: nowrap;">struct libusb20_quirk *pq</var>);</p><p class=Pp><var class=Ft>struct libusb20_backend *</var><br><code class=Fn>libusb20_be_alloc_default</code>(<var class=Fa style="white-space: nowrap;">void</var>);</p><p class=Pp><var class=Ft>struct libusb20_backend *</var><br><code class=Fn>libusb20_be_alloc_freebsd</code>(<var class=Fa style="white-space: nowrap;">void</var>);</p><p class=Pp><var class=Ft>struct libusb20_backend *</var><br><code class=Fn>libusb20_be_alloc_linux</code>(<var class=Fa style="white-space: nowrap;">void</var>);</p><p class=Pp><var class=Ft>struct libusb20_device *</var><br><code class=Fn>libusb20_be_device_foreach</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_backend *pbe</var>, <var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>libusb20_be_dequeue_device</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_backend *pbe</var>, <var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>libusb20_be_enqueue_device</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_backend *pbe</var>, <var class=Fa style="white-space: nowrap;">struct libusb20_device *pdev</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>libusb20_be_free</code>(<var class=Fa style="white-space: nowrap;">struct libusb20_backend *pbe</var>);</p><p class=Pp><var class=Ft>uint8_t</var><br><code class=Fn>libusb20_me_get_1</code>(<var class=Fa style="white-space: nowrap;">const struct libusb20_me_struct *me</var>, <var class=Fa style="white-space: nowrap;">uint16_t off</var>);</p><p class=Pp><var class=Ft>uint16_t</var><br><code class=Fn>libusb20_me_get_2</code>(<var class=Fa style="white-space: nowrap;">const struct libusb20_me_struct *me</var>, <var class=Fa style="white-space: nowrap;">uint16_t off</var>);</p><p class=Pp><var class=Ft>uint16_t</var><br><code class=Fn>libusb20_me_encode</code>(<var class=Fa style="white-space: nowrap;">void *pdata</var>, <var class=Fa style="white-space: nowrap;">uint16_t len</var>, <var class=Fa style="white-space: nowrap;">const void *pdecoded</var>);</p><p class=Pp><var class=Ft>uint16_t</var><br><code class=Fn>libusb20_me_decode</code>(<var class=Fa style="white-space: nowrap;">const void *pdata</var>, <var class=Fa style="white-space: nowrap;">uint16_t len</var>, <var class=Fa style="white-space: nowrap;">void *pdecoded</var>);</p><p class=Pp><var class=Ft>const uint8_t *</var><br><code class=Fn>libusb20_desc_foreach</code>(<var class=Fa style="white-space: nowrap;">const struct libusb20_me_struct *me</var>, <var class=Fa style="white-space: nowrap;">const uint8_t *pdesc</var>);</p><p class=Pp><var class=Ft>const char *</var><br><code class=Fn>libusb20_strerror</code>(<var class=Fa style="white-space: nowrap;">int code</var>);</p><p class=Pp><var class=Ft>const char *</var><br><code class=Fn>libusb20_error_name</code>(<var class=Fa style="white-space: nowrap;">int code</var>);</p></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> The <code class=Nm>libusb20</code> library implements functions to be able to easily access and control USB through the USB file system interface. The <code class=Nm>libusb20</code> interfaces are specific to the <span class=Ux>FreeBSD</span> usb stack and are not available on other operating systems, portable applications should consider using <a class=Xr href=libusb.3.html>libusb(3)</a>. </section><section class=Sh><h2 class=Sh id=USB_TRANSFER_OPERATIONS><a class=permalink href=#USB_TRANSFER_OPERATIONS>USB TRANSFER OPERATIONS</a></h2><code class=Fn>libusb20_tr_close</code>() will release all kernel resources associated with an USB <var class=Fa>xfer</var>. This function returns zero upon success. Non-zero return values indicate a LIBUSB20_ERROR value. <p class=Pp><code class=Fn>libusb20_tr_open</code>() will allocate kernel buffer resources according to <var class=Fa>max_buf_size</var> and <var class=Fa>max_frame_count</var> associated with an USB <var class=Fa>pxfer</var> and bind the transfer to the specified <var class=Fa>ep_no</var>. <var class=Fa>max_buf_size</var> is the minimum buffer size which the data transport layer has to support. If <var class=Fa>max_buf_size</var> is zero, the <code class=Nm>libusb20</code> library will use wMaxPacketSize to compute the buffer size. This can be useful for isochronous transfers. The actual buffer size can be greater than <var class=Fa>max_buf_size</var> and is returned by <code class=Fn>libusb20_tr_get_max_total_length</code>(). If <var class=Fa>max_frame_count</var> is OR'ed with LIBUSB20_MAX_FRAME_PRE_SCALE the remaining part of the argument is converted from milliseconds into the actual number of frames rounded up, when this function returns. This flag is only valid for ISOCHRONOUS transfers and has no effect for other transfer types. The actual number of frames setup is found by calling <code class=Fn>libusb20_tr_get_max_frames</code>(). This function returns zero upon success. Non-zero return values indicate a LIBUSB20_ERROR value.</p><p class=Pp><code class=Fn>libusb20_tr_open_stream</code>() is identical to <code class=Fn>libusb20_tr_open</code>() except that a stream ID can be specified for BULK endpoints having such a feature. <code class=Fn>libusb20_tr_open</code>() can be used to open stream ID zero.</p><p class=Pp><code class=Fn>libusb20_tr_get_pointer</code>() will return a pointer to the allocated USB transfer according to the <var class=Fa>pdev</var> and <var class=Fa>tr_index</var> arguments. This function returns NULL in case of failure.</p><p class=Pp><code class=Fn>libusb20_tr_get_time_complete</code>() will return the completion time of an USB transfer in millisecond units. This function is most useful for isochronous USB transfers when doing echo cancelling.</p><p class=Pp><code class=Fn>libusb20_tr_get_actual_frames</code>() will return the actual number of USB frames after an USB transfer completed. A value of zero means that no data was transferred.</p><p class=Pp><code class=Fn>libusb20_tr_get_actual_length</code>() will return the sum of the actual length for all transferred USB frames for the given USB transfer.</p><p class=Pp><code class=Fn>libusb20_tr_get_max_frames</code>() will return the maximum number of USB frames that were allocated when an USB transfer was setup for the given USB transfer.</p><p class=Pp><code class=Fn>libusb20_tr_get_max_packet_length</code>() will return the maximum packet length in bytes associated with the given USB transfer. The packet length can be used round up buffer sizes so that short USB packets are avoided for proxy buffers.</p><p class=Pp><code class=Fn>libusb20_tr_get_max_total_length</code>() will return the maximum value for the data length sum of all USB frames associated with an USB transfer. In case of control transfers the value returned does not include the length of the SETUP packet, 8 bytes, which is part of frame zero. The returned value of this function is always aligned to the maximum packet size, wMaxPacketSize, of the endpoint which the USB transfer is bound to.</p><p class=Pp><code class=Fn>libusb20_tr_get_status</code>() will return the status of an USB transfer. Status values are defined by a set of LIBUSB20_TRANSFER_XXX enums.</p><p class=Pp><code class=Fn>libusb20_tr_pending</code>() will return non-zero if the given USB transfer is pending for completion. Else this function returns zero.</p><p class=Pp><code class=Fn>libusb20_tr_callback_wrapper</code>() This is an internal function used to wrap asynchronous USB callbacks.</p><p class=Pp><code class=Fn>libusb20_tr_clear_stall_sync</code>() This is an internal function used to synchronously clear the stall on the given USB transfer. Please see the USB specification for more information on stall clearing. If the given USB transfer is pending when this function is called, the USB transfer will complete with an error after that this function has been called.</p><p class=Pp><code class=Fn>libusb20_tr_drain</code>() will stop the given USB transfer and will not return until the USB transfer has been stopped in hardware.</p><p class=Pp><code class=Fn>libusb20_tr_set_buffer</code>() is used to set the <var class=Fa>buffer</var> pointer for the given USB transfer and <var class=Fa>fr_index</var>. Typically the frame index is zero.</p><p class=Pp><code class=Fn>libusb20_tr_set_callback</code>() is used to set the USB callback for asynchronous USB transfers. The callback type is defined by libusb20_tr_callback_t.</p><p class=Pp><code class=Fn>libusb20_tr_set_flags</code>() is used to set various USB flags for the given USB transfer.</p><dl class=Bl-tag><dt>LIBUSB20_TRANSFER_SINGLE_SHORT_NOT_OK</dt><dd>Report a short frame as error.</dd><dt>LIBUSB20_TRANSFER_MULTI_SHORT_NOT_OK</dt><dd>Multiple short frames are not allowed.</dd><dt>LIBUSB20_TRANSFER_FORCE_SHORT</dt><dd>All transmitted frames are short terminated.</dd><dt>LIBUSB20_TRANSFER_DO_CLEAR_STALL</dt><dd>Will do a clear-stall before starting the transfer.</dd></dl><p class=Pp><code class=Fn>libusb20_tr_get_length</code>() returns the length of the given USB frame by index. After an USB transfer is complete the USB frame length will get updated to the actual transferred length.</p><p class=Pp><code class=Fn>libusb20_tr_set_length</code>() sets the length of the given USB frame by index.</p><p class=Pp><code class=Fn>libusb20_tr_set_priv_sc0</code>() sets private driver pointer number zero.</p><p class=Pp><code class=Fn>libusb20_tr_set_priv_sc1</code>() sets private driver pointer number one.</p><p class=Pp><code class=Fn>libusb20_tr_set_timeout</code>() sets the timeout for the given USB transfer. A timeout value of zero means no timeout. The timeout is given in milliseconds.</p><p class=Pp><code class=Fn>libusb20_tr_set_total_frames</code>() sets the total number of frames that should be executed when the USB transfer is submitted. The total number of USB frames must be less than the maximum number of USB frames associated with the given USB transfer.</p><p class=Pp><code class=Fn>libusb20_tr_setup_bulk</code>() is a helper function for setting up a single frame USB BULK transfer.</p><p class=Pp><code class=Fn>libusb20_tr_setup_control</code>() is a helper function for setting up a single or dual frame USB CONTROL transfer depending on the control transfer length.</p><p class=Pp><code class=Fn>libusb20_tr_setup_intr</code>() is a helper function for setting up a single frame USB INTERRUPT transfer.</p><p class=Pp><code class=Fn>libusb20_tr_setup_isoc</code>() is a helper function for setting up a multi frame USB ISOCHRONOUS transfer.</p><p class=Pp><code class=Fn>libusb20_tr_bulk_intr_sync</code>() will perform a synchronous BULK or INTERRUPT transfer having length given by the <var class=Fa>length</var> argument and buffer pointer given by the <var class=Fa>pbuf</var> argument on the USB transfer given by the <var class=Fa>xfer</var> argument. If the <var class=Fa>pactlen</var> argument is non-NULL the actual transfer length will be stored at the given pointer destination. If the <var class=Fa>timeout</var> argument is non-zero the transfer will timeout after the given value in milliseconds. This function does not change the transfer flags, like short packet not ok. This function returns zero on success else a LIBUSB20_TRANSFER_XXX value is returned.</p><p class=Pp><code class=Fn>libusb20_tr_start</code>() will get the USB transfer started, if not already started. This function will not get the transfer queued in hardware. This function is non-blocking.</p><p class=Pp><code class=Fn>libusb20_tr_stop</code>() will get the USB transfer stopped, if not already stopped. This function is non-blocking, which means that the actual stop can happen after the return of this function.</p><p class=Pp><code class=Fn>libusb20_tr_submit</code>() will get the USB transfer queued in hardware.</p><p class=Pp><code class=Fn>libusb20_tr_get_priv_sc0</code>() returns private driver pointer number zero associated with an USB transfer.</p><p class=Pp><code class=Fn>libusb20_tr_get_priv_sc1</code>() returns private driver pointer number one associated with an USB transfer.</p></section><section class=Sh><h2 class=Sh id=USB_DEVICE_OPERATIONS><a class=permalink href=#USB_DEVICE_OPERATIONS>USB DEVICE OPERATIONS</a></h2><code class=Fn>libusb20_dev_get_backend_name</code>() returns a zero terminated string describing the backend used. <p class=Pp><code class=Fn>libusb20_dev_get_port_path</code>() retrieves the list of USB port numbers which the datastream for a given USB device follows. The first port number is the Root HUB port number. Then children port numbers follow. The Root HUB device itself has a port path length of zero. Valid port numbers start at one and range until and including 255. Typically there should not be more than 16 levels, due to electrical and protocol limitations. This functions returns the number of actual port levels upon success else a LIBUSB20_ERROR value is returned which are always negative. If the actual number of port levels is greater than the maximum specified, a LIBUSB20_ERROR value is returned.</p><p class=Pp><code class=Fn>libusb20_dev_get_info</code>() retrieves the BSD specific usb_device_info structure into the memory location given by <var class=Fa>pinfo</var>. The USB device given by <var class=Fa>pdev</var> must be opened before this function will succeed. This function returns zero on success else a LIBUSB20_ERROR value is returned.</p><p class=Pp><code class=Fn>libusb20_dev_get_iface_desc</code>() retrieves the kernel interface description for the given USB <var class=Fa>iface_index</var>. The format of the USB interface description is: "drivername&lt;unit&gt;: &lt;description&gt;" The description string is always zero terminated. A zero length string is written in case no driver is attached to the given interface. The USB device given by <var class=Fa>pdev</var> must be opened before this function will succeed. This function returns zero on success else a LIBUSB20_ERROR value is returned.</p><p class=Pp><code class=Fn>libusb20_dev_get_desc</code>() returns a zero terminated string describing the given USB device. The format of the string is: "drivername&lt;unit&gt;: &lt;description&gt;"</p><p class=Pp><code class=Fn>libusb20_dev_get_stats</code>() retrieves the device statistics into the structure pointed to by the <var class=Fa>pstats</var> argument. This function returns zero on success else a LIBUSB20_ERROR value is returned.</p><p class=Pp><code class=Fn>libusb20_dev_close</code>() will close the given USB device. This function returns zero on success else a LIBUSB20_ERROR value is returned.</p><p class=Pp><code class=Fn>libusb20_dev_detach_kernel_driver</code>() will try to detach the kernel driver for the USB interface given by <var class=Fa>iface_index</var>. This function returns zero on success else a LIBUSB20_ERROR value is returned.</p><p class=Pp><code class=Fn>libusb20_dev_set_config_index</code>() will try to set the configuration index on an USB device. The first configuration index is zero. The un-configure index is 255. This function returns zero on success else a LIBUSB20_ERROR value is returned.</p><p class=Pp><code class=Fn>libusb20_dev_get_debug</code>() returns the debug level of an USB device.</p><p class=Pp><code class=Fn>libusb20_dev_get_fd</code>() returns the file descriptor of the given USB device. A negative value is returned when no file descriptor is present. The file descriptor can be used for polling purposes.</p><p class=Pp><code class=Fn>libusb20_dev_kernel_driver_active</code>() returns zero if a kernel driver is active on the given USB interface. Else a LIBUSB20_ERROR value is returned.</p><p class=Pp><code class=Fn>libusb20_dev_open</code>() opens an USB device so that setting up USB transfers becomes possible. The number of USB transfers can be zero which means only control transfers are allowed. This function returns zero on success else a LIBUSB20_ERROR value is returned. A return value of LIBUSB20_ERROR_BUSY means that the device is already opened.</p><p class=Pp><code class=Fn>libusb20_dev_process</code>() is called to sync kernel USB transfers with userland USB transfers. This function returns zero on success else a LIBUSB20_ERROR value is returned typically indicating that the given USB device has been detached.</p><p class=Pp><code class=Fn>libusb20_dev_request_sync</code>() will perform a synchronous control request on the given USB device. Before this call will succeed the USB device must be opened. <var class=Fa>setup</var> is a pointer to a decoded and host endian SETUP packet. <var class=Fa>data</var> is a pointer to a data transfer buffer associated with the control transaction. This argument can be NULL. <var class=Fa>pactlen</var> is a pointer to a variable that will hold the actual transfer length after the control transaction is complete. <var class=Fa>timeout</var> is the transaction timeout given in milliseconds. A timeout of zero means no timeout. <var class=Fa>flags</var> is used to specify transaction flags, for example LIBUSB20_TRANSFER_SINGLE_SHORT_NOT_OK. This function returns zero on success else a LIBUSB20_ERROR value is returned.</p><p class=Pp><code class=Fn>libusb20_dev_req_string_sync</code>() will synchronously request an USB string by language ID and string index into the given buffer limited by a maximum length. This function returns zero on success else a LIBUSB20_ERROR value is returned.</p><p class=Pp><code class=Fn>libusb20_dev_req_string_simple_sync</code>() will synchronously request an USB string using the default language ID and convert the string into ASCII before storing the string into the given buffer limited by a maximum length which includes the terminating zero. This function returns zero on success else a LIBUSB20_ERROR value is returned.</p><p class=Pp><code class=Fn>libusb20_dev_reset</code>() will try to BUS reset the given USB device and restore the last set USB configuration. This function returns zero on success else a LIBUSB20_ERROR value is returned.</p><p class=Pp><code class=Fn>libusb20_dev_check_connected</code>() will check if an opened USB device is still connected. This function returns zero if the device is still connected else a LIBUSB20_ERROR value is returned.</p><p class=Pp><code class=Fn>libusb20_dev_set_power_mode</code>() sets the power mode of the USB device. Valid power modes:</p><dl class=Bl-tag><dt>LIBUSB20_POWER_OFF</dt><dd style="width: auto;"> </dd><dt>LIBUSB20_POWER_ON</dt><dd style="width: auto;"> </dd><dt>LIBUSB20_POWER_SAVE</dt><dd style="width: auto;"> </dd><dt>LIBUSB20_POWER_SUSPEND</dt><dd style="width: auto;"> </dd><dt>LIBUSB20_POWER_RESUME</dt><dd style="width: auto;"> </dd></dl><p class=Pp>This function returns zero on success else a LIBUSB20_ERROR value is returned.</p><p class=Pp><code class=Fn>libusb20_dev_get_power_mode</code>() returns the currently selected power mode for the given USB device.</p><p class=Pp><code class=Fn>libusb20_dev_get_power_usage</code>() returns the reported power usage in milliamps for the given USB device. A power usage of zero typically means that the device is self powered.</p><p class=Pp><code class=Fn>libusb20_dev_set_alt_index</code>() will try to set the given alternate index for the given USB interface index. This function returns zero on success else a LIBUSB20_ERROR value is returned.</p><p class=Pp><code class=Fn>libusb20_dev_get_device_desc</code>() returns a pointer to the decoded and host endian version of the device descriptor. The USB device need not be opened when calling this function.</p><p class=Pp><code class=Fn>libusb20_dev_alloc_config</code>() will read out and decode the USB config descriptor for the given USB device and config index. This function returns a pointer to the decoded configuration which must eventually be passed to free(). NULL is returned in case of failure.</p><p class=Pp><code class=Fn>libusb20_dev_alloc</code>() is an internal function to allocate a new USB device.</p><p class=Pp><code class=Fn>libusb20_dev_get_address</code>() returns the internal and not necessarily the real hardware address of the given USB device. Valid addresses start at one.</p><p class=Pp><code class=Fn>libusb20_dev_get_parent_address</code>() returns the internal and not necessarily the real hardware address of the given parent USB HUB device. This value is zero for the root HUB which usually has a device address equal to one. Valid addresses start at one.</p><p class=Pp><code class=Fn>libusb20_dev_get_parent_port</code>() returns the port number on the parent USB HUB device. This value is zero for the root HUB which usually has a device address equal to one. Valid port numbers start at one.</p><p class=Pp><code class=Fn>libusb20_dev_get_bus_number</code>() returns the internal bus number which the given USB device belongs to. Valid bus numbers start at zero.</p><p class=Pp><code class=Fn>libusb20_dev_get_mode</code>() returns the current operation mode of the USB entity. Valid return values are:</p><dl class=Bl-tag><dt>LIBUSB20_MODE_HOST</dt><dd style="width: auto;"> </dd><dt>LIBUSB20_MODE_DEVICE</dt><dd style="width: auto;"> </dd></dl><p class=Pp><code class=Fn>libusb20_dev_get_speed</code>() returns the current speed of the given USB device.</p><dl class=Bl-tag><dt>LIBUSB20_SPEED_UNKNOWN</dt><dd style="width: auto;"> </dd><dt>LIBUSB20_SPEED_LOW</dt><dd style="width: auto;"> </dd><dt>LIBUSB20_SPEED_FULL</dt><dd style="width: auto;"> </dd><dt>LIBUSB20_SPEED_HIGH</dt><dd style="width: auto;"> </dd><dt>LIBUSB20_SPEED_VARIABLE</dt><dd style="width: auto;"> </dd><dt>LIBUSB20_SPEED_SUPER</dt><dd style="width: auto;"> </dd></dl><p class=Pp><code class=Fn>libusb20_dev_get_config_index</code>() returns the currently selected config index for the given USB device.</p><p class=Pp><code class=Fn>libusb20_dev_free</code>() will free the given USB device and all associated USB transfers.</p><p class=Pp><code class=Fn>libusb20_dev_set_debug</code>() will set the debug level for the given USB device.</p><p class=Pp><code class=Fn>libusb20_dev_wait_process</code>() will wait until a pending USB transfer has completed on the given USB device. A timeout value can be specified which is passed on to the <a class=Xr href=poll.2.html>poll(2)</a> function.</p></section><section class=Sh><h2 class=Sh id=USB_BACKEND_OPERATIONS><a class=permalink href=#USB_BACKEND_OPERATIONS>USB BACKEND OPERATIONS</a></h2><code class=Fn>libusb20_be_get_template</code>() will return the currently selected global USB device side mode template into the integer pointer <var class=Fa>ptemp</var>. This function returns zero on success else a LIBUSB20_ERROR value is returned. <p class=Pp><code class=Fn>libusb20_be_set_template</code>() will set the global USB device side mode template to <var class=Fa>temp</var>. The new template is not activated until after the next USB enumeration. The template number decides how the USB device will present itself to the USB Host, like Mass Storage Device, USB Ethernet Device. Also see the <a class=Xr href=usb2_template.4.html>usb2_template(4)</a> module. This function returns zero on success else a LIBUSB20_ERROR value is returned.</p><p class=Pp><code class=Fn>libusb20_be_get_dev_quirk</code>() will return the device quirk according to <var class=Fa>index</var> into the libusb20_quirk structure pointed to by <var class=Fa>pq</var>. This function returns zero on success else a LIBUSB20_ERROR value is returned. If the given quirk does not exist LIBUSB20_ERROR_NOT_FOUND is returned.</p><p class=Pp><code class=Fn>libusb20_be_get_quirk_name</code>() will return the quirk name according to <var class=Fa>index</var> into the libusb20_quirk structure pointed to by <var class=Fa>pq</var>. This function returns zero on success else a LIBUSB20_ERROR value is returned. If the given quirk does not exist LIBUSB20_ERROR_NOT_FOUND is returned.</p><p class=Pp><code class=Fn>libusb20_be_add_dev_quirk</code>() will add the libusb20_quirk structure pointed to by the <var class=Fa>pq</var> argument into the device quirk list. This function returns zero on success else a LIBUSB20_ERROR value is returned. If the given quirk cannot be added LIBUSB20_ERROR_NO_MEM is returned.</p><p class=Pp><code class=Fn>libusb20_be_remove_dev_quirk</code>() will remove the quirk matching the libusb20_quirk structure pointed to by the <var class=Fa>pq</var> argument from the device quirk list. This function returns zero on success else a LIBUSB20_ERROR value is returned. If the given quirk does not exist LIBUSB20_ERROR_NOT_FOUND is returned.</p><p class=Pp><code class=Fn>libusb20_be_alloc_default</code>() <code class=Fn>libusb20_be_alloc_freebsd</code>() <code class=Fn>libusb20_be_alloc_linux</code>() These functions are used to allocate a specific USB backend or the operating system default USB backend. Allocating a backend is a way to scan for currently present USB devices.</p><p class=Pp><code class=Fn>libusb20_be_device_foreach</code>() is used to iterate USB devices present in a USB backend. The starting value of <var class=Fa>pdev</var> is NULL. This function returns the next USB device in the list. If NULL is returned the end of the USB device list has been reached.</p><p class=Pp><code class=Fn>libusb20_be_dequeue_device</code>() will dequeue the given USB device pointer from the backend USB device list. Dequeued USB devices will not be freed when the backend is freed.</p><p class=Pp><code class=Fn>libusb20_be_enqueue_device</code>() will enqueue the given USB device pointer in the backend USB device list. Enqueued USB devices will get freed when the backend is freed.</p><p class=Pp><code class=Fn>libusb20_be_free</code>() will free the given backend and all USB devices in its device list.</p></section><section class=Sh><h2 class=Sh id=USB_DESCRIPTOR_PARSING><a class=permalink href=#USB_DESCRIPTOR_PARSING>USB DESCRIPTOR PARSING</a></h2><code class=Fn>libusb20_me_get_1</code>(<var class=Fa>pie</var>, <var class=Fa>offset</var>) This function will return a byte at the given byte offset of a message entity. This function is safe against invalid offsets. <p class=Pp><code class=Fn>libusb20_me_get_2</code>(<var class=Fa>pie</var>, <var class=Fa>offset</var>) This function will return a little endian 16-bit value at the given byte offset of a message entity. This function is safe against invalid offsets.</p><p class=Pp><code class=Fn>libusb20_me_encode</code>(<var class=Fa>pbuf</var>, <var class=Fa>len</var>, <var class=Fa>pdecoded</var>) This function will encode a so-called *DECODED structure into binary format. The total encoded length that will fit in the given buffer is returned. If the buffer pointer is NULL no data will be written to the buffer location.</p><p class=Pp><code class=Fn>libusb20_me_decode</code>(<var class=Fa>pbuf</var>, <var class=Fa>len</var>, <var class=Fa>pdecoded</var>) This function will decode a binary structure into a so-called *DECODED structure. The total decoded length is returned. The buffer pointer cannot be NULL.</p></section><section class=Sh><h2 class=Sh id=USB_DEBUGGING><a class=permalink href=#USB_DEBUGGING>USB DEBUGGING</a></h2><var class=Ft>const char *</var><code class=Fn>libusb20_strerror</code>(<var class=Fa>int code</var>) Get the ASCII representation of the error given by the <var class=Fa>code</var> argument. This function does not return NULL. <p class=Pp><var class=Ft>const char *</var><code class=Fn>libusb20_error_name</code>(<var class=Fa>int code</var>) Get the ASCII representation of the error enum given by the <var class=Fa>code</var> argument. This function does not return NULL.</p></section><section class=Sh><h2 class=Sh id=FILES><a class=permalink href=#FILES>FILES</a></h2><dl class=Bl-tag><dt><span class=Pa>/dev/usb</span></dt><dd style="width: auto;"> </dd></dl></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=libusb.3.html>libusb(3)</a>, <a class=Xr href=usb.4.html>usb(4)</a>, <a class=Xr href=usbconfig.8.html>usbconfig(8)</a>, <a class=Xr href=usbdump.8.html>usbdump(8)</a></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> Some parts of the <code class=Nm>libusb20</code> API derives from the libusb project at sourceforge. </section></div><table class=foot><tr><td class=foot-date>December 27, 2019</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>