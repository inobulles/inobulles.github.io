<!DOCTYPE html>
<html><head><meta charset=utf-8><title>pci_iov_detach(9)</title><keywords content=man,pci_iov_detach></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>pci_iov_detach(9)</h1><table class=head><tr><td class=head-ltitle>PCI(9)</td><td class=head-vol>FreeBSD Kernel Developer's Manual</td><td class=head-rtitle>PCI(9)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>pci</code>, <code class=Nm>pci_alloc_msi</code>, <code class=Nm>pci_alloc_msix</code>, <code class=Nm>pci_disable_busmaster</code>, <code class=Nm>pci_disable_io</code>, <code class=Nm>pci_enable_busmaster</code>, <code class=Nm>pci_enable_io</code>, <code class=Nm>pci_find_bsf</code>, <code class=Nm>pci_find_cap</code>, <code class=Nm>pci_find_dbsf</code>, <code class=Nm>pci_find_device</code>, <code class=Nm>pci_find_extcap</code>, <code class=Nm>pci_find_htcap</code>, <code class=Nm>pci_find_next_cap</code>, <code class=Nm>pci_find_next_extcap</code>, <code class=Nm>pci_find_next_htcap</code>, <code class=Nm>pci_find_pcie_root_port</code>, <code class=Nm>pci_get_id</code>, <code class=Nm>pci_get_max_payload</code>, <code class=Nm>pci_get_max_read_req</code>, <code class=Nm>pci_get_powerstate</code>, <code class=Nm>pci_get_vpd_ident</code>, <code class=Nm>pci_get_vpd_readonly</code>, <code class=Nm>pci_iov_attach</code>, <code class=Nm>pci_iov_attach_name</code>, <code class=Nm>pci_iov_detach</code>, <code class=Nm>pci_msi_count</code>, <code class=Nm>pci_msix_count</code>, <code class=Nm>pci_msix_pba_bar</code>, <code class=Nm>pci_msix_table_bar</code>, <code class=Nm>pci_pending_msix</code>, <code class=Nm>pci_read_config</code>, <code class=Nm>pci_release_msi</code>, <code class=Nm>pci_remap_msix</code>, <code class=Nm>pci_restore_state</code>, <code class=Nm>pci_save_state</code>, <code class=Nm>pci_set_max_read_req</code>, <code class=Nm>pci_set_powerstate</code>, <code class=Nm>pci_write_config</code>, <code class=Nm>pcie_adjust_config</code>, <code class=Nm>pcie_flr</code>, <code class=Nm>pcie_get_max_completion_timeout</code>, <code class=Nm>pcie_read_config</code>, <code class=Nm>pcie_wait_for_pending_transactions</code>, <code class=Nm>pcie_write_config</code> — <div class=Nd>PCI bus interface</div></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/sys/bus.h.html>sys/bus.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/dev/pci/pcireg.h.html>dev/pci/pcireg.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/dev/pci/pcivar.h.html>dev/pci/pcivar.h</a>&gt;</code><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_alloc_msi</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">int *count</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_alloc_msix</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">int *count</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_disable_busmaster</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_disable_io</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">int space</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_enable_busmaster</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_enable_io</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">int space</var>);</p><p class=Pp><var class=Ft>device_t</var><br><code class=Fn>pci_find_bsf</code>(<var class=Fa style="white-space: nowrap;">uint8_t bus</var>, <var class=Fa style="white-space: nowrap;">uint8_t slot</var>, <var class=Fa style="white-space: nowrap;">uint8_t func</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_find_cap</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">int capability</var>, <var class=Fa style="white-space: nowrap;">int *capreg</var>);</p><p class=Pp><var class=Ft>device_t</var><br><code class=Fn>pci_find_dbsf</code>(<var class=Fa style="white-space: nowrap;">uint32_t domain</var>, <var class=Fa style="white-space: nowrap;">uint8_t bus</var>, <var class=Fa style="white-space: nowrap;">uint8_t slot</var>, <var class=Fa style="white-space: nowrap;">uint8_t func</var>);</p><p class=Pp><var class=Ft>device_t</var><br><code class=Fn>pci_find_device</code>(<var class=Fa style="white-space: nowrap;">uint16_t vendor</var>, <var class=Fa style="white-space: nowrap;">uint16_t device</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_find_extcap</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">int capability</var>, <var class=Fa style="white-space: nowrap;">int *capreg</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_find_htcap</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">int capability</var>, <var class=Fa style="white-space: nowrap;">int *capreg</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_find_next_cap</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">int capability</var>, <var class=Fa style="white-space: nowrap;">int start</var>, <var class=Fa style="white-space: nowrap;">int *capreg</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_find_next_extcap</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">int capability</var>, <var class=Fa style="white-space: nowrap;">int start</var>, <var class=Fa style="white-space: nowrap;">int *capreg</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_find_next_htcap</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">int capability</var>, <var class=Fa style="white-space: nowrap;">int start</var>, <var class=Fa style="white-space: nowrap;">int *capreg</var>);</p><p class=Pp><var class=Ft>device_t</var><br><code class=Fn>pci_find_pcie_root_port</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_get_id</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">enum pci_id_type type</var>, <var class=Fa style="white-space: nowrap;">uintptr_t *id</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_get_max_payload</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_get_max_read_req</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_get_powerstate</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_get_vpd_ident</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">const char **identptr</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_get_vpd_readonly</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">const char *kw</var>, <var class=Fa style="white-space: nowrap;">const char **vptr</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_msi_count</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_msix_count</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_msix_pba_bar</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_msix_table_bar</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_pending_msix</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">u_int index</var>);</p><p class=Pp><var class=Ft>uint32_t</var><br><code class=Fn>pci_read_config</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">int reg</var>, <var class=Fa style="white-space: nowrap;">int width</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_release_msi</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_remap_msix</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">int count</var>, <var class=Fa style="white-space: nowrap;">const u_int *vectors</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>pci_restore_state</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>pci_save_state</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_set_max_read_req</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">int size</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_set_powerstate</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">int state</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>pci_write_config</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">int reg</var>, <var class=Fa style="white-space: nowrap;">uint32_t val</var>, <var class=Fa style="white-space: nowrap;">int width</var>);</p><p class=Pp><var class=Ft>uint32_t</var><br><code class=Fn>pcie_adjust_config</code>(<var class=Fa>device_t dev</var>, <var class=Fa>int reg</var>, <var class=Fa>uint32_t mask</var>, <var class=Fa>uint32_t val</var>, <var class=Fa>int width</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>pcie_flr</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">u_int max_delay</var>, <var class=Fa style="white-space: nowrap;">bool force</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pcie_get_max_completion_timeout</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>);</p><p class=Pp><var class=Ft>uint32_t</var><br><code class=Fn>pcie_read_config</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">int reg</var>, <var class=Fa style="white-space: nowrap;">int width</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>pcie_wait_for_pending_transactions</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">u_int max_delay</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>pcie_write_config</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">int reg</var>, <var class=Fa style="white-space: nowrap;">uint32_t val</var>, <var class=Fa style="white-space: nowrap;">int width</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>pci_event_fn</code>(<var class=Fa style="white-space: nowrap;">void *arg</var>, <var class=Fa style="white-space: nowrap;">device_t dev</var>);</p><p class=Pp><code class=Fn>EVENTHANDLER_REGISTER</code>(<var class=Fa style="white-space: nowrap;">pci_add_device</var>, <var class=Fa style="white-space: nowrap;">pci_event_fn</var>);</p><p class=Pp><code class=Fn>EVENTHANDLER_DEREGISTER</code>(<var class=Fa style="white-space: nowrap;">pci_delete_resource</var>, <var class=Fa style="white-space: nowrap;">pci_event_fn</var>);</p><p class=Pp><code class=In>#include &lt;<a class=In href=../src/dev/pci/pci_iov.h.html>dev/pci/pci_iov.h</a>&gt;</code></p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_iov_attach</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">nvlist_t *pf_schema</var>, <var class=Fa style="white-space: nowrap;">nvlist_t *vf_schema</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_iov_attach_name</code>(<var class=Fa>device_t dev</var>, <var class=Fa>nvlist_t *pf_schema</var>, <var class=Fa>nvlist_t *vf_schema</var>, <var class=Fa>const char *fmt</var>, <var class=Fa>...</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>pci_iov_detach</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>);</p></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> The <code class=Nm>pci</code> set of functions are used for managing PCI devices. The functions are split into several groups: raw configuration access, locating devices, device information, device configuration, and message signaled interrupts. <section class=Ss><h2 class=Ss id=Raw_Configuration_Access><a class=permalink href=#Raw_Configuration_Access>Raw Configuration Access</a></h2> The <code class=Fn>pci_read_config</code>() function is used to read data from the PCI configuration space of the device <var class=Fa>dev</var>, at offset <var class=Fa>reg</var>, with <var class=Fa>width</var> specifying the size of the access. <p class=Pp>The <code class=Fn>pci_write_config</code>() function is used to write the value <var class=Fa>val</var> to the PCI configuration space of the device <var class=Fa>dev</var>, at offset <var class=Fa>reg</var>, with <var class=Fa>width</var> specifying the size of the access.</p><p class=Pp>The <code class=Fn>pcie_adjust_config</code>() function is used to modify the value of a register in the PCI-express capability register set of device <var class=Fa>dev</var>. The offset <var class=Fa>reg</var> specifies a relative offset in the register set with <var class=Fa>width</var> specifying the size of the access. The new value of the register is computed by modifying bits set in <var class=Fa>mask</var> to the value in <var class=Fa>val</var>. Any bits not specified in <var class=Fa>mask</var> are preserved. The previous value of the register is returned.</p><p class=Pp>The <code class=Fn>pcie_read_config</code>() function is used to read the value of a register in the PCI-express capability register set of device <var class=Fa>dev</var>. The offset <var class=Fa>reg</var> specifies a relative offset in the register set with <var class=Fa>width</var> specifying the size of the access.</p><p class=Pp>The <code class=Fn>pcie_write_config</code>() function is used to write the value <var class=Fa>val</var> to a register in the PCI-express capability register set of device <var class=Fa>dev</var>. The offset <var class=Fa>reg</var> specifies a relative offset in the register set with <var class=Fa>width</var> specifying the size of the access.</p><p class=Pp><i class=Em>NOTE</i>: Device drivers should only use these functions for functionality that is not available via another <code class=Fn>pci</code>() function.</p></section><section class=Ss><h2 class=Ss id=Locating_Devices><a class=permalink href=#Locating_Devices>Locating Devices</a></h2> The <code class=Fn>pci_find_bsf</code>() function looks up the <var class=Vt>device_t</var> of a PCI device, given its <var class=Fa>bus</var>, <var class=Fa>slot</var>, and <var class=Fa>func</var>. The <var class=Fa>slot</var> number actually refers to the number of the device on the bus, which does not necessarily indicate its geographic location in terms of a physical slot. Note that in case the system has multiple PCI domains, the <code class=Fn>pci_find_bsf</code>() function only searches the first one. Actually, it is equivalent to: <div class="Bd Pp Bd-indent"><pre>
pci_find_dbsf(0, bus, slot, func);
</pre></div><p class=Pp>The <code class=Fn>pci_find_dbsf</code>() function looks up the <var class=Vt>device_t</var> of a PCI device, given its <var class=Fa>domain</var>, <var class=Fa>bus</var>, <var class=Fa>slot</var>, and <var class=Fa>func</var>. The <var class=Fa>slot</var> number actually refers to the number of the device on the bus, which does not necessarily indicate its geographic location in terms of a physical slot.</p><p class=Pp>The <code class=Fn>pci_find_device</code>() function looks up the <var class=Vt>device_t</var> of a PCI device, given its <var class=Fa>vendor</var> and <var class=Fa>device</var> IDs. Note that there can be multiple matches for this search; this function only returns the first matching device.</p></section><section class=Ss><h2 class=Ss id=Device_Information><a class=permalink href=#Device_Information>Device Information</a></h2> The <code class=Fn>pci_find_cap</code>() function is used to locate the first instance of a PCI capability register set for the device <var class=Fa>dev</var>. The capability to locate is specified by ID via <var class=Fa>capability</var>. Constant macros of the form <code class=Dv>PCIY_xxx</code> for standard capability IDs are defined in <code class=In>&lt;<a class=In href=../src/dev/pci/pcireg.h.html>dev/pci/pcireg.h</a>&gt;</code>. If the capability is found, then <var class=Fa>*capreg</var> is set to the offset in configuration space of the capability register set, and <code class=Fn>pci_find_cap</code>() returns zero. If the capability is not found or the device does not support capabilities, <code class=Fn>pci_find_cap</code>() returns an error. The <code class=Fn>pci_find_next_cap</code>() function is used to locate the next instance of a PCI capability register set for the device <var class=Fa>dev</var>. The <var class=Fa>start</var> should be the <var class=Fa>*capreg</var> returned by a prior <code class=Fn>pci_find_cap</code>() or <code class=Fn>pci_find_next_cap</code>(). When no more instances are located <code class=Fn>pci_find_next_cap</code>() returns an error. <p class=Pp>The <code class=Fn>pci_find_extcap</code>() function is used to locate the first instance of a PCI-express extended capability register set for the device <var class=Fa>dev</var>. The extended capability to locate is specified by ID via <var class=Fa>capability</var>. Constant macros of the form <code class=Dv>PCIZ_xxx</code> for standard extended capability IDs are defined in <code class=In>&lt;<a class=In href=../src/dev/pci/pcireg.h.html>dev/pci/pcireg.h</a>&gt;</code>. If the extended capability is found, then <var class=Fa>*capreg</var> is set to the offset in configuration space of the extended capability register set, and <code class=Fn>pci_find_extcap</code>() returns zero. If the extended capability is not found or the device is not a PCI-express device, <code class=Fn>pci_find_extcap</code>() returns an error. The <code class=Fn>pci_find_next_extcap</code>() function is used to locate the next instance of a PCI-express extended capability register set for the device <var class=Fa>dev</var>. The <var class=Fa>start</var> should be the <var class=Fa>*capreg</var> returned by a prior <code class=Fn>pci_find_extcap</code>() or <code class=Fn>pci_find_next_extcap</code>(). When no more instances are located <code class=Fn>pci_find_next_extcap</code>() returns an error.</p><p class=Pp>The <code class=Fn>pci_find_htcap</code>() function is used to locate the first instance of a HyperTransport capability register set for the device <var class=Fa>dev</var>. The capability to locate is specified by type via <var class=Fa>capability</var>. Constant macros of the form <code class=Dv>PCIM_HTCAP_xxx</code> for standard HyperTransport capability types are defined in <code class=In>&lt;<a class=In href=../src/dev/pci/pcireg.h.html>dev/pci/pcireg.h</a>&gt;</code>. If the capability is found, then <var class=Fa>*capreg</var> is set to the offset in configuration space of the capability register set, and <code class=Fn>pci_find_htcap</code>() returns zero. If the capability is not found or the device is not a HyperTransport device, <code class=Fn>pci_find_htcap</code>() returns an error. The <code class=Fn>pci_find_next_htcap</code>() function is used to locate the next instance of a HyperTransport capability register set for the device <var class=Fa>dev</var>. The <var class=Fa>start</var> should be the <var class=Fa>*capreg</var> returned by a prior <code class=Fn>pci_find_htcap</code>() or <code class=Fn>pci_find_next_htcap</code>(). When no more instances are located <code class=Fn>pci_find_next_htcap</code>() returns an error.</p><p class=Pp>The <code class=Fn>pci_find_pcie_root_port</code>() function walks up the PCI device hierarchy to locate the PCI-express root port upstream of <var class=Fa>dev</var>. If a root port is not found, <code class=Fn>pci_find_pcie_root_port</code>() returns <code class=Dv>NULL</code>.</p><p class=Pp>The <code class=Fn>pci_get_id</code>() function is used to read an identifier from a device. The <var class=Fa>type</var> flag is used to specify which identifier to read. The following flags are supported:</p><dl class=Bl-hang><dt><a class=permalink href=#PCI_ID_RID><code class=Dv id=PCI_ID_RID>PCI_ID_RID</code></a></dt><dd>Read the routing identifier for the device.</dd><dt><a class=permalink href=#PCI_ID_MSI><code class=Dv id=PCI_ID_MSI>PCI_ID_MSI</code></a></dt><dd>Read the MSI routing ID. This is needed by some interrupt controllers to route MSI and MSI-X interrupts.</dd></dl><p class=Pp>The <code class=Fn>pci_get_vpd_ident</code>() function is used to fetch a device's Vital Product Data (VPD) identifier string. If the device <var class=Fa>dev</var> supports VPD and provides an identifier string, then <var class=Fa>*identptr</var> is set to point at a read-only, null-terminated copy of the identifier string, and <code class=Fn>pci_get_vpd_ident</code>() returns zero. If the device does not support VPD or does not provide an identifier string, then <code class=Fn>pci_get_vpd_ident</code>() returns an error.</p><p class=Pp>The <code class=Fn>pci_get_vpd_readonly</code>() function is used to fetch the value of a single VPD read-only keyword for the device <var class=Fa>dev</var>. The keyword to fetch is identified by the two character string <var class=Fa>kw</var>. If the device supports VPD and provides a read-only value for the requested keyword, then <var class=Fa>*vptr</var> is set to point at a read-only, null-terminated copy of the value, and <code class=Fn>pci_get_vpd_readonly</code>() returns zero. If the device does not support VPD or does not provide the requested keyword, then <code class=Fn>pci_get_vpd_readonly</code>() returns an error.</p><p class=Pp>The <code class=Fn>pcie_get_max_completion_timeout</code>() function returns the maximum completion timeout configured for the device <var class=Fa>dev</var> in microseconds. If the <var class=Fa>dev</var> device is not a PCI-express device, <code class=Fn>pcie_get_max_completion_timeout</code>() returns zero. When completion timeouts are disabled for <var class=Fa>dev</var>, this function returns the maxmimum timeout that would be used if timeouts were enabled.</p><p class=Pp>The <code class=Fn>pcie_wait_for_pending_transactions</code>() function waits for any pending transactions initiated by the <var class=Fa>dev</var> device to complete. The function checks for pending transactions by polling the transactions pending flag in the PCI-express device status register. It returns <code class=Dv>true</code> once the transaction pending flag is clear. If transactions are still pending after <var class=Fa>max_delay</var> milliseconds, <code class=Fn>pcie_wait_for_pending_transactions</code>() returns <code class=Dv>false</code>. If <var class=Fa>max_delay</var> is set to zero, <code class=Fn>pcie_wait_for_pending_transactions</code>() performs a single check; otherwise, this function may sleep while polling the transactions pending flag. <code class=Nm>pcie_wait_for_pending_transactions</code> returns <code class=Dv>true</code> if <var class=Fa>dev</var> is not a PCI-express device.</p></section><section class=Ss><h2 class=Ss id=Device_Configuration><a class=permalink href=#Device_Configuration>Device Configuration</a></h2> The <code class=Fn>pci_enable_busmaster</code>() function enables PCI bus mastering for the device <var class=Fa>dev</var>, by setting the <code class=Dv>PCIM_CMD_BUSMASTEREN</code> bit in the <code class=Dv>PCIR_COMMAND</code> register. The <code class=Fn>pci_disable_busmaster</code>() function clears this bit. <p class=Pp>The <code class=Fn>pci_enable_io</code>() function enables memory or I/O port address decoding for the device <var class=Fa>dev</var>, by setting the <code class=Dv>PCIM_CMD_MEMEN</code> or <code class=Dv>PCIM_CMD_PORTEN</code> bit in the <code class=Dv>PCIR_COMMAND</code> register appropriately. The <code class=Fn>pci_disable_io</code>() function clears the appropriate bit. The <var class=Fa>space</var> argument specifies which resource is affected; this can be either <code class=Dv>SYS_RES_MEMORY</code> or <code class=Dv>SYS_RES_IOPORT</code> as appropriate. Device drivers should generally not use these routines directly. The PCI bus will enable decoding automatically when a <code class=Dv>SYS_RES_MEMORY</code> or <code class=Dv>SYS_RES_IOPORT</code> resource is activated via <a class=Xr href=bus_alloc_resource.9.html>bus_alloc_resource(9)</a> or <a class=Xr href=bus_activate_resource.9.html>bus_activate_resource(9)</a>.</p><p class=Pp>The <code class=Fn>pci_get_max_payload</code>() function returns the current maximum TLP payload size in bytes for a PCI-express device. If the <var class=Fa>dev</var> device is not a PCI-express device, <code class=Fn>pci_get_max_payload</code>() returns zero.</p><p class=Pp>The <code class=Fn>pci_get_max_read_req</code>() function returns the current maximum read request size in bytes for a PCI-express device. If the <var class=Fa>dev</var> device is not a PCI-express device, <code class=Fn>pci_get_max_read_req</code>() returns zero.</p><p class=Pp>The <code class=Fn>pci_set_max_read_req</code>() sets the PCI-express maximum read request size for <var class=Fa>dev</var>. The requested <var class=Fa>size</var> may be adjusted, and <code class=Fn>pci_set_max_read_req</code>() returns the actual size set in bytes. If the <var class=Fa>dev</var> device is not a PCI-express device, <code class=Fn>pci_set_max_read_req</code>() returns zero.</p><p class=Pp>The <code class=Fn>pci_get_powerstate</code>() function returns the current power state of the device <var class=Fa>dev</var>. If the device does not support power management capabilities, then the default state of <code class=Dv>PCI_POWERSTATE_D0</code> is returned. The following power states are defined by PCI:</p><dl class=Bl-hang><dt><a class=permalink href=#PCI_POWERSTATE_D0><code class=Dv id=PCI_POWERSTATE_D0>PCI_POWERSTATE_D0</code></a></dt><dd>State in which device is on and running. It is receiving full power from the system and delivering full functionality to the user.</dd><dt><a class=permalink href=#PCI_POWERSTATE_D1><code class=Dv id=PCI_POWERSTATE_D1>PCI_POWERSTATE_D1</code></a></dt><dd>Class-specific low-power state in which device context may or may not be lost. Buses in this state cannot do anything to the bus, to force devices to lose context.</dd><dt><a class=permalink href=#PCI_POWERSTATE_D2><code class=Dv id=PCI_POWERSTATE_D2>PCI_POWERSTATE_D2</code></a></dt><dd>Class-specific low-power state in which device context may or may not be lost. Attains greater power savings than <code class=Dv>PCI_POWERSTATE_D1</code>. Buses in this state can cause devices to lose some context. Devices <i class=Em>must</i> be prepared for the bus to be in this state or higher.</dd><dt><a class=permalink href=#PCI_POWERSTATE_D3><code class=Dv id=PCI_POWERSTATE_D3>PCI_POWERSTATE_D3</code></a></dt><dd>State in which the device is off and not running. Device context is lost, and power from the device can be removed.</dd><dt><a class=permalink href=#PCI_POWERSTATE_UNKNOWN><code class=Dv id=PCI_POWERSTATE_UNKNOWN>PCI_POWERSTATE_UNKNOWN</code></a></dt><dd>State of the device is unknown.</dd></dl><p class=Pp>The <code class=Fn>pci_set_powerstate</code>() function is used to transition the device <var class=Fa>dev</var> to the PCI power state <var class=Fa>state</var>. If the device does not support power management capabilities or it does not support the specific power state <var class=Fa>state</var>, then the function will fail with <code class=Er>EOPNOTSUPP</code>.</p><p class=Pp>The <code class=Fn>pci_iov_attach</code>() function is used to advertise that the given device (and associated device driver) supports PCI Single-Root I/O Virtualization (SR-IOV). A driver that supports SR-IOV must implement the <a class=Xr href=PCI_IOV_INIT.9.html>PCI_IOV_INIT(9)</a>, <a class=Xr href=PCI_IOV_ADD_VF.9.html>PCI_IOV_ADD_VF(9)</a> and <a class=Xr href=PCI_IOV_UNINIT.9.html>PCI_IOV_UNINIT(9)</a> methods. This function should be called during the <a class=Xr href=DEVICE_ATTACH.9.html>DEVICE_ATTACH(9)</a> method. If this function returns an error, it is recommended that the device driver still successfully attaches, but runs with SR-IOV disabled. The <var class=Fa>pf_schema</var> and <var class=Fa>vf_schema</var> parameters are used to define what device-specific configuration parameters the device driver accepts when SR-IOV is enabled for the Physical Function (PF) and for individual Virtual Functions (VFs) respectively. See <a class=Xr href=pci_iov_schema.9.html>pci_iov_schema(9)</a> for details on how to construct the schema. If either the <span class=Pa>pf_schema</span> or <span class=Pa>vf_schema</span> is invalid or specifies parameter names that conflict with parameter names that are already in use, <code class=Fn>pci_iov_attach</code>() will return an error and SR-IOV will not be available on the PF device. If a driver does not accept configuration parameters for either the PF device or the VF devices, the driver must pass an empty schema for that device. The SR-IOV infrastructure takes ownership of the <var class=Fa>pf_schema</var> and <var class=Fa>vf_schema</var> and is responsible for freeing them. The driver must never free the schemas itself.</p><p class=Pp>The <code class=Fn>pci_iov_attach_name</code>() function is a variant of <code class=Fn>pci_iov_attach</code>() that allows the name of the associated character device in <span class=Pa>/dev/iov</span> to be specified by <var class=Fa>fmt</var>. The <code class=Fn>pci_iov_attach</code>() function uses the name of <var class=Fa>dev</var> as the device name.</p><p class=Pp>The <code class=Fn>pci_iov_detach</code>() function is used to advise the SR-IOV infrastructure that the driver for the given device is attempting to detach and that all SR-IOV resources for the device must be released. This function must be called during the <a class=Xr href=DEVICE_DETACH.9.html>DEVICE_DETACH(9)</a> method if <code class=Fn>pci_iov_attach</code>() was successfully called on the device and <code class=Fn>pci_iov_detach</code>() has not subsequently been called on the device and returned no error. If this function returns an error, the <a class=Xr href=DEVICE_DETACH.9.html>DEVICE_DETACH(9)</a> method must fail and return an error, as detaching the PF driver while VF devices are active would cause system instability. This function is safe to call and will always succeed if <code class=Fn>pci_iov_attach</code>() previously failed with an error on the given device, or if <code class=Fn>pci_iov_attach</code>() was never called on the device.</p><p class=Pp>The <code class=Fn>pci_save_state</code>() and <code class=Fn>pci_restore_state</code>() functions can be used by a device driver to save and restore standard PCI config registers. The <code class=Fn>pci_save_state</code>() function must be invoked while the device has valid state before <code class=Fn>pci_restore_state</code>() can be used. If the device is not in the fully-powered state (<code class=Dv>PCI_POWERSTATE_D0</code>) when <code class=Fn>pci_restore_state</code>() is invoked, then the device will be transitioned to <code class=Dv>PCI_POWERSTATE_D0</code> before any config registers are restored.</p><p class=Pp>The <code class=Fn>pcie_flr</code>() function requests a Function Level Reset (FLR) of <var class=Fa>dev</var>. If <var class=Fa>dev</var> is not a PCI-express device or does not support Function Level Resets via the PCI-express device control register, <code class=Dv>false</code> is returned. Pending transactions are drained by disabling busmastering and calling <code class=Fn>pcie_wait_for_pending_transactions</code>() before resetting the device. The <var class=Fa>max_delay</var> argument specifies the maximum timeout to wait for pending transactions as described for <code class=Fn>pcie_wait_for_pending_transactions</code>(). If <code class=Fn>pcie_wait_for_pending_transactions</code>() fails with a timeout and <var class=Fa>force</var> is <code class=Dv>false</code>, busmastering is re-enabled and <code class=Dv>false</code> is returned. If <code class=Fn>pcie_wait_for_pending_transactions</code>() fails with a timeout and <var class=Fa>force</var> is <code class=Dv>true</code>, the device is reset despite the timeout. After the reset has been requested, <code class=Nm>pcie_flr</code> sleeps for at least 100 milliseconds before returning <code class=Dv>true</code>. Note that <code class=Nm>pcie_flr</code> does not save and restore any state around the reset. The caller should save and restore state as needed.</p></section><section class=Ss><h2 class=Ss id=Message_Signaled_Interrupts><a class=permalink href=#Message_Signaled_Interrupts>Message Signaled Interrupts</a></h2> Message Signaled Interrupts (MSI) and Enhanced Message Signaled Interrupts (MSI-X) are PCI capabilities that provide an alternate method for PCI devices to signal interrupts. The legacy INTx interrupt is available to PCI devices as a <code class=Dv>SYS_RES_IRQ</code> resource with a resource ID of zero. MSI and MSI-X interrupts are available to PCI devices as one or more <code class=Dv>SYS_RES_IRQ</code> resources with resource IDs greater than zero. A driver must ask the PCI bus to allocate MSI or MSI-X interrupts using <code class=Fn>pci_alloc_msi</code>() or <code class=Fn>pci_alloc_msix</code>() before it can use MSI or MSI-X <code class=Dv>SYS_RES_IRQ</code> resources. A driver is not allowed to use the legacy INTx <code class=Dv>SYS_RES_IRQ</code> resource if MSI or MSI-X interrupts have been allocated, and attempts to allocate MSI or MSI-X interrupts will fail if the driver is currently using the legacy INTx <code class=Dv>SYS_RES_IRQ</code> resource. A driver is only allowed to use either MSI or MSI-X, but not both. <p class=Pp>The <code class=Fn>pci_msi_count</code>() function returns the maximum number of MSI messages supported by the device <var class=Fa>dev</var>. If the device does not support MSI, then <code class=Fn>pci_msi_count</code>() returns zero.</p><p class=Pp>The <code class=Fn>pci_alloc_msi</code>() function attempts to allocate <var class=Fa>*count</var> MSI messages for the device <var class=Fa>dev</var>. The <code class=Fn>pci_alloc_msi</code>() function may allocate fewer messages than requested for various reasons including requests for more messages than the device <var class=Fa>dev</var> supports, or if the system has a shortage of available MSI messages. On success, <var class=Fa>*count</var> is set to the number of messages allocated and <code class=Fn>pci_alloc_msi</code>() returns zero. The <code class=Dv>SYS_RES_IRQ</code> resources for the allocated messages will be available at consecutive resource IDs beginning with one. If <code class=Fn>pci_alloc_msi</code>() is not able to allocate any messages, it returns an error. Note that MSI only supports message counts that are powers of two; requests to allocate a non-power of two count of messages will fail.</p><p class=Pp>The <code class=Fn>pci_release_msi</code>() function is used to release any allocated MSI or MSI-X messages back to the system. If any MSI or MSI-X <code class=Dv>SYS_RES_IRQ</code> resources are allocated by the driver or have a configured interrupt handler, this function will fail with <code class=Er>EBUSY</code>. The <code class=Fn>pci_release_msi</code>() function returns zero on success and an error on failure.</p><p class=Pp>The <code class=Fn>pci_msix_count</code>() function returns the maximum number of MSI-X messages supported by the device <var class=Fa>dev</var>. If the device does not support MSI-X, then <code class=Fn>pci_msix_count</code>() returns zero.</p><p class=Pp>The <code class=Fn>pci_msix_pba_bar</code>() function returns the offset in configuration space of the Base Address Register (BAR) containing the MSI-X Pending Bit Array (PBA) for device <var class=Fa>dev</var>. The returned value can be used as the resource ID with <a class=Xr href=bus_alloc_resource.9.html>bus_alloc_resource(9)</a> and <a class=Xr href=bus_release_resource.9.html>bus_release_resource(9)</a> to allocate the BAR. If the device does not support MSI-X, then <code class=Fn>pci_msix_pba_bar</code>() returns -1.</p><p class=Pp>The <code class=Fn>pci_msix_table_bar</code>() function returns the offset in configuration space of the BAR containing the MSI-X vector table for device <var class=Fa>dev</var>. The returned value can be used as the resource ID with <a class=Xr href=bus_alloc_resource.9.html>bus_alloc_resource(9)</a> and <a class=Xr href=bus_release_resource.9.html>bus_release_resource(9)</a> to allocate the BAR. If the device does not support MSI-X, then <code class=Fn>pci_msix_table_bar</code>() returns -1.</p><p class=Pp>The <code class=Fn>pci_alloc_msix</code>() function attempts to allocate <var class=Fa>*count</var> MSI-X messages for the device <var class=Fa>dev</var>. The <code class=Fn>pci_alloc_msix</code>() function may allocate fewer messages than requested for various reasons including requests for more messages than the device <var class=Fa>dev</var> supports, or if the system has a shortage of available MSI-X messages. On success, <var class=Fa>*count</var> is set to the number of messages allocated and <code class=Fn>pci_alloc_msix</code>() returns zero. For MSI-X messages, the resource ID for each <code class=Dv>SYS_RES_IRQ</code> resource identifies the index in the MSI-X table of the corresponding message. A resource ID of one maps to the first index of the MSI-X table; a resource ID two identifies the second index in the table, etc. The <code class=Fn>pci_alloc_msix</code>() function assigns the <var class=Fa>*count</var> messages allocated to the first <var class=Fa>*count</var> table indices. If <code class=Fn>pci_alloc_msix</code>() is not able to allocate any messages, it returns an error. Unlike MSI, MSI-X does not require message counts that are powers of two.</p><p class=Pp>The BARs containing the MSI-X vector table and PBA must be allocated via <a class=Xr href=bus_alloc_resource.9.html>bus_alloc_resource(9)</a> before calling <code class=Fn>pci_alloc_msix</code>() and must not be released until after calling <code class=Fn>pci_release_msi</code>(). Note that the vector table and PBA may be stored in the same BAR or in different BARs.</p><p class=Pp>The <code class=Fn>pci_pending_msix</code>() function examines the <var class=Fa>dev</var> device's PBA to determine the pending status of the MSI-X message at table index <var class=Fa>index</var>. If the indicated message is pending, this function returns a non-zero value; otherwise, it returns zero. Passing an invalid <var class=Fa>index</var> to this function will result in undefined behavior.</p><p class=Pp>As mentioned in the description of <code class=Fn>pci_alloc_msix</code>(), MSI-X messages are initially assigned to the first N table entries. A driver may use a different distribution of available messages to table entries via the <code class=Fn>pci_remap_msix</code>() function. Note that this function must be called after a successful call to <code class=Fn>pci_alloc_msix</code>() but before any of the <code class=Dv>SYS_RES_IRQ</code> resources are allocated. The <code class=Fn>pci_remap_msix</code>() function returns zero on success, or an error on failure.</p><p class=Pp>The <var class=Fa>vectors</var> array should contain <var class=Fa>count</var> message vectors. The array maps directly to the MSI-X table in that the first entry in the array specifies the message used for the first entry in the MSI-X table, the second entry in the array corresponds to the second entry in the MSI-X table, etc. The vector value in each array index can either be zero to indicate that no message should be assigned to the corresponding MSI-X table entry, or it can be a number from one to N (where N is the count returned from the previous call to <code class=Fn>pci_alloc_msix</code>()) to indicate which of the allocated messages should be assigned to the corresponding MSI-X table entry.</p><p class=Pp>If <code class=Fn>pci_remap_msix</code>() succeeds, each MSI-X table entry with a non-zero vector will have an associated <code class=Dv>SYS_RES_IRQ</code> resource whose resource ID corresponds to the table index as described above for <code class=Fn>pci_alloc_msix</code>(). MSI-X table entries that with a vector of zero will not have an associated <code class=Dv>SYS_RES_IRQ</code> resource. Additionally, if any of the original messages allocated by <code class=Fn>pci_alloc_msix</code>() are not used in the new distribution of messages in the MSI-X table, they will be released automatically. Note that if a driver wishes to use fewer messages than were allocated by <code class=Fn>pci_alloc_msix</code>(), the driver must use a single, contiguous range of messages beginning with one in the new distribution. The <code class=Fn>pci_remap_msix</code>() function will fail if this condition is not met.</p></section><section class=Ss><h2 class=Ss id=Device_Events><a class=permalink href=#Device_Events>Device Events</a></h2> The <var class=Va>pci_add_device</var> event handler is invoked every time a new PCI device is added to the system. This includes the creation of Virtual Functions via SR-IOV. <p class=Pp>The <var class=Va>pci_delete_device</var> event handler is invoked every time a PCI device is removed from the system.</p><p class=Pp>Both event handlers pass the <var class=Vt>device_t</var> object of the relevant PCI device as <var class=Fa>dev</var> to each callback function. Both event handlers are invoked while <var class=Fa>dev</var> is unattached but with valid instance variables.</p></section></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=pci.4.html>pci(4)</a>, <a class=Xr href=pciconf.8.html>pciconf(8)</a>, <a class=Xr href=bus_alloc_resource.9.html>bus_alloc_resource(9)</a>, <a class=Xr href=bus_dma.9.html>bus_dma(9)</a>, <a class=Xr href=bus_release_resource.9.html>bus_release_resource(9)</a>, <a class=Xr href=bus_setup_intr.9.html>bus_setup_intr(9)</a>, <a class=Xr href=bus_teardown_intr.9.html>bus_teardown_intr(9)</a>, <a class=Xr href=devclass.9.html>devclass(9)</a>, <a class=Xr href=device.9.html>device(9)</a>, <a class=Xr href=driver.9.html>driver(9)</a>, <a class=Xr href=eventhandler.9.html>eventhandler(9)</a>, <a class=Xr href=rman.9.html>rman(9)</a><p class=Pp><cite class=Rs><span class=RsT>NewBus</span>, <i class=RsB>FreeBSD Developers' Handbook</i>, <a href=https://www.FreeBSD.org/doc/en_US.ISO8859-1/books/developers-handbook/ class=RsU>https://www.FreeBSD.org/doc/en_US.ISO8859-1/books/developers-handbook/</a>.</cite></p><p class=Pp><cite class=Rs><span class=RsA>Shanley</span> and <span class=RsA>Anderson</span>, <i class=RsB>PCI System Architecture</i>, <i class=RsI>Addison-Wesley</i>, <span class=RsN>2nd Edition</span>, <span class=RsO>ISBN 0-201-30974-2</span>.</cite></p></section><section class=Sh><h2 class=Sh id=AUTHORS><a class=permalink href=#AUTHORS>AUTHORS</a></h2> This manual page was written by <span class=An>Bruce M Simpson</span> &lt;<a class=Mt href=mailto:bms@FreeBSD.org>bms@FreeBSD.org</a>&gt; and <span class=An>John Baldwin</span> &lt;<a class=Mt href=mailto:jhb@FreeBSD.org>jhb@FreeBSD.org</a>&gt;. </section><section class=Sh><h2 class=Sh id=BUGS><a class=permalink href=#BUGS>BUGS</a></h2> The kernel PCI code has a number of references to “slot numbers”. These do not refer to the geographic location of PCI devices, but to the device number assigned by the combination of the PCI IDSEL mechanism and the platform firmware. This should be taken note of when working with the kernel PCI code. <p class=Pp>The PCI bus driver should allocate the MSI-X vector table and PBA internally as necessary rather than requiring the caller to do so.</p></section></div><table class=foot><tr><td class=foot-date>January 15, 2017</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>