<!DOCTYPE html>
<html><head><meta charset=utf-8><title>ctf(5)</title><keywords content=man,ctf></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>ctf(5)</h1><table class=head><tr><td class=head-ltitle>CTF(5)</td><td class=head-vol>FreeBSD File Formats Manual</td><td class=head-rtitle>CTF(5)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>ctf</code> — <div class=Nd>Compact C Type Format</div></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/sys/ctf.h.html>sys/ctf.h</a>&gt;</code></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2><code class=Nm>ctf</code> is designed to be a compact representation of the C programming language's type information focused on serving the needs of dynamic tracing, debuggers, and other in-situ and post-mortem introspection tools. <code class=Nm>ctf</code> data is generally included in <b class=Sy>ELF</b> objects and is tagged as <b class=Sy>SHT_PROGBITS</b> to ensure that the data is accessible in a running process and in subsequent core dumps, if generated. <p class=Pp>The <code class=Nm>ctf</code> data contained in each file has information about the layout and sizes of C types, including intrinsic types, enumerations, structures, typedefs, and unions, that are used by the corresponding <b class=Sy>ELF</b> object. The <code class=Nm>ctf</code> data may also include information about the types of global objects and the return type and arguments of functions in the symbol table.</p><p class=Pp>Because a <code class=Nm>ctf</code> file is often embedded inside a file, rather than being a standalone file itself, it may also be referred to as a <code class=Nm>ctf</code><b class=Sy>container</b>.</p><p class=Pp>On <span class=Ux>FreeBSD</span> systems, <code class=Nm>ctf</code> data is consumed by <a class=Xr href=dtrace.1.html>dtrace(1)</a>. Programmatic access to <code class=Nm>ctf</code> data can be obtained through libctf.</p><p class=Pp>The <code class=Nm>ctf</code> file format is broken down into seven different sections. The first section is the <b class=Sy>preamble</b> and <b class=Sy>header</b>, which describes the version of the <code class=Nm>ctf</code> file, the links it has to other <code class=Nm>ctf</code> files, and the sizes of the other sections. The next section is the <b class=Sy>label</b> section, which provides a way of identifying similar groups of <code class=Nm>ctf</code> data across multiple files. This is followed by the <b class=Sy>object</b> information section, which describes the types of global symbols. The subsequent section is the <b class=Sy>function</b> information section, which describes the return types and arguments of functions. The next section is the <b class=Sy>type</b> information section, which describes the format and layout of the C types themselves, and finally the last section is the <b class=Sy>string</b> section, which contains the names of types, enumerations, members, and labels.</p><p class=Pp>While strictly speaking, only the <b class=Sy>preamble</b> and <b class=Sy>header</b> are required, to be actually useful, both the type and string sections are necessary.</p><p class=Pp>A <code class=Nm>ctf</code> file may contain all of the type information that it requires, or it may optionally refer to another <code class=Nm>ctf</code> file which holds the remaining types. When a <code class=Nm>ctf</code> file refers to another file, it is called the <b class=Sy>child</b> and the file it refers to is called the <b class=Sy>parent</b>. A given file may only refer to one parent. This process is called <i class=Em>uniquification</i> because it ensures each child only has type information that is unique to it. A common example of this is that most kernel modules in illumos are uniquified against the kernel module <b class=Sy>genunix</b> and the type information that comes from the <b class=Sy>IP</b> module. This means that a module only has types that are unique to itself and the most common types in the kernel are not duplicated.</p></section><section class=Sh><h2 class=Sh id=FILE_FORMAT><a class=permalink href=#FILE_FORMAT>FILE FORMAT</a></h2> This documents version <i class=Em>two</i> of the <code class=Nm>ctf</code> file format. All applications and tools on <span class=Ux>FreeBSD</span> currently produce and operate on this version. <p class=Pp>The file format can be summarized with the following image, the following sections will cover this in more detail.</p><div class="Bd Pp"><pre>

         +-------------+  0t0
+--------| Preamble    |
|        +-------------+  0t4
|+-------| Header      |
||       +-------------+  0t36 + cth_lbloff
||+------| Labels      |
|||      +-------------+  0t36 + cth_objtoff
|||+-----| Objects     |
||||     +-------------+  0t36 + cth_funcoff
||||+----| Functions   |
|||||    +-------------+  0t36 + cth_typeoff
|||||+---| Types       |
||||||   +-------------+  0t36 + cth_stroff
||||||+--| Strings     |
|||||||  +-------------+  0t36 + cth_stroff + cth_strlen
|||||||
|||||||
|||||||
|||||||    +-- magic -   vers   flags
|||||||    |          |    |      |
|||||||   +------+------+------+------+
+---------| 0xcf | 0xf1 | 0x02 | 0x00 |
 ||||||   +------+------+------+------+
 ||||||   0      1      2      3      4
 ||||||
 ||||||    + parent label        + objects
 ||||||    |       + parent name |     + functions    + strings
 ||||||    |       |     + label |     |      + types |       + strlen
 ||||||    |       |     |       |     |      |       |       |
 ||||||   +------+------+------+------+------+-------+-------+-------+
 +--------| 0x00 | 0x00 | 0x00 | 0x08 | 0x36 | 0x110 | 0x5f4 | 0x611 |
  |||||   +------+------+------+------+------+-------+-------+-------+
  |||||   0x04   0x08   0x0c   0x10   0x14    0x18    0x1c    0x20   0x24
  |||||
  |||||         + Label name
  |||||         |       + Label type
  |||||         |       |       + Next label
  |||||         |       |       |
  |||||       +-------+------+-----+
  +-----------| 0x01  | 0x42 | ... |
   ||||       +-------+------+-----+
   ||||  cth_lbloff   +0x4   +0x8  cth_objtoff
   ||||
   ||||
   |||| Symidx  0t15   0t43   0t44
   ||||       +------+------+------+-----+
   +----------| 0x00 | 0x42 | 0x36 | ... |
    |||       +------+------+------+-----+
    ||| cth_objtoff  +0x2   +0x4   +0x6   cth_funcoff
    |||
    |||        + CTF_TYPE_INFO         + CTF_TYPE_INFO
    |||        |        + Return type  |
    |||        |        |       + arg0 |
    |||       +--------+------+------+-----+
    +---------| 0x2c10 | 0x08 | 0x0c | ... |
     ||       +--------+------+------+-----+
     || cth_funcff     +0x2   +0x4   +0x6  cth_typeoff
     ||
     ||         + ctf_stype_t for type 1
     ||         |  integer           + integer encoding
     ||         |                    |          + ctf_stype_t for type 2
     ||         |                    |          |
     ||       +--------------------+-----------+-----+
     +--------| 0x19 * 0xc01 * 0x0 | 0x1000000 | ... |
      |       +--------------------+-----------+-----+
      | cth_typeoff               +0x08      +0x0c  cth_stroff
      |
      |     +--- str 0
      |     |    +--- str 1       + str 2
      |     |    |                |
      |     v    v                v
      |   +----+---+---+---+----+---+---+---+---+---+----+
      +---| \0 | i | n | t | \0 | f | o | o | _ | t | \0 |
          +----+---+---+---+----+---+---+---+---+---+----+
          0    1   2   3   4    5   6   7   8   9   10   11
</pre></div><p class=Pp>Every <code class=Nm>ctf</code> file begins with a <b class=Sy>preamble</b>, followed by a <b class=Sy>header</b>. The <b class=Sy>preamble</b> is defined as follows:</p><div class="Bd Pp"><pre>
typedef struct ctf_preamble {
	uint16_t ctp_magic;	/* magic number (CTF_MAGIC) */
	uint8_t ctp_version;	/* data format version number (CTF_VERSION) */
	uint8_t ctp_flags;	/* flags (see below) */
} ctf_preamble_t;
</pre></div><p class=Pp>The <b class=Sy>preamble</b> is four bytes long and must be four byte aligned. This <b class=Sy>preamble</b> defines the version of the <code class=Nm>ctf</code> file which defines the format of the rest of the header. While the header may change in subsequent versions, the preamble will not change across versions, though the interpretation of its flags may change from version to version. The <i class=Em>ctp_magic</i> member defines the magic number for the <code class=Nm>ctf</code> file format. This must always be <code class=Li>0xcff1</code>. If another value is encountered, then the file should not be treated as a <code class=Nm>ctf</code> file. The <i class=Em>ctp_version</i> member defines the version of the <code class=Nm>ctf</code> file. The current version is <code class=Li>2</code>. It is possible to encounter an unsupported version. In that case, software should not try to parse the format, as it may have changed. Finally, the <i class=Em>ctp_flags</i> member describes aspects of the file which modify its interpretation. The following flags are currently defined:</p><div class="Bd Pp"><pre>
#define	CTF_F_COMPRESS		0x01
</pre></div><p class=Pp>The flag <b class=Sy>CTF_F_COMPRESS</b> indicates that the body of the <code class=Nm>ctf</code> file, all the data following the <b class=Sy>header</b>, has been compressed through the <b class=Sy>zlib</b> library and its <b class=Sy>deflate</b> algorithm. If this flag is not present, then the body has not been compressed and no special action is needed to interpret it. All offsets into the data as described by <b class=Sy>header</b>, always refer to the <b class=Sy>uncompressed</b> data.</p><p class=Pp>In version two of the <code class=Nm>ctf</code> file format, the <b class=Sy>header</b> denotes whether or not this <code class=Nm>ctf</code> file is the child of another <code class=Nm>ctf</code> file and also indicates the size of the remaining sections. The structure for the <b class=Sy>header</b> logically contains a copy of the <b class=Sy>preamble</b> and the two have a combined size of 36 bytes.</p><div class="Bd Pp"><pre>
typedef struct ctf_header {
	ctf_preamble_t cth_preamble;
	uint32_t cth_parlabel;	/* ref to name of parent lbl uniq'd against */
	uint32_t cth_parname;	/* ref to basename of parent */
	uint32_t cth_lbloff;	/* offset of label section */
	uint32_t cth_objtoff;	/* offset of object section */
	uint32_t cth_funcoff;	/* offset of function section */
	uint32_t cth_typeoff;	/* offset of type section */
	uint32_t cth_stroff;	/* offset of string section */
	uint32_t cth_strlen;	/* length of string section in bytes */
} ctf_header_t;
</pre></div><p class=Pp>After the <b class=Sy>preamble</b>, the next two members <i class=Em>cth_parlablel</i> and <i class=Em>cth_parname</i>, are used to identify the parent. The value of both members are offsets into the <b class=Sy>string</b> section which point to the start of a null-terminated string. For more information on the encoding of strings, see the subsection on <a class=Sx href=#String_Identifiers>String Identifiers</a>. If the value of either is zero, then there is no entry for that member. If the member <i class=Em>cth_parlabel</i> is set, then the <i class=Em>ctf_parname</i> member must be set, otherwise it will not be possible to find the parent. If <i class=Em>ctf_parname</i> is set, it is not necessary to define <i class=Em>cth_parlabel</i>, as the parent may not have a label. For more information on labels and their interpretation, see <a class=Sx href=#The_Label_Section>The Label Section</a>.</p><p class=Pp>The remaining members (excepting <i class=Em>cth_strlen</i>) describe the beginning of the corresponding sections. These offsets are relative to the end of the <b class=Sy>header</b>. Therefore, something with an offset of 0 is at an offset of thirty-six bytes relative to the start of the <code class=Nm>ctf</code> file. The difference between members indicates the size of the section itself. Different offsets have different alignment requirements. The start of the <i class=Em>cth_objotoff</i> and <i class=Em>cth_funcoff</i> must be two byte aligned, while the sections <i class=Em>cth_lbloff</i> and <i class=Em>cth_typeoff</i> must be four-byte aligned. The section <i class=Em>cth_stroff</i> has no alignment requirements. To calculate the size of a given section, excepting the <b class=Sy>string</b> section, one should subtract the offset of the section from the following one. For example, the size of the <b class=Sy>types</b> section can be calculated by subtracting <i class=Em>cth_stroff</i> from <i class=Em>cth_typeoff</i>.</p><p class=Pp>Finally, the member <i class=Em>cth_strlen</i> describes the length of the string section itself. From it, you can also calculate the size of the entire <code class=Nm>ctf</code> file by adding together the size of the <b class=Sy>ctf_header_t</b>, the offset of the string section in <i class=Em>cth_stroff</i>, and the size of the string section in <i class=Em>cth_srlen</i>.</p><section class=Ss><h2 class=Ss id=Type_Identifiers><a class=permalink href=#Type_Identifiers>Type Identifiers</a></h2> Through the <code class=Nm>ctf</code> data, types are referred to by identifiers. A given <code class=Nm>ctf</code> file supports up to 32767 (0x7fff) types. The first valid type identifier is 0x1. When a given <code class=Nm>ctf</code> file is a child, indicated by a non-zero entry for the <b class=Sy>header</b>'s <i class=Em>cth_parname</i>, then the first valid type identifier is 0x8000 and the last is 0xffff. In this case, type identifiers 0x1 through 0x7fff are references to the parent. <p class=Pp>The type identifier zero is a sentinel value used to indicate that there is no type information available or it is an unknown type.</p><p class=Pp>Throughout the file format, the identifier is stored in different sized values; however, the minimum size to represent a given identifier is a <b class=Sy>uint16_t</b>. Other consumers of <code class=Nm>ctf</code> information may use larger or opaque identifiers.</p></section><section class=Ss><h2 class=Ss id=String_Identifiers><a class=permalink href=#String_Identifiers>String Identifiers</a></h2> String identifiers are always encoded as four byte unsigned integers which are an offset into a string table. The <code class=Nm>ctf</code> format supports two different string tables which have an identifier of zero or one. This identifier is stored in the high-order bit of the unsigned four byte offset. Therefore, the maximum supported offset into one of these tables is 0x7ffffffff. <p class=Pp>Table identifier zero, always refers to the <b class=Sy>string</b> section in the CTF file itself. String table identifier one refers to an external string table which is the ELF string table for the ELF symbol table associated with the <code class=Nm>ctf</code> container.</p></section><section class=Ss><h2 class=Ss id=Type_Encoding><a class=permalink href=#Type_Encoding>Type Encoding</a></h2> Every <code class=Nm>ctf</code> type begins with metadata encoded into a <b class=Sy>uint16_t</b>. This encoded information tells us three different pieces of information: <ul class="Bl-bullet Bd-indent Bl-compact"><li>The kind of the type</li><li>Whether this type is a root type or not</li><li>The length of the variable data</li></ul><p class=Pp>The 16 bits that make up the encoding are broken down such that you have five bits for the kind, one bit for indicating whether or not it is a root type, and 10 bits for the variable length. This is laid out as follows:</p><div class="Bd Pp Bd-indent"><pre>
+--------------------+
| kind | root | vlen |
+--------------------+
15   11   10   9    0
</pre></div><p class=Pp>The current version of the file format defines 14 different kinds. The interpretation of these different kinds will be discussed in the section <a class=Sx href=#The_Type_Section>The Type Section</a>. If a kind is encountered that is not listed below, then it is not a valid <code class=Nm>ctf</code> file. The kinds are defined as follows:</p><div class="Bd Pp Bd-indent"><pre>
#define	CTF_K_UNKNOWN	0
#define	CTF_K_INTEGER	1
#define	CTF_K_FLOAT	2
#define	CTF_K_POINTER	3
#define	CTF_K_ARRAY	4
#define	CTF_K_FUNCTION	5
#define	CTF_K_STRUCT	6
#define	CTF_K_UNION	7
#define	CTF_K_ENUM	8
#define	CTF_K_FORWARD	9
#define	CTF_K_TYPEDEF	10
#define	CTF_K_VOLATILE	11
#define	CTF_K_CONST	12
#define	CTF_K_RESTRICT	13
</pre></div><p class=Pp>Programs directly reference many types; however, other types are referenced indirectly because they are part of some other structure. These types that are referenced directly and used are called <b class=Sy>root</b> types. Other types may be used indirectly, for example, a program may reference a structure directly, but not one of its members which has a type. That type is not considered a <b class=Sy>root</b> type. If a type is a <b class=Sy>root</b> type, then it will have bit 10 set.</p><p class=Pp>The variable length section is specific to each kind and is discussed in the section <a class=Sx href=#The_Type_Section>The Type Section</a>.</p><p class=Pp>The following macros are useful for constructing and deconstructing the encoded type information:</p><div class="Bd Pp Bd-indent"><pre>

#define	CTF_MAX_VLEN	0x3ff
#define	CTF_INFO_KIND(info)	(((info) &amp; 0xf800) &gt;&gt; 11)
#define	CTF_INFO_ISROOT(info)	(((info) &amp; 0x0400) &gt;&gt; 10)
#define	CTF_INFO_VLEN(info)	(((info) &amp; CTF_MAX_VLEN))

#define	CTF_TYPE_INFO(kind, isroot, vlen) \
	(((kind) &lt;&lt; 11) | (((isroot) ? 1 : 0) &lt;&lt; 10) | ((vlen) &amp; CTF_MAX_VLEN))
</pre></div></section><section class=Ss><h2 class=Ss id=The_Label_Section><a class=permalink href=#The_Label_Section>The Label Section</a></h2> When consuming <code class=Nm>ctf</code> data, it is often useful to know whether two different <code class=Nm>ctf</code> containers come from the same source base and version. For example, when building illumos, there are many kernel modules that are built against a single collection of source code. A label is encoded into the <code class=Nm>ctf</code> files that corresponds with the particular build. This ensures that if files on the system were to become mixed up from multiple releases, that they are not used together by tools, particularly when a child needs to refer to a type in the parent. Because they are linked using the type identifiers, if the wrong parent is used then the wrong type will be encountered. <p class=Pp>Each label is encoded in the file format using the following eight byte structure:</p><div class="Bd Pp"><pre>
typedef struct ctf_lblent {
	uint32_t ctl_label;	/* ref to name of label */
	uint32_t ctl_typeidx;	/* last type associated with this label */
} ctf_lblent_t;
</pre></div><p class=Pp>Each label has two different components, a name and a type identifier. The name is encoded in the <i class=Em>ctl_label</i> member which is in the format defined in the section <a class=Sx href=#String_Identifiers>String Identifiers</a>. Generally, the names of all labels are found in the internal string section.</p><p class=Pp>The type identifier encoded in the member <i class=Em>ctl_typeidx</i> refers to the last type identifier that a label refers to in the current file. Labels only refer to types in the current file, if the <code class=Nm>ctf</code> file is a child, then it will have the same label as its parent; however, its label will only refer to its types, not its parent's.</p><p class=Pp>It is also possible, though rather uncommon, for a <code class=Nm>ctf</code> file to have multiple labels. Labels are placed one after another, every eight bytes. When multiple labels are present, types may only belong to a single label.</p></section><section class=Ss><h2 class=Ss id=The_Object_Section><a class=permalink href=#The_Object_Section>The Object Section</a></h2> The object section provides a mapping from ELF symbols of type <b class=Sy>STT_OBJECT</b> in the symbol table to a type identifier. Every entry in this section is a <b class=Sy>uint16_t</b> which contains a type identifier as described in the section <a class=Sx href=#Type_Identifiers>Type Identifiers</a>. If there is no information for an object, then the type identifier 0x0 is stored for that entry. <p class=Pp>To walk the object section, you need to have a corresponding <b class=Sy>symbol table</b> in the ELF object that contains the <code class=Nm>ctf</code> data. Not every object is included in this section. Specifically, when walking the symbol table, an entry is skipped if it matches any of the following conditions:</p><p class=Pp></p><ul class="Bl-bullet Bd-indent Bl-compact"><li>The symbol type is not <b class=Sy>STT_OBJECT</b></li><li>The symbol's section index is <b class=Sy>SHN_UNDEF</b></li><li>The symbol's name offset is zero</li><li>The symbol's section index is <b class=Sy>SHN_ABS</b> and the value of the symbol is zero.</li><li>The symbol's name is <code class=Li>_START_</code> or <code class=Li>_END_</code>. These are skipped because they are used for scoping local symbols in ELF.</li></ul><p class=Pp>The following sample code shows an example of iterating the object section and skipping the correct symbols:</p><div class="Bd Pp"><pre>
#include &lt;gelf.h&gt;
#include &lt;stdio.h&gt;

/*
 * Given the start of the object section in the CTF file, the number of symbols,
 * and the ELF Data sections for the symbol table and the string table, this
 * prints the type identifiers that correspond to objects. Note, a more robust
 * implementation should ensure that they don't walk beyond the end of the CTF
 * object section.
 */
static int
walk_symbols(uint16_t *objtoff, Elf_Data *symdata, Elf_Data *strdata,
    long nsyms)
{
	long i;
	uintptr_t strbase = strdata-&gt;d_buf;

	for (i = 1; i &lt; nsyms; i++, objftoff++) {
		const char *name;
		GElf_Sym sym;

		if (gelf_getsym(symdata, i, &amp;sym) == NULL)
			return (1);

		if (GELF_ST_TYPE(sym.st_info) != STT_OBJECT)
			continue;
		if (sym.st_shndx == SHN_UNDEF || sym.st_name == 0)
			continue;
		if (sym.st_shndx == SHN_ABS &amp;&amp; sym.st_value == 0)
			continue;
		name = (const char *)(strbase + sym.st_name);
		if (strcmp(name, "_START_") == 0 || strcmp(name, "_END_") == 0)
			continue;

		(void) printf("Symbol %d has type %d0, i, *objtoff);
	}

	return (0);
}
</pre></div></section><section class=Ss><h2 class=Ss id=The_Function_Section><a class=permalink href=#The_Function_Section>The Function Section</a></h2> The function section of the <code class=Nm>ctf</code> file encodes the types of both the function's arguments and the function's return value. Similar to <a class=Sx href=#The_Object_Section>The Object Section</a>, the function section encodes information for all symbols of type <b class=Sy>STT_FUNCTION</b>, excepting those that fit specific criteria. Unlike with objects, because functions have a variable number of arguments, they start with a type encoding as defined in <a class=Sx href=#Type_Encoding>Type Encoding</a>, which is the size of a <b class=Sy>uint16_t</b>. For functions which have no type information available, they are encoded as <code class=Li>CTF_TYPE_INFO(CTF_K_UNKNOWN, 0, 0)</code>. Functions with arguments are encoded differently. Here, the variable length is turned into the number of arguments in the function. If a function is a <b class=Sy>varargs</b> type function, then the number of arguments is increased by one. Functions with type information are encoded as: <code class=Li>CTF_TYPE_INFO(CTF_K_FUNCTION, 0, nargs)</code>. <p class=Pp>For functions that have no type information, nothing else is encoded, and the next function is encoded. For functions with type information, the next <b class=Sy>uint16_t</b> is encoded with the type identifier of the return type of the function. It is followed by each of the type identifiers of the arguments, if any exist, in the order that they appear in the function. Therefore, argument 0 is the first type identifier and so on. When a function has a final varargs argument, that is encoded with the type identifier of zero.</p><p class=Pp>Like <a class=Sx href=#The_Object_Section>The Object Section</a>, the function section is encoded in the order of the symbol table. It has similar, but slightly different considerations from objects. While iterating the symbol table, if any of the following conditions are true, then the entry is skipped and no corresponding entry is written:</p><p class=Pp></p><ul class="Bl-bullet Bd-indent Bl-compact"><li>The symbol type is not <b class=Sy>STT_FUNCTION</b></li><li>The symbol's section index is <b class=Sy>SHN_UNDEF</b></li><li>The symbol's name offset is zero</li><li>The symbol's name is <code class=Li>_START_</code> or <code class=Li>_END_</code>. These are skipped because they are used for scoping local symbols in ELF.</li></ul></section><section class=Ss><h2 class=Ss id=The_Type_Section><a class=permalink href=#The_Type_Section>The Type Section</a></h2> The type section is the heart of the <code class=Nm>ctf</code> data. It encodes all of the information about the types themselves. The base of the type information comes in two forms, a short form and a long form, each of which may be followed by a variable number of arguments. The following definitions describe the short and long forms: <div class="Bd Pp"><pre>
#define	CTF_MAX_SIZE	0xfffe	/* max size of a type in bytes */
#define	CTF_LSIZE_SENT	0xffff	/* sentinel for ctt_size */
#define	CTF_MAX_LSIZE	UINT64_MAX

typedef struct ctf_stype {
	uint32_t ctt_name;	/* reference to name in string table */
	uint16_t ctt_info;	/* encoded kind, variant length */
	union {
		uint16_t _size;	/* size of entire type in bytes */
		uint16_t _type;	/* reference to another type */
	} _u;
} ctf_stype_t;

typedef struct ctf_type {
	uint32_t ctt_name;	/* reference to name in string table */
	uint16_t ctt_info;	/* encoded kind, variant length */
	union {
		uint16_t _size;	/* always CTF_LSIZE_SENT */
		uint16_t _type; /* do not use */
	} _u;
	uint32_t ctt_lsizehi;	/* high 32 bits of type size in bytes */
	uint32_t ctt_lsizelo;	/* low 32 bits of type size in bytes */
} ctf_type_t;

#define	ctt_size _u._size	/* for fundamental types that have a size */
#define	ctt_type _u._type	/* for types that reference another type */
</pre></div><p class=Pp>Type sizes are stored in <b class=Sy>bytes</b>. The basic small form uses a <b class=Sy>uint16_t</b> to store the number of bytes. If the number of bytes in a structure would exceed 0xfffe, then the alternate form, the <b class=Sy>ctf_type_t</b>, is used instead. To indicate that the larger form is being used, the member <i class=Em>ctt_size</i> is set to value of <b class=Sy>CTF_LSIZE_SENT</b> (0xffff). In general, when going through the type section, consumers use the <b class=Sy>ctf_type_t</b> structure, but pay attention to the value of the member <i class=Em>ctt_size</i> to determine whether they should increment their scan by the size of the <b class=Sy>ctf_stype_t</b> or <b class=Sy>ctf_type_t</b>. Not all kinds of types use <b class=Sy>ctt_size</b>. Those which do not, will always use the <b class=Sy>ctf_stype_t</b> structure. The individual sections for each kind have more information.</p><p class=Pp>Types are written out in order. Therefore the first entry encountered has a type id of 0x1, or 0x8000 if a child. The member <i class=Em>ctt_name</i> is encoded as described in the section <a class=Sx href=#String_Identifiers>String Identifiers</a>. The string that it points to is the name of the type. If the identifier points to an empty string (one that consists solely of a null terminator) then the type does not have a name, this is common with anonymous structures and unions that only have a typedef to name them, as well as pointers and qualifiers.</p><p class=Pp>The next member, the <i class=Em>ctt_info</i>, is encoded as described in the section <a class=Sx href=#Type_Encoding>Type Encoding</a>. The type's kind tells us how to interpret the remaining data in the <b class=Sy>ctf_type_t</b> and any variable length data that may exist. The rest of this section will be broken down into the interpretation of the various kinds.</p></section><section class=Ss><h2 class=Ss id=Encoding_of_Integers><a class=permalink href=#Encoding_of_Integers>Encoding of Integers</a></h2> Integers, which are of type <b class=Sy>CTF_K_INTEGER</b>, have no variable length arguments. Instead, they are followed by a <b class=Sy>uint32_t</b> which describes their encoding. All integers must be encoded with a variable length of zero. The <i class=Em>ctt_size</i> member describes the length of the integer in bytes. In general, integer sizes will be rounded up to the closest power of two. <p class=Pp>The integer encoding contains three different pieces of information:</p><ul class="Bl-bullet Bd-indent Bl-compact"><li>The encoding of the integer</li><li>The offset in <b class=Sy>bits</b> of the type</li><li>The size in <b class=Sy>bits</b> of the type</li></ul><p class=Pp>This encoding can be expressed through the following macros:</p><div class="Bd Pp Bd-indent"><pre>
#define	CTF_INT_ENCODING(data)	(((data) &amp; 0xff000000) &gt;&gt; 24)
#define	CTF_INT_OFFSET(data)	(((data) &amp; 0x00ff0000) &gt;&gt; 16)
#define	CTF_INT_BITS(data)	(((data) &amp; 0x0000ffff))

#define	CTF_INT_DATA(encoding, offset, bits) \
	(((encoding) &lt;&lt; 24) | ((offset) &lt;&lt; 16) | (bits))
</pre></div><p class=Pp>The following flags are defined for the encoding at this time:</p><div class="Bd Pp Bd-indent"><pre>
#define	CTF_INT_SIGNED		0x01
#define	CTF_INT_CHAR		0x02
#define	CTF_INT_BOOL		0x04
#define	CTF_INT_VARARGS		0x08
</pre></div><p class=Pp>By default, an integer is considered to be unsigned, unless it has the <b class=Sy>CTF_INT_SIGNED</b> flag set. If the flag <b class=Sy>CTF_INT_CHAR</b> is set, that indicates that the integer is of a type that stores character data, for example the intrinsic C type <b class=Sy>char</b> would have the <b class=Sy>CTF_INT_CHAR</b> flag set. If the flag <b class=Sy>CTF_INT_BOOL</b> is set, that indicates that the integer represents a boolean type. For example, the intrinsic C type <b class=Sy>_Bool</b> would have the <b class=Sy>CTF_INT_BOOL</b> flag set. Finally, the flag <b class=Sy>CTF_INT_VARARGS</b> indicates that the integer is used as part of a variable number of arguments. This encoding is rather uncommon.</p></section><section class=Ss><h2 class=Ss id=Encoding_of_Floats><a class=permalink href=#Encoding_of_Floats>Encoding of Floats</a></h2> Floats, which are of type <b class=Sy>CTF_K_FLOAT</b>, are similar to their integer counterparts. They have no variable length arguments and are followed by a four byte encoding which describes the kind of float that exists. The <i class=Em>ctt_size</i> member is the size, in bytes, of the float. The float encoding has three different pieces of information inside of it: <p class=Pp></p><ul class="Bl-bullet Bd-indent Bl-compact"><li>The specific kind of float that exists</li><li>The offset in <b class=Sy>bits</b> of the float</li><li>The size in <b class=Sy>bits</b> of the float</li></ul><p class=Pp>This encoding can be expressed through the following macros:</p><div class="Bd Pp Bd-indent"><pre>
#define	CTF_FP_ENCODING(data)	(((data) &amp; 0xff000000) &gt;&gt; 24)
#define	CTF_FP_OFFSET(data)	(((data) &amp; 0x00ff0000) &gt;&gt; 16)
#define	CTF_FP_BITS(data)	(((data) &amp; 0x0000ffff))

#define	CTF_FP_DATA(encoding, offset, bits) \
	(((encoding) &lt;&lt; 24) | ((offset) &lt;&lt; 16) | (bits))
</pre></div><p class=Pp>Where as the encoding for integers is a series of flags, the encoding for floats maps to a specific kind of float. It is not a flag-based value. The kinds of floats correspond to both their size, and the encoding. This covers all of the basic C intrinsic floating point types. The following are the different kinds of floats represented in the encoding:</p><div class="Bd Pp Bd-indent"><pre>
#define	CTF_FP_SINGLE	1	/* IEEE 32-bit float encoding */
#define	CTF_FP_DOUBLE	2	/* IEEE 64-bit float encoding */
#define	CTF_FP_CPLX	3	/* Complex encoding */
#define	CTF_FP_DCPLX	4	/* Double complex encoding */
#define	CTF_FP_LDCPLX	5	/* Long double complex encoding */
#define	CTF_FP_LDOUBLE	6	/* Long double encoding */
#define	CTF_FP_INTRVL	7	/* Interval (2x32-bit) encoding */
#define	CTF_FP_DINTRVL	8	/* Double interval (2x64-bit) encoding */
#define	CTF_FP_LDINTRVL	9	/* Long double interval (2x128-bit) encoding */
#define	CTF_FP_IMAGRY	10	/* Imaginary (32-bit) encoding */
#define	CTF_FP_DIMAGRY	11	/* Long imaginary (64-bit) encoding */
#define	CTF_FP_LDIMAGRY	12	/* Long double imaginary (128-bit) encoding */
</pre></div></section><section class=Ss><h2 class=Ss id=Encoding_of_Arrays><a class=permalink href=#Encoding_of_Arrays>Encoding of Arrays</a></h2> Arrays, which are of type <b class=Sy>CTF_K_ARRAY</b>, have no variable length arguments. They are followed by a structure which describes the number of elements in the array, the type identifier of the elements in the array, and the type identifier of the index of the array. With arrays, the <i class=Em>ctt_size</i> member is set to zero. The structure that follows an array is defined as: <div class="Bd Pp"><pre>
typedef struct ctf_array {
	uint16_t cta_contents;	/* reference to type of array contents */
	uint16_t cta_index;	/* reference to type of array index */
	uint32_t cta_nelems;	/* number of elements */
} ctf_array_t;
</pre></div><p class=Pp>The <i class=Em>cta_contents</i> and <i class=Em>cta_index</i> members of the <b class=Sy>ctf_array_t</b> are type identifiers which are encoded as per the section <a class=Sx href=#Type_Identifiers>Type Identifiers</a>. The member <i class=Em>cta_nelems</i> is a simple four byte unsigned count of the number of elements. This count may be zero when encountering C99's flexible array members.</p></section><section class=Ss><h2 class=Ss id=Encoding_of_Functions><a class=permalink href=#Encoding_of_Functions>Encoding of Functions</a></h2> Function types, which are of type <b class=Sy>CTF_K_FUNCTION</b>, use the variable length list to be the number of arguments in the function. When the function has a final member which is a varargs, then the argument count is incremented by one to account for the variable argument. Here, the <i class=Em>ctt_type</i> member is encoded with the type identifier of the return type of the function. Note that the <i class=Em>ctt_size</i> member is not used here. <p class=Pp>The variable argument list contains the type identifiers for the arguments of the function, if any. Each one is represented by a <b class=Sy>uint16_t</b> and encoded according to the <a class=Sx href=#Type_Identifiers>Type Identifiers</a> section. If the function's last argument is of type varargs, then it is also written out, but the type identifier is zero. This is included in the count of the function's arguments. An extra type identifier may follow the argument and return type identifiers in order to maintain four-byte alignment for the following type definition. Such a type identifier is not included in the argument count and has a value of zero.</p></section><section class=Ss><h2 class=Ss id=Encoding_of_Structures_and_Unions><a class=permalink href=#Encoding_of_Structures_and_Unions>Encoding of Structures and Unions</a></h2> Structures and Unions, which are encoded with <b class=Sy>CTF_K_STRUCT</b> and <b class=Sy>CTF_K_UNION</b> respectively, are very similar constructs in C. The main difference between them is the fact that members of a structure follow one another, where as in a union, all members share the same memory. They are also very similar in terms of their encoding in <code class=Nm>ctf</code>. The variable length argument for structures and unions represents the number of members that they have. The value of the member <i class=Em>ctt_size</i> is the size of the structure and union. There are two different structures which are used to encode members in the variable list. When the size of a structure or union is greater than or equal to the large member threshold, 8192, then a different structure is used to encode the member, all members are encoded using the same structure. The structure for members is as follows: <div class="Bd Pp"><pre>
typedef struct ctf_member {
	uint32_t ctm_name;	/* reference to name in string table */
	uint16_t ctm_type;	/* reference to type of member */
	uint16_t ctm_offset;	/* offset of this member in bits */
} ctf_member_t;

typedef struct ctf_lmember {
	uint32_t ctlm_name;	/* reference to name in string table */
	uint16_t ctlm_type;	/* reference to type of member */
	uint16_t ctlm_pad;	/* padding */
	uint32_t ctlm_offsethi;	/* high 32 bits of member offset in bits */
	uint32_t ctlm_offsetlo;	/* low 32 bits of member offset in bits */
} ctf_lmember_t;
</pre></div><p class=Pp>Both the <i class=Em>ctm_name</i> and <i class=Em>ctlm_name</i> refer to the name of the member. The name is encoded as an offset into the string table as described by the section <a class=Sx href=#String_Identifiers>String Identifiers</a>. The members <b class=Sy>ctm_type</b> and <b class=Sy>ctlm_type</b> both refer to the type of the member. They are encoded as per the section <a class=Sx href=#Type_Identifiers>Type Identifiers</a>.</p><p class=Pp>The last piece of information that is present is the offset which describes the offset in memory at which the member begins. For unions, this value will always be zero because each member of a union has an offset of zero. For structures, this is the offset in <b class=Sy>bits</b> at which the member begins. Note that a compiler may lay out a type with padding. This means that the difference in offset between two consecutive members may be larger than the size of the member. When the size of the overall structure is strictly less than 8192 bytes, the normal structure, <b class=Sy>ctf_member_t</b>, is used and the offset in bits is stored in the member <i class=Em>ctm_offset</i>. However, when the size of the structure is greater than or equal to 8192 bytes, then the number of bits is split into two 32-bit quantities. One member, <i class=Em>ctlm_offsethi</i>, represents the upper 32 bits of the offset, while the other member, <i class=Em>ctlm_offsetlo</i>, represents the lower 32 bits of the offset. These can be joined together to get a 64-bit sized offset in bits by shifting the member <i class=Em>ctlm_offsethi</i> to the left by thirty two and then doing a binary or of <i class=Em>ctlm_offsetlo</i>.</p></section><section class=Ss><h2 class=Ss id=Encoding_of_Enumerations><a class=permalink href=#Encoding_of_Enumerations>Encoding of Enumerations</a></h2> Enumerations, noted by the type <b class=Sy>CTF_K_ENUM</b>, are similar to structures. Enumerations use the variable list to note the number of values that the enumeration contains, which we'll term enumerators. In C, an enumeration is always equivalent to the intrinsic type <b class=Sy>int</b>, thus the value of the member <i class=Em>ctt_size</i> is always the size of an integer which is determined based on the current model. For <span class=Ux>FreeBSD</span> systems, this will always be 4, as an integer is always defined to be 4 bytes large in both <b class=Sy>ILP32</b> and <b class=Sy>LP64</b>, regardless of the architecture. For further details, see <a class=Xr href=arch.7.html>arch(7)</a>. <p class=Pp>The enumerators encoded in an enumeration have the following structure in the variable list:</p><div class="Bd Pp"><pre>
typedef struct ctf_enum {
	uint32_t cte_name;	/* reference to name in string table */
	int32_t cte_value;	/* value associated with this name */
} ctf_enum_t;
</pre></div><p class=Pp>The member <i class=Em>cte_name</i> refers to the name of the enumerator's value, it is encoded according to the rules in the section <a class=Sx href=#String_Identifiers>String Identifiers</a>. The member <i class=Em>cte_value</i> contains the integer value of this enumerator.</p></section><section class=Ss><h2 class=Ss id=Encoding_of_Forward_References><a class=permalink href=#Encoding_of_Forward_References>Encoding of Forward References</a></h2> Forward references, types of kind <b class=Sy>CTF_K_FORWARD</b>, in a <code class=Nm>ctf</code> file refer to types which may not have a definition at all, only a name. If the <code class=Nm>ctf</code> file is a child, then it may be that the forward is resolved to an actual type in the parent, otherwise the definition may be in another <code class=Nm>ctf</code> container or may not be known at all. The only member of the <b class=Sy>ctf_type_t</b> that matters for a forward declaration is the <i class=Em>ctt_name</i> which points to the name of the forward reference in the string table as described earlier. There is no other information recorded for forward references. </section><section class=Ss><h2 class=Ss id=Encoding_of_Pointers,_Typedefs,_Volatile,_Const,_and_Restrict><a class=permalink href=#Encoding_of_Pointers,_Typedefs,_Volatile,_Const,_and_Restrict>Encoding of Pointers, Typedefs, Volatile, Const, and Restrict</a></h2> Pointers, typedefs, volatile, const, and restrict are all similar in <code class=Nm>ctf</code>. They all refer to another type. In the case of typedefs, they provide an alternate name, while volatile, const, and restrict change how the type is interpreted in the C programming language. This covers the <code class=Nm>ctf</code> kinds <b class=Sy>CTF_K_POINTER</b>, <b class=Sy>CTF_K_TYPEDEF</b>, <b class=Sy>CTF_K_VOLATILE</b>, <b class=Sy>CTF_K_RESTRICT</b>, and <b class=Sy>CTF_K_CONST</b>. <p class=Pp>These types have no variable list entries and use the member <i class=Em>ctt_type</i> to refer to the base type that they modify.</p></section><section class=Ss><h2 class=Ss id=Encoding_of_Unknown_Types><a class=permalink href=#Encoding_of_Unknown_Types>Encoding of Unknown Types</a></h2> Types with the kind <b class=Sy>CTF_K_UNKNOWN</b> are used to indicate gaps in the type identifier space. These entries consume an identifier, but do not define anything. Nothing should refer to these gap identifiers. </section><section class=Ss><h2 class=Ss id=Dependencies_Between_Types><a class=permalink href=#Dependencies_Between_Types>Dependencies Between Types</a></h2> C types can be imagined as a directed, cyclic, graph. Structures and unions may refer to each other in a way that creates a cyclic dependency. In cases such as these, the entire type section must be read in and processed. Consumers must not assume that every type can be laid out in dependency order; they cannot. </section><section class=Ss><h2 class=Ss id=The_String_Section><a class=permalink href=#The_String_Section>The String Section</a></h2> The last section of the <code class=Nm>ctf</code> file is the <b class=Sy>string</b> section. This section encodes all of the strings that appear throughout the other sections. It is laid out as a series of characters followed by a null terminator. Generally, all names are written out in ASCII, as most C compilers do not allow any characters to appear in identifiers outside of a subset of ASCII. However, any extended characters sets should be written out as a series of UTF-8 bytes. <p class=Pp>The first entry in the section, at offset zero, is a single null terminator to reference the empty string. Following that, each C string should be written out, including the null terminator. Offsets that refer to something in this section should refer to the first byte which begins a string. Beyond the first byte in the section being the null terminator, the order of strings is unimportant.</p></section><section class=Ss><h2 class=Ss id=Data_Encoding_and_ELF_Considerations><a class=permalink href=#Data_Encoding_and_ELF_Considerations>Data Encoding and ELF Considerations</a></h2><code class=Nm>ctf</code> data is generally included in ELF objects which specify information to identify the architecture and endianness of the file. A <code class=Nm>ctf</code> container inside such an object must match the endianness of the ELF object. Aside from the question of the endian encoding of data, there should be no other differences between architectures. While many of the types in this document refer to non-fixed size C integral types, they are equivalent in the models <b class=Sy>ILP32</b> and <b class=Sy>LP64</b>. If any other model is being used with <code class=Nm>ctf</code> data that has different sizes, then it must not use the model's sizes for those integral types and instead use the fixed size equivalents based on an <b class=Sy>ILP32</b> environment. <p class=Pp>When placing a <code class=Nm>ctf</code> container inside of an ELF object, there are certain conventions that are expected for the purposes of tooling being able to find the <code class=Nm>ctf</code> data. In particular, a given ELF object should only contain a single <code class=Nm>ctf</code> section. Multiple containers should be merged together into a single one.</p><p class=Pp>The <code class=Nm>ctf</code> file should be included in its own ELF section. The section's name must be ‘<code class=Li>.SUNW_ctf</code>’. The type of the section must be <b class=Sy>SHT_PROGBITS</b>. The section should have a link set to the symbol table and its address alignment must be 4.</p></section></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=dtrace.1.html>dtrace(1)</a>, <a class=Xr href=elf.3.html>elf(3)</a>, <a class=Xr href=gelf.3.html>gelf(3)</a>, <a class=Xr href=a.out.5.html>a.out(5)</a>, <a class=Xr href=elf.5.html>elf(5)</a>, <a class=Xr href=arch.7.html>arch(7)</a></section></div><table class=foot><tr><td class=foot-date>September 26, 2014</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>