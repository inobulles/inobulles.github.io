<!DOCTYPE html>
<html><head><meta charset=utf-8><title>pf(4)</title><keywords content=man,pf></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>pf(4)</h1><table class=head><tr><td class=head-ltitle>PF(4)</td><td class=head-vol>FreeBSD Kernel Interfaces Manual</td><td class=head-rtitle>PF(4)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>pf</code> — <div class=Nd>packet filter</div></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=Cd>device pf</code><br><code class=Cd>options PF_DEFAULT_TO_DROP</code></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> Packet filtering takes place in the kernel. A pseudo-device, <span class=Pa>/dev/pf</span>, allows userland processes to control the behavior of the packet filter through an <a class=Xr href=ioctl.2.html>ioctl(2)</a> interface. There are commands to enable and disable the filter, load rulesets, add and remove individual rules or state table entries, and retrieve statistics. The most commonly used functions are covered by <a class=Xr href=pfctl.8.html>pfctl(8)</a>. <p class=Pp>Manipulations like loading a ruleset that involve more than a single <a class=Xr href=ioctl.2.html>ioctl(2)</a> call require a so-called <i class=Em>ticket</i>, which prevents the occurrence of multiple concurrent manipulations.</p><p class=Pp>Fields of <a class=Xr href=ioctl.2.html>ioctl(2)</a> parameter structures that refer to packet data (like addresses and ports) are generally expected in network byte-order.</p><p class=Pp>Rules and address tables are contained in so-called <i class=Em>anchors</i>. When servicing an <a class=Xr href=ioctl.2.html>ioctl(2)</a> request, if the anchor field of the argument structure is empty, the kernel will use the default anchor (i.e., the main ruleset) in operations. Anchors are specified by name and may be nested, with components separated by ‘/’ characters, similar to how file system hierarchies are laid out. The final component of the anchor path is the anchor under which operations will be performed.</p></section><section class=Sh><h2 class=Sh id=SYSCTL_VARIABLES_AND_LOADER_TUNABLES><a class=permalink href=#SYSCTL_VARIABLES_AND_LOADER_TUNABLES>SYSCTL VARIABLES AND LOADER TUNABLES</a></h2> The following <a class=Xr href=loader.8.html>loader(8)</a> tunables are available. <dl class=Bl-tag><dt><var class=Va>net.pf.states_hashsize</var></dt><dd>Size of hash tables that store states. Should be power of 2. Default value is 131072.</dd><dt><var class=Va>net.pf.source_nodes_hashsize</var></dt><dd>Size of hash table that store source nodes. Should be power of 2. Default value is 32768.</dd></dl><p class=Pp>Read only <a class=Xr href=sysctl.8.html>sysctl(8)</a> variables with matching names are provided to obtain current values at runtime.</p></section><section class=Sh><h2 class=Sh id=KERNEL_OPTIONS><a class=permalink href=#KERNEL_OPTIONS>KERNEL OPTIONS</a></h2> The following options in the kernel configuration file are related to <code class=Nm>pf</code> operation: <p class=Pp></p><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#PF_DEFAULT_TO_DROP><code class=Dv id=PF_DEFAULT_TO_DROP>PF_DEFAULT_TO_DROP</code></a></dt><dd>Change default policy to drop by default</dd></dl></section><section class=Sh><h2 class=Sh id=IOCTL_INTERFACE><a class=permalink href=#IOCTL_INTERFACE>IOCTL INTERFACE</a></h2><code class=Nm>pf</code> supports the following <a class=Xr href=ioctl.2.html>ioctl(2)</a> commands, available through ⟨<span class=Pa>net/pfvar.h</span>⟩: <dl class=Bl-tag><dt><a class=permalink href=#DIOCSTART><code class=Dv id=DIOCSTART>DIOCSTART</code></a></dt><dd>Start the packet filter.</dd><dt><a class=permalink href=#DIOCSTOP><code class=Dv id=DIOCSTOP>DIOCSTOP</code></a></dt><dd>Stop the packet filter.</dd><dt><a class=permalink href=#DIOCSTARTALTQ><code class=Dv id=DIOCSTARTALTQ>DIOCSTARTALTQ</code></a></dt><dd>Start the ALTQ bandwidth control system (see <a class=Xr href=altq.9.html>altq(9)</a>).</dd><dt><a class=permalink href=#DIOCSTOPALTQ><code class=Dv id=DIOCSTOPALTQ>DIOCSTOPALTQ</code></a></dt><dd>Stop the ALTQ bandwidth control system.</dd><dt><a class=permalink href=#DIOCBEGINADDRS><code class=Dv id=DIOCBEGINADDRS>DIOCBEGINADDRS</code></a><var class=Fa>struct pfioc_pooladdr *pp</var></dt><dd><div class="Bd Pp"><pre>
struct pfioc_pooladdr {
	u_int32_t		action;
	u_int32_t		ticket;
	u_int32_t		nr;
	u_int32_t		r_num;
	u_int8_t		r_action;
	u_int8_t		r_last;
	u_int8_t		af;
	char			anchor[MAXPATHLEN];
	struct pf_pooladdr	addr;
};
    </pre></div><p class=Pp>Clear the buffer address pool and get a <var class=Va>ticket</var> for subsequent <code class=Dv>DIOCADDADDR</code>, <code class=Dv>DIOCADDRULE</code>, and <code class=Dv>DIOCCHANGERULE</code> calls.</p></dd><dt><a class=permalink href=#DIOCADDADDR><code class=Dv id=DIOCADDADDR>DIOCADDADDR</code></a><var class=Fa>struct pfioc_pooladdr *pp</var></dt><dd><p class=Pp>Add the pool address <var class=Va>addr</var> to the buffer address pool to be used in the following <code class=Dv>DIOCADDRULE</code> or <code class=Dv>DIOCCHANGERULE</code> call. All other members of the structure are ignored.</p></dd><dt><a class=permalink href=#DIOCADDRULE><code class=Dv id=DIOCADDRULE>DIOCADDRULE</code></a><var class=Fa>struct pfioc_rule *pr</var></dt><dd><div class="Bd Pp"><pre>
struct pfioc_rule {
	u_int32_t	action;
	u_int32_t	ticket;
	u_int32_t	pool_ticket;
	u_int32_t	nr;
	char		anchor[MAXPATHLEN];
	char		anchor_call[MAXPATHLEN];
	struct pf_rule	rule;
};
    </pre></div><p class=Pp>Add <var class=Va>rule</var> at the end of the inactive ruleset. This call requires a <var class=Va>ticket</var> obtained through a preceding <code class=Dv>DIOCXBEGIN</code> call and a <var class=Va>pool_ticket</var> obtained through a <code class=Dv>DIOCBEGINADDRS</code> call. <code class=Dv>DIOCADDADDR</code> must also be called if any pool addresses are required. The optional <var class=Va>anchor</var> name indicates the anchor in which to append the rule. <var class=Va>nr</var> and <var class=Va>action</var> are ignored.</p></dd><dt><a class=permalink href=#DIOCADDALTQ><code class=Dv id=DIOCADDALTQ>DIOCADDALTQ</code></a><var class=Fa>struct pfioc_altq *pa</var></dt><dd>Add an ALTQ discipline or queue. <div class="Bd Pp"><pre>
struct pfioc_altq {
	u_int32_t	action;
	u_int32_t	ticket;
	u_int32_t	nr;
	struct pf_altq  altq;
};
    </pre></div></dd><dt><a class=permalink href=#DIOCGETRULES><code class=Dv id=DIOCGETRULES>DIOCGETRULES</code></a><var class=Fa>struct pfioc_rule *pr</var></dt><dd>Get a <var class=Va>ticket</var> for subsequent <code class=Dv>DIOCGETRULE</code> calls and the number <var class=Va>nr</var> of rules in the active ruleset.</dd><dt><a class=permalink href=#DIOCGETRULE><code class=Dv id=DIOCGETRULE>DIOCGETRULE</code></a><var class=Fa>struct pfioc_rule *pr</var></dt><dd>Get a <var class=Va>rule</var> by its number <var class=Va>nr</var> using the <var class=Va>ticket</var> obtained through a preceding <code class=Dv>DIOCGETRULES</code> call. If <var class=Va>action</var> is set to <code class=Dv>PF_GET_CLR_CNTR</code>, the per-rule statistics on the requested rule are cleared.</dd><dt><a class=permalink href=#DIOCGETADDRS><code class=Dv id=DIOCGETADDRS>DIOCGETADDRS</code></a><var class=Fa>struct pfioc_pooladdr *pp</var></dt><dd>Get a <var class=Va>ticket</var> for subsequent <code class=Dv>DIOCGETADDR</code> calls and the number <var class=Va>nr</var> of pool addresses in the rule specified with <var class=Va>r_action</var>, <var class=Va>r_num</var>, and <var class=Va>anchor</var>.</dd><dt><a class=permalink href=#DIOCGETADDR><code class=Dv id=DIOCGETADDR>DIOCGETADDR</code></a><var class=Fa>struct pfioc_pooladdr *pp</var></dt><dd>Get the pool address <var class=Va>addr</var> by its number <var class=Va>nr</var> from the rule specified with <var class=Va>r_action</var>, <var class=Va>r_num</var>, and <var class=Va>anchor</var> using the <var class=Va>ticket</var> obtained through a preceding <code class=Dv>DIOCGETADDRS</code> call.</dd><dt><a class=permalink href=#DIOCGETALTQS><code class=Dv id=DIOCGETALTQS>DIOCGETALTQS</code></a><var class=Fa>struct pfioc_altq *pa</var></dt><dd>Get a <var class=Va>ticket</var> for subsequent <code class=Dv>DIOCGETALTQ</code> calls and the number <var class=Va>nr</var> of queues in the active list.</dd><dt><a class=permalink href=#DIOCGETALTQ><code class=Dv id=DIOCGETALTQ>DIOCGETALTQ</code></a><var class=Fa>struct pfioc_altq *pa</var></dt><dd>Get the queueing discipline <var class=Va>altq</var> by its number <var class=Va>nr</var> using the <var class=Va>ticket</var> obtained through a preceding <code class=Dv>DIOCGETALTQS</code> call.</dd><dt><a class=permalink href=#DIOCGETQSTATS><code class=Dv id=DIOCGETQSTATS>DIOCGETQSTATS</code></a><var class=Fa>struct pfioc_qstats *pq</var></dt><dd>Get the statistics on a queue. <div class="Bd Pp"><pre>
struct pfioc_qstats {
	u_int32_t	 ticket;
	u_int32_t	 nr;
	void		*buf;
	int		 nbytes;
	u_int8_t	 scheduler;
};
    </pre></div><p class=Pp>This call fills in a pointer to the buffer of statistics <var class=Va>buf</var>, of length <var class=Va>nbytes</var>, for the queue specified by <var class=Va>nr</var>.</p></dd><dt><a class=permalink href=#DIOCGETRULESETS><code class=Dv id=DIOCGETRULESETS>DIOCGETRULESETS</code></a><var class=Fa>struct pfioc_ruleset *pr</var></dt><dd><div class="Bd Pp"><pre>
struct pfioc_ruleset {
	u_int32_t	 nr;
	char		 path[MAXPATHLEN];
	char		 name[PF_ANCHOR_NAME_SIZE];
};
    </pre></div><p class=Pp>Get the number <var class=Va>nr</var> of rulesets (i.e., anchors) directly attached to the anchor named by <var class=Va>path</var> for use in subsequent <code class=Dv>DIOCGETRULESET</code> calls. Nested anchors, since they are not directly attached to the given anchor, will not be included. This ioctl returns <code class=Er>EINVAL</code> if the given anchor does not exist.</p></dd><dt><a class=permalink href=#DIOCGETRULESET><code class=Dv id=DIOCGETRULESET>DIOCGETRULESET</code></a><var class=Fa>struct pfioc_ruleset *pr</var></dt><dd>Get a ruleset (i.e., an anchor) <var class=Va>name</var> by its number <var class=Va>nr</var> from the given anchor <var class=Va>path</var>, the maximum number of which can be obtained from a preceding <code class=Dv>DIOCGETRULESETS</code> call. This ioctl returns <code class=Er>EINVAL</code> if the given anchor does not exist or <code class=Er>EBUSY</code> if another process is concurrently updating a ruleset.</dd><dt><a class=permalink href=#DIOCADDSTATE><code class=Dv id=DIOCADDSTATE>DIOCADDSTATE</code></a><var class=Fa>struct pfioc_state *ps</var></dt><dd>Add a state entry. <div class="Bd Pp"><pre>
struct pfioc_state {
	struct pfsync_state	state;
};
    </pre></div></dd><dt><a class=permalink href=#DIOCGETSTATENV><code class=Dv id=DIOCGETSTATENV>DIOCGETSTATENV</code></a><var class=Fa>struct pfioc_nv *nv</var></dt><dd>Extract the entry identified by the <var class=Va>id</var> and <var class=Va>creatorid</var> fields of the <var class=Va>state</var> nvlist from the state table.</dd><dt><a class=permalink href=#DIOCKILLSTATES><code class=Dv id=DIOCKILLSTATES>DIOCKILLSTATES</code></a><var class=Fa>struct pfioc_state_kill *psk</var></dt><dd>Remove matching entries from the state table. This ioctl returns the number of killed states in <var class=Va>psk_killed</var>. <div class="Bd Pp"><pre>
struct pfioc_state_kill {
	struct pf_state_cmp	psk_pfcmp;
	sa_family_t		psk_af;
	int			psk_proto;
	struct pf_rule_addr	psk_src;
	struct pf_rule_addr	psk_dst;
	char			psk_ifname[IFNAMSIZ];
	char			psk_label[PF_RULE_LABEL_SIZE];
	u_int			psk_killed;
};
    </pre></div></dd><dt><a class=permalink href=#DIOCCLRSTATES><code class=Dv id=DIOCCLRSTATES>DIOCCLRSTATES</code></a><var class=Fa>struct pfioc_state_kill *psk</var></dt><dd>Clear all states. It works like <code class=Dv>DIOCKILLSTATES</code>, but ignores the <var class=Va>psk_af</var>, <var class=Va>psk_proto</var>, <var class=Va>psk_src</var>, and <var class=Va>psk_dst</var> fields of the <var class=Vt>pfioc_state_kill</var> structure.</dd><dt><a class=permalink href=#DIOCSETSTATUSIF><code class=Dv id=DIOCSETSTATUSIF>DIOCSETSTATUSIF</code></a><var class=Fa>struct pfioc_if *pi</var></dt><dd>Specify the interface for which statistics are accumulated. <div class="Bd Pp"><pre>
struct pfioc_if {
	char		 ifname[IFNAMSIZ];
};
    </pre></div></dd><dt><a class=permalink href=#DIOCGETSTATUS><code class=Dv id=DIOCGETSTATUS>DIOCGETSTATUS</code></a><var class=Fa>struct pf_status *s</var></dt><dd>Get the internal packet filter statistics. <div class="Bd Pp"><pre>
struct pf_status {
	u_int64_t	counters[PFRES_MAX];
	u_int64_t	lcounters[LCNT_MAX];
	u_int64_t	fcounters[FCNT_MAX];
	u_int64_t	scounters[SCNT_MAX];
	u_int64_t	pcounters[2][2][3];
	u_int64_t	bcounters[2][2];
	u_int32_t	running;
	u_int32_t	states;
	u_int32_t	src_nodes;
	u_int32_t	since;
	u_int32_t	debug;
	u_int32_t	hostid;
	char		ifname[IFNAMSIZ];
	u_int8_t	pf_chksum[MD5_DIGEST_LENGTH];
};
    </pre></div></dd><dt><a class=permalink href=#DIOCCLRSTATUS><code class=Dv id=DIOCCLRSTATUS>DIOCCLRSTATUS</code></a></dt><dd>Clear the internal packet filter statistics.</dd><dt><a class=permalink href=#DIOCNATLOOK><code class=Dv id=DIOCNATLOOK>DIOCNATLOOK</code></a><var class=Fa>struct pfioc_natlook *pnl</var></dt><dd>Look up a state table entry by source and destination addresses and ports. <div class="Bd Pp"><pre>
struct pfioc_natlook {
	struct pf_addr	 saddr;
	struct pf_addr	 daddr;
	struct pf_addr	 rsaddr;
	struct pf_addr	 rdaddr;
	u_int16_t	 sport;
	u_int16_t	 dport;
	u_int16_t	 rsport;
	u_int16_t	 rdport;
	sa_family_t	 af;
	u_int8_t	 proto;
	u_int8_t	 direction;
};
    </pre></div></dd><dt><a class=permalink href=#DIOCSETDEBUG><code class=Dv id=DIOCSETDEBUG>DIOCSETDEBUG</code></a><var class=Fa>u_int32_t *level</var></dt><dd>Set the debug level. <div class="Bd Pp"><pre>
enum	{ PF_DEBUG_NONE, PF_DEBUG_URGENT, PF_DEBUG_MISC,
	  PF_DEBUG_NOISY };
    </pre></div></dd><dt><a class=permalink href=#DIOCGETSTATESNV><code class=Dv id=DIOCGETSTATESNV>DIOCGETSTATESNV</code></a><var class=Fa>struct pfioc_nv *nv</var></dt><dd>Get state table entries. <div class="Bd Pp"><pre>
nvlist pf_state_key {
	nvlist pf_addr	addr[2];
	number		port[2];
	number		af;
	number		proto;
};

nvlist pf_state_scrub {
	bool	timestamp;
	number	ttl;
	number	ts_mod;
};

nvlist pf_state_peer {
	nvlist pf_state_scrub	scrub;
	number			seqlo;
	number			seqhi;
	number			seqdiff;
	number			max_win;
	number			mss;
	number			state;
	number			wscale;
};

nvlist pf_state {
	number			id;
	string			ifname;
	nvlist pf_state_key	stack_key;
	nvlist pf_state_key	wire_key;
	nvlist pf_state_peer	src;
	nvlist pf_state_peer	dst;
	nvlist pf_addr		rt_addr;
	number			rule;
	number			anchor;
	number			nat_rule;
	number			expire;
	number			packets[2];
	number			bytes[2];
	number			creatorid;
	number			direction;
	number			log;
	number			state_flags;
	number			timeout;
	number			sync_flags;
};

nvlist pf_states {
	number		count;
	nvlist pf_state	states[];
};
    </pre></div><p class=Pp>If <var class=Va>pfioc_nv.size</var> is insufficiently large, as many states as possible that can fit into this size will be copied into the supplied buffer.</p></dd><dt><a class=permalink href=#DIOCCHANGERULE><code class=Dv id=DIOCCHANGERULE>DIOCCHANGERULE</code></a><var class=Fa>struct pfioc_rule *pcr</var></dt><dd>Add or remove the <var class=Va>rule</var> in the ruleset specified by <var class=Va>rule.action</var>. <p class=Pp>The type of operation to be performed is indicated by <var class=Va>action</var>, which can be any of the following:</p><div class="Bd Pp"><pre>
enum	{ PF_CHANGE_NONE, PF_CHANGE_ADD_HEAD, PF_CHANGE_ADD_TAIL,
	  PF_CHANGE_ADD_BEFORE, PF_CHANGE_ADD_AFTER,
	  PF_CHANGE_REMOVE, PF_CHANGE_GET_TICKET };
    </pre></div><p class=Pp><var class=Va>ticket</var> must be set to the value obtained with <code class=Dv>PF_CHANGE_GET_TICKET</code> for all actions except <code class=Dv>PF_CHANGE_GET_TICKET</code>. <var class=Va>pool_ticket</var> must be set to the value obtained with the <code class=Dv>DIOCBEGINADDRS</code> call for all actions except <code class=Dv>PF_CHANGE_REMOVE</code> and <code class=Dv>PF_CHANGE_GET_TICKET</code>. <var class=Va>anchor</var> indicates to which anchor the operation applies. <var class=Va>nr</var> indicates the rule number against which <code class=Dv>PF_CHANGE_ADD_BEFORE</code>, <code class=Dv>PF_CHANGE_ADD_AFTER</code>, or <code class=Dv>PF_CHANGE_REMOVE</code> actions are applied.</p></dd><dt><a class=permalink href=#DIOCCHANGEADDR><code class=Dv id=DIOCCHANGEADDR>DIOCCHANGEADDR</code></a><var class=Fa>struct pfioc_pooladdr *pca</var></dt><dd>Add or remove the pool address <var class=Va>addr</var> from the rule specified by <var class=Va>r_action</var>, <var class=Va>r_num</var>, and <var class=Va>anchor</var>.</dd><dt><a class=permalink href=#DIOCSETTIMEOUT><code class=Dv id=DIOCSETTIMEOUT>DIOCSETTIMEOUT</code></a><var class=Fa>struct pfioc_tm *pt</var></dt><dd><div class="Bd Pp"><pre>
struct pfioc_tm {
	int		 timeout;
	int		 seconds;
};
    </pre></div><p class=Pp>Set the state timeout of <var class=Va>timeout</var> to <var class=Va>seconds</var>. The old value will be placed into <var class=Va>seconds</var>. For possible values of <var class=Va>timeout</var>, consult the <code class=Dv>PFTM_*</code> values in ⟨<span class=Pa>net/pfvar.h</span>⟩.</p></dd><dt><a class=permalink href=#DIOCGETTIMEOUT><code class=Dv id=DIOCGETTIMEOUT>DIOCGETTIMEOUT</code></a><var class=Fa>struct pfioc_tm *pt</var></dt><dd>Get the state timeout of <var class=Va>timeout</var>. The value will be placed into the <var class=Va>seconds</var> field.</dd><dt><a class=permalink href=#DIOCCLRRULECTRS><code class=Dv id=DIOCCLRRULECTRS>DIOCCLRRULECTRS</code></a></dt><dd>Clear per-rule statistics.</dd><dt><a class=permalink href=#DIOCSETLIMIT><code class=Dv id=DIOCSETLIMIT>DIOCSETLIMIT</code></a><var class=Fa>struct pfioc_limit *pl</var></dt><dd>Set the hard limits on the memory pools used by the packet filter. <div class="Bd Pp"><pre>
struct pfioc_limit {
	int		index;
	unsigned	limit;
};

enum	{ PF_LIMIT_STATES, PF_LIMIT_SRC_NODES, PF_LIMIT_FRAGS,
	  PF_LIMIT_TABLE_ENTRIES, PF_LIMIT_MAX };
    </pre></div></dd><dt><a class=permalink href=#DIOCGETLIMIT><code class=Dv id=DIOCGETLIMIT>DIOCGETLIMIT</code></a><var class=Fa>struct pfioc_limit *pl</var></dt><dd>Get the hard <var class=Va>limit</var> for the memory pool indicated by <var class=Va>index</var>.</dd><dt><a class=permalink href=#DIOCRCLRTABLES><code class=Dv id=DIOCRCLRTABLES>DIOCRCLRTABLES</code></a><var class=Fa>struct pfioc_table *io</var></dt><dd>Clear all tables. All the ioctls that manipulate radix tables use the same structure described below. For <code class=Dv>DIOCRCLRTABLES</code>, <var class=Va>pfrio_ndel</var> contains on exit the number of tables deleted. <div class="Bd Pp"><pre>
struct pfioc_table {
	struct pfr_table	 pfrio_table;
	void			*pfrio_buffer;
	int			 pfrio_esize;
	int			 pfrio_size;
	int			 pfrio_size2;
	int			 pfrio_nadd;
	int			 pfrio_ndel;
	int			 pfrio_nchange;
	int			 pfrio_flags;
	u_int32_t		 pfrio_ticket;
};
#define pfrio_exists    pfrio_nadd
#define pfrio_nzero     pfrio_nadd
#define pfrio_nmatch    pfrio_nadd
#define pfrio_naddr     pfrio_size2
#define pfrio_setflag   pfrio_size2
#define pfrio_clrflag   pfrio_nadd
    </pre></div></dd><dt><a class=permalink href=#DIOCRADDTABLES><code class=Dv id=DIOCRADDTABLES>DIOCRADDTABLES</code></a><var class=Fa>struct pfioc_table *io</var></dt><dd>Create one or more tables. On entry, <var class=Va>pfrio_buffer</var> must point to an array of <var class=Vt>struct pfr_table</var> containing at least <var class=Vt>pfrio_size</var> elements. <var class=Vt>pfrio_esize</var> must be the size of <var class=Vt>struct pfr_table</var>. On exit, <var class=Va>pfrio_nadd</var> contains the number of tables effectively created. <div class="Bd Pp"><pre>
struct pfr_table {
	char		pfrt_anchor[MAXPATHLEN];
	char		pfrt_name[PF_TABLE_NAME_SIZE];
	u_int32_t	pfrt_flags;
	u_int8_t	pfrt_fback;
};
    </pre></div></dd><dt><a class=permalink href=#DIOCRDELTABLES><code class=Dv id=DIOCRDELTABLES>DIOCRDELTABLES</code></a><var class=Fa>struct pfioc_table *io</var></dt><dd>Delete one or more tables. On entry, <var class=Va>pfrio_buffer</var> must point to an array of <var class=Vt>struct pfr_table</var> containing at least <var class=Vt>pfrio_size</var> elements. <var class=Vt>pfrio_esize</var> must be the size of <var class=Vt>struct pfr_table</var>. On exit, <var class=Va>pfrio_ndel</var> contains the number of tables effectively deleted.</dd><dt><a class=permalink href=#DIOCRGETTABLES><code class=Dv id=DIOCRGETTABLES>DIOCRGETTABLES</code></a><var class=Fa>struct pfioc_table *io</var></dt><dd>Get the list of all tables. On entry, <var class=Va>pfrio_buffer[pfrio_size]</var> contains a valid writeable buffer for <var class=Vt>pfr_table</var> structures. On exit, <var class=Va>pfrio_size</var> contains the number of tables written into the buffer. If the buffer is too small, the kernel does not store anything but just returns the required buffer size, without error.</dd><dt><a class=permalink href=#DIOCRGETTSTATS><code class=Dv id=DIOCRGETTSTATS>DIOCRGETTSTATS</code></a><var class=Fa>struct pfioc_table *io</var></dt><dd>This call is like <code class=Dv>DIOCRGETTABLES</code> but is used to get an array of <var class=Vt>pfr_tstats</var> structures. <div class="Bd Pp"><pre>
struct pfr_tstats {
	struct pfr_table pfrts_t;
	u_int64_t	 pfrts_packets
			     [PFR_DIR_MAX][PFR_OP_TABLE_MAX];
	u_int64_t	 pfrts_bytes
			     [PFR_DIR_MAX][PFR_OP_TABLE_MAX];
	u_int64_t	 pfrts_match;
	u_int64_t	 pfrts_nomatch;
	long		 pfrts_tzero;
	int		 pfrts_cnt;
	int		 pfrts_refcnt[PFR_REFCNT_MAX];
};
#define pfrts_name	 pfrts_t.pfrt_name
#define pfrts_flags	 pfrts_t.pfrt_flags
    </pre></div></dd><dt><a class=permalink href=#DIOCRCLRTSTATS><code class=Dv id=DIOCRCLRTSTATS>DIOCRCLRTSTATS</code></a><var class=Fa>struct pfioc_table *io</var></dt><dd>Clear the statistics of one or more tables. On entry, <var class=Va>pfrio_buffer</var> must point to an array of <var class=Vt>struct pfr_table</var> containing at least <var class=Vt>pfrio_size</var> elements. <var class=Vt>pfrio_esize</var> must be the size of <var class=Vt>struct pfr_table</var>. On exit, <var class=Va>pfrio_nzero</var> contains the number of tables effectively cleared.</dd><dt><a class=permalink href=#DIOCRCLRADDRS><code class=Dv id=DIOCRCLRADDRS>DIOCRCLRADDRS</code></a><var class=Fa>struct pfioc_table *io</var></dt><dd>Clear all addresses in a table. On entry, <var class=Va>pfrio_table</var> contains the table to clear. On exit, <var class=Va>pfrio_ndel</var> contains the number of addresses removed.</dd><dt><a class=permalink href=#DIOCRADDADDRS><code class=Dv id=DIOCRADDADDRS>DIOCRADDADDRS</code></a><var class=Fa>struct pfioc_table *io</var></dt><dd>Add one or more addresses to a table. On entry, <var class=Va>pfrio_table</var> contains the table ID and <var class=Va>pfrio_buffer</var> must point to an array of <var class=Vt>struct pfr_addr</var> containing at least <var class=Vt>pfrio_size</var> elements to add to the table. <var class=Vt>pfrio_esize</var> must be the size of <var class=Vt>struct pfr_addr</var>. On exit, <var class=Va>pfrio_nadd</var> contains the number of addresses effectively added. <div class="Bd Pp"><pre>
struct pfr_addr {
	union {
		struct in_addr	 _pfra_ip4addr;
		struct in6_addr	 _pfra_ip6addr;
	}		 pfra_u;
	u_int8_t	 pfra_af;
	u_int8_t	 pfra_net;
	u_int8_t	 pfra_not;
	u_int8_t	 pfra_fback;
};
#define pfra_ip4addr    pfra_u._pfra_ip4addr
#define pfra_ip6addr    pfra_u._pfra_ip6addr
    </pre></div></dd><dt><a class=permalink href=#DIOCRDELADDRS><code class=Dv id=DIOCRDELADDRS>DIOCRDELADDRS</code></a><var class=Fa>struct pfioc_table *io</var></dt><dd>Delete one or more addresses from a table. On entry, <var class=Va>pfrio_table</var> contains the table ID and <var class=Va>pfrio_buffer</var> must point to an array of <var class=Vt>struct pfr_addr</var> containing at least <var class=Vt>pfrio_size</var> elements to delete from the table. <var class=Vt>pfrio_esize</var> must be the size of <var class=Vt>struct pfr_addr</var>. On exit, <var class=Va>pfrio_ndel</var> contains the number of addresses effectively deleted.</dd><dt><a class=permalink href=#DIOCRSETADDRS><code class=Dv id=DIOCRSETADDRS>DIOCRSETADDRS</code></a><var class=Fa>struct pfioc_table *io</var></dt><dd>Replace the content of a table by a new address list. This is the most complicated command, which uses all the structure members. <p class=Pp>On entry, <var class=Va>pfrio_table</var> contains the table ID and <var class=Va>pfrio_buffer</var> must point to an array of <var class=Vt>struct pfr_addr</var> containing at least <var class=Vt>pfrio_size</var> elements which become the new contents of the table. <var class=Vt>pfrio_esize</var> must be the size of <var class=Vt>struct pfr_addr</var>. Additionally, if <var class=Va>pfrio_size2</var> is non-zero, <var class=Va>pfrio_buffer[pfrio_size..pfrio_size2]</var> must be a writeable buffer, into which the kernel can copy the addresses that have been deleted during the replace operation. On exit, <var class=Va>pfrio_ndel</var>, <var class=Va>pfrio_nadd</var>, and <var class=Va>pfrio_nchange</var> contain the number of addresses deleted, added, and changed by the kernel. If <var class=Va>pfrio_size2</var> was set on entry, <var class=Va>pfrio_size2</var> will point to the size of the buffer used, exactly like <code class=Dv>DIOCRGETADDRS</code>.</p></dd><dt><a class=permalink href=#DIOCRGETADDRS><code class=Dv id=DIOCRGETADDRS>DIOCRGETADDRS</code></a><var class=Fa>struct pfioc_table *io</var></dt><dd>Get all the addresses of a table. On entry, <var class=Va>pfrio_table</var> contains the table ID and <var class=Va>pfrio_buffer[pfrio_size]</var> contains a valid writeable buffer for <var class=Vt>pfr_addr</var> structures. On exit, <var class=Va>pfrio_size</var> contains the number of addresses written into the buffer. If the buffer was too small, the kernel does not store anything but just returns the required buffer size, without returning an error.</dd><dt><a class=permalink href=#DIOCRGETASTATS><code class=Dv id=DIOCRGETASTATS>DIOCRGETASTATS</code></a><var class=Fa>struct pfioc_table *io</var></dt><dd>This call is like <code class=Dv>DIOCRGETADDRS</code> but is used to get an array of <var class=Vt>pfr_astats</var> structures. <div class="Bd Pp"><pre>
struct pfr_astats {
	struct pfr_addr	 pfras_a;
	u_int64_t	 pfras_packets
			     [PFR_DIR_MAX][PFR_OP_ADDR_MAX];
	u_int64_t	 pfras_bytes
			     [PFR_DIR_MAX][PFR_OP_ADDR_MAX];
	long		 pfras_tzero;
};
    </pre></div></dd><dt><a class=permalink href=#DIOCRCLRASTATS><code class=Dv id=DIOCRCLRASTATS>DIOCRCLRASTATS</code></a><var class=Fa>struct pfioc_table *io</var></dt><dd>Clear the statistics of one or more addresses. On entry, <var class=Va>pfrio_table</var> contains the table ID and <var class=Va>pfrio_buffer</var> must point to an array of <var class=Vt>struct pfr_addr</var> containing at least <var class=Vt>pfrio_size</var> elements to be cleared from the table. <var class=Vt>pfrio_esize</var> must be the size of <var class=Vt>struct pfr_addr</var>. On exit, <var class=Va>pfrio_nzero</var> contains the number of addresses effectively cleared.</dd><dt><a class=permalink href=#DIOCRTSTADDRS><code class=Dv id=DIOCRTSTADDRS>DIOCRTSTADDRS</code></a><var class=Fa>struct pfioc_table *io</var></dt><dd>Test if the given addresses match a table. On entry, <var class=Va>pfrio_table</var> contains the table ID and <var class=Va>pfrio_buffer</var> must point to an array of <var class=Vt>struct pfr_addr</var> containing at least <var class=Vt>pfrio_size</var> elements, each of which will be tested for a match in the table. <var class=Vt>pfrio_esize</var> must be the size of <var class=Vt>struct pfr_addr</var>. On exit, the kernel updates the <var class=Vt>pfr_addr</var> array by setting the <var class=Va>pfra_fback</var> member appropriately.</dd><dt><a class=permalink href=#DIOCRSETTFLAGS><code class=Dv id=DIOCRSETTFLAGS>DIOCRSETTFLAGS</code></a><var class=Fa>struct pfioc_table *io</var></dt><dd>Change the <code class=Dv>PFR_TFLAG_CONST</code> or <code class=Dv>PFR_TFLAG_PERSIST</code> flags of a table. On entry, <var class=Va>pfrio_buffer</var> must point to an array of <var class=Vt>struct pfr_table</var> containing at least <var class=Vt>pfrio_size</var> elements. <var class=Va>pfrio_esize</var> must be the size of <var class=Vt>struct pfr_table</var>. <var class=Va>pfrio_setflag</var> must contain the flags to add, while <var class=Va>pfrio_clrflag</var> must contain the flags to remove. On exit, <var class=Va>pfrio_nchange</var> and <var class=Va>pfrio_ndel</var> contain the number of tables altered or deleted by the kernel. Yes, tables can be deleted if one removes the <code class=Dv>PFR_TFLAG_PERSIST</code> flag of an unreferenced table.</dd><dt><a class=permalink href=#DIOCRINADEFINE><code class=Dv id=DIOCRINADEFINE>DIOCRINADEFINE</code></a><var class=Fa>struct pfioc_table *io</var></dt><dd>Defines a table in the inactive set. On entry, <var class=Va>pfrio_table</var> contains the table ID and <var class=Va>pfrio_buffer[pfrio_size]</var> contains an array of <var class=Vt>pfr_addr</var> structures to put in the table. A valid ticket must also be supplied to <var class=Va>pfrio_ticket</var>. On exit, <var class=Va>pfrio_nadd</var> contains 0 if the table was already defined in the inactive list or 1 if a new table has been created. <var class=Va>pfrio_naddr</var> contains the number of addresses effectively put in the table.</dd><dt><a class=permalink href=#DIOCXBEGIN><code class=Dv id=DIOCXBEGIN>DIOCXBEGIN</code></a><var class=Fa>struct pfioc_trans *io</var></dt><dd><div class="Bd Pp"><pre>
struct pfioc_trans {
	int		 size;	/* number of elements */
	int		 esize;	/* size of each element in bytes */
	struct pfioc_trans_e {
		int		rs_num;
		char		anchor[MAXPATHLEN];
		u_int32_t	ticket;
	}		*array;
};
    </pre></div><p class=Pp>Clear all the inactive rulesets specified in the <var class=Vt>pfioc_trans_e</var> array. For each ruleset, a ticket is returned for subsequent "add rule" ioctls, as well as for the <code class=Dv>DIOCXCOMMIT</code> and <code class=Dv>DIOCXROLLBACK</code> calls.</p><p class=Pp>Ruleset types, identified by <var class=Va>rs_num</var>, include the following:</p><p class=Pp></p><div class=Bd-indent><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#PF_RULESET_SCRUB><code class=Dv id=PF_RULESET_SCRUB>PF_RULESET_SCRUB</code></a></dt><dd>Scrub (packet normalization) rules.</dd><dt><a class=permalink href=#PF_RULESET_FILTER><code class=Dv id=PF_RULESET_FILTER>PF_RULESET_FILTER</code></a></dt><dd>Filter rules.</dd><dt><a class=permalink href=#PF_RULESET_NAT><code class=Dv id=PF_RULESET_NAT>PF_RULESET_NAT</code></a></dt><dd>NAT (Network Address Translation) rules.</dd><dt><a class=permalink href=#PF_RULESET_BINAT><code class=Dv id=PF_RULESET_BINAT>PF_RULESET_BINAT</code></a></dt><dd>Bidirectional NAT rules.</dd><dt><a class=permalink href=#PF_RULESET_RDR><code class=Dv id=PF_RULESET_RDR>PF_RULESET_RDR</code></a></dt><dd>Redirect rules.</dd><dt><a class=permalink href=#PF_RULESET_ALTQ><code class=Dv id=PF_RULESET_ALTQ>PF_RULESET_ALTQ</code></a></dt><dd>ALTQ disciplines.</dd><dt><a class=permalink href=#PF_RULESET_TABLE><code class=Dv id=PF_RULESET_TABLE>PF_RULESET_TABLE</code></a></dt><dd>Address tables.</dd></dl></div></dd><dt><a class=permalink href=#DIOCXCOMMIT><code class=Dv id=DIOCXCOMMIT>DIOCXCOMMIT</code></a><var class=Fa>struct pfioc_trans *io</var></dt><dd>Atomically switch a vector of inactive rulesets to the active rulesets. This call is implemented as a standard two-phase commit, which will either fail for all rulesets or completely succeed. All tickets need to be valid. This ioctl returns <code class=Er>EBUSY</code> if another process is concurrently updating some of the same rulesets.</dd><dt><a class=permalink href=#DIOCXROLLBACK><code class=Dv id=DIOCXROLLBACK>DIOCXROLLBACK</code></a><var class=Fa>struct pfioc_trans *io</var></dt><dd>Clean up the kernel by undoing all changes that have taken place on the inactive rulesets since the last <code class=Dv>DIOCXBEGIN</code>. <code class=Dv>DIOCXROLLBACK</code> will silently ignore rulesets for which the ticket is invalid.</dd><dt><a class=permalink href=#DIOCSETHOSTID><code class=Dv id=DIOCSETHOSTID>DIOCSETHOSTID</code></a><var class=Fa>u_int32_t *hostid</var></dt><dd>Set the host ID, which is used by <a class=Xr href=pfsync.4.html>pfsync(4)</a> to identify which host created state table entries.</dd><dt><a class=permalink href=#DIOCOSFPFLUSH><code class=Dv id=DIOCOSFPFLUSH>DIOCOSFPFLUSH</code></a></dt><dd>Flush the passive OS fingerprint table.</dd><dt><a class=permalink href=#DIOCOSFPADD><code class=Dv id=DIOCOSFPADD>DIOCOSFPADD</code></a><var class=Fa>struct pf_osfp_ioctl *io</var></dt><dd><div class="Bd Pp"><pre>
struct pf_osfp_ioctl {
	struct pf_osfp_entry {
		SLIST_ENTRY(pf_osfp_entry) fp_entry;
		pf_osfp_t		fp_os;
		char			fp_class_nm[PF_OSFP_LEN];
		char			fp_version_nm[PF_OSFP_LEN];
		char			fp_subtype_nm[PF_OSFP_LEN];
	} 			fp_os;
	pf_tcpopts_t		fp_tcpopts;
	u_int16_t		fp_wsize;
	u_int16_t		fp_psize;
	u_int16_t		fp_mss;
	u_int16_t		fp_flags;
	u_int8_t		fp_optcnt;
	u_int8_t		fp_wscale;
	u_int8_t		fp_ttl;
	int			fp_getnum;
};
    </pre></div><p class=Pp>Add a passive OS fingerprint to the table. Set <var class=Va>fp_os.fp_os</var> to the packed fingerprint, <var class=Va>fp_os.fp_class_nm</var> to the name of the class (Linux, Windows, etc), <var class=Va>fp_os.fp_version_nm</var> to the name of the version (NT, 95, 98), and <var class=Va>fp_os.fp_subtype_nm</var> to the name of the subtype or patchlevel. The members <var class=Va>fp_mss</var>, <var class=Va>fp_wsize</var>, <var class=Va>fp_psize</var>, <var class=Va>fp_ttl</var>, <var class=Va>fp_optcnt</var>, and <var class=Va>fp_wscale</var> are set to the TCP MSS, the TCP window size, the IP length, the IP TTL, the number of TCP options, and the TCP window scaling constant of the TCP SYN packet, respectively.</p><p class=Pp>The <var class=Va>fp_flags</var> member is filled according to the ⟨<span class=Pa>net/pfvar.h</span>⟩ include file <code class=Dv>PF_OSFP_*</code> defines. The <var class=Va>fp_tcpopts</var> member contains packed TCP options. Each option uses <code class=Dv>PF_OSFP_TCPOPT_BITS</code> bits in the packed value. Options include any of <code class=Dv>PF_OSFP_TCPOPT_NOP</code>, <code class=Dv>PF_OSFP_TCPOPT_SACK</code>, <code class=Dv>PF_OSFP_TCPOPT_WSCALE</code>, <code class=Dv>PF_OSFP_TCPOPT_MSS</code>, or <code class=Dv>PF_OSFP_TCPOPT_TS</code>.</p><p class=Pp>The <var class=Va>fp_getnum</var> member is not used with this ioctl.</p><p class=Pp>The structure's slack space must be zeroed for correct operation; <a class=Xr href=memset.3.html>memset(3)</a> the whole structure to zero before filling and sending to the kernel.</p></dd><dt><a class=permalink href=#DIOCOSFPGET><code class=Dv id=DIOCOSFPGET>DIOCOSFPGET</code></a><var class=Fa>struct pf_osfp_ioctl *io</var></dt><dd>Get the passive OS fingerprint number <var class=Va>fp_getnum</var> from the kernel's fingerprint list. The rest of the structure members will come back filled. Get the whole list by repeatedly incrementing the <var class=Va>fp_getnum</var> number until the ioctl returns <code class=Er>EBUSY</code>.</dd><dt><a class=permalink href=#DIOCGETSRCNODES><code class=Dv id=DIOCGETSRCNODES>DIOCGETSRCNODES</code></a><var class=Fa>struct pfioc_src_nodes *psn</var></dt><dd><div class="Bd Pp"><pre>
struct pfioc_src_nodes {
	int	psn_len;
	union {
		caddr_t		psu_buf;
		struct pf_src_node	*psu_src_nodes;
	} psn_u;
#define psn_buf		psn_u.psu_buf
#define psn_src_nodes	psn_u.psu_src_nodes
};
    </pre></div><p class=Pp>Get the list of source nodes kept by sticky addresses and source tracking. The ioctl must be called once with <var class=Va>psn_len</var> set to 0. If the ioctl returns without error, <var class=Va>psn_len</var> will be set to the size of the buffer required to hold all the <var class=Va>pf_src_node</var> structures held in the table. A buffer of this size should then be allocated, and a pointer to this buffer placed in <var class=Va>psn_buf</var>. The ioctl must then be called again to fill this buffer with the actual source node data. After that call, <var class=Va>psn_len</var> will be set to the length of the buffer actually used.</p></dd><dt><a class=permalink href=#DIOCCLRSRCNODES><code class=Dv id=DIOCCLRSRCNODES>DIOCCLRSRCNODES</code></a></dt><dd>Clear the tree of source tracking nodes.</dd><dt><a class=permalink href=#DIOCIGETIFACES><code class=Dv id=DIOCIGETIFACES>DIOCIGETIFACES</code></a><var class=Fa>struct pfioc_iface *io</var></dt><dd>Get the list of interfaces and interface drivers known to <code class=Nm>pf</code>. All the ioctls that manipulate interfaces use the same structure described below: <div class="Bd Pp"><pre>
struct pfioc_iface {
	char			 pfiio_name[IFNAMSIZ];
	void			*pfiio_buffer;
	int			 pfiio_esize;
	int			 pfiio_size;
	int			 pfiio_nzero;
	int			 pfiio_flags;
};
    </pre></div><p class=Pp>If not empty, <var class=Va>pfiio_name</var> can be used to restrict the search to a specific interface or driver. <var class=Va>pfiio_buffer[pfiio_size]</var> is the user-supplied buffer for returning the data. On entry, <var class=Va>pfiio_size</var> contains the number of <var class=Vt>pfi_kif</var> entries that can fit into the buffer. The kernel will replace this value by the real number of entries it wants to return. <var class=Va>pfiio_esize</var> should be set to <code class=Li>sizeof(struct pfi_kif)</code>.</p><p class=Pp>The data is returned in the <var class=Vt>pfi_kif</var> structure described below:</p><div class="Bd Pp"><pre>
struct pfi_kif {
	RB_ENTRY(pfi_kif)		 pfik_tree;
	char				 pfik_name[IFNAMSIZ];
	u_int64_t			 pfik_packets[2][2][2];
	u_int64_t			 pfik_bytes[2][2][2];
	u_int32_t			 pfik_tzero;
	int				 pfik_flags;
	struct pf_state_tree_lan_ext	 pfik_lan_ext;
	struct pf_state_tree_ext_gwy	 pfik_ext_gwy;
	TAILQ_ENTRY(pfi_kif)		 pfik_w_states;
	void				*pfik_ah_cookie;
	struct ifnet			*pfik_ifp;
	struct ifg_group		*pfik_group;
	int				 pfik_states;
	int				 pfik_rules;
	TAILQ_HEAD(, pfi_dynaddr)	 pfik_dynaddrs;
};
    </pre></div></dd><dt><a class=permalink href=#DIOCSETIFFLAG><code class=Dv id=DIOCSETIFFLAG>DIOCSETIFFLAG</code></a><var class=Fa>struct pfioc_iface *io</var></dt><dd>Set the user settable flags (described above) of the <code class=Nm>pf</code> internal interface description. The filtering process is the same as for <code class=Dv>DIOCIGETIFACES</code>. <div class="Bd Pp"><pre>
#define PFI_IFLAG_SKIP	0x0100	/* skip filtering on interface */
    </pre></div></dd><dt><a class=permalink href=#DIOCCLRIFFLAG><code class=Dv id=DIOCCLRIFFLAG>DIOCCLRIFFLAG</code></a><var class=Fa>struct pfioc_iface *io</var></dt><dd>Works as <code class=Dv>DIOCSETIFFLAG</code> above but clears the flags.</dd><dt><a class=permalink href=#DIOCKILLSRCNODES><code class=Dv id=DIOCKILLSRCNODES>DIOCKILLSRCNODES</code></a><var class=Fa>struct pfioc_iface *io</var></dt><dd>Explicitly remove source tracking nodes.</dd></dl></section><section class=Sh><h2 class=Sh id=FILES><a class=permalink href=#FILES>FILES</a></h2><dl class="Bl-tag Bl-compact"><dt><span class=Pa>/dev/pf</span></dt><dd>packet filtering device.</dd></dl></section><section class=Sh><h2 class=Sh id=EXAMPLES><a class=permalink href=#EXAMPLES>EXAMPLES</a></h2> The following example demonstrates how to use the <code class=Dv>DIOCNATLOOK</code> command to find the internal host/port of a NATed connection: <div class="Bd Pp"><pre>
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/fcntl.h&gt;
#include &lt;net/if.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;net/pfvar.h&gt;
#include &lt;err.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

u_int32_t
read_address(const char *s)
{
	int a, b, c, d;

	sscanf(s, "%i.%i.%i.%i", &amp;a, &amp;b, &amp;c, &amp;d);
	return htonl(a &lt;&lt; 24 | b &lt;&lt; 16 | c &lt;&lt; 8 | d);
}

void
print_address(u_int32_t a)
{
	a = ntohl(a);
	printf("%d.%d.%d.%d", a &gt;&gt; 24 &amp; 255, a &gt;&gt; 16 &amp; 255,
	    a &gt;&gt; 8 &amp; 255, a &amp; 255);
}

int
main(int argc, char *argv[])
{
	struct pfioc_natlook nl;
	int dev;

	if (argc != 5) {
		printf("%s &lt;gwy addr&gt; &lt;gwy port&gt; &lt;ext addr&gt; &lt;ext port&gt;\n",
		    argv[0]);
		return 1;
	}

	dev = open("/dev/pf", O_RDWR);
	if (dev == -1)
		err(1, "open(\"/dev/pf\") failed");

	memset(&amp;nl, 0, sizeof(struct pfioc_natlook));
	nl.saddr.v4.s_addr	= read_address(argv[1]);
	nl.sport		= htons(atoi(argv[2]));
	nl.daddr.v4.s_addr	= read_address(argv[3]);
	nl.dport		= htons(atoi(argv[4]));
	nl.af			= AF_INET;
	nl.proto		= IPPROTO_TCP;
	nl.direction		= PF_IN;

	if (ioctl(dev, DIOCNATLOOK, &amp;nl))
		err(1, "DIOCNATLOOK");

	printf("internal host ");
	print_address(nl.rsaddr.v4.s_addr);
	printf(":%u\n", ntohs(nl.rsport));
	return 0;
}
</pre></div></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=ioctl.2.html>ioctl(2)</a>, <a class=Xr href=altq.4.html>altq(4)</a>, <a class=Xr href=if_bridge.4.html>if_bridge(4)</a>, <a class=Xr href=pflog.4.html>pflog(4)</a>, <a class=Xr href=pfsync.4.html>pfsync(4)</a>, <a class=Xr href=pfctl.8.html>pfctl(8)</a>, <a class=Xr href=altq.9.html>altq(9)</a></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> The <code class=Nm>pf</code> packet filtering mechanism first appeared in <span class=Ux>OpenBSD 3.0</span> and then <span class=Ux>FreeBSD 5.2</span>. <p class=Pp>This implementation is derived from <span class=Ux>OpenBSD 4.5</span>. It has been heavily modified to be capable of running in multithreaded <span class=Ux>FreeBSD</span> kernel and scale its performance on multiple CPUs.</p></section></div><table class=foot><tr><td class=foot-date>May 7, 2021</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>