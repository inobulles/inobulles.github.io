<!DOCTYPE html>
<html><head><meta charset=utf-8><title>taskqueue_member(9)</title><keywords content=man,taskqueue_member></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>taskqueue_member(9)</h1><table class=head><tr><td class=head-ltitle>TASKQUEUE(9)</td><td class=head-vol>FreeBSD Kernel Developer's Manual</td><td class=head-rtitle>TASKQUEUE(9)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>taskqueue</code> — <div class=Nd>asynchronous task execution</div></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/sys/param.h.html>sys/param.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/sys/kernel.h.html>sys/kernel.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/sys/malloc.h.html>sys/malloc.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/sys/queue.h.html>sys/queue.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/sys/taskqueue.h.html>sys/taskqueue.h</a>&gt;</code><div class="Bd Pp"><pre>
typedef void (*task_fn_t)(void *context, int pending);

typedef void (*taskqueue_enqueue_fn)(void *context);

struct task {
	STAILQ_ENTRY(task)	ta_link;	/* link for queue */
	u_short			ta_pending;	/* count times queued */
	u_short			ta_priority;	/* priority of task in queue */
	task_fn_t		ta_func;	/* task handler */
	void			*ta_context;	/* argument for handler */
};

enum taskqueue_callback_type {
	TASKQUEUE_CALLBACK_TYPE_INIT,
	TASKQUEUE_CALLBACK_TYPE_SHUTDOWN,
};

typedef void (*taskqueue_callback_fn)(void *context);

struct timeout_task;
</pre></div><br><var class=Ft>struct taskqueue *</var><br><code class=Fn>taskqueue_create</code>(<var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">int mflags</var>, <var class=Fa style="white-space: nowrap;">taskqueue_enqueue_fn enqueue</var>, <var class=Fa style="white-space: nowrap;">void *context</var>); <p class=Pp><var class=Ft>struct taskqueue *</var><br><code class=Fn>taskqueue_create_fast</code>(<var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">int mflags</var>, <var class=Fa style="white-space: nowrap;">taskqueue_enqueue_fn enqueue</var>, <var class=Fa style="white-space: nowrap;">void *context</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>taskqueue_start_threads</code>(<var class=Fa style="white-space: nowrap;">struct taskqueue **tqp</var>, <var class=Fa style="white-space: nowrap;">int count</var>, <var class=Fa style="white-space: nowrap;">int pri</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">...</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>taskqueue_start_threads_cpuset</code>(<var class=Fa>struct taskqueue **tqp</var>, <var class=Fa>int count</var>, <var class=Fa>int pri</var>, <var class=Fa>cpuset_t *mask</var>, <var class=Fa>const char *name</var>, <var class=Fa>...</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>taskqueue_start_threads_in_proc</code>(<var class=Fa>struct taskqueue **tqp</var>, <var class=Fa>int count</var>, <var class=Fa>int pri</var>, <var class=Fa>struct proc *proc</var>, <var class=Fa>const char *name</var>, <var class=Fa>...</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>taskqueue_set_callback</code>(<var class=Fa style="white-space: nowrap;">struct taskqueue *queue</var>, <var class=Fa style="white-space: nowrap;">enum taskqueue_callback_type cb_type</var>, <var class=Fa style="white-space: nowrap;">taskqueue_callback_fn callback</var>, <var class=Fa style="white-space: nowrap;">void *context</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>taskqueue_free</code>(<var class=Fa style="white-space: nowrap;">struct taskqueue *queue</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>taskqueue_enqueue</code>(<var class=Fa style="white-space: nowrap;">struct taskqueue *queue</var>, <var class=Fa style="white-space: nowrap;">struct task *task</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>taskqueue_enqueue_timeout</code>(<var class=Fa style="white-space: nowrap;">struct taskqueue *queue</var>, <var class=Fa style="white-space: nowrap;">struct timeout_task *timeout_task</var>, <var class=Fa style="white-space: nowrap;">int ticks</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>taskqueue_enqueue_timeout_sbt</code>(<var class=Fa style="white-space: nowrap;">struct taskqueue *queue</var>, <var class=Fa style="white-space: nowrap;">struct timeout_task *timeout_task</var>, <var class=Fa style="white-space: nowrap;">sbintime_t sbt</var>, <var class=Fa style="white-space: nowrap;">sbintime_t pr</var>, <var class=Fa style="white-space: nowrap;">int flags</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>taskqueue_cancel</code>(<var class=Fa style="white-space: nowrap;">struct taskqueue *queue</var>, <var class=Fa style="white-space: nowrap;">struct task *task</var>, <var class=Fa style="white-space: nowrap;">u_int *pendp</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>taskqueue_cancel_timeout</code>(<var class=Fa style="white-space: nowrap;">struct taskqueue *queue</var>, <var class=Fa style="white-space: nowrap;">struct timeout_task *timeout_task</var>, <var class=Fa style="white-space: nowrap;">u_int *pendp</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>taskqueue_drain</code>(<var class=Fa style="white-space: nowrap;">struct taskqueue *queue</var>, <var class=Fa style="white-space: nowrap;">struct task *task</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>taskqueue_drain_timeout</code>(<var class=Fa style="white-space: nowrap;">struct taskqueue *queue</var>, <var class=Fa style="white-space: nowrap;">struct timeout_task *timeout_task</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>taskqueue_drain_all</code>(<var class=Fa style="white-space: nowrap;">struct taskqueue *queue</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>taskqueue_quiesce</code>(<var class=Fa style="white-space: nowrap;">struct taskqueue *queue</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>taskqueue_block</code>(<var class=Fa style="white-space: nowrap;">struct taskqueue *queue</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>taskqueue_unblock</code>(<var class=Fa style="white-space: nowrap;">struct taskqueue *queue</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>taskqueue_member</code>(<var class=Fa style="white-space: nowrap;">struct taskqueue *queue</var>, <var class=Fa style="white-space: nowrap;">struct thread *td</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>taskqueue_run</code>(<var class=Fa style="white-space: nowrap;">struct taskqueue *queue</var>);</p><p class=Pp><code class=Fn>TASK_INIT</code>(<var class=Fa style="white-space: nowrap;">struct task *task</var>, <var class=Fa style="white-space: nowrap;">int priority</var>, <var class=Fa style="white-space: nowrap;">task_fn_t func</var>, <var class=Fa style="white-space: nowrap;">void *context</var>);</p><p class=Pp><code class=Fn>TASK_INITIALIZER</code>(<var class=Fa style="white-space: nowrap;">int priority</var>, <var class=Fa style="white-space: nowrap;">task_fn_t func</var>, <var class=Fa style="white-space: nowrap;">void *context</var>);</p><p class=Pp><code class=Fn>TASKQUEUE_DECLARE</code>(<var class=Fa style="white-space: nowrap;">name</var>);</p><p class=Pp><code class=Fn>TASKQUEUE_DEFINE</code>(<var class=Fa style="white-space: nowrap;">name</var>, <var class=Fa style="white-space: nowrap;">taskqueue_enqueue_fn enqueue</var>, <var class=Fa style="white-space: nowrap;">void *context</var>, <var class=Fa style="white-space: nowrap;">init</var>);</p><p class=Pp><code class=Fn>TASKQUEUE_FAST_DEFINE</code>(<var class=Fa style="white-space: nowrap;">name</var>, <var class=Fa style="white-space: nowrap;">taskqueue_enqueue_fn enqueue</var>, <var class=Fa style="white-space: nowrap;">void *context</var>, <var class=Fa style="white-space: nowrap;">init</var>);</p><p class=Pp><code class=Fn>TASKQUEUE_DEFINE_THREAD</code>(<var class=Fa style="white-space: nowrap;">name</var>);</p><p class=Pp><code class=Fn>TASKQUEUE_FAST_DEFINE_THREAD</code>(<var class=Fa style="white-space: nowrap;">name</var>);</p><p class=Pp><code class=Fn>TIMEOUT_TASK_INIT</code>(<var class=Fa style="white-space: nowrap;">struct taskqueue *queue</var>, <var class=Fa style="white-space: nowrap;">struct timeout_task *timeout_task</var>, <var class=Fa style="white-space: nowrap;">int priority</var>, <var class=Fa style="white-space: nowrap;">task_fn_t func</var>, <var class=Fa style="white-space: nowrap;">void *context</var>);</p></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> These functions provide a simple interface for asynchronous execution of code. <p class=Pp>The function <code class=Fn>taskqueue_create</code>() is used to create new queues. The arguments to <code class=Fn>taskqueue_create</code>() include a name that should be unique, a set of <a class=Xr href=malloc.9.html>malloc(9)</a> flags that specify whether the call to <code class=Fn>malloc</code>() is allowed to sleep, a function that is called from <code class=Fn>taskqueue_enqueue</code>() when a task is added to the queue, and a pointer to the memory location where the identity of the thread that services the queue is recorded. The function called from <code class=Fn>taskqueue_enqueue</code>() must arrange for the queue to be processed (for instance by scheduling a software interrupt or waking a kernel thread). The memory location where the thread identity is recorded is used to signal the service thread(s) to terminate--when this value is set to zero and the thread is signaled it will terminate. If the queue is intended for use in fast interrupt handlers <code class=Fn>taskqueue_create_fast</code>() should be used in place of <code class=Fn>taskqueue_create</code>().</p><p class=Pp>The function <code class=Fn>taskqueue_free</code>() should be used to free the memory used by the queue. Any tasks that are on the queue will be executed at this time after which the thread servicing the queue will be signaled that it should exit.</p><p class=Pp>Once a taskqueue has been created, its threads should be started using <code class=Fn>taskqueue_start_threads</code>(), <code class=Fn>taskqueue_start_threads_cpuset</code>() or <code class=Fn>taskqueue_start_threads_in_proc</code>(). <code class=Fn>taskqueue_start_threads_cpuset</code>() takes a <var class=Va>cpuset</var> argument which will cause the threads which are started for the taskqueue to be restricted to run on the given CPUs. <code class=Fn>taskqueue_start_threads_in_proc</code>() takes a <var class=Va>proc</var> argument which will cause the threads which are started for the taskqueue to be assigned to the given kernel process. Callbacks may optionally be registered using <code class=Fn>taskqueue_set_callback</code>(). Currently, callbacks may be registered for the following purposes:</p><dl class=Bl-tag><dt><a class=permalink href=#TASKQUEUE_CALLBACK_TYPE_INIT><code class=Dv id=TASKQUEUE_CALLBACK_TYPE_INIT>TASKQUEUE_CALLBACK_TYPE_INIT</code></a></dt><dd>This callback is called by every thread in the taskqueue, before it executes any tasks. This callback must be set before the taskqueue's threads are started.</dd><dt><a class=permalink href=#TASKQUEUE_CALLBACK_TYPE_SHUTDOWN><code class=Dv id=TASKQUEUE_CALLBACK_TYPE_SHUTDOWN>TASKQUEUE_CALLBACK_TYPE_SHUTDOWN</code></a></dt><dd>This callback is called by every thread in the taskqueue, after it executes its last task. This callback will always be called before the taskqueue structure is reclaimed.</dd></dl><p class=Pp>To add a task to the list of tasks queued on a taskqueue, call <code class=Fn>taskqueue_enqueue</code>() with pointers to the queue and task. If the task's <var class=Va>ta_pending</var> field is non-zero, then it is simply incremented to reflect the number of times the task was enqueued, up to a cap of USHRT_MAX. Otherwise, the task is added to the list before the first task which has a lower <var class=Va>ta_priority</var> value or at the end of the list if no tasks have a lower priority. Enqueueing a task does not perform any memory allocation which makes it suitable for calling from an interrupt handler. This function will return <code class=Er>EPIPE</code> if the queue is being freed.</p><p class=Pp>When a task is executed, first it is removed from the queue, the value of <var class=Va>ta_pending</var> is recorded and then the field is zeroed. The function <var class=Va>ta_func</var> from the task structure is called with the value of the field <var class=Va>ta_context</var> as its first argument and the value of <var class=Va>ta_pending</var> as its second argument. After the function <var class=Va>ta_func</var> returns, <a class=Xr href=wakeup.9.html>wakeup(9)</a> is called on the task pointer passed to <code class=Fn>taskqueue_enqueue</code>().</p><p class=Pp>The <code class=Fn>taskqueue_enqueue_timeout</code>() function is used to schedule the enqueue after the specified number of <var class=Va>ticks</var>. The <code class=Fn>taskqueue_enqueue_timeout_sbt</code>() function provides finer control over the scheduling based on <var class=Va>sbt</var>, <var class=Va>pr</var>, and <var class=Va>flags</var>, as detailed in <a class=Xr href=timeout.9.html>timeout(9)</a>. Only non-fast task queues can be used for <var class=Va>timeout_task</var> scheduling. If the <var class=Va>ticks</var> argument is negative, the already scheduled enqueueing is not re-scheduled. Otherwise, the task is scheduled for enqueueing in the future, after the absolute value of <var class=Va>ticks</var> is passed. This function returns -1 if the task is being drained. Otherwise, the number of pending calls is returned.</p><p class=Pp>The <code class=Fn>taskqueue_cancel</code>() function is used to cancel a task. The <var class=Va>ta_pending</var> count is cleared, and the old value returned in the reference parameter <var class=Fa>pendp</var>, if it is non-<code class=Dv>NULL</code>. If the task is currently running, <code class=Dv>EBUSY</code> is returned, otherwise 0. To implement a blocking <code class=Fn>taskqueue_cancel</code>() that waits for a running task to finish, it could look like:</p><div class="Bd Pp Bd-indent"><pre>
while (taskqueue_cancel(tq, task, NULL) != 0)
	taskqueue_drain(tq, task);
</pre></div><p class=Pp>Note that, as with <code class=Fn>taskqueue_drain</code>(), the caller is responsible for ensuring that the task is not re-enqueued after being canceled.</p><p class=Pp>Similarly, the <code class=Fn>taskqueue_cancel_timeout</code>() function is used to cancel the scheduled task execution.</p><p class=Pp>The <code class=Fn>taskqueue_drain</code>() function is used to wait for the task to finish, and the <code class=Fn>taskqueue_drain_timeout</code>() function is used to wait for the scheduled task to finish. There is no guarantee that the task will not be enqueued after call to <code class=Fn>taskqueue_drain</code>(). If the caller wants to put the task into a known state, then before calling <code class=Fn>taskqueue_drain</code>() the caller should use out-of-band means to ensure that the task would not be enqueued. For example, if the task is enqueued by an interrupt filter, then the interrupt could be disabled.</p><p class=Pp>The <code class=Fn>taskqueue_drain_all</code>() function is used to wait for all pending and running tasks that are enqueued on the taskqueue to finish. Tasks posted to the taskqueue after <code class=Fn>taskqueue_drain_all</code>() begins processing, including pending enqueues scheduled by a previous call to <code class=Fn>taskqueue_enqueue_timeout</code>(), do not extend the wait time of <code class=Fn>taskqueue_drain_all</code>() and may complete after <code class=Fn>taskqueue_drain_all</code>() returns. The <code class=Fn>taskqueue_quiesce</code>() function is used to wait for the queue to become empty and for all running tasks to finish. To avoid blocking indefinitely, the caller must ensure by some mechanism that tasks will eventually stop being posted to the queue.</p><p class=Pp>The <code class=Fn>taskqueue_block</code>() function blocks the taskqueue. It prevents any enqueued but not running tasks from being executed. Future calls to <code class=Fn>taskqueue_enqueue</code>() will enqueue tasks, but the tasks will not be run until <code class=Fn>taskqueue_unblock</code>() is called. Please note that <code class=Fn>taskqueue_block</code>() does not wait for any currently running tasks to finish. Thus, the <code class=Fn>taskqueue_block</code>() does not provide a guarantee that <code class=Fn>taskqueue_run</code>() is not running after <code class=Fn>taskqueue_block</code>() returns, but it does provide a guarantee that <code class=Fn>taskqueue_run</code>() will not be called again until <code class=Fn>taskqueue_unblock</code>() is called. If the caller requires a guarantee that <code class=Fn>taskqueue_run</code>() is not running, then this must be arranged by the caller. Note that if <code class=Fn>taskqueue_drain</code>() is called on a task that is enqueued on a taskqueue that is blocked by <code class=Fn>taskqueue_block</code>(), then <code class=Fn>taskqueue_drain</code>() can not return until the taskqueue is unblocked. This can result in a deadlock if the thread blocked in <code class=Fn>taskqueue_drain</code>() is the thread that is supposed to call <code class=Fn>taskqueue_unblock</code>(). Thus, use of <code class=Fn>taskqueue_drain</code>() after <code class=Fn>taskqueue_block</code>() is discouraged, because the state of the task can not be known in advance. The same caveat applies to <code class=Fn>taskqueue_drain_all</code>().</p><p class=Pp>The <code class=Fn>taskqueue_unblock</code>() function unblocks the previously blocked taskqueue. All enqueued tasks can be run after this call.</p><p class=Pp>The <code class=Fn>taskqueue_member</code>() function returns <span class=No>1</span> if the given thread <var class=Fa>td</var> is part of the given taskqueue <var class=Fa>queue</var> and <span class=No>0</span> otherwise.</p><p class=Pp>The <code class=Fn>taskqueue_run</code>() function will run all pending tasks in the specified <var class=Fa>queue</var>. Normally this function is only used internally.</p><p class=Pp>A convenience macro, <code class=Fn>TASK_INIT</code>(<var class=Fa>task</var>, <var class=Fa>priority</var>, <var class=Fa>func</var>, <var class=Fa>context</var>) is provided to initialise a <var class=Va>task</var> structure. The <code class=Fn>TASK_INITIALIZER</code>() macro generates an initializer for a task structure. A macro <code class=Fn>TIMEOUT_TASK_INIT</code>(<var class=Fa>queue</var>, <var class=Fa>timeout_task</var>, <var class=Fa>priority</var>, <var class=Fa>func</var>, <var class=Fa>context</var>) initializes the <var class=Va>timeout_task</var> structure. The values of <var class=Va>priority</var>, <var class=Va>func</var>, and <var class=Va>context</var> are simply copied into the task structure fields and the <var class=Va>ta_pending</var> field is cleared.</p><p class=Pp>Five macros <code class=Fn>TASKQUEUE_DECLARE</code>(<var class=Fa>name</var>), <code class=Fn>TASKQUEUE_DEFINE</code>(<var class=Fa>name</var>, <var class=Fa>enqueue</var>, <var class=Fa>context</var>, <var class=Fa>init</var>), <code class=Fn>TASKQUEUE_FAST_DEFINE</code>(<var class=Fa>name</var>, <var class=Fa>enqueue</var>, <var class=Fa>context</var>, <var class=Fa>init</var>), and <code class=Fn>TASKQUEUE_DEFINE_THREAD</code>(<var class=Fa>name</var>) <code class=Fn>TASKQUEUE_FAST_DEFINE_THREAD</code>(<var class=Fa>name</var>) are used to declare a reference to a global queue, to define the implementation of the queue, and declare a queue that uses its own thread. The <code class=Fn>TASKQUEUE_DEFINE</code>() macro arranges to call <code class=Fn>taskqueue_create</code>() with the values of its <var class=Va>name</var>, <var class=Va>enqueue</var> and <var class=Va>context</var> arguments during system initialisation. After calling <code class=Fn>taskqueue_create</code>(), the <var class=Va>init</var> argument to the macro is executed as a C statement, allowing any further initialisation to be performed (such as registering an interrupt handler, etc.).</p><p class=Pp>The <code class=Fn>TASKQUEUE_DEFINE_THREAD</code>() macro defines a new taskqueue with its own kernel thread to serve tasks. The variable <var class=Vt>struct taskqueue *taskqueue_name</var> is used to enqueue tasks onto the queue.</p><p class=Pp><code class=Fn>TASKQUEUE_FAST_DEFINE</code>() and <code class=Fn>TASKQUEUE_FAST_DEFINE_THREAD</code>() act just like <code class=Fn>TASKQUEUE_DEFINE</code>() and <code class=Fn>TASKQUEUE_DEFINE_THREAD</code>() respectively but taskqueue is created with <code class=Fn>taskqueue_create_fast</code>().</p><section class=Ss><h2 class=Ss id=Predefined_Task_Queues><a class=permalink href=#Predefined_Task_Queues>Predefined Task Queues</a></h2> The system provides four global taskqueues, <var class=Va>taskqueue_fast</var>, <var class=Va>taskqueue_swi</var>, <var class=Va>taskqueue_swi_giant</var>, and <var class=Va>taskqueue_thread</var>. The <var class=Va>taskqueue_fast</var> queue is for swi handlers dispatched from fast interrupt handlers, where sleep mutexes cannot be used. The swi taskqueues are run via a software interrupt mechanism. The <var class=Va>taskqueue_swi</var> queue runs without the protection of the <var class=Va>Giant</var> kernel lock, and the <var class=Va>taskqueue_swi_giant</var> queue runs with the protection of the <var class=Va>Giant</var> kernel lock. The thread taskqueue <var class=Va>taskqueue_thread</var> runs in a kernel thread context, and tasks run from this thread do not run under the <var class=Va>Giant</var> kernel lock. If the caller wants to run under <var class=Va>Giant</var>, he should explicitly acquire and release <var class=Va>Giant</var> in his taskqueue handler routine. <p class=Pp>To use these queues, call <code class=Fn>taskqueue_enqueue</code>() with the value of the global taskqueue variable for the queue you wish to use.</p><p class=Pp>The software interrupt queues can be used, for instance, for implementing interrupt handlers which must perform a significant amount of processing in the handler. The hardware interrupt handler would perform minimal processing of the interrupt and then enqueue a task to finish the work. This reduces to a minimum the amount of time spent with interrupts disabled.</p><p class=Pp>The thread queue can be used, for instance, by interrupt level routines that need to call kernel functions that do things that can only be done from a thread context. (e.g., call malloc with the M_WAITOK flag.)</p><p class=Pp>Note that tasks queued on shared taskqueues such as <var class=Va>taskqueue_swi</var> may be delayed an indeterminate amount of time before execution. If queueing delays cannot be tolerated then a private taskqueue should be created with a dedicated processing thread.</p></section></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=ithread.9.html>ithread(9)</a>, <a class=Xr href=kthread.9.html>kthread(9)</a>, <a class=Xr href=swi.9.html>swi(9)</a><a class=Xr href=timeout.9.html>timeout(9)</a></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> This interface first appeared in <span class=Ux>FreeBSD 5.0</span>. There is a similar facility called work_queue in the Linux kernel. </section><section class=Sh><h2 class=Sh id=AUTHORS><a class=permalink href=#AUTHORS>AUTHORS</a></h2> This manual page was written by <span class=An>Doug Rabson</span>. </section></div><table class=foot><tr><td class=foot-date>October 17, 2019</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>