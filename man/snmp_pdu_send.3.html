<!DOCTYPE html>
<html><head><meta charset=utf-8><title>snmp_pdu_send(3)</title><keywords content=man,snmp_pdu_send></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>snmp_pdu_send(3)</h1><table class=head><tr><td class=head-ltitle>BSNMPCLIENT(3)</td><td class=head-vol>FreeBSD Library Functions Manual</td><td class=head-rtitle>BSNMPCLIENT(3)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>snmp_client</code>, <code class=Nm>snmp_client_init</code>, <code class=Nm>snmp_client_set_host</code>, <code class=Nm>snmp_client_set_port</code>, <code class=Nm>snmp_send_cb_f</code>, <code class=Nm>snmp_timeout_cb_f</code>, <code class=Nm>snmp_timeout_start_f</code>, <code class=Nm>snmp_timeout_stop_f</code>, <code class=Nm>snmp_open</code>, <code class=Nm>snmp_close</code>, <code class=Nm>snmp_pdu_create</code>, <code class=Nm>snmp_add_binding</code>, <code class=Nm>snmp_pdu_check</code>, <code class=Nm>snmp_pdu_send</code>, <code class=Nm>snmp_oid_append</code>, <code class=Nm>snmp_parse_server</code>, <code class=Nm>snmp_receive</code>, <code class=Nm>snmp_table_cb_f</code>, <code class=Nm>snmp_table_fetch</code>, <code class=Nm>snmp_table_fetch_async</code>, <code class=Nm>snmp_dialog</code>, <code class=Nm>snmp_discover_engine</code> — <div class=Nd>SNMP client library</div></section><section class=Sh><h2 class=Sh id=LIBRARY><a class=permalink href=#LIBRARY>LIBRARY</a></h2> Begemot SNMP library (libbsnmp, -lbsnmp) </section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/asn1.h.html>asn1.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/snmp.h.html>snmp.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/snmpclient.h.html>snmpclient.h</a>&gt;</code><p class=Pp><var class=Ft>typedef void</var><br><code class=Fn>(*snmp_send_cb_f)</code>(<var class=Fa style="white-space: nowrap;">struct snmp_pdu *req</var>, <var class=Fa style="white-space: nowrap;">struct snmp_pdu *resp</var>, <var class=Fa style="white-space: nowrap;">void *uarg</var>);</p><p class=Pp><var class=Ft>typedef void</var><br><code class=Fn>(*snmp_timeout_cb_f)</code>(<var class=Fa style="white-space: nowrap;">void *uarg</var>);</p><p class=Pp><var class=Ft>typedef void *</var><br><code class=Fn>(*snmp_timeout_start_f)</code>(<var class=Fa style="white-space: nowrap;">struct timeval *timeout</var>, <var class=Fa style="white-space: nowrap;">snmp_timeout_cb_f callback</var>, <var class=Fa style="white-space: nowrap;">void *uarg</var>);</p><p class=Pp><var class=Ft>typedef void</var><br><code class=Fn>(*snmp_timeout_stop_f)</code>(<var class=Fa style="white-space: nowrap;">void *timeout_id</var>);</p><p class=Pp><var class=Vt>extern struct snmp_client snmp_client</var>;</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>snmp_client_init</code>(<var class=Fa style="white-space: nowrap;">struct snmp_client *client</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>snmp_client_set_host</code>(<var class=Fa style="white-space: nowrap;">struct snmp_client *client</var>, <var class=Fa style="white-space: nowrap;">const char *host</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>snmp_client_set_port</code>(<var class=Fa style="white-space: nowrap;">struct snmp_client *client</var>, <var class=Fa style="white-space: nowrap;">const char *port</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>snmp_open</code>(<var class=Fa style="white-space: nowrap;">const char *host</var>, <var class=Fa style="white-space: nowrap;">const char *port</var>, <var class=Fa style="white-space: nowrap;">const char *read_community</var>, <var class=Fa style="white-space: nowrap;">const char *write_community</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>snmp_close</code>(<var class=Fa style="white-space: nowrap;">void</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>snmp_pdu_create</code>(<var class=Fa style="white-space: nowrap;">struct snmp_pdu *pdu</var>, <var class=Fa style="white-space: nowrap;">u_int op</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>snmp_add_binding</code>(<var class=Fa style="white-space: nowrap;">struct snmp_pdu *pdu</var>, <var class=Fa style="white-space: nowrap;">...</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>snmp_pdu_check</code>(<var class=Fa style="white-space: nowrap;">const struct snmp_pdu *req</var>, <var class=Fa style="white-space: nowrap;">const struct snmp_pdu *resp</var>);</p><p class=Pp><var class=Ft>int32_t</var><br><code class=Fn>snmp_pdu_send</code>(<var class=Fa style="white-space: nowrap;">struct snmp_pdu *pdu</var>, <var class=Fa style="white-space: nowrap;">snmp_send_cb_f func</var>, <var class=Fa style="white-space: nowrap;">void *uarg</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>snmp_oid_append</code>(<var class=Fa style="white-space: nowrap;">struct asn_oid *oid</var>, <var class=Fa style="white-space: nowrap;">const char *fmt</var>, <var class=Fa style="white-space: nowrap;">...</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>snmp_parse_server</code>(<var class=Fa style="white-space: nowrap;">struct snmp_client *sc</var>, <var class=Fa style="white-space: nowrap;">const char *str</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>snmp_receive</code>(<var class=Fa style="white-space: nowrap;">int blocking</var>);</p><p class=Pp><var class=Ft>typedef void</var><br><code class=Fn>(*snmp_table_cb_f)</code>(<var class=Fa style="white-space: nowrap;">void *list</var>, <var class=Fa style="white-space: nowrap;">void *arg</var>, <var class=Fa style="white-space: nowrap;">int res</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>snmp_table_fetch</code>(<var class=Fa style="white-space: nowrap;">const struct snmp_table *descr</var>, <var class=Fa style="white-space: nowrap;">void *list</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>snmp_table_fetch_async</code>(<var class=Fa style="white-space: nowrap;">const struct snmp_table *descr</var>, <var class=Fa style="white-space: nowrap;">void *list</var>, <var class=Fa style="white-space: nowrap;">snmp_table_cb_f callback</var>, <var class=Fa style="white-space: nowrap;">void *uarg</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>snmp_dialog</code>(<var class=Fa style="white-space: nowrap;">struct snmp_pdu *req</var>, <var class=Fa style="white-space: nowrap;">struct snmp_pdu *resp</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>snmp_discover_engine</code>(<var class=Fa style="white-space: nowrap;">void</var>);</p></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> The SNMP library contains routines to easily build SNMP client applications that use SNMP versions 1, 2 or 3. Most of the routines use a <var class=Vt>struct snmp_client</var>: <div class="Bd Pp Bd-indent"><pre>
struct snmp_client {
	enum snmp_version	version;
	int			trans;	/* which transport to use */

	/* these two are read-only for the application */
	char			*cport;	/* port number as string */
	char			*chost;	/* host name or IP address as string */

	char			read_community[SNMP_COMMUNITY_MAXLEN + 1];
	char			write_community[SNMP_COMMUNITY_MAXLEN + 1];

	/* SNMPv3 specific fields */
	int32_t			identifier;
	int32_t			security_model;
	struct snmp_engine	engine;
	struct snmp_user	user;

	/* SNMPv3 Access control - VACM*/
	uint32_t		clen;
	uint8_t			cengine[SNMP_ENGINE_ID_SIZ];
	char			cname[SNMP_CONTEXT_NAME_SIZ];

	struct timeval		timeout;
	u_int			retries;

	int			dump_pdus;

	size_t			txbuflen;
	size_t			rxbuflen;

	int			fd;

	int32_t			next_reqid;
	int32_t			max_reqid;
	int32_t			min_reqid;

	char			error[SNMP_STRERROR_LEN];

	snmp_timeout_start_f	timeout_start;
	snmp_timeout_stop_f	timeout_stop;

	char			local_path[sizeof(SNMP_LOCAL_PATH)];
};
</pre></div><p class=Pp>The fields of this structure are described below.</p><dl class=Bl-tag><dt><var class=Va>version</var></dt><dd>This is the version of SNMP to use. See <a class=Xr href=bsnmplib.3.html>bsnmplib(3)</a> for applicable values. The default version is <code class=Li>SNMP_V2c</code>.</dd><dt><var class=Va>trans</var></dt><dd>If this is <code class=Dv>SNMP_TRANS_LOC_DGRAM</code> a local datagram socket is used. If it is <code class=Dv>SNMP_TRANS_LOC_STREAM</code> a local stream socket is used. For <code class=Dv>SNMP_TRANS_UDP</code> a UDP socket is created. It uses the <var class=Va>chost</var> field as the path to the server's socket for local sockets.</dd><dt><var class=Va>cport</var></dt><dd>The SNMP agent's UDP port number. This may be a symbolic port number (from <span class=Pa>/etc/services</span>) or a numeric port number. If this field is <code class=Li>NULL</code> (the default) the standard SNMP port is used. This field should not be changed directly but rather by calling <code class=Fn>snmp_client_set_port</code>().</dd><dt><var class=Va>chost</var></dt><dd>The SNMP agent's host name, IP address or <span class=Ux>UNIX</span> domain socket path name. If this is <code class=Li>NULL</code> (the default) <code class=Li>localhost</code> is assumed. This field should not be changed directly but rather through calling <code class=Fn>snmp_client_set_host</code>().</dd><dt><var class=Va>read_community</var></dt><dd>This is the community name to be used for all requests except SET requests. The default is ‘public’.</dd><dt><var class=Va>write_community</var></dt><dd>The community name to be used for SET requests. The default is ‘private’.</dd><dt><var class=Va>identifier</var></dt><dd>The message identifier value to be used with SNMPv3 PDUs. Incremented with each transmitted PDU.</dd><dt><var class=Va>security_model</var></dt><dd>The security model to be used with SNMPv3 PDUs. Currently only User-Based Security model specified by RFC 3414 (value 3) is supported.</dd><dt><var class=Va>engine</var></dt><dd>The authoritive SNMP engine parameters to be used with SNMPv3 PDUs.</dd><dt><var class=Va>user</var></dt><dd>The USM SNMP user credentials to be used with SNMPv3 PDUs.</dd><dt><var class=Va>clen</var></dt><dd>The length of the context engine id to be used with SNMPv3 PDUs.</dd><dt><var class=Va>cengine</var></dt><dd>The context engine id to be used with SNMPv3 PDUs. Default is empty.</dd><dt><var class=Va>cname</var></dt><dd>The context name to be used with SNMPv3 PDUs. Default is ‘’.</dd><dt><var class=Va>timeout</var></dt><dd>The maximum time to wait for responses to requests. If the time elapses, the request is resent up to <var class=Va>retries</var> times. The default is 3 seconds.</dd><dt><var class=Va>retries</var></dt><dd>Number of times a request PDU is to be resent. If set to 0, the request is sent only once. The default is 3 retransmissions.</dd><dt><var class=Va>dump_pdus</var></dt><dd>If set to a non-zero value all received and sent PDUs are dumped via <a class=Xr href=snmp_pdu_dump.3.html>snmp_pdu_dump(3)</a>. The default is not to dump PDUs.</dd><dt><var class=Va>txbuflen</var></dt><dd>The encoding buffer size to be allocated for transmitted PDUs. The default is 10000 octets.</dd><dt><var class=Va>rxbuflen</var></dt><dd>The decoding buffer size to be allocated for received PDUs. This is the size of the maximum PDU that can be received. The default is 10000 octets.</dd><dt><var class=Va>fd</var></dt><dd>After calling <code class=Fn>snmp_open</code>() this is the file socket file descriptor used for sending and receiving PDUs.</dd><dt><var class=Va>next_reqid</var></dt><dd>The request id of the next PDU to send. Used internal by the library.</dd><dt><var class=Va>max_reqid</var></dt><dd>The maximum request id to use for outgoing PDUs. The default is <code class=Li>INT32_MAX</code>.</dd><dt><var class=Va>min_reqid</var></dt><dd>The minimum request id to use for outgoing PDUs. Request ids are allocated linearily starting at <var class=Va>min_reqid</var> up to <var class=Va>max_reqid</var>.</dd><dt><var class=Va>error</var></dt><dd>If an error happens, this field is set to a printable string describing the error.</dd><dt><var class=Va>timeout_start</var></dt><dd>This field must point to a function setting up a one shot timeout. After the timeout has elapsed, the given callback function must be called with the user argument. The <code class=Fn>timeout_start</code>() function must return a <var class=Vt>void *</var> identifying the timeout.</dd><dt><var class=Va>timeout_stop</var></dt><dd>This field must be set to a function that stops a running timeout. The function will be called with the return value of the corresponding <code class=Fn>timeout_start</code>() function.</dd><dt><var class=Va>local_path</var></dt><dd>If in local socket mode, the name of the clients socket. Not needed by the application.</dd></dl><p class=Pp>In the current implementation there is a global variable</p><p class=Pp></p><div class="Bd Bd-indent"><var class=Vt>extern struct snmp_client snmp_client</var>;</div><p class=Pp>that is used by all the library functions. The first call into the library must be a call to <code class=Fn>snmp_client_init</code>() to initialize this global variable to the default values. After this call and before calling <code class=Fn>snmp_open</code>() the fields of the variable may be modified by the user. The modification of the <var class=Va>chost</var> and <var class=Va>cport</var> fields should be done only via the functions <code class=Fn>snmp_client_set_host</code>() and <code class=Fn>snmp_client_set_port</code>().</p><p class=Pp>The function <code class=Fn>snmp_open</code>() creates a UDP or <span class=Ux>UNIX</span> domain socket and connects it to the agent's IP address and port. If any of the arguments of the call is not <code class=Li>NULL</code> the corresponding field in the global <var class=Va>snmp_client</var> is set from the argument. Otherwise the values that are already in that variable are used. The function <code class=Fn>snmp_close</code>() closes the socket, stops all timeouts and frees all dynamically allocated resources.</p><p class=Pp>The next three functions are used to create request PDUs. The function <code class=Fn>snmp_pdu_create</code>() initializes a PDU of type <var class=Va>op</var>. It does not allocate space for the PDU itself. This is the responsibility of the caller. <code class=Fn>snmp_add_binding</code>() adds bindings to the PDU and returns the (zero based) index of the first new binding. The arguments are pairs of pointer to the OIDs and syntax constants, terminated by a NULL. The call</p><div class="Bd Pp Bd-indent"><pre>
snmp_add_binding(&amp;pdu,
    &amp;oid1, SNMP_SYNTAX_INTEGER,
    &amp;oid2, SNMP_SYNTAX_OCTETSTRING,
    NULL);
</pre></div><p class=Pp>adds two new bindings to the PDU and returns the index of the first one. It is the responsibility of the caller to set the value part of the binding if necessary. The functions returns -1 if the maximum number of bindings is exhausted. The function <code class=Fn>snmp_oid_append</code>() can be used to construct variable OIDs for requests. It takes a pointer to an <var class=Vt>struct asn_oid</var> that is to be constructed, a format string, and a number of arguments the type of which depends on the format string. The format string is interpreted character by character in the following way:</p><dl class=Bl-tag><dt><a class=permalink href=#i><code class=Li id=i>i</code></a></dt><dd>This format expects an argument of type <var class=Vt>asn_subid_t</var> and appends this as a single integer to the OID.</dd><dt><a class=permalink href=#a><code class=Li id=a>a</code></a></dt><dd>This format expects an argument of type <var class=Vt>struct in_addr</var> and appends to four parts of the IP address to the OID.</dd><dt><a class=permalink href=#s><code class=Li id=s>s</code></a></dt><dd>This format expects an argument of type <var class=Vt>const char *</var> and appends the length of the string (as computed by <a class=Xr href=strlen.3.html>strlen(3)</a>) and each of the characters in the string to the OID.</dd> ( <dt><var class=Va>N</var>)</dt><dd>This format expects no argument. <var class=Va>N</var> must be a decimal number and is stored into an internal variable <var class=Va>size</var>.</dd><dt><a class=permalink href=#b><code class=Li id=b>b</code></a></dt><dd>This format expects an argument of type <var class=Vt>const char *</var> and appends <var class=Va>size</var> characters from the string to the OID. The string may contain <code class=Li>NUL</code> characters.</dd><dt><a class=permalink href=#c><code class=Li id=c>c</code></a></dt><dd>This format expects two arguments: one of type <var class=Vt>size_t</var> and one of type <var class=Vt>const u_char *</var>. The first argument gives the number of bytes to append to the OID from the string pointed to by the second argument.</dd></dl><p class=Pp>The function <code class=Fn>snmp_pdu_check</code>() may be used to check a response PDU. A number of checks are performed (error code, equal number of bindings, syntaxes and values for SET PDUs). The function returns +1 if everything is ok, 0 if a NOSUCHNAME or similar error was detected, -1 if the response PDU had fatal errors and -2 if <var class=Fa>resp</var> is <code class=Li>NULL</code> (a timeout occurred).</p><p class=Pp>The function <code class=Fn>snmp_pdu_send</code>() encodes and sends the given PDU. It records the PDU together with the callback and user pointers in an internal list and arranges for retransmission if no response is received. When a response is received or the retransmission count is exceeded the callback <var class=Fa>func</var> is called with the original request PDU, the response PDU and the user argument <var class=Fa>uarg</var>. If the retransmit count is exceeded, <var class=Fa>func</var> is called with the original request PDU, the response pointer set to <code class=Li>NULL</code> and the user argument <var class=Fa>uarg</var>. The caller should not free the request PDU until the callback function is called. The callback function must free the request PDU and the response PDU (if not <code class=Li>NULL ).</code></p><p class=Pp>The function <code class=Fn>snmp_receive</code>() tries to receive a PDU. If the argument is zero, the function polls to see whether a packet is available, if the argument is non-zero, the function blocks until the next packet is received. The packet is delivered via the usual callback mechanism (non-response packets are silently dropped). The function returns 0, if a packet was received and successfully dispatched, -1 if an error occurred or no packet was available (in polling mode).</p><p class=Pp>The next two functions are used to retrieve tables from SNMP agents. They use the following input structure, that describes the table:</p><div class="Bd Pp Bd-indent"><pre>
struct snmp_table {
	struct asn_oid		table;
	struct asn_oid		last_change;
	u_int			max_iter;
	size_t			entry_size;
	u_int			index_size;
	uint64_t		req_mask;

	struct snmp_table_entry {
	    asn_subid_t		subid;
	    enum snmp_syntax	syntax;
	    off_t		offset;
	}			entries[];
};
</pre></div><p class=Pp>The fields of this structure have the following meaning:</p><dl class=Bl-tag><dt><var class=Va>table</var></dt><dd>This is the base OID of the table.</dd><dt><var class=Va>last_change</var></dt><dd>Some tables have a scalar variable of type TIMETICKS attached to them, that holds the time when the table was last changed. This OID should be the OID of this variable (without the .0 index). When the table is retrieved with multiple GET requests, and the variable changes between two request, the table fetch is restarted.</dd><dt><var class=Va>max_iter</var></dt><dd>Maximum number of tries to fetch the table.</dd><dt><var class=Va>entry_size</var></dt><dd>The table fetching routines return a list of structures one for each table row. This variable is the size of one structure and used to <a class=Xr href=malloc.3.html>malloc(3)</a> the structure.</dd><dt><var class=Va>index_size</var></dt><dd>This is the number of index columns in the table.</dd><dt><var class=Va>req_mask</var></dt><dd>This is a bit mask with a 1 for each table column that is required. Bit 0 corresponds to the first element (index 0) in the array <var class=Va>entries</var>, bit 1 to the second (index 1) and so on. SNMP tables may be sparse. For sparse columns the bit should not be set. If the bit for a given column is set and the column value cannot be retrieved for a given row, the table fetch is restarted assuming that the table is currently being modified by the agent. The bits for the index columns are ignored.</dd><dt><var class=Va>entries</var></dt><dd>This is a variable sized array of column descriptors. This array is terminated by an element with syntax <code class=Li>SNMP_SYNTAX_NULL</code>. The first <var class=Va>index_size</var> elements describe all the index columns of the table, the rest are normal columns. If for the column at ‘<code class=Li>entries[N]</code>’ the expression ‘<code class=Li>req_mask &amp; (1 &lt;&lt; N)</code>’ yields true, the column is considered a required column. The fields of this the array elements have the following meaning: <dl class=Bl-tag><dt><var class=Va>subid</var></dt><dd>This is the OID subid of the column. This is ignored for index entries. Index entries are decoded according to the <var class=Va>syntax</var> field.</dd><dt><var class=Va>syntax</var></dt><dd>This is the syntax of the column or index. A syntax of <code class=Li>SNMP_SYNTAX_NULL</code> terminates the array.</dd><dt><var class=Va>offset</var></dt><dd>This is the starting offset of the value of the column in the return structures. This field can be set with the ISO-C <code class=Fn>offsetof</code>() macro.</dd></dl></dd></dl><p class=Pp>Both table fetching functions return TAILQ (see <a class=Xr href=queue.3.html>queue(3)</a>) of structures--one for each table row. These structures must start with a <code class=Fn>TAILQ_ENTRY</code>() and a <var class=Vt>uint64_t</var> and are allocated via <a class=Xr href=malloc.3.html>malloc(3)</a>. The <var class=Fa>list</var> argument of the table functions must point to a <code class=Fn>TAILQ_HEAD</code>(). The <var class=Vt>uint64_t</var> fields, usually called <var class=Va>found</var> is used to indicate which of the columns have been found for the given row. It is encoded like the <var class=Fa>req_mask</var> field.</p><p class=Pp>The function <code class=Fn>snmp_table_fetch</code>() synchronously fetches the given table. If everything is ok 0 is returned. Otherwise the function returns -1 and sets an appropriate error string. The function <code class=Fn>snmp_table_fetch_async</code>() fetches the tables asynchronously. If either the entire table is fetch, or an error occurs the callback function <var class=Fa>callback</var> is called with the callers arguments <var class=Fa>list</var> and <var class=Fa>uarg</var> and a parameter that is either 0 if the table was fetched, or -1 if there was an error. The function itself returns -1 if it could not initialize fetching of the table.</p><p class=Pp>The following table description is used to fetch the ATM interface table:</p><div class="Bd Pp Bd-indent"><pre>
/*
 * ATM interface table
 */
struct atmif {
	TAILQ_ENTRY(atmif) link;
	uint64_t	found;
	int32_t		index;
	u_char		*ifname;
	size_t		ifnamelen;
	uint32_t	node_id;
	uint32_t	pcr;
	int32_t		media;
	uint32_t	vpi_bits;
	uint32_t	vci_bits;
	uint32_t	max_vpcs;
	uint32_t	max_vccs;
	u_char		*esi;
	size_t		esilen;
	int32_t		carrier;
};
TAILQ_HEAD(atmif_list, atmif);

/* list of all ATM interfaces */
struct atmif_list atmif_list;

static const struct snmp_table atmif_table = {
	OIDX_begemotAtmIfTable,
	OIDX_begemotAtmIfTableLastChange, 2,
	sizeof(struct atmif),
	1, 0x7ffULL,
	{
	  { 0, SNMP_SYNTAX_INTEGER,
		offsetof(struct atmif, index) },
	  { 1, SNMP_SYNTAX_OCTETSTRING,
		offsetof(struct atmif, ifname) },
	  { 2, SNMP_SYNTAX_GAUGE,
		offsetof(struct atmif, node_id) },
	  { 3, SNMP_SYNTAX_GAUGE,
		offsetof(struct atmif, pcr) },
	  { 4, SNMP_SYNTAX_INTEGER,
		offsetof(struct atmif, media) },
	  { 5, SNMP_SYNTAX_GAUGE,
		offsetof(struct atmif, vpi_bits) },
	  { 6, SNMP_SYNTAX_GAUGE,
		offsetof(struct atmif, vci_bits) },
	  { 7, SNMP_SYNTAX_GAUGE,
		offsetof(struct atmif, max_vpcs) },
	  { 8, SNMP_SYNTAX_GAUGE,
		offsetof(struct atmif, max_vccs) },
	  { 9, SNMP_SYNTAX_OCTETSTRING,
		offsetof(struct atmif, esi) },
	  { 10, SNMP_SYNTAX_INTEGER,
		offsetof(struct atmif, carrier) },
          { 0, SNMP_SYNTAX_NULL, 0 }
	}
};

...
	if (snmp_table_fetch(&amp;atmif_table, &amp;atmif_list) != 0)
		errx(1, "AtmIf table: %s", snmp_client.error);
...
</pre></div><p class=Pp>The function <code class=Fn>snmp_dialog</code>() is used to execute a synchonuous dialog with the agent. The request PDU <var class=Fa>req</var> is sent and the function blocks until the response PDU is received. Note, that asynchonuous receives are handled (i.e. callback functions of other send calls or table fetches may be called while in the function). The response PDU is returned in <var class=Fa>resp</var>. If no response could be received after all timeouts and retries, the function returns -1. If a response was received 0 is returned.</p><p class=Pp>The function <code class=Fn>snmp_discover_engine</code>() is used to discover the authoritative snmpEngineId of a remote SNMPv3 agent. A request PDU with empty USM user name is sent and the client's engine parameters are set according to the snmpEngine parameters received in the response PDU. If the client is configured to use authentication and/or privacy and the snmpEngineBoots and/or snmpEngineTime in the response had zero values, an additional request (possibly encrypted) with the appropriate user credentials is sent to fetch the missing values. Note, that the function blocks until the discovery process is completed. If no response could be received after all timeouts and retries, or the response contained errors the function returns -1. If the discovery process was completed 0 is returned.</p><p class=Pp>The function <code class=Fn>snmp_parse_server</code>() is used to parse an SNMP server specification string and fill in the fields of a <var class=Vt>struct snmp_client</var>. The syntax of a server specification is</p><p class=Pp></p><div class="Bd Bd-indent">[trans::][community@][server][:port]</div><p class=Pp>where <var class=Va>trans</var> is the transport name (one of udp, stream or dgram), <var class=Va>community</var> is the string to be used for both the read and the write community, <var class=Va>server</var> is the server's host name in case of UDP and the path name in case of a local socket, and <var class=Va>port</var> is the port in case of UDP transport. The function returns 0 in the case of success and return -1 and sets the error string in case of an error.</p></section><section class=Sh><h2 class=Sh id=DIAGNOSTICS><a class=permalink href=#DIAGNOSTICS>DIAGNOSTICS</a></h2> If an error occurs in any of the function an error indication as described above is returned. Additionally the function sets a printable error string in the <var class=Va>error</var> filed of <var class=Va>snmp_client</var>. </section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=gensnmptree.1.html>gensnmptree(1)</a>, <a class=Xr href=bsnmpd.1.html>bsnmpd(1)</a>, <a class=Xr href=bsnmpagent.3.html>bsnmpagent(3)</a>, <a class=Xr href=bsnmplib.3.html>bsnmplib(3)</a></section><section class=Sh><h2 class=Sh id=STANDARDS><a class=permalink href=#STANDARDS>STANDARDS</a></h2> This implementation conforms to the applicable IETF RFCs and ITU-T recommendations. </section><section class=Sh><h2 class=Sh id=AUTHORS><a class=permalink href=#AUTHORS>AUTHORS</a></h2><span class=An>Hartmut Brandt</span> ⟨harti@FreeBSD.org⟩ <br><span class=An>Kendy Kutzner</span> ⟨kutzner@fokus.gmd.de⟩ </section></div><table class=foot><tr><td class=foot-date>December 31, 2016</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>