<!DOCTYPE html>
<html><head><meta charset=utf-8><title>EVP_CIPHER_CTX_set_padding(3)</title><keywords content=man,EVP_CIPHER_CTX_set_padding></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>EVP_CIPHER_CTX_set_padding(3)</h1><table class=head><tr><td class=head-ltitle>EVP_ENCRYPTINIT(3)</td><td class=head-vol>OpenSSL</td><td class=head-rtitle>EVP_ENCRYPTINIT(3)</td></tr></table><div class=manual-text><br><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2> EVP_CIPHER_CTX_new, EVP_CIPHER_CTX_reset, EVP_CIPHER_CTX_free, EVP_EncryptInit_ex, EVP_EncryptUpdate, EVP_EncryptFinal_ex, EVP_DecryptInit_ex, EVP_DecryptUpdate, EVP_DecryptFinal_ex, EVP_CipherInit_ex, EVP_CipherUpdate, EVP_CipherFinal_ex, EVP_CIPHER_CTX_set_key_length, EVP_CIPHER_CTX_ctrl, EVP_EncryptInit, EVP_EncryptFinal, EVP_DecryptInit, EVP_DecryptFinal, EVP_CipherInit, EVP_CipherFinal, EVP_get_cipherbyname, EVP_get_cipherbynid, EVP_get_cipherbyobj, EVP_CIPHER_nid, EVP_CIPHER_block_size, EVP_CIPHER_key_length, EVP_CIPHER_iv_length, EVP_CIPHER_flags, EVP_CIPHER_mode, EVP_CIPHER_type, EVP_CIPHER_CTX_cipher, EVP_CIPHER_CTX_nid, EVP_CIPHER_CTX_block_size, EVP_CIPHER_CTX_key_length, EVP_CIPHER_CTX_iv_length, EVP_CIPHER_CTX_get_app_data, EVP_CIPHER_CTX_set_app_data, EVP_CIPHER_CTX_type, EVP_CIPHER_CTX_flags, EVP_CIPHER_CTX_mode, EVP_CIPHER_param_to_asn1, EVP_CIPHER_asn1_to_param, EVP_CIPHER_CTX_set_padding, EVP_enc_null - EVP cipher routines </section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><pre>
 #include &lt;openssl/evp.h&gt;

 EVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void);
 int EVP_CIPHER_CTX_reset(EVP_CIPHER_CTX *ctx);
 void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *ctx);

 int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
                        ENGINE *impl, const unsigned char *key, const unsigned char *iv);
 int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
                       int *outl, const unsigned char *in, int inl);
 int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);

 int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
                        ENGINE *impl, const unsigned char *key, const unsigned char *iv);
 int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
                       int *outl, const unsigned char *in, int inl);
 int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);

 int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
                       ENGINE *impl, const unsigned char *key, const unsigned char *iv, int enc);
 int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
                      int *outl, const unsigned char *in, int inl);
 int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);

 int EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
                     const unsigned char *key, const unsigned char *iv);
 int EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);

 int EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
                     const unsigned char *key, const unsigned char *iv);
 int EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);

 int EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
                    const unsigned char *key, const unsigned char *iv, int enc);
 int EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);

 int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *x, int padding);
 int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen);
 int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);
 int EVP_CIPHER_CTX_rand_key(EVP_CIPHER_CTX *ctx, unsigned char *key);

 const EVP_CIPHER *EVP_get_cipherbyname(const char *name);
 const EVP_CIPHER *EVP_get_cipherbynid(int nid);
 const EVP_CIPHER *EVP_get_cipherbyobj(const ASN1_OBJECT *a);

 int EVP_CIPHER_nid(const EVP_CIPHER *e);
 int EVP_CIPHER_block_size(const EVP_CIPHER *e);
 int EVP_CIPHER_key_length(const EVP_CIPHER *e);
 int EVP_CIPHER_iv_length(const EVP_CIPHER *e);
 unsigned long EVP_CIPHER_flags(const EVP_CIPHER *e);
 unsigned long EVP_CIPHER_mode(const EVP_CIPHER *e);
 int EVP_CIPHER_type(const EVP_CIPHER *ctx);

 const EVP_CIPHER *EVP_CIPHER_CTX_cipher(const EVP_CIPHER_CTX *ctx);
 int EVP_CIPHER_CTX_nid(const EVP_CIPHER_CTX *ctx);
 int EVP_CIPHER_CTX_block_size(const EVP_CIPHER_CTX *ctx);
 int EVP_CIPHER_CTX_key_length(const EVP_CIPHER_CTX *ctx);
 int EVP_CIPHER_CTX_iv_length(const EVP_CIPHER_CTX *ctx);
 void *EVP_CIPHER_CTX_get_app_data(const EVP_CIPHER_CTX *ctx);
 void EVP_CIPHER_CTX_set_app_data(const EVP_CIPHER_CTX *ctx, void *data);
 int EVP_CIPHER_CTX_type(const EVP_CIPHER_CTX *ctx);
 int EVP_CIPHER_CTX_mode(const EVP_CIPHER_CTX *ctx);

 int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
 int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
</pre></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> The EVP cipher routines are a high-level interface to certain symmetric ciphers. <p class=Pp><b>EVP_CIPHER_CTX_new()</b> creates a cipher context.</p><p class=Pp><b>EVP_CIPHER_CTX_free()</b> clears all information from a cipher context and free up any allocated memory associate with it, including <b>ctx</b> itself. This function should be called after all operations using a cipher are complete so sensitive information does not remain in memory.</p><p class=Pp><b>EVP_EncryptInit_ex()</b> sets up cipher context <b>ctx</b> for encryption with cipher <b>type</b> from ENGINE <b>impl</b>. <b>ctx</b> must be created before calling this function. <b>type</b> is normally supplied by a function such as <b>EVP_aes_256_cbc()</b>. If <b>impl</b> is NULL then the default implementation is used. <b>key</b> is the symmetric key to use and <b>iv</b> is the IV to use (if necessary), the actual number of bytes used for the key and IV depends on the cipher. It is possible to set all parameters to NULL except <b>type</b> in an initial call and supply the remaining parameters in subsequent calls, all of which have <b>type</b> set to NULL. This is done when the default cipher parameters are not appropriate.</p><p class=Pp><b>EVP_EncryptUpdate()</b> encrypts <b>inl</b> bytes from the buffer <b>in</b> and writes the encrypted version to <b>out</b>. This function can be called multiple times to encrypt successive blocks of data. The amount of data written depends on the block alignment of the encrypted data. For most ciphers and modes, the amount of data written can be anything from zero bytes to (inl + cipher_block_size - 1) bytes. For wrap cipher modes, the amount of data written can be anything from zero bytes to (inl + cipher_block_size) bytes. For stream ciphers, the amount of data written can be anything from zero bytes to inl bytes. Thus, <b>out</b> should contain sufficient room for the operation being performed. The actual number of bytes written is placed in <b>outl</b>. It also checks if <b>in</b> and <b>out</b> are partially overlapping, and if they are 0 is returned to indicate failure.</p><p class=Pp>If padding is enabled (the default) then <b>EVP_EncryptFinal_ex()</b> encrypts the "final" data, that is any data that remains in a partial block. It uses standard block padding (aka PKCS padding) as described in the NOTES section, below. The encrypted final data is written to <b>out</b> which should have sufficient space for one cipher block. The number of bytes written is placed in <b>outl</b>. After this function is called the encryption operation is finished and no further calls to <b>EVP_EncryptUpdate()</b> should be made.</p><p class=Pp>If padding is disabled then <b>EVP_EncryptFinal_ex()</b> will not encrypt any more data and it will return an error if any data remains in a partial block: that is if the total data length is not a multiple of the block size.</p><p class=Pp><b>EVP_DecryptInit_ex()</b>, <b>EVP_DecryptUpdate()</b> and <b>EVP_DecryptFinal_ex()</b> are the corresponding decryption operations. <b>EVP_DecryptFinal()</b> will return an error code if padding is enabled and the final block is not correctly formatted. The parameters and restrictions are identical to the encryption operations except that if padding is enabled the decrypted data buffer <b>out</b> passed to <b>EVP_DecryptUpdate()</b> should have sufficient room for (<b>inl</b> + cipher_block_size) bytes unless the cipher block size is 1 in which case <b>inl</b> bytes is sufficient.</p><p class=Pp><b>EVP_CipherInit_ex()</b>, <b>EVP_CipherUpdate()</b> and <b>EVP_CipherFinal_ex()</b> are functions that can be used for decryption or encryption. The operation performed depends on the value of the <b>enc</b> parameter. It should be set to 1 for encryption, 0 for decryption and -1 to leave the value unchanged (the actual value of 'enc' being supplied in a previous call).</p><p class=Pp><b>EVP_CIPHER_CTX_reset()</b> clears all information from a cipher context and free up any allocated memory associate with it, except the <b>ctx</b> itself. This function should be called anytime <b>ctx</b> is to be reused for another <b>EVP_CipherInit()</b> / <b>EVP_CipherUpdate()</b> / <b>EVP_CipherFinal()</b> series of calls.</p><p class=Pp><b>EVP_EncryptInit()</b>, <b>EVP_DecryptInit()</b> and <b>EVP_CipherInit()</b> behave in a similar way to <b>EVP_EncryptInit_ex()</b>, <b>EVP_DecryptInit_ex()</b> and <b>EVP_CipherInit_ex()</b> except they always use the default cipher implementation.</p><p class=Pp><b>EVP_EncryptFinal()</b>, <b>EVP_DecryptFinal()</b> and <b>EVP_CipherFinal()</b> are identical to <b>EVP_EncryptFinal_ex()</b>, <b>EVP_DecryptFinal_ex()</b> and <b>EVP_CipherFinal_ex()</b>. In previous releases they also cleaned up the <b>ctx</b>, but this is no longer done and <b>EVP_CIPHER_CTX_clean()</b> must be called to free any context resources.</p><p class=Pp><b>EVP_get_cipherbyname()</b>, <b>EVP_get_cipherbynid()</b> and <b>EVP_get_cipherbyobj()</b> return an EVP_CIPHER structure when passed a cipher name, a NID or an ASN1_OBJECT structure.</p><p class=Pp><b>EVP_CIPHER_nid()</b> and <b>EVP_CIPHER_CTX_nid()</b> return the NID of a cipher when passed an <b>EVP_CIPHER</b> or <b>EVP_CIPHER_CTX</b> structure. The actual NID value is an internal value which may not have a corresponding OBJECT IDENTIFIER.</p><p class=Pp><b>EVP_CIPHER_CTX_set_padding()</b> enables or disables padding. This function should be called after the context is set up for encryption or decryption with <b>EVP_EncryptInit_ex()</b>, <b>EVP_DecryptInit_ex()</b> or <b>EVP_CipherInit_ex()</b>. By default encryption operations are padded using standard block padding and the padding is checked and removed when decrypting. If the <b>pad</b> parameter is zero then no padding is performed, the total amount of data encrypted or decrypted must then be a multiple of the block size or an error will occur.</p><p class=Pp><b>EVP_CIPHER_key_length()</b> and <b>EVP_CIPHER_CTX_key_length()</b> return the key length of a cipher when passed an <b>EVP_CIPHER</b> or <b>EVP_CIPHER_CTX</b> structure. The constant <b>EVP_MAX_KEY_LENGTH</b> is the maximum key length for all ciphers. Note: although <b>EVP_CIPHER_key_length()</b> is fixed for a given cipher, the value of <b>EVP_CIPHER_CTX_key_length()</b> may be different for variable key length ciphers.</p><p class=Pp><b>EVP_CIPHER_CTX_set_key_length()</b> sets the key length of the cipher ctx. If the cipher is a fixed length cipher then attempting to set the key length to any value other than the fixed value is an error.</p><p class=Pp><b>EVP_CIPHER_iv_length()</b> and <b>EVP_CIPHER_CTX_iv_length()</b> return the IV length of a cipher when passed an <b>EVP_CIPHER</b> or <b>EVP_CIPHER_CTX</b>. It will return zero if the cipher does not use an IV. The constant <b>EVP_MAX_IV_LENGTH</b> is the maximum IV length for all ciphers.</p><p class=Pp><b>EVP_CIPHER_block_size()</b> and <b>EVP_CIPHER_CTX_block_size()</b> return the block size of a cipher when passed an <b>EVP_CIPHER</b> or <b>EVP_CIPHER_CTX</b> structure. The constant <b>EVP_MAX_BLOCK_LENGTH</b> is also the maximum block length for all ciphers.</p><p class=Pp><b>EVP_CIPHER_type()</b> and <b>EVP_CIPHER_CTX_type()</b> return the type of the passed cipher or context. This "type" is the actual NID of the cipher OBJECT IDENTIFIER as such it ignores the cipher parameters and 40 bit RC2 and 128 bit RC2 have the same NID. If the cipher does not have an object identifier or does not have ASN1 support this function will return <b>NID_undef</b>.</p><p class=Pp><b>EVP_CIPHER_CTX_cipher()</b> returns the <b>EVP_CIPHER</b> structure when passed an <b>EVP_CIPHER_CTX</b> structure.</p><p class=Pp><b>EVP_CIPHER_mode()</b> and <b>EVP_CIPHER_CTX_mode()</b> return the block cipher mode: EVP_CIPH_ECB_MODE, EVP_CIPH_CBC_MODE, EVP_CIPH_CFB_MODE, EVP_CIPH_OFB_MODE, EVP_CIPH_CTR_MODE, EVP_CIPH_GCM_MODE, EVP_CIPH_CCM_MODE, EVP_CIPH_XTS_MODE, EVP_CIPH_WRAP_MODE or EVP_CIPH_OCB_MODE. If the cipher is a stream cipher then EVP_CIPH_STREAM_CIPHER is returned.</p><p class=Pp><b>EVP_CIPHER_param_to_asn1()</b> sets the AlgorithmIdentifier "parameter" based on the passed cipher. This will typically include any parameters and an IV. The cipher IV (if any) must be set when this call is made. This call should be made before the cipher is actually "used" (before any <b>EVP_EncryptUpdate()</b>, <b>EVP_DecryptUpdate()</b> calls for example). This function may fail if the cipher does not have any ASN1 support.</p><p class=Pp><b>EVP_CIPHER_asn1_to_param()</b> sets the cipher parameters based on an ASN1 AlgorithmIdentifier "parameter". The precise effect depends on the cipher In the case of RC2, for example, it will set the IV and effective key length. This function should be called after the base cipher type is set but before the key is set. For example <b>EVP_CipherInit()</b> will be called with the IV and key set to NULL, <b>EVP_CIPHER_asn1_to_param()</b> will be called and finally <b>EVP_CipherInit()</b> again with all parameters except the key set to NULL. It is possible for this function to fail if the cipher does not have any ASN1 support or the parameters cannot be set (for example the RC2 effective key length is not supported.</p><p class=Pp><b>EVP_CIPHER_CTX_ctrl()</b> allows various cipher specific parameters to be determined and set.</p><p class=Pp><b>EVP_CIPHER_CTX_rand_key()</b> generates a random key of the appropriate length based on the cipher context. The EVP_CIPHER can provide its own random key generation routine to support keys of a specific form. <b>Key</b> must point to a buffer at least as big as the value returned by <b>EVP_CIPHER_CTX_key_length()</b>.</p></section><section class=Sh><h2 class=Sh id=RETURN_VALUES><a class=permalink href=#RETURN_VALUES>RETURN VALUES</a></h2><b>EVP_CIPHER_CTX_new()</b> returns a pointer to a newly created <b>EVP_CIPHER_CTX</b> for success and <b>NULL</b> for failure. <p class=Pp><b>EVP_EncryptInit_ex()</b>, <b>EVP_EncryptUpdate()</b> and <b>EVP_EncryptFinal_ex()</b> return 1 for success and 0 for failure.</p><p class=Pp><b>EVP_DecryptInit_ex()</b> and <b>EVP_DecryptUpdate()</b> return 1 for success and 0 for failure. <b>EVP_DecryptFinal_ex()</b> returns 0 if the decrypt failed or 1 for success.</p><p class=Pp><b>EVP_CipherInit_ex()</b> and <b>EVP_CipherUpdate()</b> return 1 for success and 0 for failure. <b>EVP_CipherFinal_ex()</b> returns 0 for a decryption failure or 1 for success.</p><p class=Pp><b>EVP_CIPHER_CTX_reset()</b> returns 1 for success and 0 for failure.</p><p class=Pp><b>EVP_get_cipherbyname()</b>, <b>EVP_get_cipherbynid()</b> and <b>EVP_get_cipherbyobj()</b> return an <b>EVP_CIPHER</b> structure or NULL on error.</p><p class=Pp><b>EVP_CIPHER_nid()</b> and <b>EVP_CIPHER_CTX_nid()</b> return a NID.</p><p class=Pp><b>EVP_CIPHER_block_size()</b> and <b>EVP_CIPHER_CTX_block_size()</b> return the block size.</p><p class=Pp><b>EVP_CIPHER_key_length()</b> and <b>EVP_CIPHER_CTX_key_length()</b> return the key length.</p><p class=Pp><b>EVP_CIPHER_CTX_set_padding()</b> always returns 1.</p><p class=Pp><b>EVP_CIPHER_iv_length()</b> and <b>EVP_CIPHER_CTX_iv_length()</b> return the IV length or zero if the cipher does not use an IV.</p><p class=Pp><b>EVP_CIPHER_type()</b> and <b>EVP_CIPHER_CTX_type()</b> return the NID of the cipher's OBJECT IDENTIFIER or NID_undef if it has no defined OBJECT IDENTIFIER.</p><p class=Pp><b>EVP_CIPHER_CTX_cipher()</b> returns an <b>EVP_CIPHER</b> structure.</p><p class=Pp><b>EVP_CIPHER_param_to_asn1()</b> and <b>EVP_CIPHER_asn1_to_param()</b> return greater than zero for success and zero or a negative number on failure.</p><p class=Pp><b>EVP_CIPHER_CTX_rand_key()</b> returns 1 for success.</p></section><section class=Sh><h2 class=Sh id=CIPHER_LISTING><a class=permalink href=#CIPHER_LISTING>CIPHER LISTING</a></h2> All algorithms have a fixed key length unless otherwise stated. <p class=Pp>Refer to "SEE ALSO" for the full list of ciphers available through the EVP interface.</p><dl class=Bl-tag><dt><b>EVP_enc_null()</b></dt><dd>Null cipher: does nothing.</dd></dl></section><section class=Sh><h2 class=Sh id=AEAD_Interface><a class=permalink href=#AEAD_Interface>AEAD Interface</a></h2> The EVP interface for Authenticated Encryption with Associated Data (AEAD) modes are subtly altered and several additional <i>ctrl</i> operations are supported depending on the mode specified. <p class=Pp>To specify additional authenticated data (AAD), a call to <b>EVP_CipherUpdate()</b>, <b>EVP_EncryptUpdate()</b> or <b>EVP_DecryptUpdate()</b> should be made with the output parameter <b>out</b> set to <b>NULL</b>.</p><p class=Pp>When decrypting, the return value of <b>EVP_DecryptFinal()</b> or <b>EVP_CipherFinal()</b> indicates whether the operation was successful. If it does not indicate success, the authentication operation has failed and any output data <b>MUST NOT</b> be used as it is corrupted.</p><section class=Ss><h2 class=Ss id=_s-1GCM_s0_and__s-1OCB_s0_Modes><a class=permalink href=#_s-1GCM_s0_and__s-1OCB_s0_Modes>GCM and OCB Modes</a></h2> The following <i>ctrl</i>s are supported in GCM and OCB modes. <dl class=Bl-tag><dt>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN, ivlen, NULL)</dt><dd>Sets the IV length. This call can only be made before specifying an IV. If not called a default IV length is used. <p class=Pp>For GCM AES and OCB AES the default is 12 (i.e. 96 bits). For OCB mode the maximum is 15.</p></dd><dt>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, taglen, tag)</dt><dd>Writes <span class=Li>"taglen"</span> bytes of the tag value to the buffer indicated by <span class=Li>"tag"</span>. This call can only be made when encrypting data and <b>after</b> all data has been processed (e.g. after an <b>EVP_EncryptFinal()</b> call). <p class=Pp>For OCB, <span class=Li>"taglen"</span> must either be 16 or the value previously set via <b>EVP_CTRL_AEAD_SET_TAG</b>.</p></dd><dt>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, taglen, tag)</dt><dd>Sets the expected tag to <span class=Li>"taglen"</span> bytes from <span class=Li>"tag"</span>. The tag length can only be set before specifying an IV. <span class=Li>"taglen"</span> must be between 1 and 16 inclusive. <p class=Pp>For GCM, this call is only valid when decrypting data.</p><p class=Pp>For OCB, this call is valid when decrypting data to set the expected tag, and before encryption to set the desired tag length.</p><p class=Pp>In OCB mode, calling this before encryption with <span class=Li>"tag"</span> set to <span class=Li>"NULL"</span> sets the tag length. If this is not called prior to encryption, a default tag length is used.</p><p class=Pp>For OCB AES, the default tag length is 16 (i.e. 128 bits). It is also the maximum tag length for OCB.</p></dd></dl></section><section class=Ss><h2 class=Ss id=_s-1CCM_s0_Mode><a class=permalink href=#_s-1CCM_s0_Mode>CCM Mode</a></h2> The EVP interface for CCM mode is similar to that of the GCM mode but with a few additional requirements and different <i>ctrl</i> values. <p class=Pp>For CCM mode, the total plaintext or ciphertext length <b>MUST</b> be passed to <b>EVP_CipherUpdate()</b>, <b>EVP_EncryptUpdate()</b> or <b>EVP_DecryptUpdate()</b> with the output and input parameters (<b>in</b> and <b>out</b>) set to <b>NULL</b> and the length passed in the <b>inl</b> parameter.</p><p class=Pp>The following <i>ctrl</i>s are supported in CCM mode.</p><dl class=Bl-tag><dt>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, taglen, tag)</dt><dd>This call is made to set the expected <b>CCM</b> tag value when decrypting or the length of the tag (with the <span class=Li>"tag"</span> parameter set to NULL) when encrypting. The tag length is often referred to as <b>M</b>. If not set a default value is used (12 for AES). When decrypting, the tag needs to be set before passing in data to be decrypted, but as in GCM and OCB mode, it can be set after passing additional authenticated data (see "AEAD Interface").</dd><dt>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_CCM_SET_L, ivlen, NULL)</dt><dd>Sets the CCM <b>L</b> value. If not set a default is used (8 for AES).</dd><dt>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN, ivlen, NULL)</dt><dd>Sets the CCM nonce (IV) length. This call can only be made before specifying a nonce value. The nonce length is given by <b>15 - L</b> so it is 7 by default for AES.</dd></dl></section><section class=Ss><h2 class=Ss id=ChaCha20_-Poly1305><a class=permalink href=#ChaCha20_-Poly1305>ChaCha20-Poly1305</a></h2> The following <i>ctrl</i>s are supported for the ChaCha20-Poly1305 AEAD algorithm. <dl class=Bl-tag><dt>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN, ivlen, NULL)</dt><dd>Sets the nonce length. This call can only be made before specifying the nonce. If not called a default nonce length of 12 (i.e. 96 bits) is used. The maximum nonce length is 12 bytes (i.e. 96-bits). If a nonce of less than 12 bytes is set then the nonce is automatically padded with leading 0 bytes to make it 12 bytes in length.</dd><dt>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, taglen, tag)</dt><dd>Writes <span class=Li>"taglen"</span> bytes of the tag value to the buffer indicated by <span class=Li>"tag"</span>. This call can only be made when encrypting data and <b>after</b> all data has been processed (e.g. after an <b>EVP_EncryptFinal()</b> call). <p class=Pp><span class=Li>"taglen"</span> specified here must be 16 (<b>POLY1305_BLOCK_SIZE</b>, i.e. 128-bits) or less.</p></dd><dt>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, taglen, tag)</dt><dd>Sets the expected tag to <span class=Li>"taglen"</span> bytes from <span class=Li>"tag"</span>. The tag length can only be set before specifying an IV. <span class=Li>"taglen"</span> must be between 1 and 16 (<b>POLY1305_BLOCK_SIZE</b>) inclusive. This call is only valid when decrypting data.</dd></dl></section></section><section class=Sh><h2 class=Sh id=NOTES><a class=permalink href=#NOTES>NOTES</a></h2> Where possible the <b>EVP</b> interface to symmetric ciphers should be used in preference to the low-level interfaces. This is because the code then becomes transparent to the cipher used and much more flexible. Additionally, the <b>EVP</b> interface will ensure the use of platform specific cryptographic acceleration such as AES-NI (the low-level interfaces do not provide the guarantee). <p class=Pp>PKCS padding works by adding <b>n</b> padding bytes of value <b>n</b> to make the total length of the encrypted data a multiple of the block size. Padding is always added so if the data is already a multiple of the block size <b>n</b> will equal the block size. For example if the block size is 8 and 11 bytes are to be encrypted then 5 padding bytes of value 5 will be added.</p><p class=Pp>When decrypting the final block is checked to see if it has the correct form.</p><p class=Pp>Although the decryption operation can produce an error if padding is enabled, it is not a strong test that the input data or key is correct. A random block has better than 1 in 256 chance of being of the correct format and problems with the input data earlier on will not produce a final decrypt error.</p><p class=Pp>If padding is disabled then the decryption operation will always succeed if the total amount of data decrypted is a multiple of the block size.</p><p class=Pp>The functions <b>EVP_EncryptInit()</b>, <b>EVP_EncryptFinal()</b>, <b>EVP_DecryptInit()</b>, <b>EVP_CipherInit()</b> and <b>EVP_CipherFinal()</b> are obsolete but are retained for compatibility with existing code. New code should use <b>EVP_EncryptInit_ex()</b>, <b>EVP_EncryptFinal_ex()</b>, <b>EVP_DecryptInit_ex()</b>, <b>EVP_DecryptFinal_ex()</b>, <b>EVP_CipherInit_ex()</b> and <b>EVP_CipherFinal_ex()</b> because they can reuse an existing context without allocating and freeing it up on each call.</p><p class=Pp>There are some differences between functions <b>EVP_CipherInit()</b> and <b>EVP_CipherInit_ex()</b>, significant in some circumstances. <b>EVP_CipherInit()</b> fills the passed context object with zeros. As a consequence, <b>EVP_CipherInit()</b> does not allow step-by-step initialization of the ctx when the <i>key</i> and <i>iv</i> are passed in separate calls. It also means that the flags set for the CTX are removed, and it is especially important for the <b>EVP_CIPHER_CTX_FLAG_WRAP_ALLOW</b> flag treated specially in <b>EVP_CipherInit_ex()</b>.</p><p class=Pp><b>EVP_get_cipherbynid()</b>, and <b>EVP_get_cipherbyobj()</b> are implemented as macros.</p></section><section class=Sh><h2 class=Sh id=BUGS><a class=permalink href=#BUGS>BUGS</a></h2><b>EVP_MAX_KEY_LENGTH</b> and <b>EVP_MAX_IV_LENGTH</b> only refer to the internal ciphers with default key lengths. If custom ciphers exceed these values the results are unpredictable. This is because it has become standard practice to define a generic key as a fixed unsigned char array containing <b>EVP_MAX_KEY_LENGTH</b> bytes. <p class=Pp>The ASN1 code is incomplete (and sometimes inaccurate) it has only been tested for certain common S/MIME ciphers (RC2, DES, triple DES) in CBC mode.</p></section><section class=Sh><h2 class=Sh id=EXAMPLES><a class=permalink href=#EXAMPLES>EXAMPLES</a></h2> Encrypt a string using IDEA: <p class=Pp></p><pre>
 int do_crypt(char *outfile)
 {
     unsigned char outbuf[1024];
     int outlen, tmplen;
     /*
      * Bogus key and IV: we'd normally set these from
      * another source.
      */
     unsigned char key[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
     unsigned char iv[] = {1,2,3,4,5,6,7,8};
     char intext[] = "Some Crypto Text";
     EVP_CIPHER_CTX *ctx;
     FILE *out;

     ctx = EVP_CIPHER_CTX_new();
     EVP_EncryptInit_ex(ctx, EVP_idea_cbc(), NULL, key, iv);

     if (!EVP_EncryptUpdate(ctx, outbuf, &amp;outlen, intext, strlen(intext))) {
         /* Error */
         EVP_CIPHER_CTX_free(ctx);
         return 0;
     }
     /*
      * Buffer passed to EVP_EncryptFinal() must be after data just
      * encrypted to avoid overwriting it.
      */
     if (!EVP_EncryptFinal_ex(ctx, outbuf + outlen, &amp;tmplen)) {
         /* Error */
         EVP_CIPHER_CTX_free(ctx);
         return 0;
     }
     outlen += tmplen;
     EVP_CIPHER_CTX_free(ctx);
     /*
      * Need binary mode for fopen because encrypted data is
      * binary data. Also cannot use strlen() on it because
      * it won't be NUL terminated and may contain embedded
      * NULs.
      */
     out = fopen(outfile, "wb");
     if (out == NULL) {
         /* Error */
         return 0;
     }
     fwrite(outbuf, 1, outlen, out);
     fclose(out);
     return 1;
 }
</pre><p class=Pp>The ciphertext from the above example can be decrypted using the <b>openssl</b> utility with the command line (shown on two lines for clarity):</p><p class=Pp></p><pre>
 openssl idea -d \
     -K 000102030405060708090A0B0C0D0E0F -iv 0102030405060708 &lt;filename
</pre><p class=Pp>General encryption and decryption function example using FILE I/O and AES128 with a 128-bit key:</p><p class=Pp></p><pre>
 int do_crypt(FILE *in, FILE *out, int do_encrypt)
 {
     /* Allow enough space in output buffer for additional block */
     unsigned char inbuf[1024], outbuf[1024 + EVP_MAX_BLOCK_LENGTH];
     int inlen, outlen;
     EVP_CIPHER_CTX *ctx;
     /*
      * Bogus key and IV: we'd normally set these from
      * another source.
      */
     unsigned char key[] = "0123456789abcdeF";
     unsigned char iv[] = "1234567887654321";

     /* Don't set key or IV right away; we want to check lengths */
     ctx = EVP_CIPHER_CTX_new();
     EVP_CipherInit_ex(ctx, EVP_aes_128_cbc(), NULL, NULL, NULL,
                       do_encrypt);
     OPENSSL_assert(EVP_CIPHER_CTX_key_length(ctx) == 16);
     OPENSSL_assert(EVP_CIPHER_CTX_iv_length(ctx) == 16);

     /* Now we can set key and IV */
     EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, do_encrypt);

     for (;;) {
         inlen = fread(inbuf, 1, 1024, in);
         if (inlen &lt;= 0)
             break;
         if (!EVP_CipherUpdate(ctx, outbuf, &amp;outlen, inbuf, inlen)) {
             /* Error */
             EVP_CIPHER_CTX_free(ctx);
             return 0;
         }
         fwrite(outbuf, 1, outlen, out);
     }
     if (!EVP_CipherFinal_ex(ctx, outbuf, &amp;outlen)) {
         /* Error */
         EVP_CIPHER_CTX_free(ctx);
         return 0;
     }
     fwrite(outbuf, 1, outlen, out);

     EVP_CIPHER_CTX_free(ctx);
     return 1;
 }
</pre></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><b>evp</b>(7) <p class=Pp>Supported ciphers are listed in:</p><p class=Pp><b>EVP_aes</b>(3), <b>EVP_aria</b>(3), <b>EVP_bf</b>(3), <b>EVP_camellia</b>(3), <b>EVP_cast5</b>(3), <b>EVP_chacha20</b>(3), <b>EVP_des</b>(3), <b>EVP_desx</b>(3), <b>EVP_idea</b>(3), <b>EVP_rc2</b>(3), <b>EVP_rc4</b>(3), <b>EVP_rc5</b>(3), <b>EVP_seed</b>(3), <b>EVP_sm4</b>(3)</p></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> Support for OCB mode was added in OpenSSL 1.1.0. <p class=Pp><b>EVP_CIPHER_CTX</b> was made opaque in OpenSSL 1.1.0. As a result, <b>EVP_CIPHER_CTX_reset()</b> appeared and <b>EVP_CIPHER_CTX_cleanup()</b> disappeared. <b>EVP_CIPHER_CTX_init()</b> remains as an alias for <b>EVP_CIPHER_CTX_reset()</b>.</p></section><section class=Sh><h2 class=Sh id=COPYRIGHT><a class=permalink href=#COPYRIGHT>COPYRIGHT</a></h2> Copyright 2000-2020 The OpenSSL Project Authors. All Rights Reserved. <p class=Pp>Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at &lt;https://www.openssl.org/source/license.html&gt;.</p></section></div><table class=foot><tr><td class=foot-date>2020-09-22</td><td class=foot-os>1.1.1h</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>