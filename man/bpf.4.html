<!DOCTYPE html>
<html><head><meta charset=utf-8><title>bpf(4)</title><keywords content=man,bpf></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>bpf(4)</h1><table class=head><tr><td class=head-ltitle>BPF(4)</td><td class=head-vol>FreeBSD Kernel Interfaces Manual</td><td class=head-rtitle>BPF(4)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>bpf</code> — <div class=Nd>Berkeley Packet Filter</div></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=Cd>device bpf</code></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> The Berkeley Packet Filter provides a raw interface to data link layers in a protocol independent fashion. All packets on the network, even those destined for other hosts, are accessible through this mechanism. <p class=Pp>The packet filter appears as a character special device, <span class=Pa>/dev/bpf</span>. After opening the device, the file descriptor must be bound to a specific network interface with the <code class=Dv>BIOCSETIF</code> ioctl. A given interface can be shared by multiple listeners, and the filter underlying each descriptor will see an identical packet stream.</p><p class=Pp>Associated with each open instance of a <code class=Nm>bpf</code> file is a user-settable packet filter. Whenever a packet is received by an interface, all file descriptors listening on that interface apply their filter. Each descriptor that accepts the packet receives its own copy.</p><p class=Pp>A packet can be sent out on the network by writing to a <code class=Nm>bpf</code> file descriptor. The writes are unbuffered, meaning only one packet can be processed per write. Currently, only writes to Ethernets and SLIP links are supported.</p></section><section class=Sh><h2 class=Sh id=BUFFER_MODES><a class=permalink href=#BUFFER_MODES>BUFFER MODES</a></h2><code class=Nm>bpf</code> devices deliver packet data to the application via memory buffers provided by the application. The buffer mode is set using the <code class=Dv>BIOCSETBUFMODE</code> ioctl, and read using the <code class=Dv>BIOCGETBUFMODE</code> ioctl. <section class=Ss><h2 class=Ss id=Buffered_read_mode><a class=permalink href=#Buffered_read_mode>Buffered read mode</a></h2> By default, <code class=Nm>bpf</code> devices operate in the <code class=Dv>BPF_BUFMODE_BUFFER</code> mode, in which packet data is copied explicitly from kernel to user memory using the <a class=Xr href=read.2.html>read(2)</a> system call. The user process will declare a fixed buffer size that will be used both for sizing internal buffers and for all <a class=Xr href=read.2.html>read(2)</a> operations on the file. This size is queried using the <code class=Dv>BIOCGBLEN</code> ioctl, and is set using the <code class=Dv>BIOCSBLEN</code> ioctl. Note that an individual packet larger than the buffer size is necessarily truncated. </section><section class=Ss><h2 class=Ss id=Zero_copy_buffer_mode><a class=permalink href=#Zero_copy_buffer_mode>Zero-copy buffer mode</a></h2><code class=Nm>bpf</code> devices may also operate in the <code class=Dv>BPF_BUFMODE_ZEROCOPY</code> mode, in which packet data is written directly into two user memory buffers by the kernel, avoiding both system call and copying overhead. Buffers are of fixed (and equal) size, page-aligned, and an even multiple of the page size. The maximum zero-copy buffer size is returned by the <code class=Dv>BIOCGETZMAX</code> ioctl. Note that an individual packet larger than the buffer size is necessarily truncated. <p class=Pp>The user process registers two memory buffers using the <code class=Dv>BIOCSETZBUF</code> ioctl, which accepts a <var class=Vt>struct bpf_zbuf</var> pointer as an argument:</p><div class="Bd Pp"><pre>
struct bpf_zbuf {
	void *bz_bufa;
	void *bz_bufb;
	size_t bz_buflen;
};
</pre></div><p class=Pp><var class=Vt>bz_bufa</var> is a pointer to the userspace address of the first buffer that will be filled, and <var class=Vt>bz_bufb</var> is a pointer to the second buffer. <code class=Nm>bpf</code> will then cycle between the two buffers as they fill and are acknowledged.</p><p class=Pp>Each buffer begins with a fixed-length header to hold synchronization and data length information for the buffer:</p><div class="Bd Pp"><pre>
struct bpf_zbuf_header {
	volatile u_int  bzh_kernel_gen;	/* Kernel generation number. */
	volatile u_int  bzh_kernel_len;	/* Length of data in the buffer. */
	volatile u_int  bzh_user_gen;	/* User generation number. */
	/* ...padding for future use... */
};
</pre></div><p class=Pp>The header structure of each buffer, including all padding, should be zeroed before it is configured using <code class=Dv>BIOCSETZBUF</code>. Remaining space in the buffer will be used by the kernel to store packet data, laid out in the same format as with buffered read mode.</p><p class=Pp>The kernel and the user process follow a simple acknowledgement protocol via the buffer header to synchronize access to the buffer: when the header generation numbers, <var class=Vt>bzh_kernel_gen</var> and <var class=Vt>bzh_user_gen</var>, hold the same value, the kernel owns the buffer, and when they differ, userspace owns the buffer.</p><p class=Pp>While the kernel owns the buffer, the contents are unstable and may change asynchronously; while the user process owns the buffer, its contents are stable and will not be changed until the buffer has been acknowledged.</p><p class=Pp>Initializing the buffer headers to all 0's before registering the buffer has the effect of assigning initial ownership of both buffers to the kernel. The kernel signals that a buffer has been assigned to userspace by modifying <var class=Vt>bzh_kernel_gen</var>, and userspace acknowledges the buffer and returns it to the kernel by setting the value of <var class=Vt>bzh_user_gen</var> to the value of <var class=Vt>bzh_kernel_gen</var>.</p><p class=Pp>In order to avoid caching and memory re-ordering effects, the user process must use atomic operations and memory barriers when checking for and acknowledging buffers:</p><div class="Bd Pp"><pre>
#include &lt;machine/atomic.h&gt;

/*
 * Return ownership of a buffer to the kernel for reuse.
 */
static void
buffer_acknowledge(struct bpf_zbuf_header *bzh)
{

	atomic_store_rel_int(&amp;bzh-&gt;bzh_user_gen, bzh-&gt;bzh_kernel_gen);
}

/*
 * Check whether a buffer has been assigned to userspace by the kernel.
 * Return true if userspace owns the buffer, and false otherwise.
 */
static int
buffer_check(struct bpf_zbuf_header *bzh)
{

	return (bzh-&gt;bzh_user_gen !=
	    atomic_load_acq_int(&amp;bzh-&gt;bzh_kernel_gen));
}
</pre></div><p class=Pp>The user process may force the assignment of the next buffer, if any data is pending, to userspace using the <code class=Dv>BIOCROTZBUF</code> ioctl. This allows the user process to retrieve data in a partially filled buffer before the buffer is full, such as following a timeout; the process must recheck for buffer ownership using the header generation numbers, as the buffer will not be assigned to userspace if no data was present.</p><p class=Pp>As in the buffered read mode, <a class=Xr href=kqueue.2.html>kqueue(2)</a>, <a class=Xr href=poll.2.html>poll(2)</a>, and <a class=Xr href=select.2.html>select(2)</a> may be used to sleep awaiting the availability of a completed buffer. They will return a readable file descriptor when ownership of the next buffer is assigned to user space.</p><p class=Pp>In the current implementation, the kernel may assign zero, one, or both buffers to the user process; however, an earlier implementation maintained the invariant that at most one buffer could be assigned to the user process at a time. In order to both ensure progress and high performance, user processes should acknowledge a completely processed buffer as quickly as possible, returning it for reuse, and not block waiting on a second buffer while holding another buffer.</p></section></section><section class=Sh><h2 class=Sh id=IOCTLS><a class=permalink href=#IOCTLS>IOCTLS</a></h2> The <a class=Xr href=ioctl.2.html>ioctl(2)</a> command codes below are defined in <code class=In>&lt;<a class=In href=../src/net/bpf.h.html>net/bpf.h</a>&gt;</code>. All commands require these includes: <div class="Bd Pp"><pre>
	#include &lt;sys/types.h&gt;
	#include &lt;sys/time.h&gt;
	#include &lt;sys/ioctl.h&gt;
	#include &lt;net/bpf.h&gt;
</pre></div><p class=Pp>Additionally, <code class=Dv>BIOCGETIF</code> and <code class=Dv>BIOCSETIF</code> require <code class=In>&lt;<a class=In href=../src/sys/socket.h.html>sys/socket.h</a>&gt;</code> and <code class=In>&lt;<a class=In href=../src/net/if.h.html>net/if.h</a>&gt;</code>.</p><p class=Pp>In addition to <code class=Dv>FIONREAD</code> the following commands may be applied to any open <code class=Nm>bpf</code> file. The (third) argument to <a class=Xr href=ioctl.2.html>ioctl(2)</a> should be a pointer to the type indicated.</p><dl class=Bl-tag><dt><a class=permalink href=#BIOCGBLEN><code class=Dv id=BIOCGBLEN>BIOCGBLEN</code></a></dt><dd>(<code class=Li>u_int</code>) Returns the required buffer length for reads on <code class=Nm>bpf</code> files.</dd><dt><a class=permalink href=#BIOCSBLEN><code class=Dv id=BIOCSBLEN>BIOCSBLEN</code></a></dt><dd>(<code class=Li>u_int</code>) Sets the buffer length for reads on <code class=Nm>bpf</code> files. The buffer must be set before the file is attached to an interface with <code class=Dv>BIOCSETIF</code>. If the requested buffer size cannot be accommodated, the closest allowable size will be set and returned in the argument. A read call will result in <code class=Er>EINVAL</code> if it is passed a buffer that is not this size.</dd><dt><a class=permalink href=#BIOCGDLT><code class=Dv id=BIOCGDLT>BIOCGDLT</code></a></dt><dd>(<code class=Li>u_int</code>) Returns the type of the data link layer underlying the attached interface. <code class=Er>EINVAL</code> is returned if no interface has been specified. The device types, prefixed with “<code class=Li>DLT_</code>”, are defined in <code class=In>&lt;<a class=In href=../src/net/bpf.h.html>net/bpf.h</a>&gt;</code>.</dd><dt><a class=permalink href=#BIOCGDLTLIST><code class=Dv id=BIOCGDLTLIST>BIOCGDLTLIST</code></a></dt><dd>(<code class=Li>struct bpf_dltlist</code>) Returns an array of the available types of the data link layer underlying the attached interface: <div class="Bd Pp Bd-indent"><pre>
struct bpf_dltlist {
	u_int bfl_len;
	u_int *bfl_list;
};
    </pre></div><p class=Pp>The available types are returned in the array pointed to by the <var class=Va>bfl_list</var> field while their length in u_int is supplied to the <var class=Va>bfl_len</var> field. <code class=Er>ENOMEM</code> is returned if there is not enough buffer space and <code class=Er>EFAULT</code> is returned if a bad address is encountered. The <var class=Va>bfl_len</var> field is modified on return to indicate the actual length in u_int of the array returned. If <var class=Va>bfl_list</var> is <code class=Dv>NULL</code>, the <var class=Va>bfl_len</var> field is set to indicate the required length of an array in u_int.</p></dd><dt><a class=permalink href=#BIOCSDLT><code class=Dv id=BIOCSDLT>BIOCSDLT</code></a></dt><dd>(<code class=Li>u_int</code>) Changes the type of the data link layer underlying the attached interface. <code class=Er>EINVAL</code> is returned if no interface has been specified or the specified type is not available for the interface.</dd><dt><a class=permalink href=#BIOCPROMISC><code class=Dv id=BIOCPROMISC>BIOCPROMISC</code></a></dt><dd>Forces the interface into promiscuous mode. All packets, not just those destined for the local host, are processed. Since more than one file can be listening on a given interface, a listener that opened its interface non-promiscuously may receive packets promiscuously. This problem can be remedied with an appropriate filter. <p class=Pp>The interface remains in promiscuous mode until all files listening promiscuously are closed.</p></dd><dt><a class=permalink href=#BIOCFLUSH><code class=Dv id=BIOCFLUSH>BIOCFLUSH</code></a></dt><dd>Flushes the buffer of incoming packets, and resets the statistics that are returned by BIOCGSTATS.</dd><dt><a class=permalink href=#BIOCGETIF><code class=Dv id=BIOCGETIF>BIOCGETIF</code></a></dt><dd>(<code class=Li>struct ifreq</code>) Returns the name of the hardware interface that the file is listening on. The name is returned in the ifr_name field of the <code class=Li>ifreq</code> structure. All other fields are undefined.</dd><dt><a class=permalink href=#BIOCSETIF><code class=Dv id=BIOCSETIF>BIOCSETIF</code></a></dt><dd>(<code class=Li>struct ifreq</code>) Sets the hardware interface associated with the file. This command must be performed before any packets can be read. The device is indicated by name using the <code class=Li>ifr_name</code> field of the <code class=Li>ifreq</code> structure. Additionally, performs the actions of <code class=Dv>BIOCFLUSH</code>.</dd><dt><a class=permalink href=#BIOCSRTIMEOUT><code class=Dv id=BIOCSRTIMEOUT>BIOCSRTIMEOUT</code></a></dt><dd style="width: auto;"> </dd><dt><a class=permalink href=#BIOCGRTIMEOUT><code class=Dv id=BIOCGRTIMEOUT>BIOCGRTIMEOUT</code></a></dt><dd>(<code class=Li>struct timeval</code>) Sets or gets the read timeout parameter. The argument specifies the length of time to wait before timing out on a read request. This parameter is initialized to zero by <a class=Xr href=open.2.html>open(2)</a>, indicating no timeout.</dd><dt><a class=permalink href=#BIOCGSTATS><code class=Dv id=BIOCGSTATS>BIOCGSTATS</code></a></dt><dd>(<code class=Li>struct bpf_stat</code>) Returns the following structure of packet statistics: <div class="Bd Pp"><pre>
struct bpf_stat {
	u_int bs_recv;    /* number of packets received */
	u_int bs_drop;    /* number of packets dropped */
};
    </pre></div><p class=Pp>The fields are:</p><dl class="Bl-hang Bd-indent"><dt><a class=permalink href=#bs_recv><code class=Li id=bs_recv>bs_recv</code></a></dt><dd>the number of packets received by the descriptor since opened or reset (including any buffered since the last read call); and</dd><dt><a class=permalink href=#bs_drop><code class=Li id=bs_drop>bs_drop</code></a></dt><dd>the number of packets which were accepted by the filter but dropped by the kernel because of buffer overflows (i.e., the application's reads are not keeping up with the packet traffic).</dd></dl></dd><dt><a class=permalink href=#BIOCIMMEDIATE><code class=Dv id=BIOCIMMEDIATE>BIOCIMMEDIATE</code></a></dt><dd>(<code class=Li>u_int</code>) Enables or disables “immediate mode”, based on the truth value of the argument. When immediate mode is enabled, reads return immediately upon packet reception. Otherwise, a read will block until either the kernel buffer becomes full or a timeout occurs. This is useful for programs like <a class=Xr href=rarpd.8.html>rarpd(8)</a> which must respond to messages in real time. The default for a new file is off.</dd><dt><a class=permalink href=#BIOCSETF><code class=Dv id=BIOCSETF>BIOCSETF</code></a></dt><dd style="width: auto;"> </dd><dt><a class=permalink href=#BIOCSETFNR><code class=Dv id=BIOCSETFNR>BIOCSETFNR</code></a></dt><dd>(<code class=Li>struct bpf_program</code>) Sets the read filter program used by the kernel to discard uninteresting packets. An array of instructions and its length is passed in using the following structure: <div class="Bd Pp"><pre>
struct bpf_program {
	u_int bf_len;
	struct bpf_insn *bf_insns;
};
    </pre></div><p class=Pp>The filter program is pointed to by the <code class=Li>bf_insns</code> field while its length in units of ‘<code class=Li>struct bpf_insn</code>’ is given by the <code class=Li>bf_len</code> field. See section <a class=Sx href=#FILTER_MACHINE>FILTER MACHINE</a> for an explanation of the filter language. The only difference between <code class=Dv>BIOCSETF</code> and <code class=Dv>BIOCSETFNR</code> is <code class=Dv>BIOCSETF</code> performs the actions of <code class=Dv>BIOCFLUSH</code> while <code class=Dv>BIOCSETFNR</code> does not.</p></dd><dt><a class=permalink href=#BIOCSETWF><code class=Dv id=BIOCSETWF>BIOCSETWF</code></a></dt><dd>(<code class=Li>struct bpf_program</code>) Sets the write filter program used by the kernel to control what type of packets can be written to the interface. See the <code class=Dv>BIOCSETF</code> command for more information on the <code class=Nm>bpf</code> filter program.</dd><dt><a class=permalink href=#BIOCVERSION><code class=Dv id=BIOCVERSION>BIOCVERSION</code></a></dt><dd>(<code class=Li>struct bpf_version</code>) Returns the major and minor version numbers of the filter language currently recognized by the kernel. Before installing a filter, applications must check that the current version is compatible with the running kernel. Version numbers are compatible if the major numbers match and the application minor is less than or equal to the kernel minor. The kernel version number is returned in the following structure: <div class="Bd Pp"><pre>
struct bpf_version {
        u_short bv_major;
        u_short bv_minor;
};
    </pre></div><p class=Pp>The current version numbers are given by <code class=Dv>BPF_MAJOR_VERSION</code> and <code class=Dv>BPF_MINOR_VERSION</code> from <code class=In>&lt;<a class=In href=../src/net/bpf.h.html>net/bpf.h</a>&gt;</code>. An incompatible filter may result in undefined behavior (most likely, an error returned by <code class=Fn>ioctl</code>() or haphazard packet matching).</p></dd><dt><a class=permalink href=#BIOCGRSIG><code class=Dv id=BIOCGRSIG>BIOCGRSIG</code></a></dt><dd style="width: auto;"> </dd><dt><a class=permalink href=#BIOCSRSIG><code class=Dv id=BIOCSRSIG>BIOCSRSIG</code></a></dt><dd>(<code class=Li>u_int</code>) Sets or gets the receive signal. This signal will be sent to the process or process group specified by <code class=Dv>FIOSETOWN</code>. It defaults to <code class=Dv>SIGIO</code>.</dd><dt><a class=permalink href=#BIOCSHDRCMPLT><code class=Dv id=BIOCSHDRCMPLT>BIOCSHDRCMPLT</code></a></dt><dd style="width: auto;"> </dd><dt><a class=permalink href=#BIOCGHDRCMPLT><code class=Dv id=BIOCGHDRCMPLT>BIOCGHDRCMPLT</code></a></dt><dd>(<code class=Li>u_int</code>) Sets or gets the status of the “header complete” flag. Set to zero if the link level source address should be filled in automatically by the interface output routine. Set to one if the link level source address will be written, as provided, to the wire. This flag is initialized to zero by default.</dd><dt><a class=permalink href=#BIOCSSEESENT><code class=Dv id=BIOCSSEESENT>BIOCSSEESENT</code></a></dt><dd style="width: auto;"> </dd><dt><a class=permalink href=#BIOCGSEESENT><code class=Dv id=BIOCGSEESENT>BIOCGSEESENT</code></a></dt><dd>(<code class=Li>u_int</code>) These commands are obsolete but left for compatibility. Use <code class=Dv>BIOCSDIRECTION</code> and <code class=Dv>BIOCGDIRECTION</code> instead. Sets or gets the flag determining whether locally generated packets on the interface should be returned by BPF. Set to zero to see only incoming packets on the interface. Set to one to see packets originating locally and remotely on the interface. This flag is initialized to one by default.</dd><dt><a class=permalink href=#BIOCSDIRECTION><code class=Dv id=BIOCSDIRECTION>BIOCSDIRECTION</code></a></dt><dd style="width: auto;"> </dd><dt><a class=permalink href=#BIOCGDIRECTION><code class=Dv id=BIOCGDIRECTION>BIOCGDIRECTION</code></a></dt><dd>(<code class=Li>u_int</code>) Sets or gets the setting determining whether incoming, outgoing, or all packets on the interface should be returned by BPF. Set to <code class=Dv>BPF_D_IN</code> to see only incoming packets on the interface. Set to <code class=Dv>BPF_D_INOUT</code> to see packets originating locally and remotely on the interface. Set to <code class=Dv>BPF_D_OUT</code> to see only outgoing packets on the interface. This setting is initialized to <code class=Dv>BPF_D_INOUT</code> by default.</dd><dt><a class=permalink href=#BIOCSTSTAMP><code class=Dv id=BIOCSTSTAMP>BIOCSTSTAMP</code></a></dt><dd style="width: auto;"> </dd><dt><a class=permalink href=#BIOCGTSTAMP><code class=Dv id=BIOCGTSTAMP>BIOCGTSTAMP</code></a></dt><dd>(<code class=Li>u_int</code>) Set or get format and resolution of the time stamps returned by BPF. Set to <code class=Dv>BPF_T_MICROTIME</code>, <code class=Dv>BPF_T_MICROTIME_FAST</code>, <code class=Dv>BPF_T_MICROTIME_MONOTONIC</code>, or <code class=Dv>BPF_T_MICROTIME_MONOTONIC_FAST</code> to get time stamps in 64-bit <var class=Vt>struct timeval</var> format. Set to <code class=Dv>BPF_T_NANOTIME</code>, <code class=Dv>BPF_T_NANOTIME_FAST</code>, <code class=Dv>BPF_T_NANOTIME_MONOTONIC</code>, or <code class=Dv>BPF_T_NANOTIME_MONOTONIC_FAST</code> to get time stamps in 64-bit <var class=Vt>struct timespec</var> format. Set to <code class=Dv>BPF_T_BINTIME</code>, <code class=Dv>BPF_T_BINTIME_FAST</code>, <code class=Dv>BPF_T_NANOTIME_MONOTONIC</code>, or <code class=Dv>BPF_T_BINTIME_MONOTONIC_FAST</code> to get time stamps in 64-bit <var class=Vt>struct bintime</var> format. Set to <code class=Dv>BPF_T_NONE</code> to ignore time stamp. All 64-bit time stamp formats are wrapped in <var class=Vt>struct bpf_ts</var>. The <code class=Dv>BPF_T_MICROTIME_FAST</code>, <code class=Dv>BPF_T_NANOTIME_FAST</code>, <code class=Dv>BPF_T_BINTIME_FAST</code>, <code class=Dv>BPF_T_MICROTIME_MONOTONIC_FAST</code>, <code class=Dv>BPF_T_NANOTIME_MONOTONIC_FAST</code>, and <code class=Dv>BPF_T_BINTIME_MONOTONIC_FAST</code> are analogs of corresponding formats without _FAST suffix but do not perform a full time counter query, so their accuracy is one timer tick. The <code class=Dv>BPF_T_MICROTIME_MONOTONIC</code>, <code class=Dv>BPF_T_NANOTIME_MONOTONIC</code>, <code class=Dv>BPF_T_BINTIME_MONOTONIC</code>, <code class=Dv>BPF_T_MICROTIME_MONOTONIC_FAST</code>, <code class=Dv>BPF_T_NANOTIME_MONOTONIC_FAST</code>, and <code class=Dv>BPF_T_BINTIME_MONOTONIC_FAST</code> store the time elapsed since kernel boot. This setting is initialized to <code class=Dv>BPF_T_MICROTIME</code> by default.</dd><dt><a class=permalink href=#BIOCFEEDBACK><code class=Dv id=BIOCFEEDBACK>BIOCFEEDBACK</code></a></dt><dd>(<code class=Li>u_int</code>) Set packet feedback mode. This allows injected packets to be fed back as input to the interface when output via the interface is successful. When <code class=Dv>BPF_D_INOUT</code> direction is set, injected outgoing packet is not returned by BPF to avoid duplication. This flag is initialized to zero by default.</dd><dt><a class=permalink href=#BIOCLOCK><code class=Dv id=BIOCLOCK>BIOCLOCK</code></a></dt><dd>Set the locked flag on the <code class=Nm>bpf</code> descriptor. This prevents the execution of ioctl commands which could change the underlying operating parameters of the device.</dd><dt><a class=permalink href=#BIOCGETBUFMODE><code class=Dv id=BIOCGETBUFMODE>BIOCGETBUFMODE</code></a></dt><dd style="width: auto;"> </dd><dt><a class=permalink href=#BIOCSETBUFMODE><code class=Dv id=BIOCSETBUFMODE>BIOCSETBUFMODE</code></a></dt><dd>(<code class=Li>u_int</code>) Get or set the current <code class=Nm>bpf</code> buffering mode; possible values are <code class=Dv>BPF_BUFMODE_BUFFER</code>, buffered read mode, and <code class=Dv>BPF_BUFMODE_ZBUF</code>, zero-copy buffer mode.</dd><dt><a class=permalink href=#BIOCSETZBUF><code class=Dv id=BIOCSETZBUF>BIOCSETZBUF</code></a></dt><dd>(<code class=Li>struct bpf_zbuf</code>) Set the current zero-copy buffer locations; buffer locations may be set only once zero-copy buffer mode has been selected, and prior to attaching to an interface. Buffers must be of identical size, page-aligned, and an integer multiple of pages in size. The three fields <var class=Vt>bz_bufa</var>, <var class=Vt>bz_bufb</var>, and <var class=Vt>bz_buflen</var> must be filled out. If buffers have already been set for this device, the ioctl will fail.</dd><dt><a class=permalink href=#BIOCGETZMAX><code class=Dv id=BIOCGETZMAX>BIOCGETZMAX</code></a></dt><dd>(<code class=Li>size_t</code>) Get the largest individual zero-copy buffer size allowed. As two buffers are used in zero-copy buffer mode, the limit (in practice) is twice the returned size. As zero-copy buffers consume kernel address space, conservative selection of buffer size is suggested, especially when there are multiple <code class=Nm>bpf</code> descriptors in use on 32-bit systems.</dd><dt><a class=permalink href=#BIOCROTZBUF><code class=Dv id=BIOCROTZBUF>BIOCROTZBUF</code></a></dt><dd>Force ownership of the next buffer to be assigned to userspace, if any data present in the buffer. If no data is present, the buffer will remain owned by the kernel. This allows consumers of zero-copy buffering to implement timeouts and retrieve partially filled buffers. In order to handle the case where no data is present in the buffer and therefore ownership is not assigned, the user process must check <var class=Vt>bzh_kernel_gen</var> against <var class=Vt>bzh_user_gen</var>.</dd><dt><a class=permalink href=#BIOCSETVLANPCP><code class=Dv id=BIOCSETVLANPCP>BIOCSETVLANPCP</code></a></dt><dd>Set the VLAN PCP bits to the supplied value.</dd></dl></section><section class=Sh><h2 class=Sh id=STANDARD_IOCTLS><a class=permalink href=#STANDARD_IOCTLS>STANDARD IOCTLS</a></h2><code class=Nm>bpf</code> now supports several standard <a class=Xr href=ioctl.2.html>ioctl(2)</a>'s which allow the user to do async and/or non-blocking I/O to an open file descriptor. <dl class=Bl-tag><dt><a class=permalink href=#FIONREAD><code class=Dv id=FIONREAD>FIONREAD</code></a></dt><dd>(<code class=Li>int</code>) Returns the number of bytes that are immediately available for reading.</dd><dt><a class=permalink href=#SIOCGIFADDR><code class=Dv id=SIOCGIFADDR>SIOCGIFADDR</code></a></dt><dd>(<code class=Li>struct ifreq</code>) Returns the address associated with the interface.</dd><dt><a class=permalink href=#FIONBIO><code class=Dv id=FIONBIO>FIONBIO</code></a></dt><dd>(<code class=Li>int</code>) Sets or clears non-blocking I/O. If arg is non-zero, then doing a <a class=Xr href=read.2.html>read(2)</a> when no data is available will return -1 and <var class=Va>errno</var> will be set to <code class=Er>EAGAIN</code>. If arg is zero, non-blocking I/O is disabled. Note: setting this overrides the timeout set by <code class=Dv>BIOCSRTIMEOUT</code>.</dd><dt><a class=permalink href=#FIOASYNC><code class=Dv id=FIOASYNC>FIOASYNC</code></a></dt><dd>(<code class=Li>int</code>) Enables or disables async I/O. When enabled (arg is non-zero), the process or process group specified by <code class=Dv>FIOSETOWN</code> will start receiving <code class=Dv>SIGIO 's</code> when packets arrive. Note that you must do an <code class=Dv>FIOSETOWN</code> in order for this to take effect, as the system will not default this for you. The signal may be changed via <code class=Dv>BIOCSRSIG</code>.</dd><dt><a class=permalink href=#FIOSETOWN><code class=Dv id=FIOSETOWN>FIOSETOWN</code></a></dt><dd style="width: auto;"> </dd><dt><a class=permalink href=#FIOGETOWN><code class=Dv id=FIOGETOWN>FIOGETOWN</code></a></dt><dd>(<code class=Li>int</code>) Sets or gets the process or process group (if negative) that should receive <code class=Dv>SIGIO</code> when packets are available. The signal may be changed using <code class=Dv>BIOCSRSIG</code> (see above).</dd></dl></section><section class=Sh><h2 class=Sh id=BPF_HEADER><a class=permalink href=#BPF_HEADER>BPF HEADER</a></h2> One of the following structures is prepended to each packet returned by <a class=Xr href=read.2.html>read(2)</a> or via a zero-copy buffer: <div class="Bd Pp"><pre>
struct bpf_xhdr {
	struct bpf_ts	bh_tstamp;     /* time stamp */
	uint32_t	bh_caplen;     /* length of captured portion */
	uint32_t	bh_datalen;    /* original length of packet */
	u_short		bh_hdrlen;     /* length of bpf header (this struct
					  plus alignment padding) */
};

struct bpf_hdr {
	struct timeval	bh_tstamp;     /* time stamp */
	uint32_t	bh_caplen;     /* length of captured portion */
	uint32_t	bh_datalen;    /* original length of packet */
	u_short		bh_hdrlen;     /* length of bpf header (this struct
					  plus alignment padding) */
};
</pre></div><p class=Pp>The fields, whose values are stored in host order, and are:</p><p class=Pp></p><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#bh_tstamp><code class=Li id=bh_tstamp>bh_tstamp</code></a></dt><dd>The time at which the packet was processed by the packet filter.</dd><dt><a class=permalink href=#bh_caplen><code class=Li id=bh_caplen>bh_caplen</code></a></dt><dd>The length of the captured portion of the packet. This is the minimum of the truncation amount specified by the filter and the length of the packet.</dd><dt><a class=permalink href=#bh_datalen><code class=Li id=bh_datalen>bh_datalen</code></a></dt><dd>The length of the packet off the wire. This value is independent of the truncation amount specified by the filter.</dd><dt><a class=permalink href=#bh_hdrlen><code class=Li id=bh_hdrlen>bh_hdrlen</code></a></dt><dd>The length of the <code class=Nm>bpf</code> header, which may not be equal to <code class=Fn>sizeof</code>(<var class=Fa>struct bpf_xhdr</var>) or <code class=Fn>sizeof</code>(<var class=Fa>struct bpf_hdr</var>).</dd></dl><p class=Pp>The <code class=Li>bh_hdrlen</code> field exists to account for padding between the header and the link level protocol. The purpose here is to guarantee proper alignment of the packet data structures, which is required on alignment sensitive architectures and improves performance on many other architectures. The packet filter ensures that the <var class=Vt>bpf_xhdr</var>, <var class=Vt>bpf_hdr</var> and the network layer header will be word aligned. Currently, <var class=Vt>bpf_hdr</var> is used when the time stamp is set to <code class=Dv>BPF_T_MICROTIME</code>, <code class=Dv>BPF_T_MICROTIME_FAST</code>, <code class=Dv>BPF_T_MICROTIME_MONOTONIC</code>, <code class=Dv>BPF_T_MICROTIME_MONOTONIC_FAST</code>, or <code class=Dv>BPF_T_NONE</code> for backward compatibility reasons. Otherwise, <var class=Vt>bpf_xhdr</var> is used. However, <var class=Vt>bpf_hdr</var> may be deprecated in the near future. Suitable precautions must be taken when accessing the link layer protocol fields on alignment restricted machines. (This is not a problem on an Ethernet, since the type field is a short falling on an even offset, and the addresses are probably accessed in a bytewise fashion).</p><p class=Pp>Additionally, individual packets are padded so that each starts on a word boundary. This requires that an application has some knowledge of how to get from packet to packet. The macro <code class=Dv>BPF_WORDALIGN</code> is defined in <code class=In>&lt;<a class=In href=../src/net/bpf.h.html>net/bpf.h</a>&gt;</code> to facilitate this process. It rounds up its argument to the nearest word aligned value (where a word is <code class=Dv>BPF_ALIGNMENT</code> bytes wide).</p><p class=Pp>For example, if ‘<code class=Li>p</code>’ points to the start of a packet, this expression will advance it to the next packet:</p><div class="Bd Bd-indent"><code class=Li>p = (char *)p + BPF_WORDALIGN(p-&gt;bh_hdrlen + p-&gt;bh_caplen)</code></div><p class=Pp>For the alignment mechanisms to work properly, the buffer passed to <a class=Xr href=read.2.html>read(2)</a> must itself be word aligned. The <a class=Xr href=malloc.3.html>malloc(3)</a> function will always return an aligned buffer.</p></section><section class=Sh><h2 class=Sh id=FILTER_MACHINE><a class=permalink href=#FILTER_MACHINE>FILTER MACHINE</a></h2> A filter program is an array of instructions, with all branches forwardly directed, terminated by a <i class=Em>return</i> instruction. Each instruction performs some action on the pseudo-machine state, which consists of an accumulator, index register, scratch memory store, and implicit program counter. <p class=Pp>The following structure defines the instruction format:</p><div class="Bd Pp"><pre>
struct bpf_insn {
	u_short     code;
	u_char      jt;
	u_char      jf;
	bpf_u_int32 k;
};
</pre></div><p class=Pp>The <code class=Li>k</code> field is used in different ways by different instructions, and the <code class=Li>jt</code> and <code class=Li>jf</code> fields are used as offsets by the branch instructions. The opcodes are encoded in a semi-hierarchical fashion. There are eight classes of instructions: <code class=Dv>BPF_LD</code>, <code class=Dv>BPF_LDX</code>, <code class=Dv>BPF_ST</code>, <code class=Dv>BPF_STX</code>, <code class=Dv>BPF_ALU</code>, <code class=Dv>BPF_JMP</code>, <code class=Dv>BPF_RET</code>, and <code class=Dv>BPF_MISC</code>. Various other mode and operator bits are or'd into the class to give the actual instructions. The classes and modes are defined in <code class=In>&lt;<a class=In href=../src/net/bpf.h.html>net/bpf.h</a>&gt;</code>.</p><p class=Pp>Below are the semantics for each defined <code class=Nm>bpf</code> instruction. We use the convention that A is the accumulator, X is the index register, P[] packet data, and M[] scratch memory store. P[i:n] gives the data at byte offset “i” in the packet, interpreted as a word (n=4), unsigned halfword (n=2), or unsigned byte (n=1). M[i] gives the i'th word in the scratch memory store, which is only addressed in word units. The memory store is indexed from 0 to <code class=Dv>BPF_MEMWORDS</code> - 1. <code class=Li>k</code>, <code class=Li>jt</code>, and <code class=Li>jf</code> are the corresponding fields in the instruction definition. “len” refers to the length of the packet.</p><dl class=Bl-tag><dt><a class=permalink href=#BPF_LD><code class=Dv id=BPF_LD>BPF_LD</code></a></dt><dd>These instructions copy a value into the accumulator. The type of the source operand is specified by an “addressing mode” and can be a constant (<code class=Dv>BPF_IMM</code>), packet data at a fixed offset (<code class=Dv>BPF_ABS</code>), packet data at a variable offset (<code class=Dv>BPF_IND</code>), the packet length (<code class=Dv>BPF_LEN</code>), or a word in the scratch memory store (<code class=Dv>BPF_MEM</code>). For <code class=Dv>BPF_IND</code> and <code class=Dv>BPF_ABS</code>, the data size must be specified as a word (<code class=Dv>BPF_W</code>), halfword (<code class=Dv>BPF_H</code>), or byte (<code class=Dv>BPF_B</code>). The semantics of all the recognized <code class=Dv>BPF_LD</code> instructions follow. <div class="Bd Pp"><pre>
BPF_LD+BPF_W+BPF_ABS	A &lt;- P[k:4]
BPF_LD+BPF_H+BPF_ABS	A &lt;- P[k:2]
BPF_LD+BPF_B+BPF_ABS	A &lt;- P[k:1]
BPF_LD+BPF_W+BPF_IND	A &lt;- P[X+k:4]
BPF_LD+BPF_H+BPF_IND	A &lt;- P[X+k:2]
BPF_LD+BPF_B+BPF_IND	A &lt;- P[X+k:1]
BPF_LD+BPF_W+BPF_LEN	A &lt;- len
BPF_LD+BPF_IMM		A &lt;- k
BPF_LD+BPF_MEM		A &lt;- M[k]
    </pre></div></dd><dt><a class=permalink href=#BPF_LDX><code class=Dv id=BPF_LDX>BPF_LDX</code></a></dt><dd>These instructions load a value into the index register. Note that the addressing modes are more restrictive than those of the accumulator loads, but they include <code class=Dv>BPF_MSH</code>, a hack for efficiently loading the IP header length. <div class="Bd Pp"><pre>
BPF_LDX+BPF_W+BPF_IMM	X &lt;- k
BPF_LDX+BPF_W+BPF_MEM	X &lt;- M[k]
BPF_LDX+BPF_W+BPF_LEN	X &lt;- len
BPF_LDX+BPF_B+BPF_MSH	X &lt;- 4*(P[k:1]&amp;0xf)
    </pre></div></dd><dt><a class=permalink href=#BPF_ST><code class=Dv id=BPF_ST>BPF_ST</code></a></dt><dd>This instruction stores the accumulator into the scratch memory. We do not need an addressing mode since there is only one possibility for the destination. <div class="Bd Pp"><pre>
BPF_ST			M[k] &lt;- A
    </pre></div></dd><dt><a class=permalink href=#BPF_STX><code class=Dv id=BPF_STX>BPF_STX</code></a></dt><dd>This instruction stores the index register in the scratch memory store. <div class="Bd Pp"><pre>
BPF_STX			M[k] &lt;- X
    </pre></div></dd><dt><a class=permalink href=#BPF_ALU><code class=Dv id=BPF_ALU>BPF_ALU</code></a></dt><dd>The alu instructions perform operations between the accumulator and index register or constant, and store the result back in the accumulator. For binary operations, a source mode is required (<code class=Dv>BPF_K</code> or <code class=Dv>BPF_X</code>). <div class="Bd Pp"><pre>
BPF_ALU+BPF_ADD+BPF_K	A &lt;- A + k
BPF_ALU+BPF_SUB+BPF_K	A &lt;- A - k
BPF_ALU+BPF_MUL+BPF_K	A &lt;- A * k
BPF_ALU+BPF_DIV+BPF_K	A &lt;- A / k
BPF_ALU+BPF_MOD+BPF_K	A &lt;- A % k
BPF_ALU+BPF_AND+BPF_K	A &lt;- A &amp; k
BPF_ALU+BPF_OR+BPF_K	A &lt;- A | k
BPF_ALU+BPF_XOR+BPF_K	A &lt;- A ^ k
BPF_ALU+BPF_LSH+BPF_K	A &lt;- A &lt;&lt; k
BPF_ALU+BPF_RSH+BPF_K	A &lt;- A &gt;&gt; k
BPF_ALU+BPF_ADD+BPF_X	A &lt;- A + X
BPF_ALU+BPF_SUB+BPF_X	A &lt;- A - X
BPF_ALU+BPF_MUL+BPF_X	A &lt;- A * X
BPF_ALU+BPF_DIV+BPF_X	A &lt;- A / X
BPF_ALU+BPF_MOD+BPF_X	A &lt;- A % X
BPF_ALU+BPF_AND+BPF_X	A &lt;- A &amp; X
BPF_ALU+BPF_OR+BPF_X	A &lt;- A | X
BPF_ALU+BPF_XOR+BPF_X	A &lt;- A ^ X
BPF_ALU+BPF_LSH+BPF_X	A &lt;- A &lt;&lt; X
BPF_ALU+BPF_RSH+BPF_X	A &lt;- A &gt;&gt; X
BPF_ALU+BPF_NEG		A &lt;- -A
    </pre></div></dd><dt><a class=permalink href=#BPF_JMP><code class=Dv id=BPF_JMP>BPF_JMP</code></a></dt><dd>The jump instructions alter flow of control. Conditional jumps compare the accumulator against a constant (<code class=Dv>BPF_K</code>) or the index register (<code class=Dv>BPF_X</code>). If the result is true (or non-zero), the true branch is taken, otherwise the false branch is taken. Jump offsets are encoded in 8 bits so the longest jump is 256 instructions. However, the jump always (<code class=Dv>BPF_JA</code>) opcode uses the 32 bit <code class=Li>k</code> field as the offset, allowing arbitrarily distant destinations. All conditionals use unsigned comparison conventions. <div class="Bd Pp"><pre>
BPF_JMP+BPF_JA		pc += k
BPF_JMP+BPF_JGT+BPF_K	pc += (A &gt; k) ? jt : jf
BPF_JMP+BPF_JGE+BPF_K	pc += (A &gt;= k) ? jt : jf
BPF_JMP+BPF_JEQ+BPF_K	pc += (A == k) ? jt : jf
BPF_JMP+BPF_JSET+BPF_K	pc += (A &amp; k) ? jt : jf
BPF_JMP+BPF_JGT+BPF_X	pc += (A &gt; X) ? jt : jf
BPF_JMP+BPF_JGE+BPF_X	pc += (A &gt;= X) ? jt : jf
BPF_JMP+BPF_JEQ+BPF_X	pc += (A == X) ? jt : jf
BPF_JMP+BPF_JSET+BPF_X	pc += (A &amp; X) ? jt : jf
    </pre></div></dd><dt><a class=permalink href=#BPF_RET><code class=Dv id=BPF_RET>BPF_RET</code></a></dt><dd>The return instructions terminate the filter program and specify the amount of packet to accept (i.e., they return the truncation amount). A return value of zero indicates that the packet should be ignored. The return value is either a constant (<code class=Dv>BPF_K</code>) or the accumulator (<code class=Dv>BPF_A</code>). <div class="Bd Pp"><pre>
BPF_RET+BPF_A		accept A bytes
BPF_RET+BPF_K		accept k bytes
    </pre></div></dd><dt><a class=permalink href=#BPF_MISC><code class=Dv id=BPF_MISC>BPF_MISC</code></a></dt><dd>The miscellaneous category was created for anything that does not fit into the above classes, and for any new instructions that might need to be added. Currently, these are the register transfer instructions that copy the index register to the accumulator or vice versa. <div class="Bd Pp"><pre>
BPF_MISC+BPF_TAX	X &lt;- A
BPF_MISC+BPF_TXA	A &lt;- X
    </pre></div></dd></dl><p class=Pp>The <code class=Nm>bpf</code> interface provides the following macros to facilitate array initializers: <code class=Fn>BPF_STMT</code>(<var class=Fa>opcode</var>, <var class=Fa>operand</var>) and <code class=Fn>BPF_JUMP</code>(<var class=Fa>opcode</var>, <var class=Fa>operand</var>, <var class=Fa>true_offset</var>, <var class=Fa>false_offset</var>).</p></section><section class=Sh><h2 class=Sh id=SYSCTL_VARIABLES><a class=permalink href=#SYSCTL_VARIABLES>SYSCTL VARIABLES</a></h2> A set of <a class=Xr href=sysctl.8.html>sysctl(8)</a> variables controls the behaviour of the <code class=Nm>bpf</code> subsystem <dl class=Bl-tag><dt><var class=Va>net.bpf.optimize_writers</var>: <span class=No>0</span></dt><dd>Various programs use BPF to send (but not receive) raw packets (cdpd, lldpd, dhcpd, dhcp relays, etc. are good examples of such programs). They do not need incoming packets to be send to them. Turning this option on makes new BPF users to be attached to write-only interface list until program explicitly specifies read filter via <code class=Fn>pcap_set_filter</code>(). This removes any performance degradation for high-speed interfaces.</dd><dt><var class=Va>net.bpf.stats</var>:</dt><dd>Binary interface for retrieving general statistics.</dd><dt><var class=Va>net.bpf.zerocopy_enable</var>: <span class=No>0</span></dt><dd>Permits zero-copy to be used with net BPF readers. Use with caution.</dd><dt><var class=Va>net.bpf.maxinsns</var>: <span class=No>512</span></dt><dd>Maximum number of instructions that BPF program can contain. Use <a class=Xr href=tcpdump.1.html>tcpdump(1)</a><code class=Fl>-d</code> option to determine approximate number of instruction for any filter.</dd><dt><var class=Va>net.bpf.maxbufsize</var>: <span class=No>524288</span></dt><dd>Maximum buffer size to allocate for packets buffer.</dd><dt><var class=Va>net.bpf.bufsize</var>: <span class=No>4096</span></dt><dd>Default buffer size to allocate for packets buffer.</dd></dl></section><section class=Sh><h2 class=Sh id=EXAMPLES><a class=permalink href=#EXAMPLES>EXAMPLES</a></h2> The following filter is taken from the Reverse ARP Daemon. It accepts only Reverse ARP requests. <div class="Bd Pp"><pre>
struct bpf_insn insns[] = {
	BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 12),
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, ETHERTYPE_REVARP, 0, 3),
	BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 20),
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, ARPOP_REVREQUEST, 0, 1),
	BPF_STMT(BPF_RET+BPF_K, sizeof(struct ether_arp) +
		 sizeof(struct ether_header)),
	BPF_STMT(BPF_RET+BPF_K, 0),
};
</pre></div><p class=Pp>This filter accepts only IP packets between host 128.3.112.15 and 128.3.112.35.</p><div class="Bd Pp"><pre>
struct bpf_insn insns[] = {
	BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 12),
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, ETHERTYPE_IP, 0, 8),
	BPF_STMT(BPF_LD+BPF_W+BPF_ABS, 26),
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x8003700f, 0, 2),
	BPF_STMT(BPF_LD+BPF_W+BPF_ABS, 30),
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x80037023, 3, 4),
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x80037023, 0, 3),
	BPF_STMT(BPF_LD+BPF_W+BPF_ABS, 30),
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x8003700f, 0, 1),
	BPF_STMT(BPF_RET+BPF_K, (u_int)-1),
	BPF_STMT(BPF_RET+BPF_K, 0),
};
</pre></div><p class=Pp>Finally, this filter returns only TCP finger packets. We must parse the IP header to reach the TCP header. The <code class=Dv>BPF_JSET</code> instruction checks that the IP fragment offset is 0 so we are sure that we have a TCP header.</p><div class="Bd Pp"><pre>
struct bpf_insn insns[] = {
	BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 12),
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, ETHERTYPE_IP, 0, 10),
	BPF_STMT(BPF_LD+BPF_B+BPF_ABS, 23),
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, IPPROTO_TCP, 0, 8),
	BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 20),
	BPF_JUMP(BPF_JMP+BPF_JSET+BPF_K, 0x1fff, 6, 0),
	BPF_STMT(BPF_LDX+BPF_B+BPF_MSH, 14),
	BPF_STMT(BPF_LD+BPF_H+BPF_IND, 14),
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 79, 2, 0),
	BPF_STMT(BPF_LD+BPF_H+BPF_IND, 16),
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 79, 0, 1),
	BPF_STMT(BPF_RET+BPF_K, (u_int)-1),
	BPF_STMT(BPF_RET+BPF_K, 0),
};
</pre></div></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=tcpdump.1.html>tcpdump(1)</a>, <a class=Xr href=ioctl.2.html>ioctl(2)</a>, <a class=Xr href=kqueue.2.html>kqueue(2)</a>, <a class=Xr href=poll.2.html>poll(2)</a>, <a class=Xr href=select.2.html>select(2)</a>, <a class=Xr href=ng_bpf.4.html>ng_bpf(4)</a>, <a class=Xr href=bpf.9.html>bpf(9)</a><p class=Pp><cite class=Rs><span class=RsA>McCanne, S.</span> and <span class=RsA>Jacobson V.</span>, <span class=RsT>An efficient, extensible, and portable network monitor</span>.</cite></p></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> The Enet packet filter was created in 1980 by Mike Accetta and Rick Rashid at Carnegie-Mellon University. Jeffrey Mogul, at Stanford, ported the code to <span class=Ux>BSD</span> and continued its development from 1983 on. Since then, it has evolved into the Ultrix Packet Filter at DEC, a STREAMS NIT module under SunOS 4.1, and BPF. </section><section class=Sh><h2 class=Sh id=AUTHORS><a class=permalink href=#AUTHORS>AUTHORS</a></h2><span class=An>Steven McCanne</span>, of Lawrence Berkeley Laboratory, implemented BPF in Summer 1990. Much of the design is due to <span class=An>Van Jacobson</span>. <p class=Pp>Support for zero-copy buffers was added by <span class=An>Robert N. M. Watson</span> under contract to Seccuris Inc.</p></section><section class=Sh><h2 class=Sh id=BUGS><a class=permalink href=#BUGS>BUGS</a></h2> The read buffer must be of a fixed size (returned by the <code class=Dv>BIOCGBLEN</code> ioctl). <p class=Pp>A file that does not request promiscuous mode may receive promiscuously received packets as a side effect of another file requesting this mode on the same hardware interface. This could be fixed in the kernel with additional processing overhead. However, we favor the model where all files must assume that the interface is promiscuous, and if so desired, must utilize a filter to reject foreign packets.</p><p class=Pp>The <code class=Dv>SEESENT</code>, <code class=Dv>DIRECTION</code>, and <code class=Dv>FEEDBACK</code> settings have been observed to work incorrectly on some interface types, including those with hardware loopback rather than software loopback, and point-to-point interfaces. They appear to function correctly on a broad range of Ethernet-style interfaces.</p></section></div><table class=foot><tr><td class=foot-date>October 13, 2021</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>