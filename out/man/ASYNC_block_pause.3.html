<!DOCTYPE html>
<html><head><meta charset=utf-8><title>ASYNC_block_pause(3)</title><keywords content=man,ASYNC_block_pause></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>ASYNC_block_pause(3)</h1><table class=head><tr><td class=head-ltitle>ASYNC_START_JOB(3)</td><td class=head-vol>OpenSSL</td><td class=head-rtitle>ASYNC_START_JOB(3)</td></tr></table><div class=manual-text><br><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2> ASYNC_get_wait_ctx, ASYNC_init_thread, ASYNC_cleanup_thread, ASYNC_start_job, ASYNC_pause_job, ASYNC_get_current_job, ASYNC_block_pause, ASYNC_unblock_pause, ASYNC_is_capable - asynchronous job management functions </section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><pre>
 #include &lt;openssl/async.h&gt;

 int ASYNC_init_thread(size_t max_size, size_t init_size);
 void ASYNC_cleanup_thread(void);

 int ASYNC_start_job(ASYNC_JOB **job, ASYNC_WAIT_CTX *ctx, int *ret,
                     int (*func)(void *), void *args, size_t size);
 int ASYNC_pause_job(void);

 ASYNC_JOB *ASYNC_get_current_job(void);
 ASYNC_WAIT_CTX *ASYNC_get_wait_ctx(ASYNC_JOB *job);
 void ASYNC_block_pause(void);
 void ASYNC_unblock_pause(void);

 int ASYNC_is_capable(void);
</pre></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> OpenSSL implements asynchronous capabilities through an ASYNC_JOB. This represents code that can be started and executes until some event occurs. At that point the code can be paused and control returns to user code until some subsequent event indicates that the job can be resumed. <p class=Pp>The creation of an ASYNC_JOB is a relatively expensive operation. Therefore, for efficiency reasons, jobs can be created up front and reused many times. They are held in a pool until they are needed, at which point they are removed from the pool, used, and then returned to the pool when the job completes. If the user application is multi-threaded, then <b>ASYNC_init_thread()</b> may be called for each thread that will initiate asynchronous jobs. Before user code exits per-thread resources need to be cleaned up. This will normally occur automatically (see <b>OPENSSL_init_crypto</b>(3)) but may be explicitly initiated by using <b>ASYNC_cleanup_thread()</b>. No asynchronous jobs must be outstanding for the thread when <b>ASYNC_cleanup_thread()</b> is called. Failing to ensure this will result in memory leaks.</p><p class=Pp>The <b>max_size</b> argument limits the number of ASYNC_JOBs that will be held in the pool. If <b>max_size</b> is set to 0 then no upper limit is set. When an ASYNC_JOB is needed but there are none available in the pool already then one will be automatically created, as long as the total of ASYNC_JOBs managed by the pool does not exceed <b>max_size</b>. When the pool is first initialised <b>init_size</b> ASYNC_JOBs will be created immediately. If <b>ASYNC_init_thread()</b> is not called before the pool is first used then it will be called automatically with a <b>max_size</b> of 0 (no upper limit) and an <b>init_size</b> of 0 (no ASYNC_JOBs created up front).</p><p class=Pp>An asynchronous job is started by calling the <b>ASYNC_start_job()</b> function. Initially <b>*job</b> should be NULL. <b>ctx</b> should point to an ASYNC_WAIT_CTX object created through the <b>ASYNC_WAIT_CTX_new</b>(3) function. <b>ret</b> should point to a location where the return value of the asynchronous function should be stored on completion of the job. <b>func</b> represents the function that should be started asynchronously. The data pointed to by <b>args</b> and of size <b>size</b> will be copied and then passed as an argument to <b>func</b> when the job starts. ASYNC_start_job will return one of the following values:</p><dl class=Bl-tag><dt><b>ASYNC_ERR</b></dt><dd>An error occurred trying to start the job. Check the OpenSSL error queue (e.g. see <b>ERR_print_errors</b>(3)) for more details.</dd><dt><b>ASYNC_NO_JOBS</b></dt><dd>There are no jobs currently available in the pool. This call can be retried again at a later time.</dd><dt><b>ASYNC_PAUSE</b></dt><dd>The job was successfully started but was "paused" before it completed (see <b>ASYNC_pause_job()</b> below). A handle to the job is placed in <b>*job</b>. Other work can be performed (if desired) and the job restarted at a later time. To restart a job call <b>ASYNC_start_job()</b> again passing the job handle in <b>*job</b>. The <b>func</b>, <b>args</b> and <b>size</b> parameters will be ignored when restarting a job. When restarting a job <b>ASYNC_start_job()</b><b>must</b> be called from the same thread that the job was originally started from.</dd><dt><b>ASYNC_FINISH</b></dt><dd>The job completed. <b>*job</b> will be NULL and the return value from <b>func</b> will be placed in <b>*ret</b>.</dd></dl><p class=Pp>At any one time there can be a maximum of one job actively running per thread (you can have many that are paused). <b>ASYNC_get_current_job()</b> can be used to get a pointer to the currently executing ASYNC_JOB. If no job is currently executing then this will return NULL.</p><p class=Pp>If executing within the context of a job (i.e. having been called directly or indirectly by the function "func" passed as an argument to <b>ASYNC_start_job()</b>) then <b>ASYNC_pause_job()</b> will immediately return control to the calling application with ASYNC_PAUSE returned from the <b>ASYNC_start_job()</b> call. A subsequent call to ASYNC_start_job passing in the relevant ASYNC_JOB in the <b>*job</b> parameter will resume execution from the <b>ASYNC_pause_job()</b> call. If <b>ASYNC_pause_job()</b> is called whilst not within the context of a job then no action is taken and <b>ASYNC_pause_job()</b> returns immediately.</p><p class=Pp><b>ASYNC_get_wait_ctx()</b> can be used to get a pointer to the ASYNC_WAIT_CTX for the <b>job</b>. ASYNC_WAIT_CTXs can have a "wait" file descriptor associated with them. Applications can wait for the file descriptor to be ready for "read" using a system function call such as select or poll (being ready for "read" indicates that the job should be resumed). If no file descriptor is made available then an application will have to periodically "poll" the job by attempting to restart it to see if it is ready to continue.</p><p class=Pp>An example of typical usage might be an async capable engine. User code would initiate cryptographic operations. The engine would initiate those operations asynchronously and then call <b>ASYNC_WAIT_CTX_set_wait_fd</b>(3) followed by <b>ASYNC_pause_job()</b> to return control to the user code. The user code can then perform other tasks or wait for the job to be ready by calling "select" or other similar function on the wait file descriptor. The engine can signal to the user code that the job should be resumed by making the wait file descriptor "readable". Once resumed the engine should clear the wake signal on the wait file descriptor.</p><p class=Pp>The <b>ASYNC_block_pause()</b> function will prevent the currently active job from pausing. The block will remain in place until a subsequent call to <b>ASYNC_unblock_pause()</b>. These functions can be nested, e.g. if you call <b>ASYNC_block_pause()</b> twice then you must call <b>ASYNC_unblock_pause()</b> twice in order to re-enable pausing. If these functions are called while there is no currently active job then they have no effect. This functionality can be useful to avoid deadlock scenarios. For example during the execution of an ASYNC_JOB an application acquires a lock. It then calls some cryptographic function which invokes <b>ASYNC_pause_job()</b>. This returns control back to the code that created the ASYNC_JOB. If that code then attempts to acquire the same lock before resuming the original job then a deadlock can occur. By calling <b>ASYNC_block_pause()</b> immediately after acquiring the lock and <b>ASYNC_unblock_pause()</b> immediately before releasing it then this situation cannot occur.</p><p class=Pp>Some platforms cannot support async operations. The <b>ASYNC_is_capable()</b> function can be used to detect whether the current platform is async capable or not.</p></section><section class=Sh><h2 class=Sh id=RETURN_VALUES><a class=permalink href=#RETURN_VALUES>RETURN VALUES</a></h2> ASYNC_init_thread returns 1 on success or 0 otherwise. <p class=Pp>ASYNC_start_job returns one of ASYNC_ERR, ASYNC_NO_JOBS, ASYNC_PAUSE or ASYNC_FINISH as described above.</p><p class=Pp>ASYNC_pause_job returns 0 if an error occurred or 1 on success. If called when not within the context of an ASYNC_JOB then this is counted as success so 1 is returned.</p><p class=Pp>ASYNC_get_current_job returns a pointer to the currently executing ASYNC_JOB or NULL if not within the context of a job.</p><p class=Pp><b>ASYNC_get_wait_ctx()</b> returns a pointer to the ASYNC_WAIT_CTX for the job.</p><p class=Pp><b>ASYNC_is_capable()</b> returns 1 if the current platform is async capable or 0 otherwise.</p></section><section class=Sh><h2 class=Sh id=NOTES><a class=permalink href=#NOTES>NOTES</a></h2> On Windows platforms the openssl/async.h header is dependent on some of the types customarily made available by including windows.h. The application developer is likely to require control over when the latter is included, commonly as one of the first included headers. Therefore, it is defined as an application developer's responsibility to include windows.h prior to async.h. </section><section class=Sh><h2 class=Sh id=EXAMPLES><a class=permalink href=#EXAMPLES>EXAMPLES</a></h2> The following example demonstrates how to use most of the core async APIs: <p class=Pp></p><pre>
 #ifdef _WIN32
 # include &lt;windows.h&gt;
 #endif
 #include &lt;stdio.h&gt;
 #include &lt;unistd.h&gt;
 #include &lt;openssl/async.h&gt;
 #include &lt;openssl/crypto.h&gt;

 int unique = 0;

 void cleanup(ASYNC_WAIT_CTX *ctx, const void *key, OSSL_ASYNC_FD r, void *vw)
 {
     OSSL_ASYNC_FD *w = (OSSL_ASYNC_FD *)vw;

     close(r);
     close(*w);
     OPENSSL_free(w);
 }

 int jobfunc(void *arg)
 {
     ASYNC_JOB *currjob;
     unsigned char *msg;
     int pipefds[2] = {0, 0};
     OSSL_ASYNC_FD *wptr;
     char buf = 'X';

     currjob = ASYNC_get_current_job();
     if (currjob != NULL) {
         printf("Executing within a job\n");
     } else {
         printf("Not executing within a job - should not happen\n");
         return 0;
     }

     msg = (unsigned char *)arg;
     printf("Passed in message is: %s\n", msg);

     if (pipe(pipefds) != 0) {
         printf("Failed to create pipe\n");
         return 0;
     }
     wptr = OPENSSL_malloc(sizeof(OSSL_ASYNC_FD));
     if (wptr == NULL) {
         printf("Failed to malloc\n");
         return 0;
     }
     *wptr = pipefds[1];
     ASYNC_WAIT_CTX_set_wait_fd(ASYNC_get_wait_ctx(currjob), &amp;unique,
                                pipefds[0], wptr, cleanup);

     /*
      * Normally some external event would cause this to happen at some
      * later point - but we do it here for demo purposes, i.e.
      * immediately signalling that the job is ready to be woken up after
      * we return to main via ASYNC_pause_job().
      */
     write(pipefds[1], &amp;buf, 1);

     /* Return control back to main */
     ASYNC_pause_job();

     /* Clear the wake signal */
     read(pipefds[0], &amp;buf, 1);

     printf ("Resumed the job after a pause\n");

     return 1;
 }

 int main(void)
 {
     ASYNC_JOB *job = NULL;
     ASYNC_WAIT_CTX *ctx = NULL;
     int ret;
     OSSL_ASYNC_FD waitfd;
     fd_set waitfdset;
     size_t numfds;
     unsigned char msg[13] = "Hello world!";

     printf("Starting...\n");

     ctx = ASYNC_WAIT_CTX_new();
     if (ctx == NULL) {
         printf("Failed to create ASYNC_WAIT_CTX\n");
         abort();
     }

     for (;;) {
         switch (ASYNC_start_job(&amp;job, ctx, &amp;ret, jobfunc, msg, sizeof(msg))) {
         case ASYNC_ERR:
         case ASYNC_NO_JOBS:
             printf("An error occurred\n");
             goto end;
         case ASYNC_PAUSE:
             printf("Job was paused\n");
             break;
         case ASYNC_FINISH:
             printf("Job finished with return value %d\n", ret);
             goto end;
         }

         /* Wait for the job to be woken */
         printf("Waiting for the job to be woken up\n");

         if (!ASYNC_WAIT_CTX_get_all_fds(ctx, NULL, &amp;numfds)
                 || numfds &gt; 1) {
             printf("Unexpected number of fds\n");
             abort();
         }
         ASYNC_WAIT_CTX_get_all_fds(ctx, &amp;waitfd, &amp;numfds);
         FD_ZERO(&amp;waitfdset);
         FD_SET(waitfd, &amp;waitfdset);
         select(waitfd + 1, &amp;waitfdset, NULL, NULL, NULL);
     }

 end:
     ASYNC_WAIT_CTX_free(ctx);
     printf("Finishing\n");

     return 0;
 }
</pre><p class=Pp>The expected output from executing the above example program is:</p><p class=Pp></p><pre>
 Starting...
 Executing within a job
 Passed in message is: Hello world!
 Job was paused
 Waiting for the job to be woken up
 Resumed the job after a pause
 Job finished with return value 1
 Finishing
</pre></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><b>crypto</b>(7), <b>ERR_print_errors</b>(3) </section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> ASYNC_init_thread, ASYNC_cleanup_thread, ASYNC_start_job, ASYNC_pause_job, ASYNC_get_current_job, <b>ASYNC_get_wait_ctx()</b>, <b>ASYNC_block_pause()</b>, <b>ASYNC_unblock_pause()</b> and <b>ASYNC_is_capable()</b> were first added in OpenSSL 1.1.0. </section><section class=Sh><h2 class=Sh id=COPYRIGHT><a class=permalink href=#COPYRIGHT>COPYRIGHT</a></h2> Copyright 2015-2020 The OpenSSL Project Authors. All Rights Reserved. <p class=Pp>Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at &lt;https://www.openssl.org/source/license.html&gt;.</p></section></div><table class=foot><tr><td class=foot-date>2020-09-22</td><td class=foot-os>1.1.1h</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>