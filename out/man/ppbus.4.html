<!DOCTYPE html>
<html><head><meta charset=utf-8><title>ppbus(4)</title><keywords content=man,ppbus></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>ppbus(4)</h1><table class=head><tr><td class=head-ltitle>PPBUS(4)</td><td class=head-vol>FreeBSD Kernel Interfaces Manual</td><td class=head-rtitle>PPBUS(4)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>ppbus</code> — <div class=Nd>Parallel Port Bus system</div></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=Cd>device ppbus</code><p class=Pp><br><code class=Cd>device lpt</code><br><code class=Cd>device plip</code><br><code class=Cd>device ppi</code><br><code class=Cd>device pps</code><br><code class=Cd>device lpbb</code></p></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> The <i class=Em>ppbus</i> system provides a uniform, modular and architecture-independent system for the implementation of drivers to control various parallel devices, and to utilize different parallel port chipsets. </section><section class=Sh><h2 class=Sh id=DEVICE_DRIVERS><a class=permalink href=#DEVICE_DRIVERS>DEVICE DRIVERS</a></h2> In order to write new drivers or port existing drivers, the ppbus system provides the following facilities: <ul class="Bl-bullet Bd-indent"><li>architecture-independent macros or functions to access parallel ports</li><li>mechanism to allow various devices to share the same parallel port</li><li>a user interface named <a class=Xr href=ppi.4.html>ppi(4)</a> that allows parallel port access from outside the kernel without conflicting with kernel-in drivers.</li></ul><section class=Ss><h2 class=Ss id=Developing_new_drivers><a class=permalink href=#Developing_new_drivers>Developing new drivers</a></h2> The ppbus system has been designed to support the development of standard and non-standard software: <p class=Pp></p><table class="Bl-column Bl-compact"><tr><td><i class=Em>Driver</i></td><td><i class=Em>Description</i></td></tr><tr><td><b class=Sy>ppi</b></td><td>Parallel port interface for general I/O</td></tr><tr><td><b class=Sy>pps</b></td><td>Pulse per second Timing Interface</td></tr><tr><td><b class=Sy>lpbb</b></td><td>Philips official parallel port I2C bit-banging interface</td></tr></table></section><section class=Ss><h2 class=Ss id=Porting_existing_drivers><a class=permalink href=#Porting_existing_drivers>Porting existing drivers</a></h2> Another approach to the ppbus system is to port existing drivers. Various drivers have already been ported: <p class=Pp></p><table class="Bl-column Bl-compact"><tr><td><i class=Em>Driver</i></td><td><i class=Em>Description</i></td></tr><tr><td><b class=Sy>lpt</b></td><td>lpt printer driver</td></tr><tr><td><b class=Sy>plip</b></td><td>lp parallel network interface driver</td></tr></table><p class=Pp>ppbus should let you port any other software even from other operating systems that provide similar services.</p></section></section><section class=Sh><h2 class=Sh id=PARALLEL_PORT_CHIPSETS><a class=permalink href=#PARALLEL_PORT_CHIPSETS>PARALLEL PORT CHIPSETS</a></h2> Parallel port chipset support is provided by <a class=Xr href=ppc.4.html>ppc(4)</a>. <p class=Pp>The ppbus system provides functions and macros to allocate a new parallel port bus, then initialize it and upper peripheral device drivers.</p><p class=Pp>ppc makes chipset detection and initialization and then calls ppbus attach functions to initialize the ppbus system.</p></section><section class=Sh><h2 class=Sh id=PARALLEL_PORT_MODEL><a class=permalink href=#PARALLEL_PORT_MODEL>PARALLEL PORT MODEL</a></h2> The logical parallel port model chosen for the ppbus system is the PC's parallel port model. Consequently, for the i386 implementation of ppbus, most of the services provided by ppc are macros for inb() and outb() calls. But, for another architecture, accesses to one of our logical registers (data, status, control...) may require more than one I/O access. <section class=Ss><h2 class=Ss id=Description><a class=permalink href=#Description>Description</a></h2> The parallel port may operate in the following modes: <ul class="Bl-bullet Bd-indent"><li>compatible mode, also called Centronics mode</li><li>bidirectional 8/4-bits mode, also called NIBBLE mode</li><li>byte mode, also called PS/2 mode</li><li>Extended Capability Port mode, ECP</li><li>Enhanced Parallel Port mode, EPP</li><li>mixed ECP+EPP or ECP+PS/2 modes</li></ul></section><section class=Ss><h2 class=Ss id=Compatible_mode><a class=permalink href=#Compatible_mode>Compatible mode</a></h2> This mode defines the protocol used by most PCs to transfer data to a printer. In this mode, data is placed on the port's data lines, the printer status is checked for no errors and that it is not busy, and then a data Strobe is generated by the software to clock the data to the printer. <p class=Pp>Many I/O controllers have implemented a mode that uses a FIFO buffer to transfer data with the Compatibility mode protocol. This mode is referred to as "Fast Centronics" or "Parallel Port FIFO mode".</p></section><section class=Ss><h2 class=Ss id=Bidirectional_mode><a class=permalink href=#Bidirectional_mode>Bidirectional mode</a></h2> The NIBBLE mode is the most common way to get reverse channel data from a printer or peripheral. Combined with the standard host to printer mode, it provides a complete bidirectional channel. <p class=Pp>In this mode, outputs are 8-bits long. Inputs are accomplished by reading 4 of the 8 bits of the status register.</p></section><section class=Ss><h2 class=Ss id=Byte_mode><a class=permalink href=#Byte_mode>Byte mode</a></h2> In this mode, the data register is used either for outputs and inputs. Then, any transfer is 8-bits long. </section><section class=Ss><h2 class=Ss id=Extended_Capability_Port_mode><a class=permalink href=#Extended_Capability_Port_mode>Extended Capability Port mode</a></h2> The ECP protocol was proposed as an advanced mode for communication with printer and scanner type peripherals. Like the EPP protocol, ECP mode provides for a high performance bidirectional communication path between the host adapter and the peripheral. <p class=Pp>ECP protocol features include:</p><ul class="Bl-item Bd-indent"><li>Run_Length_Encoding (RLE) data compression for host adapters</li><li>FIFOs for both the forward and reverse channels</li><li>DMA as well as programmed I/O for the host register interface.</li></ul></section><section class=Ss><h2 class=Ss id=Enhanced_Parallel_Port_mode><a class=permalink href=#Enhanced_Parallel_Port_mode>Enhanced Parallel Port mode</a></h2> The EPP protocol was originally developed as a means to provide a high performance parallel port link that would still be compatible with the standard parallel port. <p class=Pp>The EPP mode has two types of cycle: address and data. What makes the difference at hardware level is the strobe of the byte placed on the data lines. Data are strobed with nAutofeed, addresses are strobed with nSelectin signals.</p><p class=Pp>A particularity of the ISA implementation of the EPP protocol is that an EPP cycle fits in an ISA cycle. In this fashion, parallel port peripherals can operate at close to the same performance levels as an equivalent ISA plug-in card.</p><p class=Pp>At software level, you may implement the protocol you wish, using data and address cycles as you want. This is for the IEEE1284 compatible part. Then, peripheral vendors may implement protocol handshake with the following status lines: PError, nFault and Select. Try to know how these lines toggle with your peripheral, allowing the peripheral to request more data, stop the transfer and so on.</p><p class=Pp>At any time, the peripheral may interrupt the host with the nAck signal without disturbing the current transfer.</p></section><section class=Ss><h2 class=Ss id=Mixed_modes><a class=permalink href=#Mixed_modes>Mixed modes</a></h2> Some manufacturers, like SMC, have implemented chipsets that support mixed modes. With such chipsets, mode switching is available at any time by accessing the extended control register. </section></section><section class=Sh><h2 class=Sh id=IEEE1284-1994_Standard><a class=permalink href=#IEEE1284-1994_Standard>IEEE1284-1994 Standard</a></h2><section class=Ss><h2 class=Ss id=Background><a class=permalink href=#Background>Background</a></h2> This standard is also named "IEEE Standard Signaling Method for a Bidirectional Parallel Peripheral Interface for Personal Computers". It defines a signaling method for asynchronous, fully interlocked, bidirectional parallel communications between hosts and printers or other peripherals. It also specifies a format for a peripheral identification string and a method of returning this string to the host outside of the bidirectional data stream. <p class=Pp>This standard is architecture independent and only specifies dialog handshake at signal level. One should refer to architecture specific documentation in order to manipulate machine dependent registers, mapped memory or other methods to control these signals.</p><p class=Pp>The IEEE1284 protocol is fully oriented with all supported parallel port modes. The computer acts as master and the peripheral as slave.</p><p class=Pp>Any transfer is defined as a finite state automaton. It allows software to properly manage the fully interlocked scheme of the signaling method. The compatible mode is supported "as is" without any negotiation because it is compatible. Any other mode must be firstly negotiated by the host to check it is supported by the peripheral, then to enter one of the forward idle states.</p><p class=Pp>At any time, the slave may want to send data to the host. This is only possible from forward idle states (nibble, byte, ecp...). So, the host must have previously negotiated to permit the peripheral to request transfer. Interrupt lines may be dedicated to the requesting signals to prevent time consuming polling methods.</p><p class=Pp>But peripheral requests are only a hint to the master host. If the host accepts the transfer, it must firstly negotiate the reverse mode and then starts the transfer. At any time during reverse transfer, the host may terminate the transfer or the slave may drive wires to signal that no more data is available.</p></section><section class=Ss><h2 class=Ss id=Implementation><a class=permalink href=#Implementation>Implementation</a></h2> IEEE1284 Standard support has been implemented at the top of the ppbus system as a set of procedures that perform high level functions like negotiation, termination, transfer in any mode without bothering you with low level characteristics of the standard. <p class=Pp>IEEE1284 interacts with the ppbus system as little as possible. That means you still have to request the ppbus when you want to access it, the negotiate function does not do it for you. And of course, release it later.</p></section></section><section class=Sh><h2 class=Sh id=ARCHITECTURE><a class=permalink href=#ARCHITECTURE>ARCHITECTURE</a></h2><section class=Ss><h2 class=Ss id=adapter,_ppbus_and_device_layers><a class=permalink href=#adapter,_ppbus_and_device_layers>adapter, ppbus and device layers</a></h2> First, there is the <i class=Em>adapter</i> layer, the lowest of the ppbus system. It provides chipset abstraction throw a set of low level functions that maps the logical model to the underlying hardware. <p class=Pp>Secondly, there is the <i class=Em>ppbus</i> layer that provides functions to:</p><ol class="Bl-enum Bd-indent"><li>share the parallel port bus among the daisy-chain like connected devices</li><li>manage devices linked to ppbus</li><li>propose an arch-independent interface to access the hardware layer.</li></ol><p class=Pp>Finally, the <i class=Em>device</i> layer gathers the parallel peripheral device drivers.</p></section><section class=Ss><h2 class=Ss id=Parallel_modes_management><a class=permalink href=#Parallel_modes_management>Parallel modes management</a></h2> We have to differentiate operating modes at various ppbus system layers. Actually, ppbus and adapter operating modes on one hands and for each one, current and available modes are separated. <p class=Pp>With this level of abstraction a particular chipset may commute from any native mode to any other mode emulated with extended modes without disturbing upper layers. For example, most chipsets support NIBBLE mode as native and emulated with ECP and/or EPP.</p><p class=Pp>This architecture should support IEEE1284-1994 modes.</p></section></section><section class=Sh><h2 class=Sh id=FEATURES><a class=permalink href=#FEATURES>FEATURES</a></h2><section class=Ss><h2 class=Ss id=The_boot_process><a class=permalink href=#The_boot_process>The boot process</a></h2> The boot process starts with the probe stage of the <a class=Xr href=ppc.4.html>ppc(4)</a> driver during ISA bus (PC architecture) initialization. During attachment of the ppc driver, a new ppbus structure is allocated, then probe and attachment for this new bus node are called. <p class=Pp>ppbus attachment tries to detect any PnP parallel peripheral (according to <span class=RsT>Plug and Play Parallel Port Devices</span> draft from (c)1993-4 Microsoft Corporation) then probes and attaches known device drivers.</p><p class=Pp>During probe, device drivers are supposed to request the ppbus and try to set their operating mode. This mode will be saved in the context structure and returned each time the driver requests the ppbus.</p></section><section class=Ss><h2 class=Ss id=Bus_allocation_and_interrupts><a class=permalink href=#Bus_allocation_and_interrupts>Bus allocation and interrupts</a></h2> ppbus allocation is mandatory not to corrupt I/O of other devices. Another usage of ppbus allocation is to reserve the port and receive incoming interrupts. <p class=Pp>High level interrupt handlers are connected to the ppbus system thanks to the newbus <code class=Fn>BUS_SETUP_INTR</code>() and <code class=Fn>BUS_TEARDOWN_INTR</code>() functions. But, in order to attach a handler, drivers must own the bus. Consequently, a ppbus request is mandatory in order to call the above functions (see existing drivers for more info). Note that the interrupt handler is automatically released when the ppbus is released.</p></section><section class=Ss><h2 class=Ss id=Microsequences><a class=permalink href=#Microsequences>Microsequences</a></h2><i class=Em>Microsequences</i> is a general purpose mechanism to allow fast low-level manipulation of the parallel port. Microsequences may be used to do either standard (in IEEE1284 modes) or non-standard transfers. The philosophy of microsequences is to avoid the overhead of the ppbus layer and do most of the job at adapter level. <p class=Pp>A microsequence is an array of opcodes and parameters. Each opcode codes an operation (opcodes are described in <a class=Xr href=microseq.9.html>microseq(9)</a>). Standard I/O operations are implemented at ppbus level whereas basic I/O operations and microseq language are coded at adapter level for efficiency.</p></section></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=lpt.4.html>lpt(4)</a>, <a class=Xr href=plip.4.html>plip(4)</a>, <a class=Xr href=ppc.4.html>ppc(4)</a>, <a class=Xr href=ppi.4.html>ppi(4)</a></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> The <code class=Nm>ppbus</code> manual page first appeared in <span class=Ux>FreeBSD 3.0</span>. </section><section class=Sh><h2 class=Sh id=AUTHORS><a class=permalink href=#AUTHORS>AUTHORS</a></h2> This manual page was written by <span class=An>Nicolas Souchu</span>. </section></div><table class=foot><tr><td class=foot-date>March 1, 1998</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>