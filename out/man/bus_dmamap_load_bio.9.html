<!DOCTYPE html>
<html><head><meta charset=utf-8><title>bus_dmamap_load_bio(9)</title><keywords content=man,bus_dmamap_load_bio></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>bus_dmamap_load_bio(9)</h1><table class=head><tr><td class=head-ltitle>BUS_DMA(9)</td><td class=head-vol>FreeBSD Kernel Developer's Manual</td><td class=head-rtitle>BUS_DMA(9)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>bus_dma</code>, <code class=Nm>bus_dma_tag_create</code>, <code class=Nm>bus_dma_tag_destroy</code>, <code class=Nm>bus_dmamap_create</code>, <code class=Nm>bus_dmamap_destroy</code>, <code class=Nm>bus_dmamap_load</code>, <code class=Nm>bus_dmamap_load_bio</code>, <code class=Nm>bus_dmamap_load_ccb</code>, <code class=Nm>bus_dmamap_load_mbuf</code>, <code class=Nm>bus_dmamap_load_mbuf_sg</code>, <code class=Nm>bus_dmamap_load_uio</code>, <code class=Nm>bus_dmamap_unload</code>, <code class=Nm>bus_dmamap_sync</code>, <code class=Nm>bus_dmamem_alloc</code>, <code class=Nm>bus_dmamem_free</code> — <div class=Nd>Bus and Machine Independent DMA Mapping Interface</div></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/machine/bus.h.html>machine/bus.h</a>&gt;</code><p class=Pp><var class=Ft>int</var><br><code class=Fn>bus_dma_tag_create</code>(<var class=Fa style="white-space: nowrap;">bus_dma_tag_t parent</var>, <var class=Fa style="white-space: nowrap;">bus_size_t alignment</var>, <var class=Fa style="white-space: nowrap;">bus_addr_t boundary</var>, <var class=Fa style="white-space: nowrap;">bus_addr_t lowaddr</var>, <var class=Fa style="white-space: nowrap;">bus_addr_t highaddr</var>, <var class=Fa style="white-space: nowrap;">bus_dma_filter_t *filtfunc</var>, <var class=Fa style="white-space: nowrap;">void *filtfuncarg</var>, <var class=Fa style="white-space: nowrap;">bus_size_t maxsize</var>, <var class=Fa style="white-space: nowrap;">int nsegments</var>, <var class=Fa style="white-space: nowrap;">bus_size_t maxsegsz</var>, <var class=Fa style="white-space: nowrap;">int flags</var>, <var class=Fa style="white-space: nowrap;">bus_dma_lock_t *lockfunc</var>, <var class=Fa style="white-space: nowrap;">void *lockfuncarg</var>, <var class=Fa style="white-space: nowrap;">bus_dma_tag_t *dmat</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bus_dma_tag_destroy</code>(<var class=Fa style="white-space: nowrap;">bus_dma_tag_t dmat</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bus_dmamap_create</code>(<var class=Fa style="white-space: nowrap;">bus_dma_tag_t dmat</var>, <var class=Fa style="white-space: nowrap;">int flags</var>, <var class=Fa style="white-space: nowrap;">bus_dmamap_t *mapp</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bus_dmamap_destroy</code>(<var class=Fa style="white-space: nowrap;">bus_dma_tag_t dmat</var>, <var class=Fa style="white-space: nowrap;">bus_dmamap_t map</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bus_dmamap_load</code>(<var class=Fa style="white-space: nowrap;">bus_dma_tag_t dmat</var>, <var class=Fa style="white-space: nowrap;">bus_dmamap_t map</var>, <var class=Fa style="white-space: nowrap;">void *buf</var>, <var class=Fa style="white-space: nowrap;">bus_size_t buflen</var>, <var class=Fa style="white-space: nowrap;">bus_dmamap_callback_t *callback</var>, <var class=Fa style="white-space: nowrap;">void *callback_arg</var>, <var class=Fa style="white-space: nowrap;">int flags</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bus_dmamap_load_bio</code>(<var class=Fa style="white-space: nowrap;">bus_dma_tag_t dmat</var>, <var class=Fa style="white-space: nowrap;">bus_dmamap_t map</var>, <var class=Fa style="white-space: nowrap;">struct bio *bio</var>, <var class=Fa style="white-space: nowrap;">bus_dmamap_callback_t *callback</var>, <var class=Fa style="white-space: nowrap;">void *callback_arg</var>, <var class=Fa style="white-space: nowrap;">int flags</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bus_dmamap_load_ccb</code>(<var class=Fa style="white-space: nowrap;">bus_dma_tag_t dmat</var>, <var class=Fa style="white-space: nowrap;">bus_dmamap_t map</var>, <var class=Fa style="white-space: nowrap;">union ccb *ccb</var>, <var class=Fa style="white-space: nowrap;">bus_dmamap_callback_t *callback</var>, <var class=Fa style="white-space: nowrap;">void *callback_arg</var>, <var class=Fa style="white-space: nowrap;">int flags</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bus_dmamap_load_mbuf</code>(<var class=Fa style="white-space: nowrap;">bus_dma_tag_t dmat</var>, <var class=Fa style="white-space: nowrap;">bus_dmamap_t map</var>, <var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">bus_dmamap_callback2_t *callback</var>, <var class=Fa style="white-space: nowrap;">void *callback_arg</var>, <var class=Fa style="white-space: nowrap;">int flags</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bus_dmamap_load_mbuf_sg</code>(<var class=Fa style="white-space: nowrap;">bus_dma_tag_t dmat</var>, <var class=Fa style="white-space: nowrap;">bus_dmamap_t map</var>, <var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">bus_dma_segment_t *segs</var>, <var class=Fa style="white-space: nowrap;">int *nsegs</var>, <var class=Fa style="white-space: nowrap;">int flags</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bus_dmamap_load_uio</code>(<var class=Fa style="white-space: nowrap;">bus_dma_tag_t dmat</var>, <var class=Fa style="white-space: nowrap;">bus_dmamap_t map</var>, <var class=Fa style="white-space: nowrap;">struct uio *uio</var>, <var class=Fa style="white-space: nowrap;">bus_dmamap_callback2_t *callback</var>, <var class=Fa style="white-space: nowrap;">void *callback_arg</var>, <var class=Fa style="white-space: nowrap;">int flags</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_dmamap_unload</code>(<var class=Fa style="white-space: nowrap;">bus_dma_tag_t dmat</var>, <var class=Fa style="white-space: nowrap;">bus_dmamap_t map</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_dmamap_sync</code>(<var class=Fa style="white-space: nowrap;">bus_dma_tag_t dmat</var>, <var class=Fa style="white-space: nowrap;">bus_dmamap_t map</var>, <var class=Fa style="white-space: nowrap;">op</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bus_dmamem_alloc</code>(<var class=Fa style="white-space: nowrap;">bus_dma_tag_t dmat</var>, <var class=Fa style="white-space: nowrap;">void **vaddr</var>, <var class=Fa style="white-space: nowrap;">int flags</var>, <var class=Fa style="white-space: nowrap;">bus_dmamap_t *mapp</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_dmamem_free</code>(<var class=Fa style="white-space: nowrap;">bus_dma_tag_t dmat</var>, <var class=Fa style="white-space: nowrap;">void *vaddr</var>, <var class=Fa style="white-space: nowrap;">bus_dmamap_t map</var>);</p></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> Direct Memory Access (DMA) is a method of transferring data without involving the CPU, thus providing higher performance. A DMA transaction can be achieved between device to memory, device to device, or memory to memory. <p class=Pp>The <code class=Nm>bus_dma</code> API is a bus, device, and machine-independent (MI) interface to DMA mechanisms. It provides the client with flexibility and simplicity by abstracting machine dependent issues like setting up DMA mappings, handling cache issues, bus specific features and limitations.</p></section><section class=Sh><h2 class=Sh id=OVERVIEW><a class=permalink href=#OVERVIEW>OVERVIEW</a></h2> A tag structure (<var class=Vt>bus_dma_tag_t</var>) is used to describe the properties of a group of related DMA transactions. One way to view this is that a tag describes the limitations of a DMA engine. For example, if a DMA engine in a device is limited to 32-bit addresses, that limitation is specified by a parameter when creating the tag for that device. Similarly, a tag can be marked as requiring buffers whose addresses are aligned to a specific boundary. <p class=Pp>Some devices may require multiple tags to describe DMA transactions with differing properties. For example, a device might require 16-byte alignment of its descriptor ring while permitting arbitrary alignment of I/O buffers. In this case, the driver must create one tag for the descriptor ring and a separate tag for I/O buffers. If a device has restrictions that are common to all DMA transactions in addition to restrictions that differ between unrelated groups of transactions, the driver can first create a “parent” tag that decribes the common restrictions. The per-group tags can then inherit these restrictions from this “parent” tag rather than having to list them explicitly when creating the per-group tags.</p><p class=Pp>A mapping structure (<var class=Vt>bus_dmamap_t</var>) represents a mapping of a memory region for DMA. On systems with I/O MMUs, the mapping structure tracks any I/O MMU entries used by a request. For DMA requests that require bounce pages, the mapping tracks the bounce pages used.</p><p class=Pp>To prepare for one or more DMA transactions, a mapping must be bound to a memory region by calling one of the <code class=Fn>bus_dmamap_load</code>() functions. These functions configure the mapping which can include programming entries in an I/O MMU and/or allocating bounce pages. An output of these functions (either directly or indirectly by invoking a callback routine) is the list of scatter/gather address ranges a consumer can pass to a DMA engine to access the memory region. When a mapping is no longer needed, the mapping must be unloaded via <code class=Fn>bus_dmamap_unload</code>().</p><p class=Pp>Before and after each DMA transaction, <code class=Fn>bus_dmamap_sync</code>() must be used to ensure that the correct data is used by the DMA engine and the CPU. If a mapping uses bounce pages, the sync operations copy data between the bounce pages and the memory region bound to the mapping. Sync operations also handle architecture-specific details such as CPU cache flushing and CPU memory operation ordering.</p></section><section class=Sh><h2 class=Sh id=STATIC_VS_DYNAMIC><a class=permalink href=#STATIC_VS_DYNAMIC>STATIC VS DYNAMIC</a></h2><code class=Nm>bus_dma</code> handles two types of DMA transactions: static and dynamic. Static transactions are used with a long-lived memory region that is reused for many transactions such as a descriptor ring. Dynamic transactions are used for transfers to or from transient buffers such as I/O buffers holding a network packet or disk block. Each transaction type uses a different subset of the <code class=Nm>bus_dma</code> API. <section class=Ss><h2 class=Ss id=Static_Transactions><a class=permalink href=#Static_Transactions>Static Transactions</a></h2> Static transactions use memory regions allocated by <code class=Nm>bus_dma</code>. Each static memory region is allocated by calling <code class=Fn>bus_dmamem_alloc</code>(). This function requires a valid tag describing the properties of the DMA transactions to this region such as alignment or address restrictions. Multiple regions can share a single tag if they share the same restrictions. <p class=Pp><code class=Fn>bus_dmamem_alloc</code>() allocates a memory region along with a mapping object. The associated tag, memory region, and mapping object must then be passed to <code class=Fn>bus_dmamap_load</code>() to bind the mapping to the allocated region and obtain the scatter/gather list.</p><p class=Pp>It is expected that <code class=Fn>bus_dmamem_alloc</code>() will attempt to allocate memory requiring less expensive sync operations (for example, implementations should not allocate regions requiring bounce pages), but sync operations should still be used. For example, a driver should use <code class=Fn>bus_dmamap_sync</code>() in an interrupt handler before reading descriptor ring entries written by the device prior to the interrupt.</p><p class=Pp>When a consumer is finished with a memory region, it should unload the mapping via <code class=Fn>bus_dmamap_unload</code>() and then release the memory region and mapping object via <code class=Fn>bus_dmamem_free</code>().</p></section><section class=Ss><h2 class=Ss id=Dynamic_Transactions><a class=permalink href=#Dynamic_Transactions>Dynamic Transactions</a></h2> Dynamic transactions map memory regions provided by other parts of the system. A tag must be created via <code class=Fn>bus_dma_tag_create</code>() to describe the DMA transactions to and from these memory regions, and a pool of mapping objects must be allocated via <code class=Fn>bus_dmamap_create</code>() to track the mappings of any in-flight transactions. <p class=Pp>When a consumer wishes to schedule a transaction for a memory region, the consumer must first obtain an unused mapping object from its pool of mapping objects. The memory region must be bound to the mapping object via one of the <code class=Fn>bus_dmamap_load</code>() functions. Before scheduling the transaction, the consumer should sync the memory region via <code class=Fn>bus_dmamap_sync</code>() with one or more of the “PRE” flags. After the transaction has completed, the consumer should sync the memory region via <code class=Fn>bus_dmamap_sync</code>() with one or more of the “POST” flags. The mapping can then be unloaded via <code class=Fn>bus_dmamap_unload</code>(), and the mapping object can be returned to the pool of unused mapping objects.</p><p class=Pp>When a consumer is no longer scheduling DMA transactions, the mapping objects should be freed via <code class=Fn>bus_dmamap_destroy</code>(), and the tag should be freed via <code class=Fn>bus_dma_tag_destroy</code>().</p></section></section><section class=Sh><h2 class=Sh id=STRUCTURES_AND_TYPES><a class=permalink href=#STRUCTURES_AND_TYPES>STRUCTURES AND TYPES</a></h2><dl class=Bl-tag><dt><var class=Vt>bus_dma_tag_t</var></dt><dd>A machine-dependent (MD) opaque type that describes the characteristics of a group of DMA transactions. DMA tags are organized into a hierarchy, with each child tag inheriting the restrictions of its parent. This allows all devices along the path of DMA transactions to contribute to the constraints of those transactions.</dd><dt><var class=Vt>bus_dma_filter_t</var></dt><dd>Client specified address filter having the format: <dl class=Bl-tag><dt><var class=Ft>int</var></dt><dd><code class=Fn>client_filter</code>(<var class=Fa>void *filtarg</var>, <var class=Fa>bus_addr_t testaddr</var>)</dd></dl><p class=Pp>Address filters can be specified during tag creation to allow for devices whose DMA address restrictions cannot be specified by a single window. The <var class=Fa>filtarg</var> argument is specified by the client during tag creation to be passed to all invocations of the callback. The <var class=Fa>testaddr</var> argument contains a potential starting address of a DMA mapping. The filter function operates on the set of addresses from <var class=Fa>testaddr</var> to ‘<code class=Li>trunc_page(testaddr) + PAGE_SIZE - 1</code>’, inclusive. The filter function should return zero if any mapping in this range can be accommodated by the device and non-zero otherwise.</p></dd><dt><var class=Vt>bus_dma_segment_t</var></dt><dd>A machine-dependent type that describes individual DMA segments. It contains the following fields: <div class="Bd Pp"><pre>
	bus_addr_t	ds_addr;
	bus_size_t	ds_len;
    </pre></div><p class=Pp>The <var class=Fa>ds_addr</var> field contains the device visible address of the DMA segment, and <var class=Fa>ds_len</var> contains the length of the DMA segment. Although the DMA segments returned by a mapping call will adhere to all restrictions necessary for a successful DMA operation, some conversion (e.g. a conversion from host byte order to the device's byte order) is almost always required when presenting segment information to the device.</p></dd><dt><var class=Vt>bus_dmamap_t</var></dt><dd>A machine-dependent opaque type describing an individual mapping. One map is used for each memory allocation that will be loaded. Maps can be reused once they have been unloaded. Multiple maps can be associated with one DMA tag. While the value of the map may evaluate to <code class=Dv>NULL</code> on some platforms under certain conditions, it should never be assumed that it will be <code class=Dv>NULL</code> in all cases.</dd><dt><var class=Vt>bus_dmamap_callback_t</var></dt><dd>Client specified callback for receiving mapping information resulting from the load of a <var class=Vt>bus_dmamap_t</var> via <code class=Fn>bus_dmamap_load</code>(), <code class=Fn>bus_dmamap_load_bio</code>() or <code class=Fn>bus_dmamap_load_ccb</code>(). Callbacks are of the format: <dl class=Bl-tag><dt><var class=Ft>void</var></dt><dd><code class=Fn>client_callback</code>(<var class=Fa>void *callback_arg</var>, <var class=Fa>bus_dma_segment_t *segs</var>, <var class=Fa>int nseg</var>, <var class=Fa>int error</var>)</dd></dl><p class=Pp>The <var class=Fa>callback_arg</var> is the callback argument passed to dmamap load functions. The <var class=Fa>segs</var> and <var class=Fa>nseg</var> arguments describe an array of <var class=Vt>bus_dma_segment_t</var> structures that represent the mapping. This array is only valid within the scope of the callback function. The success or failure of the mapping is indicated by the <var class=Fa>error</var> argument. More information on the use of callbacks can be found in the description of the individual dmamap load functions.</p></dd><dt><var class=Vt>bus_dmamap_callback2_t</var></dt><dd>Client specified callback for receiving mapping information resulting from the load of a <var class=Vt>bus_dmamap_t</var> via <code class=Fn>bus_dmamap_load_uio</code>() or <code class=Fn>bus_dmamap_load_mbuf</code>(). <p class=Pp>Callback2s are of the format:</p><dl class=Bl-tag><dt><var class=Ft>void</var></dt><dd><code class=Fn>client_callback2</code>(<var class=Fa>void *callback_arg</var>, <var class=Fa>bus_dma_segment_t *segs</var>, <var class=Fa>int nseg</var>, <var class=Fa>bus_size_t mapsize</var>, <var class=Fa>int error</var>)</dd></dl><p class=Pp>Callback2's behavior is the same as <var class=Vt>bus_dmamap_callback_t</var> with the addition that the length of the data mapped is provided via <var class=Fa>mapsize</var>.</p></dd><dt><var class=Vt>bus_dmasync_op_t</var></dt><dd>Memory synchronization operation specifier. Bus DMA requires explicit synchronization of memory with its device visible mapping in order to guarantee memory coherency. The <var class=Vt>bus_dmasync_op_t</var> allows the type of DMA operation that will be or has been performed to be communicated to the system so that the correct coherency measures are taken. The operations are represented as bitfield flags that can be combined together, though it only makes sense to combine PRE flags or POST flags, not both. See the <code class=Fn>bus_dmamap_sync</code>() description below for more details on how to use these operations. <p class=Pp>All operations specified below are performed from the host memory point of view, where a read implies data coming from the device to the host memory, and a write implies data going from the host memory to the device. Alternatively, the operations can be thought of in terms of driver operations, where reading a network packet or storage sector corresponds to a read operation in <code class=Nm>bus_dma</code>.</p><dl class=Bl-tag><dt><a class=permalink href=#BUS_DMASYNC_PREREAD><code class=Dv id=BUS_DMASYNC_PREREAD>BUS_DMASYNC_PREREAD</code></a></dt><dd>Perform any synchronization required prior to an update of host memory by the device.</dd><dt><a class=permalink href=#BUS_DMASYNC_PREWRITE><code class=Dv id=BUS_DMASYNC_PREWRITE>BUS_DMASYNC_PREWRITE</code></a></dt><dd>Perform any synchronization required after an update of host memory by the CPU and prior to device access to host memory.</dd><dt><a class=permalink href=#BUS_DMASYNC_POSTREAD><code class=Dv id=BUS_DMASYNC_POSTREAD>BUS_DMASYNC_POSTREAD</code></a></dt><dd>Perform any synchronization required after an update of host memory by the device and prior to CPU access to host memory.</dd><dt><a class=permalink href=#BUS_DMASYNC_POSTWRITE><code class=Dv id=BUS_DMASYNC_POSTWRITE>BUS_DMASYNC_POSTWRITE</code></a></dt><dd>Perform any synchronization required after device access to host memory.</dd></dl></dd><dt><var class=Vt>bus_dma_lock_t</var></dt><dd>Client specified lock/mutex manipulation method. This will be called from within busdma whenever a client lock needs to be manipulated. In its current form, the function will be called immediately before the callback for a DMA load operation that has been deferred with <code class=Dv>BUS_DMA_LOCK</code> and immediately after with <code class=Dv>BUS_DMA_UNLOCK</code>. If the load operation does not need to be deferred, then it will not be called since the function loading the map should be holding the appropriate locks. This method is of the format: <dl class=Bl-tag><dt><var class=Ft>void</var></dt><dd><code class=Fn>lockfunc</code>(<var class=Fa>void *lockfunc_arg</var>, <var class=Fa>bus_dma_lock_op_t op</var>)</dd></dl><p class=Pp>The <var class=Fa>lockfuncarg</var> argument is specified by the client during tag creation to be passed to all invocations of the callback. The <var class=Fa>op</var> argument specifies the lock operation to perform.</p><p class=Pp>Two <var class=Vt>lockfunc</var> implementations are provided for convenience. <code class=Fn>busdma_lock_mutex</code>() performs standard mutex operations on the sleep mutex provided via <var class=Fa>lockfuncarg</var>. <code class=Fn>dflt_lock</code>() will generate a system panic if it is called. It is substituted into the tag when <var class=Fa>lockfunc</var> is passed as <code class=Dv>NULL</code> to <code class=Fn>bus_dma_tag_create</code>() and is useful for tags that should not be used with deferred load operations.</p></dd><dt><var class=Vt>bus_dma_lock_op_t</var></dt><dd>Operations to be performed by the client-specified <code class=Fn>lockfunc</code>(). <dl class=Bl-tag><dt><a class=permalink href=#BUS_DMA_LOCK><code class=Dv id=BUS_DMA_LOCK>BUS_DMA_LOCK</code></a></dt><dd>Acquires and/or locks the client locking primitive.</dd><dt><a class=permalink href=#BUS_DMA_UNLOCK><code class=Dv id=BUS_DMA_UNLOCK>BUS_DMA_UNLOCK</code></a></dt><dd>Releases and/or unlocks the client locking primitive.</dd></dl></dd></dl></section><section class=Sh><h2 class=Sh id=FUNCTIONS><a class=permalink href=#FUNCTIONS>FUNCTIONS</a></h2><dl class=Bl-tag><dt><code class=Fn>bus_dma_tag_create</code>(<var class=Fa>parent</var>, <var class=Fa>alignment</var>, <var class=Fa>boundary</var>, <var class=Fa>lowaddr</var>, <var class=Fa>highaddr</var>, <var class=Fa>*filtfunc</var>, <var class=Fa>*filtfuncarg</var>, <var class=Fa>maxsize</var>, <var class=Fa>nsegments</var>, <var class=Fa>maxsegsz</var>, <var class=Fa>flags</var>, <var class=Fa>lockfunc</var>, <var class=Fa>lockfuncarg</var>, <var class=Fa>*dmat</var>)</dt><dd>Allocates a DMA tag, and initializes it according to the arguments provided: <dl class=Bl-tag><dt><var class=Fa>parent</var></dt><dd>A parent tag from which to inherit restrictions. The restrictions passed in other arguments can only further tighten the restrictions inherited from the parent tag. <p class=Pp>All tags created by a device driver must inherit from the tag returned by <code class=Fn>bus_get_dma_tag</code>() to honor restrictions between the parent bridge, CPU memory, and the device.</p></dd><dt><var class=Fa>alignment</var></dt><dd>Alignment constraint, in bytes, of any mappings created using this tag. The alignment must be a power of 2. Hardware that can DMA starting at any address would specify <i class=Em>1</i> for byte alignment. Hardware requiring DMA transfers to start on a multiple of 4K would specify <i class=Em>4096</i>.</dd><dt><var class=Fa>boundary</var></dt><dd>Boundary constraint, in bytes, of the target DMA memory region. The boundary indicates the set of addresses, all multiples of the boundary argument, that cannot be crossed by a single <var class=Vt>bus_dma_segment_t</var>. The boundary must be a power of 2 and must be no smaller than the maximum segment size. ‘<code class=Li>0</code>’ indicates that there are no boundary restrictions.</dd><dt><var class=Fa>lowaddr</var>, <var class=Fa>highaddr</var></dt><dd>Bounds of the window of bus address space that <i class=Em>cannot</i> be directly accessed by the device. The window contains all addresses greater than <var class=Fa>lowaddr</var> and less than or equal to <var class=Fa>highaddr</var>. For example, a device incapable of DMA above 4GB, would specify a <var class=Fa>highaddr</var> of <code class=Dv>BUS_SPACE_MAXADDR</code> and a <var class=Fa>lowaddr</var> of <code class=Dv>BUS_SPACE_MAXADDR_32BIT</code>. Similarly a device that can only perform DMA to addresses below 16MB would specify a <var class=Fa>highaddr</var> of <code class=Dv>BUS_SPACE_MAXADDR</code> and a <var class=Fa>lowaddr</var> of <code class=Dv>BUS_SPACE_MAXADDR_24BIT</code>. Some implementations require that some region of device visible address space, overlapping available host memory, be outside the window. This area of ‘<code class=Li>safe memory</code>’ is used to bounce requests that would otherwise conflict with the exclusion window.</dd><dt><var class=Fa>filtfunc</var></dt><dd>Optional filter function (may be <code class=Dv>NULL</code>) to be called for any attempt to map memory into the window described by <var class=Fa>lowaddr</var> and <var class=Fa>highaddr</var>. A filter function is only required when the single window described by <var class=Fa>lowaddr</var> and <var class=Fa>highaddr</var> cannot adequately describe the constraints of the device. The filter function will be called for every machine page that overlaps the exclusion window.</dd><dt><var class=Fa>filtfuncarg</var></dt><dd>Argument passed to all calls to the filter function for this tag. May be <code class=Dv>NULL</code>.</dd><dt><var class=Fa>maxsize</var></dt><dd>Maximum size, in bytes, of the sum of all segment lengths in a given DMA mapping associated with this tag.</dd><dt><var class=Fa>nsegments</var></dt><dd>Number of discontinuities (scatter/gather segments) allowed in a DMA mapped region. If there is no restriction, <code class=Dv>BUS_SPACE_UNRESTRICTED</code> may be specified.</dd><dt><var class=Fa>maxsegsz</var></dt><dd>Maximum size, in bytes, of a segment in any DMA mapped region associated with <var class=Fa>dmat</var>.</dd><dt><var class=Fa>flags</var></dt><dd>Are as follows: <dl class=Bl-tag><dt><a class=permalink href=#BUS_DMA_ALLOCNOW><code class=Dv id=BUS_DMA_ALLOCNOW>BUS_DMA_ALLOCNOW</code></a></dt><dd>Pre-allocate enough resources to handle at least one map load operation on this tag. If sufficient resources are not available, <code class=Er>ENOMEM</code> is returned. This should not be used for tags that only describe buffers that will be allocated with <code class=Fn>bus_dmamem_alloc</code>(). Also, due to resource sharing with other tags, this flag does not guarantee that resources will be allocated or reserved exclusively for this tag. It should be treated only as a minor optimization.</dd><dt><a class=permalink href=#BUS_DMA_COHERENT><code class=Dv id=BUS_DMA_COHERENT>BUS_DMA_COHERENT</code></a></dt><dd>Indicate that the DMA engine and CPU are cache-coherent. Cached memory may be used to back allocations created by <code class=Fn>bus_dmamem_alloc</code>(). For <code class=Fn>bus_dma_tag_create</code>(), the <code class=Dv>BUS_DMA_COHERENT</code> flag is currently implemented on arm64.</dd></dl></dd><dt><var class=Fa>lockfunc</var></dt><dd>Optional lock manipulation function (may be <code class=Dv>NULL</code>) to be called when busdma needs to manipulate a lock on behalf of the client. If <code class=Dv>NULL</code> is specified, <code class=Fn>dflt_lock</code>() is used.</dd><dt><var class=Fa>lockfuncarg</var></dt><dd>Optional argument to be passed to the function specified by <var class=Fa>lockfunc</var>.</dd><dt><var class=Fa>dmat</var></dt><dd>Pointer to a bus_dma_tag_t where the resulting DMA tag will be stored.</dd></dl><p class=Pp>Returns <code class=Er>ENOMEM</code> if sufficient memory is not available for tag creation or allocating mapping resources.</p></dd><dt><code class=Fn>bus_dma_tag_destroy</code>(<var class=Fa>dmat</var>)</dt><dd>Deallocate the DMA tag <var class=Fa>dmat</var> that was created by <code class=Fn>bus_dma_tag_create</code>(). <p class=Pp>Returns <code class=Er>EBUSY</code> if any DMA maps remain associated with <var class=Fa>dmat</var> or ‘<code class=Li>0</code>’ on success.</p></dd><dt><code class=Fn>bus_dmamap_create</code>(<var class=Fa>dmat</var>, <var class=Fa>flags</var>, <var class=Fa>*mapp</var>)</dt><dd>Allocates and initializes a DMA map. Arguments are as follows: <dl class=Bl-tag><dt><var class=Fa>dmat</var></dt><dd>DMA tag.</dd><dt><var class=Fa>flags</var></dt><dd>Are as follows: <dl class=Bl-tag><dt><a class=permalink href=#BUS_DMA_COHERENT_2><code class=Dv id=BUS_DMA_COHERENT_2>BUS_DMA_COHERENT</code></a></dt><dd>Attempt to map the memory loaded with this map such that cache sync operations are as cheap as possible. This flag is typically set on maps when the memory loaded with these will be accessed by both a CPU and a DMA engine, frequently such as control data and as opposed to streamable data such as receive and transmit buffers. Use of this flag does not remove the requirement of using <code class=Fn>bus_dmamap_sync</code>(), but it may reduce the cost of performing these operations. For <code class=Fn>bus_dmamap_create</code>(), the <code class=Dv>BUS_DMA_COHERENT</code> flag is currently implemented on sparc64.</dd></dl></dd><dt><var class=Fa>mapp</var></dt><dd>Pointer to a <var class=Vt>bus_dmamap_t</var> where the resulting DMA map will be stored.</dd></dl><p class=Pp>Returns <code class=Er>ENOMEM</code> if sufficient memory is not available for creating the map or allocating mapping resources.</p></dd><dt><code class=Fn>bus_dmamap_destroy</code>(<var class=Fa>dmat</var>, <var class=Fa>map</var>)</dt><dd>Frees all resources associated with a given DMA map. Arguments are as follows: <dl class=Bl-tag><dt><var class=Fa>dmat</var></dt><dd>DMA tag used to allocate <var class=Fa>map</var>.</dd><dt><var class=Fa>map</var></dt><dd>The DMA map to destroy.</dd></dl><p class=Pp>Returns <code class=Er>EBUSY</code> if a mapping is still active for <var class=Fa>map</var>.</p></dd><dt><code class=Fn>bus_dmamap_load</code>(<var class=Fa>dmat</var>, <var class=Fa>map</var>, <var class=Fa>buf</var>, <var class=Fa>buflen</var>, <var class=Fa>*callback</var>, <var class=Fa>callback_arg</var>, <var class=Fa>flags</var>)</dt><dd>Creates a mapping in device visible address space of <var class=Fa>buflen</var> bytes of <var class=Fa>buf</var>, associated with the DMA map <var class=Fa>map</var>. This call will always return immediately and will not block for any reason. Arguments are as follows: <dl class=Bl-tag><dt><var class=Fa>dmat</var></dt><dd>DMA tag used to allocate <var class=Fa>map</var>.</dd><dt><var class=Fa>map</var></dt><dd>A DMA map without a currently active mapping.</dd><dt><var class=Fa>buf</var></dt><dd>A kernel virtual address pointer to a contiguous (in KVA) buffer, to be mapped into device visible address space.</dd><dt><var class=Fa>buflen</var></dt><dd>The size of the buffer.</dd><dt><var class=Fa>callback</var><var class=Fa>callback_arg</var></dt><dd>The callback function, and its argument. This function is called once sufficient mapping resources are available for the DMA operation. If resources are temporarily unavailable, this function will be deferred until later, but the load operation will still return immediately to the caller. Thus, callers should not assume that the callback will be called before the load returns, and code should be structured appropriately to handle this. See below for specific flags and error codes that control this behavior.</dd><dt><var class=Fa>flags</var></dt><dd>Are as follows: <dl class=Bl-tag><dt><a class=permalink href=#BUS_DMA_NOWAIT><code class=Dv id=BUS_DMA_NOWAIT>BUS_DMA_NOWAIT</code></a></dt><dd>The load should not be deferred in case of insufficient mapping resources, and instead should return immediately with an appropriate error.</dd><dt><a class=permalink href=#BUS_DMA_NOCACHE><code class=Dv id=BUS_DMA_NOCACHE>BUS_DMA_NOCACHE</code></a></dt><dd>The generated transactions to and from the virtual page are non-cacheable. For <code class=Fn>bus_dmamap_load</code>(), the <code class=Dv>BUS_DMA_NOCACHE</code> flag is currently implemented on sparc64.</dd></dl></dd></dl><p class=Pp>Return values to the caller are as follows:</p><dl class=Bl-tag><dt>0</dt><dd>The callback has been called and completed. The status of the mapping has been delivered to the callback.</dd><dt><code class=Er>EINPROGRESS</code></dt><dd>The mapping has been deferred for lack of resources. The callback will be called as soon as resources are available. Callbacks are serviced in FIFO order. <p class=Pp>Note that subsequent load operations for the same tag that do not require extra resources will still succeed. This may result in out-of-order processing of requests. If the caller requires the order of requests to be preserved, then the caller is required to stall subsequent requests until a pending request's callback is invoked.</p></dd><dt><code class=Er>ENOMEM</code></dt><dd>The load request has failed due to insufficient resources, and the caller specifically used the <code class=Dv>BUS_DMA_NOWAIT</code> flag.</dd><dt><code class=Er>EINVAL</code></dt><dd>The load request was invalid. The callback has been called and has been provided the same error. This error value may indicate that <var class=Fa>dmat</var>, <var class=Fa>map</var>, <var class=Fa>buf</var>, or <var class=Fa>callback</var> were invalid, or <var class=Fa>buflen</var> was larger than the <var class=Fa>maxsize</var> argument used to create the dma tag <var class=Fa>dmat</var>.</dd></dl><p class=Pp>When the callback is called, it is presented with an error value indicating the disposition of the mapping. Error may be one of the following:</p><dl class=Bl-tag><dt>0</dt><dd>The mapping was successful and the <var class=Fa>dm_segs</var> callback argument contains an array of <var class=Vt>bus_dma_segment_t</var> elements describing the mapping. This array is only valid during the scope of the callback function.</dd><dt><code class=Er>EFBIG</code></dt><dd>A mapping could not be achieved within the segment constraints provided in the tag even though the requested allocation size was less than maxsize.</dd></dl></dd><dt><code class=Fn>bus_dmamap_load_bio</code>(<var class=Fa>dmat</var>, <var class=Fa>map</var>, <var class=Fa>bio</var>, <var class=Fa>callback</var>, <var class=Fa>callback_arg</var>, <var class=Fa>flags</var>)</dt><dd>This is a variation of <code class=Fn>bus_dmamap_load</code>() which maps buffers pointed to by <var class=Fa>bio</var> for DMA transfers. <var class=Fa>bio</var> may point to either a mapped or unmapped buffer.</dd><dt><code class=Fn>bus_dmamap_load_ccb</code>(<var class=Fa>dmat</var>, <var class=Fa>map</var>, <var class=Fa>ccb</var>, <var class=Fa>callback</var>, <var class=Fa>callback_arg</var>, <var class=Fa>flags</var>)</dt><dd>This is a variation of <code class=Fn>bus_dmamap_load</code>() which maps data pointed to by <var class=Fa>ccb</var> for DMA transfers. The data for <var class=Fa>ccb</var> may be any of the following types: <dl class=Bl-tag><dt>CAM_DATA_VADDR</dt><dd>The data is a single KVA buffer.</dd><dt>CAM_DATA_PADDR</dt><dd>The data is a single bus address range.</dd><dt>CAM_DATA_SG</dt><dd>The data is a scatter/gather list of KVA buffers.</dd><dt>CAM_DATA_SG_PADDR</dt><dd>The data is a scatter/gather list of bus address ranges.</dd><dt>CAM_DATA_BIO</dt><dd>The data is contained in a <var class=Vt>struct bio</var> attached to the CCB.</dd></dl><p class=Pp><code class=Fn>bus_dmamap_load_ccb</code>() supports the following CCB XPT function codes:</p><p class=Pp></p><ul class="Bl-item Bd-indent Bl-compact"><li>XPT_ATA_IO</li><li>XPT_CONT_TARGET_IO</li><li>XPT_SCSI_IO</li></ul></dd><dt><code class=Fn>bus_dmamap_load_mbuf</code>(<var class=Fa>dmat</var>, <var class=Fa>map</var>, <var class=Fa>mbuf</var>, <var class=Fa>callback2</var>, <var class=Fa>callback_arg</var>, <var class=Fa>flags</var>)</dt><dd>This is a variation of <code class=Fn>bus_dmamap_load</code>() which maps mbuf chains for DMA transfers. A <var class=Vt>bus_size_t</var> argument is also passed to the callback routine, which contains the mbuf chain's packet header length. The <code class=Dv>BUS_DMA_NOWAIT</code> flag is implied, thus no callback deferral will happen. <p class=Pp>Mbuf chains are assumed to be in kernel virtual address space.</p><p class=Pp>Beside the error values listed for <code class=Fn>bus_dmamap_load</code>(), <code class=Er>EINVAL</code> will be returned if the size of the mbuf chain exceeds the maximum limit of the DMA tag.</p></dd><dt><code class=Fn>bus_dmamap_load_mbuf_sg</code>(<var class=Fa>dmat</var>, <var class=Fa>map</var>, <var class=Fa>mbuf</var>, <var class=Fa>segs</var>, <var class=Fa>nsegs</var>, <var class=Fa>flags</var>)</dt><dd>This is just like <code class=Fn>bus_dmamap_load_mbuf</code>() except that it returns immediately without calling a callback function. It is provided for efficiency. The scatter/gather segment array <var class=Va>segs</var> is provided by the caller and filled in directly by the function. The <var class=Va>nsegs</var> argument is returned with the number of segments filled in. Returns the same errors as <code class=Fn>bus_dmamap_load_mbuf</code>().</dd><dt><code class=Fn>bus_dmamap_load_uio</code>(<var class=Fa>dmat</var>, <var class=Fa>map</var>, <var class=Fa>uio</var>, <var class=Fa>callback2</var>, <var class=Fa>callback_arg</var>, <var class=Fa>flags</var>)</dt><dd>This is a variation of <code class=Fn>bus_dmamap_load</code>() which maps buffers pointed to by <var class=Fa>uio</var> for DMA transfers. A <var class=Vt>bus_size_t</var> argument is also passed to the callback routine, which contains the size of <var class=Fa>uio</var>, i.e. <var class=Fa>uio-&gt;uio_resid</var>. The <code class=Dv>BUS_DMA_NOWAIT</code> flag is implied, thus no callback deferral will happen. Returns the same errors as <code class=Fn>bus_dmamap_load</code>(). <p class=Pp>If <var class=Fa>uio-&gt;uio_segflg</var> is <code class=Dv>UIO_USERSPACE</code>, then it is assumed that the buffer, <var class=Fa>uio</var> is in <var class=Fa>uio-&gt;uio_td-&gt;td_proc</var>'s address space. User space memory must be in-core and wired prior to attempting a map load operation. Pages may be locked using <a class=Xr href=vslock.9.html>vslock(9)</a>.</p></dd><dt><code class=Fn>bus_dmamap_unload</code>(<var class=Fa>dmat</var>, <var class=Fa>map</var>)</dt><dd>Unloads a DMA map. Arguments are as follows: <dl class=Bl-tag><dt><var class=Fa>dmat</var></dt><dd>DMA tag used to allocate <var class=Fa>map</var>.</dd><dt><var class=Fa>map</var></dt><dd>The DMA map that is to be unloaded.</dd></dl><p class=Pp><code class=Fn>bus_dmamap_unload</code>() will not perform any implicit synchronization of DMA buffers. This must be done explicitly by a call to <code class=Fn>bus_dmamap_sync</code>() prior to unloading the map.</p></dd><dt><code class=Fn>bus_dmamap_sync</code>(<var class=Fa>dmat</var>, <var class=Fa>map</var>, <var class=Fa>op</var>)</dt><dd>Performs synchronization of a device visible mapping with the CPU visible memory referenced by that mapping. Arguments are as follows: <dl class=Bl-tag><dt><var class=Fa>dmat</var></dt><dd>DMA tag used to allocate <var class=Fa>map</var>.</dd><dt><var class=Fa>map</var></dt><dd>The DMA mapping to be synchronized.</dd><dt><var class=Fa>op</var></dt><dd>Type of synchronization operation to perform. See the definition of <var class=Vt>bus_dmasync_op_t</var> for a description of the acceptable values for <var class=Fa>op</var>.</dd></dl><p class=Pp>The <code class=Fn>bus_dmamap_sync</code>() function is the method used to ensure that CPU's and device's direct memory access (DMA) to shared memory is coherent. For example, the CPU might be used to set up the contents of a buffer that is to be made available to a device. To ensure that the data are visible via the device's mapping of that memory, the buffer must be loaded and a DMA sync operation of <code class=Dv>BUS_DMASYNC_PREWRITE</code> must be performed after the CPU has updated the buffer and before the device access is initiated. If the CPU modifies this buffer again later, another <code class=Dv>BUS_DMASYNC_PREWRITE</code> sync operation must be performed before an additional device access. Conversely, suppose a device updates memory that is to be read by a CPU. In this case, the buffer must be loaded, and a DMA sync operation of <code class=Dv>BUS_DMASYNC_PREREAD</code> must be performed before the device access is initiated. The CPU will only be able to see the results of this memory update once the DMA operation has completed and a <code class=Dv>BUS_DMASYNC_POSTREAD</code> sync operation has been performed.</p><p class=Pp>If read and write operations are not preceded and followed by the appropriate synchronization operations, behavior is undefined.</p></dd><dt><code class=Fn>bus_dmamem_alloc</code>(<var class=Fa>dmat</var>, <var class=Fa>**vaddr</var>, <var class=Fa>flags</var>, <var class=Fa>*mapp</var>)</dt><dd>Allocates memory that is mapped into KVA at the address returned in <var class=Fa>vaddr</var> and that is permanently loaded into the newly created <var class=Vt>bus_dmamap_t</var> returned via <var class=Fa>mapp</var>. Arguments are as follows: <dl class=Bl-tag><dt><var class=Fa>dmat</var></dt><dd>DMA tag describing the constraints of the DMA mapping.</dd><dt><var class=Fa>vaddr</var></dt><dd>Pointer to a pointer that will hold the returned KVA mapping of the allocated region.</dd><dt><var class=Fa>flags</var></dt><dd>Flags are defined as follows: <dl class=Bl-tag><dt><a class=permalink href=#BUS_DMA_WAITOK><code class=Dv id=BUS_DMA_WAITOK>BUS_DMA_WAITOK</code></a></dt><dd>The routine can safely wait (sleep) for resources.</dd><dt><a class=permalink href=#BUS_DMA_NOWAIT_2><code class=Dv id=BUS_DMA_NOWAIT_2>BUS_DMA_NOWAIT</code></a></dt><dd>The routine is not allowed to wait for resources. If resources are not available, <code class=Dv>ENOMEM</code> is returned.</dd><dt><a class=permalink href=#BUS_DMA_COHERENT_3><code class=Dv id=BUS_DMA_COHERENT_3>BUS_DMA_COHERENT</code></a></dt><dd>Attempt to map this memory in a coherent fashion. See <code class=Fn>bus_dmamap_create</code>() above for a description of this flag. For <code class=Fn>bus_dmamem_alloc</code>(), the <code class=Dv>BUS_DMA_COHERENT</code> flag is currently implemented on arm, arm64 and sparc64.</dd><dt><a class=permalink href=#BUS_DMA_ZERO><code class=Dv id=BUS_DMA_ZERO>BUS_DMA_ZERO</code></a></dt><dd>Causes the allocated memory to be set to all zeros.</dd><dt><a class=permalink href=#BUS_DMA_NOCACHE_2><code class=Dv id=BUS_DMA_NOCACHE_2>BUS_DMA_NOCACHE</code></a></dt><dd>The allocated memory will not be cached in the processor caches. All memory accesses appear on the bus and are executed without reordering. For <code class=Fn>bus_dmamem_alloc</code>(), the <code class=Dv>BUS_DMA_NOCACHE</code> flag is currently implemented on amd64 and i386 where it results in the Strong Uncacheable PAT to be set for the allocated virtual address range.</dd></dl></dd><dt><var class=Fa>mapp</var></dt><dd>Pointer to a <var class=Vt>bus_dmamap_t</var> where the resulting DMA map will be stored.</dd></dl><p class=Pp>The size of memory to be allocated is <var class=Fa>maxsize</var> as specified in the call to <code class=Fn>bus_dma_tag_create</code>() for <var class=Fa>dmat</var>.</p><p class=Pp>The current implementation of <code class=Fn>bus_dmamem_alloc</code>() will allocate all requests as a single segment.</p><p class=Pp>An initial load operation is required to obtain the bus address of the allocated memory, and an unload operation is required before freeing the memory, as described below in <code class=Fn>bus_dmamem_free</code>(). Maps are automatically handled by this function and should not be explicitly allocated or destroyed.</p><p class=Pp>Although an explicit load is not required for each access to the memory referenced by the returned map, the synchronization requirements as described in the <code class=Fn>bus_dmamap_sync</code>() section still apply and should be used to achieve portability on architectures without coherent buses.</p><p class=Pp>Returns <code class=Er>ENOMEM</code> if sufficient memory is not available for completing the operation.</p></dd><dt><code class=Fn>bus_dmamem_free</code>(<var class=Fa>dmat</var>, <var class=Fa>*vaddr</var>, <var class=Fa>map</var>)</dt><dd>Frees memory previously allocated by <code class=Fn>bus_dmamem_alloc</code>(). Any mappings will be invalidated. Arguments are as follows: <dl class=Bl-tag><dt><var class=Fa>dmat</var></dt><dd>DMA tag.</dd><dt><var class=Fa>vaddr</var></dt><dd>Kernel virtual address of the memory.</dd><dt><var class=Fa>map</var></dt><dd>DMA map to be invalidated.</dd></dl></dd></dl></section><section class=Sh><h2 class=Sh id=RETURN_VALUES><a class=permalink href=#RETURN_VALUES>RETURN VALUES</a></h2> Behavior is undefined if invalid arguments are passed to any of the above functions. If sufficient resources cannot be allocated for a given transaction, <code class=Er>ENOMEM</code> is returned. All routines that are not of type <var class=Vt>void</var> will return 0 on success or an error code on failure as discussed above. <p class=Pp>All <var class=Vt>void</var> routines will succeed if provided with valid arguments.</p></section><section class=Sh><h2 class=Sh id=LOCKING><a class=permalink href=#LOCKING>LOCKING</a></h2> Two locking protocols are used by <code class=Nm>bus_dma</code>. The first is a private global lock that is used to synchronize access to the bounce buffer pool on the architectures that make use of them. This lock is strictly a leaf lock that is only used internally to <code class=Nm>bus_dma</code> and is not exposed to clients of the API. <p class=Pp>The second protocol involves protecting various resources stored in the tag. Since almost all <code class=Nm>bus_dma</code> operations are done through requests from the driver that created the tag, the most efficient way to protect the tag resources is through the lock that the driver uses. In cases where <code class=Nm>bus_dma</code> acts on its own without being called by the driver, the lock primitive specified in the tag is acquired and released automatically. An example of this is when the <code class=Fn>bus_dmamap_load</code>() callback function is called from a deferred context instead of the driver context. This means that certain <code class=Nm>bus_dma</code> functions must always be called with the same lock held that is specified in the tag. These functions include:</p><p class=Pp></p><ul class="Bl-item Bd-indent Bl-compact"><li><code class=Fn>bus_dmamap_load</code>()</li><li><code class=Fn>bus_dmamap_load_bio</code>()</li><li><code class=Fn>bus_dmamap_load_ccb</code>()</li><li><code class=Fn>bus_dmamap_load_mbuf</code>()</li><li><code class=Fn>bus_dmamap_load_mbuf_sg</code>()</li><li><code class=Fn>bus_dmamap_load_uio</code>()</li><li><code class=Fn>bus_dmamap_unload</code>()</li><li><code class=Fn>bus_dmamap_sync</code>()</li></ul><p class=Pp>There is one exception to this rule. It is common practice to call some of these functions during driver start-up without any locks held. So long as there is a guarantee of no possible concurrent use of the tag by different threads during this operation, it is safe to not hold a lock for these functions.</p><p class=Pp>Certain <code class=Nm>bus_dma</code> operations should not be called with the driver lock held, either because they are already protected by an internal lock, or because they might sleep due to memory or resource allocation. The following functions must not be called with any non-sleepable locks held:</p><p class=Pp></p><ul class="Bl-item Bd-indent Bl-compact"><li><code class=Fn>bus_dma_tag_create</code>()</li><li><code class=Fn>bus_dmamap_create</code>()</li><li><code class=Fn>bus_dmamem_alloc</code>()</li></ul><p class=Pp>All other functions do not have a locking protocol and can thus be called with or without any system or driver locks held.</p></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=devclass.9.html>devclass(9)</a>, <a class=Xr href=device.9.html>device(9)</a>, <a class=Xr href=driver.9.html>driver(9)</a>, <a class=Xr href=rman.9.html>rman(9)</a>, <a class=Xr href=vslock.9.html>vslock(9)</a><p class=Pp></p><p class=Pp><cite class=Rs><span class=RsA>Jason R. Thorpe</span>, <span class=RsT>A Machine-Independent DMA Framework for NetBSD</span>, <i class=RsJ>Proceedings of the Summer 1998 USENIX Technical Conference</i>, <span class=RsQ>USENIX Association</span>, <span class=RsD>June 1998</span>.</cite></p></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> The <code class=Nm>bus_dma</code> interface first appeared in <span class=Ux>NetBSD 1.3</span>. <p class=Pp>The <code class=Nm>bus_dma</code> API was adopted from <span class=Ux>NetBSD</span> for use in the CAM SCSI subsystem. The alterations to the original API were aimed to remove the need for a <var class=Vt>bus_dma_segment_t</var> array stored in each <var class=Vt>bus_dmamap_t</var> while allowing callers to queue up on scarce resources.</p></section><section class=Sh><h2 class=Sh id=AUTHORS><a class=permalink href=#AUTHORS>AUTHORS</a></h2> The <code class=Nm>bus_dma</code> interface was designed and implemented by <span class=An>Jason R. Thorpe</span> of the Numerical Aerospace Simulation Facility, NASA Ames Research Center. Additional input on the <code class=Nm>bus_dma</code> design was provided by <span class=An>Chris Demetriou</span>, <span class=An>Charles Hannum</span>, <span class=An>Ross Harvey</span>, <span class=An>Matthew Jacob</span>, <span class=An>Jonathan Stone</span>, and <span class=An>Matt Thomas</span>. <p class=Pp>The <code class=Nm>bus_dma</code> interface in <span class=Ux>FreeBSD</span> benefits from the contributions of <span class=An>Justin T. Gibbs</span>, <span class=An>Peter Wemm</span>, <span class=An>Doug Rabson</span>, <span class=An>Matthew N. Dodd</span>, <span class=An>Sam Leffler</span>, <span class=An>Maxime Henrion</span>, <span class=An>Jake Burkholder</span>, <span class=An>Takahashi Yoshihiro</span>, <span class=An>Scott Long</span> and many others.</p><p class=Pp>This manual page was written by <span class=An>Hiten M. Pandya</span> and <span class=An>Justin T. Gibbs</span>.</p></section></div><table class=foot><tr><td class=foot-date>August 11, 2018</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>