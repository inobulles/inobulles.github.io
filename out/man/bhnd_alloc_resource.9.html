<!DOCTYPE html>
<html><head><meta charset=utf-8><title>bhnd_alloc_resource(9)</title><keywords content=man,bhnd_alloc_resource></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>bhnd_alloc_resource(9)</h1><table class=head><tr><td class=head-ltitle>BHND(9)</td><td class=head-vol>FreeBSD Kernel Developer's Manual</td><td class=head-rtitle>BHND(9)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>bhnd</code> — <div class=Nd>BHND driver programming interface</div></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/dev/bhnd/bhnd.h.html>dev/bhnd/bhnd.h</a>&gt;</code><section class=Ss><h2 class=Ss id=Bus_Resource_Functions><a class=permalink href=#Bus_Resource_Functions>Bus Resource Functions</a></h2><var class=Ft>int</var><br><code class=Fn>bhnd_activate_resource</code>(<var class=Fa>device_t dev</var>, <var class=Fa>int type</var>, <var class=Fa>int rid</var>, <var class=Fa>struct bhnd_resource *r</var>); <p class=Pp><var class=Ft>struct bhnd_resource *</var><br><code class=Fn>bhnd_alloc_resource</code>(<var class=Fa>device_t dev</var>, <var class=Fa>int type</var>, <var class=Fa>int *rid</var>, <var class=Fa>rman_res_t start</var>, <var class=Fa>rman_res_t end</var>, <var class=Fa>rman_res_t count</var>, <var class=Fa>u_int flags</var>);</p><p class=Pp><var class=Ft>struct bhnd_resource *</var><br><code class=Fn>bhnd_alloc_resource_any</code>(<var class=Fa>device_t dev</var>, <var class=Fa>int type</var>, <var class=Fa>int *rid</var>, <var class=Fa>u_int flags</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_alloc_resources</code>(<var class=Fa>device_t dev</var>, <var class=Fa>struct resource_spec *rs</var>, <var class=Fa>struct bhnd_resource **res</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_deactivate_resource</code>(<var class=Fa>device_t dev</var>, <var class=Fa>int type</var>, <var class=Fa>int rid</var>, <var class=Fa>struct bhnd_resource *r</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_release_resource</code>(<var class=Fa>device_t dev</var>, <var class=Fa>int type</var>, <var class=Fa>int rid</var>, <var class=Fa>struct bhnd_resource *r</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_release_resources</code>(<var class=Fa>device_t dev</var>, <var class=Fa>const struct resource_spec *rs</var>, <var class=Fa>struct bhnd_resource **res</var>);</p></section><section class=Ss><h2 class=Ss id=Bus_Space_Functions><a class=permalink href=#Bus_Space_Functions>Bus Space Functions</a></h2><var class=Ft>void</var><br><code class=Fn>bhnd_bus_barrier</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>bus_size_t length</var>, <var class=Fa>int flags</var>); <p class=Pp><var class=Ft>uint8_t</var><br><code class=Fn>bhnd_bus_read_1</code>(<var class=Fa style="white-space: nowrap;">struct bhnd_resource *r</var>, <var class=Fa style="white-space: nowrap;">bus_size_t offset</var>);</p><p class=Pp><var class=Ft>uint16_t</var><br><code class=Fn>bhnd_bus_read_2</code>(<var class=Fa style="white-space: nowrap;">struct bhnd_resource *r</var>, <var class=Fa style="white-space: nowrap;">bus_size_t offset</var>);</p><p class=Pp><var class=Ft>uint32_t</var><br><code class=Fn>bhnd_bus_read_4</code>(<var class=Fa style="white-space: nowrap;">struct bhnd_resource *r</var>, <var class=Fa style="white-space: nowrap;">bus_size_t offset</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_read_multi_1</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint8_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_read_multi_2</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint16_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_read_multi_4</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint32_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_read_multi_stream_1</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint8_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_read_multi_stream_2</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint16_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_read_multi_stream_4</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint32_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_read_region_1</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint8_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_read_region_2</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint16_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_read_region_4</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint32_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_read_region_stream_1</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint8_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_read_region_stream_2</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint16_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_read_region_stream_4</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint32_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_read_stream_1</code>(<var class=Fa style="white-space: nowrap;">struct bhnd_resource *r</var>, <var class=Fa style="white-space: nowrap;">bus_size_t offset</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_read_stream_2</code>(<var class=Fa style="white-space: nowrap;">struct bhnd_resource *r</var>, <var class=Fa style="white-space: nowrap;">bus_size_t offset</var>);</p><p class=Pp><var class=Ft>uint32_t</var><br><code class=Fn>bhnd_bus_read_stream_4</code>(<var class=Fa style="white-space: nowrap;">struct bhnd_resource *r</var>, <var class=Fa style="white-space: nowrap;">bus_size_t offset</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_set_multi_1</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint8_t value</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_set_multi_2</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint16_t value</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_set_multi_4</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint32_t value</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_set_region_1</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint8_t value</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_set_region_2</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint16_t value</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_set_region_4</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint32_t value</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_write_1</code>(<var class=Fa style="white-space: nowrap;">struct bhnd_resource *r</var>, <var class=Fa style="white-space: nowrap;">uint8_t value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_write_2</code>(<var class=Fa style="white-space: nowrap;">struct bhnd_resource *r</var>, <var class=Fa style="white-space: nowrap;">uint16_t value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_write_4</code>(<var class=Fa style="white-space: nowrap;">struct bhnd_resource *r</var>, <var class=Fa style="white-space: nowrap;">uint32_t value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_write_multi_1</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint8_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_write_multi_2</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint16_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_write_multi_4</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint32_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_write_multi_stream_1</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint8_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_write_multi_stream_2</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint16_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_write_multi_stream_4</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint32_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_write_region_1</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint8_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_write_region_2</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint16_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_write_region_4</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint32_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_write_region_stream_1</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint8_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_write_region_stream_2</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint16_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_write_region_stream_4</code>(<var class=Fa>struct bhnd_resource *r</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint32_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_write_stream_1</code>(<var class=Fa style="white-space: nowrap;">struct bhnd_resource *r</var>, <var class=Fa style="white-space: nowrap;">uint8_t value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_write_stream_2</code>(<var class=Fa style="white-space: nowrap;">struct bhnd_resource *r</var>, <var class=Fa style="white-space: nowrap;">uint16_t value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_bus_write_stream_4</code>(<var class=Fa style="white-space: nowrap;">struct bhnd_resource *r</var>, <var class=Fa style="white-space: nowrap;">uint32_t value</var>);</p></section><section class=Ss><h2 class=Ss id=Device_Configuration_Functions><a class=permalink href=#Device_Configuration_Functions>Device Configuration Functions</a></h2><var class=Ft>int</var><br><code class=Fn>bhnd_read_ioctl</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">uint16_t *ioctl</var>); <p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_write_ioctl</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">uint16_t value</var>, <var class=Fa style="white-space: nowrap;">uint16_t mask</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_read_iost</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">uint16_t *iost</var>);</p><p class=Pp><var class=Ft>uint32_t</var><br><code class=Fn>bhnd_read_config</code>(<var class=Fa>device_t dev</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>void *value</var>, <var class=Fa>u_int width</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_write_config</code>(<var class=Fa>device_t dev</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>const void *value</var>, <var class=Fa>u_int width</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_reset_hw</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">uint16_t ioctl</var>, <var class=Fa style="white-space: nowrap;">uint16_t reset_ioctl</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_suspend_hw</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">uint16_t ioctl</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>bhnd_is_hw_suspended</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>);</p></section><section class=Ss><h2 class=Ss id=Device_Information_Functions><a class=permalink href=#Device_Information_Functions>Device Information Functions</a></h2><var class=Ft>bhnd_attach_type</var><br><code class=Fn>bhnd_get_attach_type</code>(<var class=Fa>device_t dev</var>); <p class=Pp><var class=Ft>const struct bhnd_chipid *</var><br><code class=Fn>bhnd_get_chipid</code>(<var class=Fa>device_t dev</var>);</p><p class=Pp><var class=Ft>bhnd_devclass_t</var><br><code class=Fn>bhnd_get_class</code>(<var class=Fa>device_t dev</var>);</p><p class=Pp><var class=Ft>u_int</var><br><code class=Fn>bhnd_get_core_index</code>(<var class=Fa>device_t dev</var>);</p><p class=Pp><var class=Ft>struct bhnd_core_info</var><br><code class=Fn>bhnd_get_core_info</code>(<var class=Fa>device_t dev</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_get_core_unit</code>(<var class=Fa>device_t dev</var>);</p><p class=Pp><var class=Ft>uint16_t</var><br><code class=Fn>bhnd_get_device</code>(<var class=Fa>device_t dev</var>);</p><p class=Pp><var class=Ft>const char *</var><br><code class=Fn>bhnd_get_device_name</code>(<var class=Fa>device_t dev</var>);</p><p class=Pp><var class=Ft>uint8_t</var><br><code class=Fn>bhnd_get_hwrev</code>(<var class=Fa>device_t dev</var>);</p><p class=Pp><var class=Ft>uint16_t</var><br><code class=Fn>bhnd_get_vendor</code>(<var class=Fa>device_t dev</var>);</p><p class=Pp><var class=Ft>const char *</var><br><code class=Fn>bhnd_get_vendor_name</code>(<var class=Fa>device_t dev</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_read_board_info</code>(<var class=Fa>device_t dev</var>, <var class=Fa>struct bhnd_board_info *info</var>);</p></section><section class=Ss><h2 class=Ss id=Device_Matching_Functions><a class=permalink href=#Device_Matching_Functions>Device Matching Functions</a></h2><var class=Ft>bool</var><br><code class=Fn>bhnd_board_matches</code>(<var class=Fa>const struct bhnd_board_info *board</var>, <var class=Fa>const struct bhnd_board_match *desc</var>); <p class=Pp><var class=Ft>device_t</var><br><code class=Fn>bhnd_bus_match_child</code>(<var class=Fa>device_t bus</var>, <var class=Fa>const struct bhnd_core_match *desc</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>bhnd_chip_matches</code>(<var class=Fa>const struct bhnd_chipid *chip</var>, <var class=Fa>const struct bhnd_chip_match *desc</var>);</p><p class=Pp><var class=Ft>struct bhnd_core_match</var><br><code class=Fn>bhnd_core_get_match_desc</code>(<var class=Fa>const struct bhnd_core_info *core</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>bhnd_core_matches</code>(<var class=Fa>const struct bhnd_core_info *core</var>, <var class=Fa>const struct bhnd_core_match *desc</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>bhnd_cores_equal</code>(<var class=Fa>const struct bhnd_core_info *lhs</var>, <var class=Fa>const struct bhnd_core_info *rhs</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>bhnd_hwrev_matches</code>(<var class=Fa>uint16_t hwrev</var>, <var class=Fa>const struct bhnd_hwrev_match *desc</var>);</p><p class=Pp><var class=Ft>const struct bhnd_core_info *</var><br><code class=Fn>bhnd_match_core</code>(<var class=Fa>const struct bhnd_core_info *cores</var>, <var class=Fa>u_int num_cores</var>, <var class=Fa>const struct bhnd_core_match *desc</var>);</p></section><section class=Ss><h2 class=Ss id=Device_Table_Functions><a class=permalink href=#Device_Table_Functions>Device Table Functions</a></h2><var class=Ft>const struct bhnd_device *</var><br><code class=Fn>bhnd_device_lookup</code>(<var class=Fa>device_t dev</var>, <var class=Fa>const struct bhnd_device *table</var>, <var class=Fa>size_t entry_size</var>); <p class=Pp><var class=Ft>bool</var><br><code class=Fn>bhnd_device_matches</code>(<var class=Fa>device_t dev</var>, <var class=Fa>const struct bhnd_device_match *desc</var>);</p><p class=Pp><var class=Ft>uint32_t</var><br><code class=Fn>bhnd_device_quirks</code>(<var class=Fa>device_t dev</var>, <var class=Fa>const struct bhnd_device *table</var>, <var class=Fa>size_t entry_size</var>);</p><p class=Pp><code class=Fn>BHND_BOARD_QUIRK</code>(<var class=Fa>board</var>, <var class=Fa>flags</var>);</p><p class=Pp><code class=Fn>BHND_CHIP_QUIRK</code>(<var class=Fa>chip</var>, <var class=Fa>hwrev</var>, <var class=Fa>flags</var>);</p><p class=Pp><code class=Fn>BHND_CORE_QUIRK</code>(<var class=Fa>hwrev</var>, <var class=Fa>flags</var>);</p><p class=Pp><code class=Fn>BHND_DEVICE</code>(<var class=Fa>vendor</var>, <var class=Fa>device</var>, <var class=Fa>desc</var>, <var class=Fa>quirks</var>, <var class=Fa>...</var>);</p><p class=Pp><code class=Fn>BHND_DEVICE_IS_END</code>(<var class=Fa>struct bhnd_device *d</var>);</p><p class=Pp><code class=Fn>BHND_DEVICE_QUIRK_IS_END</code>(<var class=Fa>struct bhnd_device_quirk *q</var>);</p><p class=Pp><code class=Fn>BHND_PKG_QUIRK</code>(<var class=Fa>chip</var>, <var class=Fa>pkg</var>, <var class=Fa>flags</var>);</p><div class="Bd Pp"><pre>
struct bhnd_device_quirk {
	struct bhnd_device_match	desc;
	uint32_t			quirks;
};
</pre></div><div class="Bd Pp"><pre>
struct bhnd_device {
    const struct bhnd_device_match	 core;
    const char				*desc;
    const struct bhnd_device_quirk	*quirks_table;
    uint32_t				 device_flags;
};
</pre></div><div class="Bd Pp"><pre>
enum {
	BHND_DF_ANY	= 0,
	BHND_DF_HOSTB	= (1 &lt;&lt; 0),
	BHND_DF_SOC	= (1 &lt;&lt; 1),
	BHND_DF_ADAPTER	= (1 &lt;&lt; 2)
};
</pre></div><div class="Bd Pp"><pre>
#define BHND_DEVICE_END { { BHND_MATCH_ANY }, NULL, NULL, 0 }
</pre></div><div class="Bd Pp"><pre>
#define BHND_DEVICE_QUIRK_END { { BHND_MATCH_ANY }, 0 }
</pre></div></section><section class=Ss><h2 class=Ss id=DMA_Address_Translation_Functions><a class=permalink href=#DMA_Address_Translation_Functions>DMA Address Translation Functions</a></h2><var class=Ft>int</var><br><code class=Fn>bhnd_get_dma_translation</code>(<var class=Fa>device_t dev</var>, <var class=Fa>u_int width</var>, <var class=Fa>uint32_t flags</var>, <var class=Fa>bus_dma_tag_t *dmat</var>, <var class=Fa>struct bhnd_dma_translation *translation</var>); <div class="Bd Pp"><pre>
struct bhnd_dma_translation {
	bhnd_addr_t	base_addr;
	bhnd_addr_t	addr_mask;
	bhnd_addr_t	addrext_mask;
	uint32_t	flags;
};
</pre></div><div class="Bd Pp"><pre>
typedef enum {
	BHND_DMA_ADDR_30BIT	= 30,
	BHND_DMA_ADDR_32BIT	= 32,
	BHND_DMA_ADDR_64BIT	= 64
} bhnd_dma_addrwidth;
</pre></div><div class="Bd Pp"><pre>
enum bhnd_dma_translation_flags {
	BHND_DMA_TRANSLATION_PHYSMAP		= (1&lt;&lt;0),
	BHND_DMA_TRANSLATION_BYTESWAPPED	= (1&lt;&lt;1)
};
</pre></div></section><section class=Ss><h2 class=Ss id=Interrupt_Functions><a class=permalink href=#Interrupt_Functions>Interrupt Functions</a></h2><var class=Ft>u_int</var><br><code class=Fn>bhnd_get_intr_count</code>(<var class=Fa>device_t dev</var>); <p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_get_intr_ivec</code>(<var class=Fa>device_t dev</var>, <var class=Fa>u_int intr</var>, <var class=Fa>u_int *ivec</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_map_intr</code>(<var class=Fa>device_t dev</var>, <var class=Fa>u_int intr</var>, <var class=Fa>rman_res_t *irq</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_unmap_intr</code>(<var class=Fa>device_t dev</var>, <var class=Fa>rman_res_t irq</var>);</p></section><section class=Ss><h2 class=Ss id=NVRAM_Functions><a class=permalink href=#NVRAM_Functions>NVRAM Functions</a></h2><var class=Ft>int</var><br><code class=Fn>bhnd_nvram_getvar</code>(<var class=Fa>device_t dev</var>, <var class=Fa>const char *name</var>, <var class=Fa>void *buf</var>, <var class=Fa>size_t *len</var>, <var class=Fa>bhnd_nvram_type type</var>); <p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_nvram_getvar_array</code>(<var class=Fa>device_t dev</var>, <var class=Fa>const char *name</var>, <var class=Fa>void *buf</var>, <var class=Fa>size_t size</var>, <var class=Fa>bhnd_nvram_type type</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_nvram_getvar_int</code>(<var class=Fa>device_t dev</var>, <var class=Fa>const char *name</var>, <var class=Fa>void *value</var>, <var class=Fa>int width</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_nvram_getvar_int8</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">int8_t *value</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_nvram_getvar_int16</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">int16_t *value</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_nvram_getvar_int32</code>(<var class=Fa style="white-space: nowrap;">device_t dev</var>, <var class=Fa style="white-space: nowrap;">const char *name</var>, <var class=Fa style="white-space: nowrap;">int32_t *value</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_nvram_getvar_uint</code>(<var class=Fa>device_t dev</var>, <var class=Fa>const char *name</var>, <var class=Fa>void *value</var>, <var class=Fa>int width</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_nvram_getvar_uint8</code>(<var class=Fa>device_t dev</var>, <var class=Fa>const char *name</var>, <var class=Fa>uint8_t *value</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_nvram_getvar_uint16</code>(<var class=Fa>device_t dev</var>, <var class=Fa>const char *name</var>, <var class=Fa>uint16_t *value</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_nvram_getvar_uint32</code>(<var class=Fa>device_t dev</var>, <var class=Fa>const char *name</var>, <var class=Fa>uint32_t *value</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_nvram_getvar_str</code>(<var class=Fa>device_t dev</var>, <var class=Fa>const char *name</var>, <var class=Fa>char *buf</var>, <var class=Fa>size_t len</var>, <var class=Fa>size_t *rlen</var>);</p><p class=Pp><var class=Ft>const char *</var><br><code class=Fn>bhnd_nvram_string_array_next</code>(<var class=Fa>const char *inp</var>, <var class=Fa>size_t ilen</var>, <var class=Fa>const char *prev</var>, <var class=Fa>size_t *olen</var>);</p><div class="Bd Pp"><pre>
typedef enum {
	BHND_NVRAM_TYPE_UINT8		= 0,
	BHND_NVRAM_TYPE_UINT16		= 1,
	BHND_NVRAM_TYPE_UINT32		= 2,
	BHND_NVRAM_TYPE_UINT64		= 3,
	BHND_NVRAM_TYPE_INT8		= 4,
	BHND_NVRAM_TYPE_INT16		= 5,
	BHND_NVRAM_TYPE_INT32		= 6,
	BHND_NVRAM_TYPE_INT64		= 7,
	BHND_NVRAM_TYPE_CHAR		= 8,
	BHND_NVRAM_TYPE_STRING		= 9,
	BHND_NVRAM_TYPE_BOOL		= 10,
	BHND_NVRAM_TYPE_NULL		= 11,
	BHND_NVRAM_TYPE_DATA		= 12
	BHND_NVRAM_TYPE_UINT8_ARRAY	= 16,
	BHND_NVRAM_TYPE_UINT16_ARRAY	= 17,
	BHND_NVRAM_TYPE_UINT32_ARRAY	= 18,
	BHND_NVRAM_TYPE_UINT64_ARRAY	= 19,
	BHND_NVRAM_TYPE_INT8_ARRAY	= 20,
	BHND_NVRAM_TYPE_INT16_ARRAY	= 21,
	BHND_NVRAM_TYPE_INT32_ARRAY	= 22,
	BHND_NVRAM_TYPE_INT64_ARRAY	= 23,
	BHND_NVRAM_TYPE_CHAR_ARRAY	= 24,
	BHND_NVRAM_TYPE_STRING_ARRAY	= 25,
	BHND_NVRAM_TYPE_BOOL_ARRAY	= 26
} bhnd_nvram_type;
</pre></div></section><section class=Ss><h2 class=Ss id=Port/Region_Functions><a class=permalink href=#Port/Region_Functions>Port/Region Functions</a></h2><var class=Ft>int</var><br><code class=Fn>bhnd_decode_port_rid</code>(<var class=Fa>device_t dev</var>, <var class=Fa>int type</var>, <var class=Fa>int rid</var>, <var class=Fa>bhnd_port_type *port_type</var>, <var class=Fa>u_int *port</var>, <var class=Fa>u_int *region</var>); <p class=Pp><var class=Ft>u_int</var><br><code class=Fn>bhnd_get_port_count</code>(<var class=Fa>device_t dev</var>, <var class=Fa>bhnd_port_type type</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_get_port_rid</code>(<var class=Fa>device_t dev</var>, <var class=Fa>bhnd_port_type type</var>, <var class=Fa>u_int port</var>, <var class=Fa>u_int region</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_get_region_addr</code>(<var class=Fa>device_t dev</var>, <var class=Fa>bhnd_port_type port_type</var>, <var class=Fa>u_int port</var>, <var class=Fa>u_int region</var>, <var class=Fa>bhnd_addr_t *region_addr</var>, <var class=Fa>bhnd_size_t *region_size</var>);</p><p class=Pp><var class=Ft>u_int</var><br><code class=Fn>bhnd_get_region_count</code>(<var class=Fa>device_t dev</var>, <var class=Fa>bhnd_port_type type</var>, <var class=Fa>u_int port</var>);</p><p class=Pp><var class=Ft>bool</var><br><code class=Fn>bhnd_is_region_valid</code>(<var class=Fa>device_t dev</var>, <var class=Fa>bhnd_port_type type</var>, <var class=Fa>u_int port</var>, <var class=Fa>u_int region</var>);</p><div class="Bd Pp"><pre>
typedef enum {
	BHND_PORT_DEVICE	= 0,
	BHND_PORT_BRIDGE	= 1,
	BHND_PORT_AGENT		= 2
} bhnd_port_type;
</pre></div></section><section class=Ss><h2 class=Ss id=Power_Management_Functions><a class=permalink href=#Power_Management_Functions>Power Management Functions</a></h2><var class=Ft>int</var><br><code class=Fn>bhnd_alloc_pmu</code>(<var class=Fa>device_t dev</var>); <p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_release_pmu</code>(<var class=Fa>device_t dev</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_enable_clocks</code>(<var class=Fa>device_t dev</var>, <var class=Fa>uint32_t clocks</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_request_clock</code>(<var class=Fa>device_t dev</var>, <var class=Fa>bhnd_clock clock</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_get_clock_freq</code>(<var class=Fa>device_t dev</var>, <var class=Fa>bhnd_clock clock</var>, <var class=Fa>u_int *freq</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_get_clock_latency</code>(<var class=Fa>device_t dev</var>, <var class=Fa>bhnd_clock clock</var>, <var class=Fa>u_int *latency</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_request_ext_rsrc</code>(<var class=Fa>device_t dev</var>, <var class=Fa>u_int rsrc</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_release_ext_rsrc</code>(<var class=Fa>device_t dev</var>, <var class=Fa>u_int rsrc</var>);</p><div class="Bd Pp"><pre>
typedef enum {
	BHND_CLOCK_DYN	= (1 &lt;&lt; 0),
	BHND_CLOCK_ILP	= (1 &lt;&lt; 1),
	BHND_CLOCK_ALP	= (1 &lt;&lt; 2),
	BHND_CLOCK_HT	= (1 &lt;&lt; 3)
} bhnd_clock;
</pre></div></section><section class=Ss><h2 class=Ss id=Service_Provider_Functions><a class=permalink href=#Service_Provider_Functions>Service Provider Functions</a></h2><var class=Ft>int</var><br><code class=Fn>bhnd_register_provider</code>(<var class=Fa>device_t dev</var>, <var class=Fa>bhnd_service_t service</var>); <p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_deregister_provider</code>(<var class=Fa>device_t dev</var>, <var class=Fa>bhnd_service_t service</var>);</p><p class=Pp><var class=Ft>device_t</var><br><code class=Fn>bhnd_retain_provider</code>(<var class=Fa>device_t dev</var>, <var class=Fa>bhnd_service_t service</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_release_provider</code>(<var class=Fa>device_t dev</var>, <var class=Fa>device_t provider</var>, <var class=Fa>bhnd_service_t service</var>);</p><div class="Bd Pp"><pre>
typedef enum {
	BHND_SERVICE_CHIPC,
	BHND_SERVICE_PWRCTL,
	BHND_SERVICE_PMU,
	BHND_SERVICE_NVRAM,
	BHND_SERVICE_GPIO,
	BHND_SERVICE_ANY	= 1000
} bhnd_service_t;
</pre></div></section><section class=Ss><h2 class=Ss id=Utility_Functions><a class=permalink href=#Utility_Functions>Utility Functions</a></h2><var class=Ft>bhnd_erom_class_t *</var><br><code class=Fn>bhnd_driver_get_erom_class</code>(<var class=Fa>driver_t *driver</var>); <p class=Pp><var class=Ft>bhnd_devclass_t</var><br><code class=Fn>bhnd_find_core_class</code>(<var class=Fa>uint16_t vendor</var>, <var class=Fa>uint16_t device</var>);</p><p class=Pp><var class=Ft>const char *</var><br><code class=Fn>bhnd_find_core_name</code>(<var class=Fa>uint16_t vendor</var>, <var class=Fa>uint16_t device</var>);</p><p class=Pp><var class=Ft>bhnd_devclass_t</var><br><code class=Fn>bhnd_core_class</code>(<var class=Fa>const struct bhnd_core_info *ci</var>);</p><p class=Pp><var class=Ft>const char *</var><br><code class=Fn>bhnd_core_name</code>(<var class=Fa>const struct bhnd_core_info *ci</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bhnd_format_chip_id</code>(<var class=Fa>char *buffer</var>, <var class=Fa>size_t size</var>, <var class=Fa>uint16_t chip_id</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_set_custom_core_desc</code>(<var class=Fa>device_t dev</var>, <var class=Fa>const char *dev_name</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bhnd_set_default_core_desc</code>(<var class=Fa>device_t dev</var>);</p><p class=Pp><var class=Ft>const char *</var><br><code class=Fn>bhnd_vendor_name</code>(<var class=Fa>uint16_t vendor</var>);</p><div class="Bd Pp"><pre>
#define	BHND_CHIPID_MAX_NAMELEN	32
</pre></div></section></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2><code class=Nm>bhnd</code> provides a unified bus and driver programming interface for the on-chip interconnects and IP cores found in Broadcom Home Networking Division (BHND) devices. <p class=Pp>The BHND device family consists of MIPS/ARM SoCs (System On a Chip) and host-connected chipsets based on a common library of Broadcom IP cores, connected via one of two on-chip backplane (hardware bus) architectures.</p><p class=Pp>Hardware designed prior to 2009 used Broadcom's “SSB” backplane architecture, based on Sonics Silicon's interconnect IP. Each core on the Sonics backplane vends a 4 KiB register block, containing both device-specific CSRs, and SSB-specific per-core device management (enable/reset/etc) registers.</p><p class=Pp>Subsequent hardware is based on Broadcom's “BCMA” backplane, based on ARM's AMBA IP. The IP cores used in earlier SSB-based devices were adapted for compatibility with the new backplane, with additional “wrapper” cores providing per-core device management functions in place of the SSB per-core management registers.</p><p class=Pp>When BHND hardware is used as a host-connected peripheral (e.g., in a PCI Wi-Fi card), the on-chip peripheral controller core is configured to operate as an endpoint device, bridging access to the SoC hardware:</p><ul class="Bl-dash Bd-indent"><li>Host access to SoC address space is provided via a set of register windows (e.g., a set of configurable windows into SoC address space mapped via PCI BARs)</li><li>DMA is supported by the bridge core's sparse mapping of host address space into the backplane address space. These address regions may be used as a target for the on-chip DMA engine.</li><li>Any backplane interrupt vectors routed to the bridge core may be mapped by the bridge to host interrupts (e.g., PCI INTx/MSI/MSI-X).</li></ul><p class=Pp>The <code class=Nm>bhnd</code> driver programming interface — and <a class=Xr href=bhndb.4.html>bhndb(4)</a> host bridge drivers — support the implementation of common drivers for Broadcom IP cores, whether attached via a BHND host bridge, or via the native SoC backplane.</p><section class=Ss><h2 class=Ss id=Bus_Resource_Functions_2><a class=permalink href=#Bus_Resource_Functions_2>Bus Resource Functions</a></h2> The bhnd_resource functions are wrappers for the standard <var class=Vt>struct resource</var> bus APIs, providing support for <var class=Vt>SYS_RES_MEMORY</var> resources that, on <a class=Xr href=bhndb.4.html>bhndb(4)</a> bridged chipsets, may require on-demand remapping of address windows prior to accessing bus memory. <p class=Pp>These functions are primarily used in the implementation of BHND platform device drivers that, on host-connected peripherals, must share a small set of register windows during initial setup and teardown.</p><p class=Pp>BHND peripherals are designed to not require register window remapping during normal operation, and most drivers may safely use the standard <var class=Vt>struct resource</var> APIs directly.</p><p class=Pp>The <code class=Fn>bhnd_activate_resource</code>() function activates a previously allocated resource.</p><p class=Pp>The arguments are as follows:</p><dl class=Bl-tag><dt><var class=Fa>dev</var></dt><dd>The device holding ownership of the allocated resource.</dd><dt><var class=Fa>type</var></dt><dd>The type of the resource.</dd><dt><var class=Fa>rid</var></dt><dd>The bus-specific handle that identifies the resource being activated.</dd><dt><var class=Fa>r</var></dt><dd>A pointer to the resource returned by <code class=Fn>bhnd_alloc_resource</code>().</dd></dl><p class=Pp>The <code class=Fn>bhnd_alloc_resource</code>() function allocates a resource from a device's parent <a class=Xr href=bhnd.4.html>bhnd(4)</a> bus.</p><p class=Pp>The arguments are as follows:</p><dl class=Bl-tag><dt><var class=Fa>dev</var></dt><dd>The device requesting resource ownership.</dd><dt><var class=Fa>type</var></dt><dd>The type of resource to allocate. This may be any type supported by the standard <a class=Xr href=bus_alloc_resource.9.html>bus_alloc_resource(9)</a> function.</dd><dt><var class=Fa>rid</var></dt><dd>The bus-specific handle identifying the resource being allocated.</dd><dt><var class=Fa>start</var></dt><dd>The start address of the resource.</dd><dt><var class=Fa>end</var></dt><dd>The end address of the resource.</dd><dt><var class=Fa>count</var></dt><dd>The size of the resource.</dd><dt><var class=Fa>flags</var></dt><dd>The flags for the resource to be allocated. These may be any values supported by the standard <a class=Xr href=bus_alloc_resource.9.html>bus_alloc_resource(9)</a> function.</dd></dl><p class=Pp>To request that the bus supply the resource's default <var class=Fa>start</var>, <var class=Fa>end</var>, and <var class=Fa>count</var> values, pass <var class=Fa>start</var> and <var class=Fa>end</var> values of 0ul and ~0ul respectively, and a <var class=Fa>count</var> of 1.</p><p class=Pp>The <code class=Fn>bhnd_alloc_resource_any</code>() function is a convenience wrapper for <code class=Fn>bhnd_alloc_resource</code>(), using the resource's default <var class=Fa>start</var>, <var class=Fa>end</var>, and <var class=Fa>count</var> values.</p><p class=Pp>The arguments are as follows:</p><dl class=Bl-tag><dt><var class=Fa>dev</var></dt><dd>The device requesting resource ownership.</dd><dt><var class=Fa>type</var></dt><dd>The type of resource to allocate. This may be any type supported by the standard <a class=Xr href=bus_alloc_resource.9.html>bus_alloc_resource(9)</a> function.</dd><dt><var class=Fa>rid</var></dt><dd>The bus-specific handle identifying the resource being allocated.</dd><dt><var class=Fa>flags</var></dt><dd>The flags for the resource to be allocated. These may be any values supported by the standard <a class=Xr href=bus_alloc_resource.9.html>bus_alloc_resource(9)</a> function.</dd></dl><p class=Pp>The <code class=Fn>bhnd_alloc_resources</code>() function allocates resources defined in resource specification from a device's parent <a class=Xr href=bhnd.4.html>bhnd(4)</a> bus.</p><p class=Pp>The arguments are as follows:</p><dl class=Bl-tag><dt><var class=Fa>dev</var></dt><dd>The device requesting ownership of the resources.</dd><dt><var class=Fa>rs</var></dt><dd>A standard bus resource specification. If all requested resources, are successfully allocated, this will be updated with the allocated resource identifiers.</dd><dt><var class=Fa>res</var></dt><dd>If all requested resources are successfully allocated, this will be populated with the allocated <var class=Vt>struct bhnd_resource</var> instances.</dd></dl><p class=Pp>The <code class=Fn>bhnd_deactivate_resource</code>() function deactivates a resource previously activated by. <code class=Fn>bhnd_activate_resource</code>(). The arguments are as follows:</p><dl class=Bl-tag><dt><var class=Fa>dev</var></dt><dd>The device holding ownership of the activated resource.</dd><dt><var class=Fa>type</var></dt><dd>The type of the resource.</dd><dt><var class=Fa>rid</var></dt><dd>The bus-specific handle identifying the resource.</dd><dt><var class=Fa>r</var></dt><dd>A pointer to the resource returned by bhnd_alloc_resource.</dd></dl><p class=Pp>The <code class=Fn>bhnd_release_resource</code>() function frees a resource previously returned by <code class=Fn>bhnd_alloc_resource</code>(). The arguments are as follows:</p><dl class=Bl-tag><dt><var class=Fa>dev</var></dt><dd>The device holding ownership of the resource.</dd><dt><var class=Fa>type</var></dt><dd>The type of the resource.</dd><dt><var class=Fa>rid</var></dt><dd>The bus-specific handle identifying the resource.</dd><dt><var class=Fa>r</var></dt><dd>A pointer to the resource returned by bhnd_alloc_resource.</dd></dl><p class=Pp>The <code class=Fn>bhnd_release_resources</code>() function frees resources previously returned by <code class=Fn>bhnd_alloc_resources</code>(). The arguments are as follows:</p><dl class=Bl-tag><dt><var class=Fa>dev</var></dt><dd>The device that owns the resources.</dd><dt><var class=Fa>rs</var></dt><dd>A standard bus resource specification previously initialized by <code class=Fn>bhnd_alloc_resources</code>().</dd><dt><var class=Fa>res</var></dt><dd>The resources to be released.</dd></dl><p class=Pp>The <var class=Vt>bhnd_resource</var> structure contains the following fields:</p><dl class=Bl-tag><dt><var class=Fa>res</var></dt><dd>A pointer to the bus <var class=Vt>struct resource</var>.</dd><dt><var class=Fa>direct</var></dt><dd>If true, the resource requires bus window remapping before it is MMIO accessible.</dd></dl></section><section class=Ss><h2 class=Ss id=Bus_Space_Functions_2><a class=permalink href=#Bus_Space_Functions_2>Bus Space Functions</a></h2> The bhnd_bus_space functions wrap their equivalent <a class=Xr href=bus_space.9.html>bus_space(9)</a> counterparts, and provide support for accessing bus memory via <var class=Vt>struct bhnd_resource</var>. <p class=Pp></p><dl class="Bl-ohang Bd-indent Bl-compact"><dt><code class=Fn>bhnd_bus_barrier</code>()</dt><dd></dd><dt><code class=Fn>bhnd_bus_[read|write]_[1|2|4]</code>()</dt><dd></dd><dt><code class=Fn>bhnd_bus_[read_multi|write_multi]_[1|2|4]</code>()</dt><dd></dd><dt><code class=Fn>bhnd_bus_[read_multi_stream|write_multi_stream]_[1|2|4]</code>()</dt><dd></dd><dt><code class=Fn>bhnd_bus_[read_region|write_region]_[1|2|4]</code>()</dt><dd></dd><dt><code class=Fn>bhnd_bus_[read_region_stream|write_region_stream]_[1|2|4]</code>()</dt><dd></dd><dt><code class=Fn>bhnd_bus_[read_stream|write_stream]_[1|2|4]</code>()</dt><dd></dd><dt><code class=Fn>bhnd_bus_[set_multi|set_stream]_[1|2|4]</code>()</dt><dd></dd></dl><p class=Pp>Drivers that do not rely on <var class=Vt>struct bhnd_resource</var> should use the standard <var class=Vt>struct resource</var> and <a class=Xr href=bus_space.9.html>bus_space(9)</a> APIs directly.</p></section><section class=Ss><h2 class=Ss id=Device_Configuration_Functions_2><a class=permalink href=#Device_Configuration_Functions_2>Device Configuration Functions</a></h2> The <code class=Fn>bhnd_read_ioctl</code>() function is used to read the I/O control register value of device <var class=Fa>dev</var>, returning the current value in <var class=Fa>ioctl</var>. <p class=Pp>The <code class=Fn>bhnd_write_ioctl</code>() function is used to modify the I/O control register of <var class=Fa>dev</var>. The new value of the register is computed by updating any bits set in <var class=Fa>mask</var> to <var class=Fa>value</var>. The following I/O control flags are supported:</p><div class=Bd-indent><dl class=Bl-tag><dt><a class=permalink href=#BHND_IOCTL_BIST><code class=Dv id=BHND_IOCTL_BIST>BHND_IOCTL_BIST</code></a></dt><dd>Initiate a built-in self-test (BIST). Must be cleared after BIST results are read via the IOST (I/O Status) register.</dd><dt><a class=permalink href=#BHND_IOCTL_PME><code class=Dv id=BHND_IOCTL_PME>BHND_IOCTL_PME</code></a></dt><dd>Enable posting of power management events by the core.</dd><dt><a class=permalink href=#BHND_IOCTL_CLK_FORCE><code class=Dv id=BHND_IOCTL_CLK_FORCE>BHND_IOCTL_CLK_FORCE</code></a></dt><dd>Force disable of clock gating, resulting in all clocks being distributed within the core. Should be set when asserting/deasserting reset to ensure the reset signal fully propagates to the entire core.</dd><dt><a class=permalink href=#BHND_IOCTL_CLK_EN><code class=Dv id=BHND_IOCTL_CLK_EN>BHND_IOCTL_CLK_EN</code></a></dt><dd>If cleared, the core clock will be disabled. Should be set during normal operation, and cleared when the core is held in reset.</dd><dt><a class=permalink href=#BHND_IOCTL_CFLAGS><code class=Dv id=BHND_IOCTL_CFLAGS>BHND_IOCTL_CFLAGS</code></a></dt><dd>The mask of IOCTL bits reserved for additional core-specific I/O control flags.</dd></dl></div><p class=Pp>The <code class=Fn>bhnd_read_iost</code>() function is used to read the I/O status register of device <var class=Fa>dev</var>, returning the current value in <var class=Fa>iost</var>. The following I/O status flags are supported:</p><div class=Bd-indent><dl class=Bl-tag><dt><a class=permalink href=#BHND_IOST_BIST_DONE><code class=Dv id=BHND_IOST_BIST_DONE>BHND_IOST_BIST_DONE</code></a></dt><dd>Set upon BIST completion. Will be cleared when the <code class=Dv>BHND_IOCTL_BIST</code> flag of the I/O control register is cleared using <code class=Fn>bhnd_write_ioctl</code>().</dd><dt><a class=permalink href=#BHND_IOST_BIST_FAIL><code class=Dv id=BHND_IOST_BIST_FAIL>BHND_IOST_BIST_FAIL</code></a></dt><dd>Set upon detection of a BIST error; the value is unspecified if BIST has not completed and <code class=Dv>BHND_IOST_BIST_DONE</code> is not also set.</dd><dt><a class=permalink href=#BHND_IOST_CLK><code class=Dv id=BHND_IOST_CLK>BHND_IOST_CLK</code></a></dt><dd>Set if the core has required that clocked be ungated, or cleared otherwise. The value is undefined if a core does not support clock gating.</dd><dt><a class=permalink href=#BHND_IOST_DMA64><code class=Dv id=BHND_IOST_DMA64>BHND_IOST_DMA64</code></a></dt><dd>Set if this core supports 64-bit DMA.</dd><dt><a class=permalink href=#BHND_IOST_CFLAGS><code class=Dv id=BHND_IOST_CFLAGS>BHND_IOST_CFLAGS</code></a></dt><dd>The mask of IOST bits reserved for additional core-specific I/O status flags.</dd></dl></div><p class=Pp>The <code class=Fn>bhnd_read_config</code>() function is used to read a data item of <var class=Fa>width</var> bytes at <var class=Fa>offset</var> from the backplane-specific agent/config space of the device <var class=Fa>dev</var>.</p><p class=Pp>The <code class=Fn>bhnd_write_config</code>() function is used to write a data item of <var class=Fa>width</var> bytes with <var class=Fa>value</var> at <var class=Fa>offset</var> from the backplane-specific agent/config space of the device <var class=Fa>dev</var>. The requested <var class=Fa>width</var> must be one of 1, 2, or 4 bytes.</p><p class=Pp>The agent/config space accessible via <code class=Fn>bhnd_read_config</code>() and <code class=Fn>bhnd_write_config</code>() is backplane-specific, and these functions should only be used for functionality that is not available via another <code class=Nm>bhnd</code> function.</p><p class=Pp>The <code class=Fn>bhnd_suspend_hw</code>() function transitions the device <var class=Fa>dev</var> to a low power “RESET” state, writing <var class=Fa>ioctl</var> to the I/O control flags of <var class=Fa>dev</var>. The hardware may be brought out of this state using <code class=Fn>bhnd_reset_hw</code>().</p><p class=Pp>The <code class=Fn>bhnd_reset_hw</code>() function first transitions the device <var class=Fa>dev</var> to a low power RESET state, writing <var class=Fa>ioctl_reset</var> to the I/O control flags of <var class=Fa>dev</var>, and then brings the device out of RESET, writing <var class=Fa>ioctl</var> to the device's I/O control flags.</p><p class=Pp>The <code class=Fn>bhnd_is_hw_suspended</code>() function returns <code class=Dv>true</code> if the device <var class=Fa>dev</var> is currently held in a RESET state, or is otherwise not clocked. Otherwise, it returns <code class=Dv>false</code>.</p><p class=Pp>Any outstanding per-device PMU requests made using <code class=Fn>bhnd_enable_clocks</code>(), <code class=Fn>bhnd_request_clock</code>(), or <code class=Fn>bhnd_request_ext_rsrc</code>() will be released automatically upon placing a device into a RESET state.</p></section><section class=Ss><h2 class=Ss id=Device_Information_Functions_2><a class=permalink href=#Device_Information_Functions_2>Device Information Functions</a></h2> The <code class=Fn>bhnd_get_attach_type</code>() function returns the attachment type of the parent <a class=Xr href=bhnd.4.html>bhnd(4)</a> bus of device <var class=Fa>dev</var>. <p class=Pp>The following attachment types are supported:</p><dl class="Bl-hang Bd-indent"><dt><a class=permalink href=#BHND_ATTACH_ADAPTER><code class=Dv id=BHND_ATTACH_ADAPTER>BHND_ATTACH_ADAPTER</code></a></dt><dd>The bus is resident on a bridged adapter, such as a PCI Wi-Fi device.</dd><dt><a class=permalink href=#BHND_ATTACH_NATIVE><code class=Dv id=BHND_ATTACH_NATIVE>BHND_ATTACH_NATIVE</code></a></dt><dd>The bus is resident on the native host, such as the primary or secondary bus of an embedded SoC.</dd></dl><p class=Pp>The <code class=Fn>bhnd_get_chipid</code>() function returns chip information from the parent <a class=Xr href=bhnd.4.html>bhnd(4)</a> bus of device <var class=Fa>dev</var>. The returned <var class=Vt>bhnd_chipid</var> struct contains the following fields:</p><div class=Bd-indent><dl class=Bl-tag><dt><var class=Fa>chip_id</var></dt><dd>The chip identifier.</dd><dt><var class=Fa>chip_rev</var></dt><dd>The chip's hardware revision.</dd><dt><var class=Fa>chip_pkg</var></dt><dd>The chip's semiconductor package identifier. <p class=Pp>Several different physical semiconductor package variants may exist for a given chip, each of which may require driver workarounds for hardware errata, unpopulated components, etc.</p></dd><dt><var class=Fa>chip_type</var></dt><dd>The interconnect architecture used by this chip.</dd><dt><var class=Fa>chip_caps</var></dt><dd>The <code class=Nm>bhnd</code> capability flags supported by this chip.</dd><dt><var class=Fa>enum_addr</var></dt><dd>The backplane enumeration address. On SSB devices, this will be the base address of the first SSB core. On BCMA devices, this will be the address of the enumeration ROM (EROM) core.</dd><dt><var class=Fa>ncores</var></dt><dd>The number of cores on the chip backplane, or 0 if unknown.</dd></dl></div><p class=Pp>The following constants are defined for known <var class=Fa>chip_type</var> values:</p><div class=Bd-indent><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#BHND_CHIPTYPE_SIBA><code class=Dv id=BHND_CHIPTYPE_SIBA>BHND_CHIPTYPE_SIBA</code></a></dt><dd>SSB interconnect.</dd><dt><a class=permalink href=#BHND_CHIPTYPE_BCMA><code class=Dv id=BHND_CHIPTYPE_BCMA>BHND_CHIPTYPE_BCMA</code></a></dt><dd>BCMA interconnect.</dd><dt><a class=permalink href=#BHND_CHIPTYPE_BCMA_ALT><code class=Dv id=BHND_CHIPTYPE_BCMA_ALT>BHND_CHIPTYPE_BCMA_ALT</code></a></dt><dd>BCMA-compatible variant found in Broadcom Northstar ARM SoCs.</dd><dt><a class=permalink href=#BHND_CHIPTYPE_UBUS><code class=Dv id=BHND_CHIPTYPE_UBUS>BHND_CHIPTYPE_UBUS</code></a></dt><dd>UBUS interconnect. This BCMA-derived interconnect is found in Broadcom BCM33xx DOCSIS SoCs, and BCM63xx xDSL SoCs. UBUS is not currently supported by <a class=Xr href=bhnd.4.html>bhnd(4)</a>.</dd></dl></div><p class=Pp>The following <var class=Fa>chip_caps</var> flags are supported:</p><div class=Bd-indent><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#BHND_CAP_BP64><code class=Dv id=BHND_CAP_BP64>BHND_CAP_BP64</code></a></dt><dd>The backplane supports 64-bit addressing.</dd><dt><a class=permalink href=#BHND_CAP_PMU><code class=Dv id=BHND_CAP_PMU>BHND_CAP_PMU</code></a></dt><dd>PMU is present.</dd></dl></div><p class=Pp>Additional symbolic constants for known <var class=Fa>chip_id</var>, <var class=Fa>chip_pkg</var>, and <var class=Fa>chip_type</var> values are defined in <code class=In>&lt;<a class=In href=../src/dev/bhnd/bhnd_ids.h.html>dev/bhnd/bhnd_ids.h</a>&gt;</code>.</p><p class=Pp>The <code class=Fn>bhnd_get_class</code>() function returns the BHND class of device <var class=Fa>dev</var>, if the device's <i class=Em>vendor</i> and <i class=Em>device</i> identifiers are recognized. Otherwise, returns <code class=Dv>BHND_DEVCLASS_OTHER</code>.</p><p class=Pp>One of the following device classes will be returned:</p><p class=Pp></p><div class=Bd-indent><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#BHND_DEVCLASS_CC><code class=Dv id=BHND_DEVCLASS_CC>BHND_DEVCLASS_CC</code></a></dt><dd>ChipCommon I/O Controller</dd><dt><a class=permalink href=#BHND_DEVCLASS_CC_B><code class=Dv id=BHND_DEVCLASS_CC_B>BHND_DEVCLASS_CC_B</code></a></dt><dd>ChipCommon Auxiliary Controller</dd><dt><a class=permalink href=#BHND_DEVCLASS_PMU><code class=Dv id=BHND_DEVCLASS_PMU>BHND_DEVCLASS_PMU</code></a></dt><dd>PMU Controller</dd><dt><a class=permalink href=#BHND_DEVCLASS_PCI><code class=Dv id=BHND_DEVCLASS_PCI>BHND_DEVCLASS_PCI</code></a></dt><dd>PCI Host/Device Bridge</dd><dt><a class=permalink href=#BHND_DEVCLASS_PCIE><code class=Dv id=BHND_DEVCLASS_PCIE>BHND_DEVCLASS_PCIE</code></a></dt><dd>PCIe Host/Device Bridge</dd><dt><a class=permalink href=#BHND_DEVCLASS_PCCARD><code class=Dv id=BHND_DEVCLASS_PCCARD>BHND_DEVCLASS_PCCARD</code></a></dt><dd>PCMCIA Host/Device Bridge</dd><dt><a class=permalink href=#BHND_DEVCLASS_RAM><code class=Dv id=BHND_DEVCLASS_RAM>BHND_DEVCLASS_RAM</code></a></dt><dd>Internal RAM/SRAM</dd><dt><a class=permalink href=#BHND_DEVCLASS_MEMC><code class=Dv id=BHND_DEVCLASS_MEMC>BHND_DEVCLASS_MEMC</code></a></dt><dd>Memory Controller</dd><dt><a class=permalink href=#BHND_DEVCLASS_ENET><code class=Dv id=BHND_DEVCLASS_ENET>BHND_DEVCLASS_ENET</code></a></dt><dd>IEEE 802.3 MAC/PHY</dd><dt><a class=permalink href=#BHND_DEVCLASS_ENET_MAC><code class=Dv id=BHND_DEVCLASS_ENET_MAC>BHND_DEVCLASS_ENET_MAC</code></a></dt><dd>IEEE 802.3 MAC</dd><dt><a class=permalink href=#BHND_DEVCLASS_ENET_PHY><code class=Dv id=BHND_DEVCLASS_ENET_PHY>BHND_DEVCLASS_ENET_PHY</code></a></dt><dd>IEEE 802.3 PHY</dd><dt><a class=permalink href=#BHND_DEVCLASS_WLAN><code class=Dv id=BHND_DEVCLASS_WLAN>BHND_DEVCLASS_WLAN</code></a></dt><dd>IEEE 802.11 MAC/PHY/Radio</dd><dt><a class=permalink href=#BHND_DEVCLASS_WLAN_MAC><code class=Dv id=BHND_DEVCLASS_WLAN_MAC>BHND_DEVCLASS_WLAN_MAC</code></a></dt><dd>IEEE 802.11 MAC</dd><dt><a class=permalink href=#BHND_DEVCLASS_WLAN_PHY><code class=Dv id=BHND_DEVCLASS_WLAN_PHY>BHND_DEVCLASS_WLAN_PHY</code></a></dt><dd>IEEE 802.11 PHY</dd><dt><a class=permalink href=#BHND_DEVCLASS_CPU><code class=Dv id=BHND_DEVCLASS_CPU>BHND_DEVCLASS_CPU</code></a></dt><dd>CPU Core</dd><dt><a class=permalink href=#BHND_DEVCLASS_SOC_ROUTER><code class=Dv id=BHND_DEVCLASS_SOC_ROUTER>BHND_DEVCLASS_SOC_ROUTER</code></a></dt><dd>Interconnect Router</dd><dt><a class=permalink href=#BHND_DEVCLASS_SOC_BRIDGE><code class=Dv id=BHND_DEVCLASS_SOC_BRIDGE>BHND_DEVCLASS_SOC_BRIDGE</code></a></dt><dd>Interconnect Host Bridge</dd><dt><a class=permalink href=#BHND_DEVCLASS_EROM><code class=Dv id=BHND_DEVCLASS_EROM>BHND_DEVCLASS_EROM</code></a></dt><dd>Device Enumeration ROM</dd><dt><a class=permalink href=#BHND_DEVCLASS_NVRAM><code class=Dv id=BHND_DEVCLASS_NVRAM>BHND_DEVCLASS_NVRAM</code></a></dt><dd>NVRAM/Flash Controller</dd><dt><a class=permalink href=#BHND_DEVCLASS_SOFTMODEM><code class=Dv id=BHND_DEVCLASS_SOFTMODEM>BHND_DEVCLASS_SOFTMODEM</code></a></dt><dd>Analog/PSTN SoftModem Codec</dd><dt><a class=permalink href=#BHND_DEVCLASS_USB_HOST><code class=Dv id=BHND_DEVCLASS_USB_HOST>BHND_DEVCLASS_USB_HOST</code></a></dt><dd>USB Host Controller</dd><dt><a class=permalink href=#BHND_DEVCLASS_USB_DEV><code class=Dv id=BHND_DEVCLASS_USB_DEV>BHND_DEVCLASS_USB_DEV</code></a></dt><dd>USB Device Controller</dd><dt><a class=permalink href=#BHND_DEVCLASS_USB_DUAL><code class=Dv id=BHND_DEVCLASS_USB_DUAL>BHND_DEVCLASS_USB_DUAL</code></a></dt><dd>USB Host/Device Controller</dd><dt><a class=permalink href=#BHND_DEVCLASS_OTHER><code class=Dv id=BHND_DEVCLASS_OTHER>BHND_DEVCLASS_OTHER</code></a></dt><dd>Other / Unknown</dd><dt><a class=permalink href=#BHND_DEVCLASS_INVALID><code class=Dv id=BHND_DEVCLASS_INVALID>BHND_DEVCLASS_INVALID</code></a></dt><dd>Invalid Class</dd></dl></div><p class=Pp>The <code class=Fn>bhnd_get_core_info</code>() function returns the core information for device <var class=Fa>dev</var>. The returned <var class=Vt>bhnd_core_info</var> structure contains the following fields:</p><p class=Pp></p><div class=Bd-indent><dl class="Bl-tag Bl-compact"><dt><var class=Fa>vendor</var></dt><dd>Vendor identifier (JEP-106, ARM 4-bit continuation encoded)</dd><dt><var class=Fa>device</var></dt><dd>Device identifier</dd><dt><var class=Fa>hwrev</var></dt><dd>Hardware revision</dd><dt><var class=Fa>core_idx</var></dt><dd>Core index</dd><dt><var class=Fa>unit</var></dt><dd>Core unit</dd></dl></div><p class=Pp>Symbolic constants for common vendor and device identifiers are defined in <code class=In>&lt;<a class=In href=../src/dev/bhnd/bhnd_ids.h.html>dev/bhnd/bhnd_ids.h</a>&gt;</code>. Common vendor identifiers include:</p><p class=Pp></p><div class=Bd-indent><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#BHND_MFGID_ARM><code class=Dv id=BHND_MFGID_ARM>BHND_MFGID_ARM</code></a></dt><dd>ARM</dd><dt><a class=permalink href=#BHND_MFGID_BCM><code class=Dv id=BHND_MFGID_BCM>BHND_MFGID_BCM</code></a></dt><dd>Broadcom</dd><dt><a class=permalink href=#BHND_MFGID_MIPS><code class=Dv id=BHND_MFGID_MIPS>BHND_MFGID_MIPS</code></a></dt><dd>MIPS</dd></dl></div><p class=Pp>The <code class=Fn>bhnd_get_core_index</code>(), <code class=Fn>bhnd_get_core_unit</code>(), <code class=Fn>bhnd_get_device</code>(), <code class=Fn>bhnd_get_hwrev</code>(), and <code class=Fn>bhnd_get_vendor</code>() functions are convenience wrappers for <code class=Fn>bhnd_get_core_info</code>(), returning, respect the <var class=Fa>core_idx</var>, <var class=Fa>core_unit</var>, <var class=Fa>device</var>, <var class=Fa>hwrev</var>, or <var class=Fa>vendor</var> field from the <var class=Vt>bhnd_core_info</var> structure.</p><p class=Pp>The <code class=Fn>bhnd_get_device_name</code>() function returns a human readable name for device <var class=Fa>dev</var>.</p><p class=Pp>The <code class=Fn>bhnd_get_vendor_name</code>() function returns a human readable name for the vendor of device <var class=Fa>dev</var>.</p><p class=Pp>The <code class=Fn>bhnd_read_board_info</code>() function attempts to read the board information for device <var class=Fa>dev</var>. The board information will be returned in the location pointed to by <var class=Fa>info</var> on success.</p><p class=Pp>The <var class=Vt>bhnd_board_info</var> structure contains the following fields:</p><div class=Bd-indent><dl class=Bl-tag><dt><var class=Fa>board_vendor</var></dt><dd>Vendor ID of the board manufacturer (PCI-SIG assigned).</dd><dt><var class=Fa>board_type</var></dt><dd>Board ID.</dd><dt><var class=Fa>board_devid</var></dt><dd>Device ID.</dd><dt><var class=Fa>board_rev</var></dt><dd>Board revision.</dd><dt><var class=Fa>board_srom_rev</var></dt><dd>Board SROM format revision.</dd><dt><var class=Fa>board_flags</var></dt><dd>Board flags (1)</dd><dt><var class=Fa>board_flags2</var></dt><dd>Board flags (2)</dd><dt><var class=Fa>board_flags3</var></dt><dd>Board flags (3)</dd></dl></div><p class=Pp>The <var class=Fa>board_devid</var> field is the Broadcom PCI device ID that most closely matches the capabilities of the BHND device (if any).</p><p class=Pp>On PCI devices, the <var class=Fa>board_vendor</var>, <var class=Fa>board_type</var>, and <var class=Fa>board_devid</var> fields default to the PCI Subsystem Vendor ID, PCI Subsystem ID, and PCI device ID, unless overridden in device NVRAM.</p><p class=Pp>On other devices, including SoCs, the <var class=Fa>board_vendor</var>, <var class=Fa>board_type</var>, and <var class=Fa>board_devid</var> fields will be populated from device NVRAM.</p><p class=Pp>Symbolic constants for common board flags are defined in <code class=In>&lt;<a class=In href=../src/dev/bhnd/bhnd_ids.h.html>dev/bhnd/bhnd_ids.h</a>&gt;</code>.</p></section><section class=Ss><h2 class=Ss id=Device_Matching_Functions_2><a class=permalink href=#Device_Matching_Functions_2>Device Matching Functions</a></h2> The bhnd device matching functions are used to match against core, chip, and board-level device attributes. Match requirements are specified using the <var class=Vt>struct bhnd_board_match</var>, <var class=Vt>struct bhnd_chip_match</var>, <var class=Vt>struct bhnd_core_match</var>, <var class=Vt>struct bhnd_device_match</var>, and <var class=Vt>struct bhnd_hwrev_match</var> match descriptor structures. <p class=Pp>The <code class=Fn>bhnd_board_matches</code>() function returns <code class=Dv>true</code> if <var class=Fa>board</var> matches the board match descriptor <var class=Fa>desc</var>. Otherwise, it returns <code class=Dv>false</code>.</p><p class=Pp>The <code class=Fn>bhnd_chip_matches</code>() function returns <code class=Dv>true</code> if <var class=Fa>chip</var> matches the chip match descriptor <var class=Fa>desc</var>. Otherwise, it returns <code class=Dv>false</code>.</p><p class=Pp>The <code class=Fn>bhnd_core_matches</code>() function returns <code class=Dv>true</code> if <var class=Fa>core</var> matches the core match descriptor <var class=Fa>desc</var>. Otherwise, it returns <code class=Dv>false</code>.</p><p class=Pp>The <code class=Fn>bhnd_device_matches</code>() function returns <code class=Dv>true</code> if the device <var class=Fa>dev</var> matches the device match descriptor <var class=Fa>desc</var>. Otherwise, it returns <code class=Dv>false</code>.</p><p class=Pp>The <code class=Fn>bhnd_hwrev_matches</code>() function returns <code class=Dv>true</code> if <var class=Fa>hwrev</var> matches the hwrev match descriptor <var class=Fa>desc</var>. Otherwise, it returns <code class=Dv>false</code>.</p><p class=Pp>The <code class=Fn>bhnd_bus_match_child</code>() function returns the first child device of <var class=Fa>bus</var> that matches the device match descriptor <var class=Fa>desc</var>. If no matching child is found, <code class=Dv>NULL</code> is returned.</p><p class=Pp>The <code class=Fn>bhnd_core_get_match_desc</code>() function returns an equality match descriptor for the core info in <var class=Fa>core</var>. The returned descriptor will match only on core attributes identical to those defined by <var class=Fa>core</var>.</p><p class=Pp>The <code class=Fn>bhnd_cores_equal</code>() function is a convenience wrapper for <code class=Fn>bhnd_core_matches</code>() and <code class=Fn>bhnd_core_get_match_desc</code>(). This function returns <code class=Dv>true</code> if the <var class=Vt>bhnd_core_info</var> structures <var class=Fa>lhs</var> and <var class=Fa>rhs</var> are equal. Otherwise, it returns <code class=Dv>false</code>.</p><p class=Pp>The <code class=Fn>bhnd_match_core</code>() function returns a pointer to the first entry in the array <var class=Fa>cores</var> of length <var class=Fa>num_cores</var> that matches <var class=Fa>desc</var>. If no matching core is found, <code class=Dv>NULL</code> is returned.</p><p class=Pp>A <var class=Vt>bhnd_board_match</var> match descriptor may be initialized using one or more of the following macros:</p><div class=Bd-indent><dl class=Bl-tag><dt><code class=Fn>BHND_MATCH_BOARD_VENDOR</code>(<var class=Fa>vendor</var>)</dt><dd>Match on boards with a vendor equal to <var class=Fa>vendor</var>.</dd><dt><code class=Fn>BHND_MATCH_BOARD_TYPE</code>(<var class=Fa>type</var>)</dt><dd>Match on boards with a type equal to <code class=Dv>BHND_BOARD_ ##</code><var class=Fa>type</var></dd><dt><code class=Fn>BHND_MATCH_SROMREV</code>(<var class=Fa>sromrev</var>)</dt><dd>Match on boards with a sromrev that matches <code class=Dv>BHND_HWREV_ ##</code><var class=Fa>sromrev</var>.</dd><dt><code class=Fn>BHND_MATCH_BOARD_REV</code>(<var class=Fa>hwrev</var>)</dt><dd>Match on boards with hardware revisions that match <code class=Dv>BHND_ ##</code><var class=Fa>hwrev</var>.</dd><dt><code class=Fn>BHND_MATCH_BOARD</code>(<var class=Fa>vendor</var>, <var class=Fa>type</var>)</dt><dd>A convenience wrapper for <code class=Fn>BHND_MATCH_BOARD_VENDOR</code>() and <code class=Fn>BHND_MATCH_BOARD_TYPE</code>().</dd></dl></div><p class=Pp>For example:</p><div class="Bd Pp Bd-indent"><pre>
struct bhnd_board_match board_desc = {
	BHND_MATCH_BOARD_VENDOR(BHND_MFGID_BROADCOM),
	BHND_MATCH_BOARD_TYPE(BCM94360X52C),
	BHND_MATCH_BOARD_REV(HWREV_ANY),
	BHND_MATCH_SROMREV(RANGE(0, 10))
};
</pre></div><p class=Pp>A <var class=Vt>bhnd_chip_match</var> match descriptor may be initialized using one or more of the following macros:</p><div class=Bd-indent><dl class=Bl-tag><dt><code class=Fn>BHND_MATCH_CHIP_ID</code>(<var class=Fa>id</var>)</dt><dd>Match on chips with an ID equal to <code class=Dv>BHND_CHIPID_ ##</code><var class=Fa>id</var></dd><dt><code class=Fn>BHND_MATCH_CHIP_REV</code>(<var class=Fa>hwrev</var>)</dt><dd>Match on chips with hardware revisions that match <code class=Dv>BHND_ ##</code><var class=Fa>hwrev</var>.</dd><dt><code class=Fn>BHND_MATCH_CHIP_PKG</code>(<var class=Fa>pkg</var>)</dt><dd>Match on chips with a package ID equal to <code class=Dv>BHND_PKGID_ ##</code><var class=Fa>pkg</var></dd><dt><code class=Fn>BHND_MATCH_CHIP_TYPE</code>(<var class=Fa>type</var>)</dt><dd>Match on chips with a chip type equal to <code class=Dv>BHND_CHIPTYPE_ ##</code><var class=Fa>type</var></dd><dt><code class=Fn>BHND_MATCH_CHIP_IP</code>(<var class=Fa>id</var>, <var class=Fa>pkg</var>)</dt><dd>A convenience wrapper for <code class=Fn>BHND_MATCH_CHIP_ID</code>() and <code class=Fn>BHND_MATCH_CHIP_PKG</code>().</dd><dt><code class=Fn>BHND_MATCH_CHIP_IPR</code>(<var class=Fa>id</var>, <var class=Fa>pkg</var>, <var class=Fa>hwrev</var>)</dt><dd>A convenience wrapper for <code class=Fn>BHND_MATCH_CHIP_ID</code>(), <code class=Fn>BHND_MATCH_CHIP_PKG</code>(), and <code class=Fn>BHND_MATCH_CHIP_REV</code>().</dd><dt><code class=Fn>BHND_MATCH_CHIP_IR</code>(<var class=Fa>id</var>, <var class=Fa>hwrev</var>)</dt><dd>A convenience wrapper for <code class=Fn>BHND_MATCH_CHIP_ID</code>() and <code class=Fn>BHND_MATCH_CHIP_REV</code>().</dd></dl></div><p class=Pp>For example:</p><div class="Bd Pp Bd-indent"><pre>
struct bhnd_chip_match chip_desc = {
	BHND_MATCH_CHIP_IP(BCM4329, BCM4329_289PIN),
	BHND_MATCH_CHIP_TYPE(SIBA)
};
</pre></div><p class=Pp>A <var class=Vt>bhnd_core_match</var> match descriptor may be initialized using one or more of the following macros:</p><div class=Bd-indent><dl class=Bl-tag><dt><code class=Fn>BHND_MATCH_CORE_VENDOR</code>(<var class=Fa>vendor</var>)</dt><dd>Match on cores with a vendor ID equal to <var class=Fa>vendor</var></dd><dt><code class=Fn>BHND_MATCH_CORE_ID</code>(<var class=Fa>id</var>)</dt><dd>Match on cores with a device ID equal to <var class=Fa>id</var></dd><dt><code class=Fn>BHND_MATCH_CORE_REV</code>(<var class=Fa>hwrev</var>)</dt><dd>Match on cores with hardware revisions that match <code class=Dv>BHND_ ##</code><var class=Fa>hwrev</var>.</dd><dt><code class=Fn>BHND_MATCH_CORE_CLASS</code>(<var class=Fa>class</var>)</dt><dd>Match on cores with a core device class equal to <var class=Fa>class</var></dd><dt><code class=Fn>BHND_MATCH_CORE_IDX</code>(<var class=Fa>idx</var>)</dt><dd>Match on cores with a core index equal to <var class=Fa>idx</var></dd><dt><code class=Fn>BHND_MATCH_CORE_UNIT</code>(<var class=Fa>unit</var>)</dt><dd>Match on cores with a core unit equal to <var class=Fa>unit</var></dd><dt><code class=Fn>BHND_MATCH_CORE</code>(<var class=Fa>vendor</var>, <var class=Fa>id</var>)</dt><dd>A convenience wrapper for <code class=Fn>BHND_MATCH_CORE_VENDOR</code>() and <code class=Fn>BHND_MATCH_CORE_ID</code>().</dd></dl></div><p class=Pp>For example:</p><div class="Bd Pp Bd-indent"><pre>
struct bhnd_core_match core_desc = {
	BHND_MATCH_CORE(BHND_MFGID_BROADCOM, BHND_COREID_CC),
	BHND_MATCH_CORE_REV(HWREV_RANGE(0, 10))
};
</pre></div><p class=Pp>The <var class=Vt>bhnd_device_match</var> match descriptor supports matching on all board, chip, and core attributes, and may be initialized using any of the <var class=Vt>bhnd_board_match</var>, <var class=Vt>bhnd_chip_match</var>, or <var class=Vt>bhnd_core_match</var> macros.</p><p class=Pp>For example:</p><div class="Bd Pp Bd-indent"><pre>
struct bhnd_device_match device_desc = {
	BHND_MATCH_CHIP_IP(BCM4329, BCM4329_289PIN),
	BHND_MATCH_BOARD_VENDOR(BHND_MFGID_BROADCOM),
	BHND_MATCH_BOARD_TYPE(BCM94329AGB),
	BHND_MATCH_CORE(BHND_MFGID_BROADCOM, BHND_COREID_CC),
};
</pre></div><p class=Pp>A <var class=Vt>bhnd_hwrev_match</var> match descriptor may be initialized using one of the following macros:</p><p class=Pp></p><div class=Bd-indent><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#BHND_HWREV_ANY><code class=Dv id=BHND_HWREV_ANY>BHND_HWREV_ANY</code></a></dt><dd>Matches any hardware revision.</dd><dt><code class=Fn>BHND_HWREV_EQ</code>(<var class=Fa>hwrev</var>)</dt><dd>Matches any hardware revision equal to <var class=Fa>hwrev</var></dd><dt><code class=Fn>BHND_HWREV_GTE</code>(<var class=Fa>hwrev</var>)</dt><dd>Matches any hardware revision greater than or equal to <var class=Fa>hwrev</var></dd><dt><code class=Fn>BHND_HWREV_LTE</code>(<var class=Fa>hwrev</var>)</dt><dd>Matches any hardware revision less than or equal to <var class=Fa>hwrev</var></dd><dt><code class=Fn>BHND_HWREV_RANGE</code>(<var class=Fa>start</var>, <var class=Fa>end</var>)</dt><dd>Matches any hardware revision within an inclusive range. If <code class=Dv>BHND_HWREV_INVALID</code> is specified as the <var class=Fa>end</var> value, will match on any revision equal to or greater than <var class=Fa>start</var></dd></dl></div></section><section class=Ss><h2 class=Ss id=Device_Table_Functions_2><a class=permalink href=#Device_Table_Functions_2>Device Table Functions</a></h2> The bhnd device table functions are used to query device and quirk tables. <p class=Pp>The <code class=Fn>bhnd_device_lookup</code>() function returns a pointer to the first entry in device table <var class=Fa>table</var> that matches the device <var class=Fa>dev</var>. The table entry size is specified by <var class=Fa>entry_size</var>.</p><p class=Pp>The <code class=Fn>bhnd_device_quirks</code>() function scan the device table <var class=Fa>table</var> for all quirk entries that match the device <var class=Fa>dev</var>, returning the bitwise OR of all matching quirk flags. The table entry size is specified by <var class=Fa>entry_size</var>.</p><p class=Pp>The <var class=Vt>bhnd_device</var> structure contains the following fields:</p><div class=Bd-indent><dl class="Bl-tag Bl-compact"><dt><var class=Fa>core</var></dt><dd>A <var class=Vt>bhnd_device_match</var> descriptor.</dd><dt><var class=Fa>desc</var></dt><dd>A verbose device description suitable for use with <a class=Xr href=device_set_desc.9.html>device_set_desc(9)</a>, or <code class=Dv>NULL</code>.</dd><dt><var class=Fa>quirks_table</var></dt><dd>The quirks table for this device, or <code class=Dv>NULL</code>.</dd><dt><var class=Fa>device_flags</var></dt><dd>The device flags required when matching this entry.</dd></dl></div><p class=Pp>The following device flags are supported:</p><div class=Bd-indent><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#BHND_DF_ANY><code class=Dv id=BHND_DF_ANY>BHND_DF_ANY</code></a></dt><dd>Match on any device.</dd><dt><a class=permalink href=#BHND_DF_HOSTB><code class=Dv id=BHND_DF_HOSTB>BHND_DF_HOSTB</code></a></dt><dd>Match only if the device is the <a class=Xr href=bhndb.4.html>bhndb(4)</a> host bridge. Implies <code class=Dv>BHND_DF_ADAPTER</code>.</dd><dt><a class=permalink href=#BHND_DF_SOC><code class=Dv id=BHND_DF_SOC>BHND_DF_SOC</code></a></dt><dd>Match only if the device is attached to a native SoC backplane.</dd><dt><a class=permalink href=#BHND_DF_ADAPTER><code class=Dv id=BHND_DF_ADAPTER>BHND_DF_ADAPTER</code></a></dt><dd>Match only if the device is attached to a <a class=Xr href=bhndb.4.html>bhndb(4)</a> bridged backplane.</dd></dl></div><p class=Pp>A <var class=Vt>bhnd_device</var> table entry may be initialized using one of the following macros:</p><dl class="Bl-ohang Bd-indent"><dt><code class=Fn>BHND_DEVICE</code>(<var class=Fa>vendor</var>, <var class=Fa>device</var>, <var class=Fa>desc</var>, <var class=Fa>quirks</var>, <var class=Fa>flags</var>)</dt><dd>Match on devices with a vendor ID equal to <code class=Dv>BHND_MFGID_ ##</code><var class=Fa>vendor</var> and a core device ID equal to <code class=Dv>BHND_COREID_ ##</code><var class=Fa>device</var>. <p class=Pp>The device's verbose description is specified by the <var class=Fa>desc</var> argument, a pointer to the device-specific quirks table is specified by the <var class=Fa>quirks</var> argument, and any required device flags may be provided in <var class=Fa>flags</var>. The optional <var class=Fa>flags</var> argument defaults to <code class=Dv>BHND_DF_ANY</code> if omitted.</p></dd><dt><a class=permalink href=#BHND_DEVICE_END><code class=Dv id=BHND_DEVICE_END>BHND_DEVICE_END</code></a></dt><dd>Terminate the <var class=Vt>bhnd_device</var> table.</dd></dl><p class=Pp>For example:</p><div class="Bd Pp Bd-indent"><pre>
struct bhnd_device bhnd_usb11_devices[] = {
	BHND_DEVICE(BCM, USB, "Broadcom USB1.1 Controller",
	    bhnd_usb11_quirks),
	BHND_DEVICE_END
};
</pre></div><p class=Pp>The <var class=Vt>bhnd_device_quirk</var> structure contains the following fields:</p><div class=Bd-indent><dl class="Bl-tag Bl-compact"><dt><var class=Fa>desc</var></dt><dd>A <var class=Vt>bhnd_device_match</var> descriptor.</dd><dt><var class=Fa>quirks</var></dt><dd>Applicable quirk flags.</dd></dl></div><p class=Pp>A bhnd_device_quirk table entry may be initialized using one of the following convenience macros:</p><div class=Bd-indent><dl class=Bl-tag><dt><code class=Fn>BHND_BOARD_QUIRK</code>(<var class=Fa>board</var>, <var class=Fa>flags</var>)</dt><dd>Set quirk flags <var class=Fa>flags</var> on devices with a board type equal to <code class=Dv>BHND_BOARD_ ##</code><var class=Fa>board</var>.</dd><dt><code class=Fn>BHND_CHIP_QUIRK</code>(<var class=Fa>chip</var>, <var class=Fa>hwrev</var>, <var class=Fa>flags</var>)</dt><dd>Set quirk flags <var class=Fa>flags</var> on devices with a chip ID equal to <code class=Dv>BHND_CHIPID_BCM ##</code><var class=Fa>chip</var> and chip hardware revision that matches <code class=Dv>BHND_ ##</code><var class=Fa>hwrev</var>.</dd><dt><code class=Fn>BHND_PKG_QUIRK</code>(<var class=Fa>chip</var>, <var class=Fa>pkg</var>, <var class=Fa>flags"</var>)</dt><dd>Set quirk flags <var class=Fa>flags</var> on devices with a chip ID equal to <code class=Dv>BHND_CHIPID_BCM ##</code><var class=Fa>chip</var> and chip package equal to <code class=Dv>BHND_ ## chip ##</code><var class=Fa>pkg</var>.</dd><dt><code class=Fn>BHND_CORE_QUIRK</code>(<var class=Fa>hwrev</var>, <var class=Fa>flags"</var>)</dt><dd>Set quirk flags <var class=Fa>flags</var> on devices with a core hardware revision that matches <code class=Dv>BHND_ ##</code><var class=Fa>hwrev</var>.</dd></dl></div> For example: <div class="Bd Pp Bd-indent"><pre>
struct bhnd_device_quirk bhnd_usb11_quirks[] = {
	BHND_DEVICE(BCM, USB, "Broadcom USB1.1 Controller",
	    bhnd_usb11_quirks),
	BHND_DEVICE_END
};
</pre></div></section><section class=Ss><h2 class=Ss id=DMA_Address_Translation_Functions_2><a class=permalink href=#DMA_Address_Translation_Functions_2>DMA Address Translation Functions</a></h2> The <code class=Fn>bhnd_get_dma_translation</code>() function is used to request a DMA address translation descriptor suitable for use with a maximum DMA address width of <var class=Fa>width</var>, with support for the requested translation <var class=Fa>flags</var>. <p class=Pp>If a suitable DMA address translation descriptor is found, it will be stored in <var class=Fa>translation</var>, and a bus DMA tag specifying the DMA translation's address restrictions will be stored in <var class=Fa>dmat</var>. The <var class=Fa>translation</var> and <var class=Fa>dmat</var> arguments may be <code class=Dv>NULL</code> if the translation descriptor or DMA tag are not desired.</p><p class=Pp>The following DMA translation flags are supported:</p><dl class="Bl-ohang Bd-indent"><dt><a class=permalink href=#BHND_DMA_TRANSLATION_PHYSMAP><code class=Dv id=BHND_DMA_TRANSLATION_PHYSMAP>BHND_DMA_TRANSLATION_PHYSMAP</code></a></dt><dd>The translation remaps the device's physical address space. <p class=Pp>This is used in conjunction with <code class=Dv>BHND_DMA_TRANSLATION_BYTESWAPPED</code> to define a DMA translation that provides byteswapped access to physical memory on big-endian MIPS SoCs.</p></dd><dt><a class=permalink href=#BHND_DMA_TRANSLATION_BYTESWAPPED><code class=Dv id=BHND_DMA_TRANSLATION_BYTESWAPPED>BHND_DMA_TRANSLATION_BYTESWAPPED</code></a></dt><dd>The translation provides a byte-swapped mapping; write requests will be byte-swapped before being written to memory, and read requests will be byte-swapped before being returned. <p class=Pp>This is primarily used to perform efficient byte swapping of DMA data on embedded MIPS SoCs executing in big-endian mode.</p></dd></dl><p class=Pp>The following symbolic constants are defined for common DMA address widths:</p><p class=Pp></p><div class=Bd-indent><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#BHND_DMA_ADDR_30BIT><code class=Dv id=BHND_DMA_ADDR_30BIT>BHND_DMA_ADDR_30BIT</code></a></dt><dd>30-bit DMA</dd><dt><a class=permalink href=#BHND_DMA_ADDR_32BIT><code class=Dv id=BHND_DMA_ADDR_32BIT>BHND_DMA_ADDR_32BIT</code></a></dt><dd>32-bit DMA</dd><dt><a class=permalink href=#BHND_DMA_ADDR_64BIT><code class=Dv id=BHND_DMA_ADDR_64BIT>BHND_DMA_ADDR_64BIT</code></a></dt><dd>64-bit DMA</dd></dl></div><p class=Pp>The <var class=Vt>bhnd_dma_translation</var> structure contains the following fields:</p><dl class=Bl-tag><dt><var class=Fa>base_addr</var></dt><dd>Host-to-device physical address translation. This may be added to a host physical address to produce a device DMA address.</dd><dt><var class=Fa>addr_mask</var></dt><dd>Device-addressable address mask. This defines the device DMA address range, and excludes any bits reserved for mapping the address within the translation window at <var class=Fa>base_addr</var>.</dd><dt><var class=Fa>addrext_mask</var></dt><dd>Device-addressable extended address mask. If a the per-core BHND DMA engine supports the 'addrext' control field, it can be used to provide address bits excluded by <var class=Fa>addr_mask</var>. <p class=Pp>Support for DMA extended address changes — including coordination with the core providing device-to-host DMA address translation — is handled transparently by the DMA engine.</p><p class=Pp>For example, on PCI Wi-Fi devices, the Wi-Fi core's DMA engine will (in effect) update the PCI host bridge core's DMA <code class=Dv>sbtopcitranslation</code> base address to map the target address prior to performing a DMA transaction.</p></dd><dt><var class=Fa>flags</var></dt><dd>Translation flags.</dd></dl></section><section class=Ss><h2 class=Ss id=Interrupt_Functions_2><a class=permalink href=#Interrupt_Functions_2>Interrupt Functions</a></h2> The <code class=Fn>bhnd_get_intr_count</code>() function is used to determine the number of backplane interrupt lines assigned to the device <var class=Fa>dev</var>. Interrupt line identifiers are allocated in monotonically increasing order, starting with 0. <p class=Pp>The <code class=Fn>bhnd_get_intr_ivec</code>() function is used to determine the backplane interrupt vector assigned to interrupt line <var class=Fa>intr</var> on the device <var class=Fa>dev</var>, writing the result to <var class=Fa>ivec</var>. Interrupt vector assignments are backplane-specific: On BCMA devices, this function returns the OOB bus line assigned to the interrupt. On SIBA devices, it returns the target OCP slave flag number assigned to the interrupt.</p><p class=Pp>The <code class=Fn>bhnd_map_intr</code>() function is used to map interrupt line <var class=Fa>intr</var> assigned to device <var class=Fa>dev</var> to an IRQ number, writing the result to <var class=Fa>irq</var>. Until unmapped, this IRQ may be used when allocating a resource of type SYS_RES_IRQ.</p><p class=Pp>Ownership of the interrupt mapping is assumed by the caller, and must be explicitly released using <var class=Fa>bhnd_unmap_intr</var>.</p><p class=Pp>The <code class=Fn>bhnd_unmap_intr</code>() function is used to unmap bus IRQ <var class=Fa>irq</var> previously mapped using <code class=Fn>bhnd_map_intr</code>() by the device <var class=Fa>dev</var>.</p></section><section class=Ss><h2 class=Ss id=NVRAM_Functions_2><a class=permalink href=#NVRAM_Functions_2>NVRAM Functions</a></h2> The <code class=Fn>bhnd_nvram_getvar</code>() function is used to read the value of NVRAM variable <var class=Fa>name</var> from the NVRAM provider(s) registered with the parent <a class=Xr href=bhnd.4.html>bhnd(4)</a> bus of device <var class=Fa>dev</var>, coerced to the desired data representation <var class=Fa>type</var>, written to the buffer specified by <var class=Fa>buf</var>. <p class=Pp>Before the call, the maximum capacity of <var class=Fa>buf</var> is specified by <var class=Fa>len</var>. After a successful call — or if <code class=Er>ENOMEM</code> is returned — the size of the available data will be written to <var class=Fa>len</var>. The size of the desired data representation can be determined by calling <code class=Fn>bhnd_nvram_getvar</code>() with a <code class=Dv>NULL</code> argument for <var class=Fa>buf</var>.</p><p class=Pp>The following NVRAM data types are supported:</p><p class=Pp></p><div class=Bd-indent><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#BHND_NVRAM_TYPE_UINT8><code class=Dv id=BHND_NVRAM_TYPE_UINT8>BHND_NVRAM_TYPE_UINT8</code></a></dt><dd>unsigned 8-bit integer</dd><dt><a class=permalink href=#BHND_NVRAM_TYPE_UINT16><code class=Dv id=BHND_NVRAM_TYPE_UINT16>BHND_NVRAM_TYPE_UINT16</code></a></dt><dd>unsigned 16-bit integer</dd><dt><a class=permalink href=#BHND_NVRAM_TYPE_UINT32><code class=Dv id=BHND_NVRAM_TYPE_UINT32>BHND_NVRAM_TYPE_UINT32</code></a></dt><dd>unsigned 32-bit integer</dd><dt><a class=permalink href=#BHND_NVRAM_TYPE_UINT64><code class=Dv id=BHND_NVRAM_TYPE_UINT64>BHND_NVRAM_TYPE_UINT64</code></a></dt><dd>signed 64-bit integer</dd><dt><a class=permalink href=#BHND_NVRAM_TYPE_INT8><code class=Dv id=BHND_NVRAM_TYPE_INT8>BHND_NVRAM_TYPE_INT8</code></a></dt><dd>signed 8-bit integer</dd><dt><a class=permalink href=#BHND_NVRAM_TYPE_INT16><code class=Dv id=BHND_NVRAM_TYPE_INT16>BHND_NVRAM_TYPE_INT16</code></a></dt><dd>signed 16-bit integer</dd><dt><a class=permalink href=#BHND_NVRAM_TYPE_INT32><code class=Dv id=BHND_NVRAM_TYPE_INT32>BHND_NVRAM_TYPE_INT32</code></a></dt><dd>signed 32-bit integer</dd><dt><a class=permalink href=#BHND_NVRAM_TYPE_INT64><code class=Dv id=BHND_NVRAM_TYPE_INT64>BHND_NVRAM_TYPE_INT64</code></a></dt><dd>signed 64-bit integer</dd><dt><a class=permalink href=#BHND_NVRAM_TYPE_CHAR><code class=Dv id=BHND_NVRAM_TYPE_CHAR>BHND_NVRAM_TYPE_CHAR</code></a></dt><dd>UTF-8 character</dd><dt><a class=permalink href=#BHND_NVRAM_TYPE_STRING><code class=Dv id=BHND_NVRAM_TYPE_STRING>BHND_NVRAM_TYPE_STRING</code></a></dt><dd>UTF-8 NUL-terminated string</dd><dt><a class=permalink href=#BHND_NVRAM_TYPE_BOOL><code class=Dv id=BHND_NVRAM_TYPE_BOOL>BHND_NVRAM_TYPE_BOOL</code></a></dt><dd>uint8 boolean value</dd><dt><a class=permalink href=#BHND_NVRAM_TYPE_NULL><code class=Dv id=BHND_NVRAM_TYPE_NULL>BHND_NVRAM_TYPE_NULL</code></a></dt><dd>NULL (empty) value</dd><dt><a class=permalink href=#BHND_NVRAM_TYPE_DATA><code class=Dv id=BHND_NVRAM_TYPE_DATA>BHND_NVRAM_TYPE_DATA</code></a></dt><dd>opaque octet string</dd><dt><a class=permalink href=#BHND_NVRAM_TYPE_UINT8_ARRAY><code class=Dv id=BHND_NVRAM_TYPE_UINT8_ARRAY>BHND_NVRAM_TYPE_UINT8_ARRAY</code></a></dt><dd>array of uint8 integers</dd><dt><a class=permalink href=#BHND_NVRAM_TYPE_UINT16_ARRAY><code class=Dv id=BHND_NVRAM_TYPE_UINT16_ARRAY>BHND_NVRAM_TYPE_UINT16_ARRAY</code></a></dt><dd>array of uint16 integers</dd><dt><a class=permalink href=#BHND_NVRAM_TYPE_UINT32_ARRAY><code class=Dv id=BHND_NVRAM_TYPE_UINT32_ARRAY>BHND_NVRAM_TYPE_UINT32_ARRAY</code></a></dt><dd>array of uint32 integers</dd><dt><a class=permalink href=#BHND_NVRAM_TYPE_UINT64_ARRAY><code class=Dv id=BHND_NVRAM_TYPE_UINT64_ARRAY>BHND_NVRAM_TYPE_UINT64_ARRAY</code></a></dt><dd>array of uint64 integers</dd><dt><a class=permalink href=#BHND_NVRAM_TYPE_INT8_ARRAY><code class=Dv id=BHND_NVRAM_TYPE_INT8_ARRAY>BHND_NVRAM_TYPE_INT8_ARRAY</code></a></dt><dd>array of int8 integers</dd><dt><a class=permalink href=#BHND_NVRAM_TYPE_INT16_ARRAY><code class=Dv id=BHND_NVRAM_TYPE_INT16_ARRAY>BHND_NVRAM_TYPE_INT16_ARRAY</code></a></dt><dd>array of int16 integers</dd><dt><a class=permalink href=#BHND_NVRAM_TYPE_INT32_ARRAY><code class=Dv id=BHND_NVRAM_TYPE_INT32_ARRAY>BHND_NVRAM_TYPE_INT32_ARRAY</code></a></dt><dd>array of int32 integers</dd><dt><a class=permalink href=#BHND_NVRAM_TYPE_INT64_ARRAY><code class=Dv id=BHND_NVRAM_TYPE_INT64_ARRAY>BHND_NVRAM_TYPE_INT64_ARRAY</code></a></dt><dd>array of int64 integers</dd><dt><a class=permalink href=#BHND_NVRAM_TYPE_CHAR_ARRAY><code class=Dv id=BHND_NVRAM_TYPE_CHAR_ARRAY>BHND_NVRAM_TYPE_CHAR_ARRAY</code></a></dt><dd>array of UTF-8 characters</dd><dt><a class=permalink href=#BHND_NVRAM_TYPE_STRING_ARRAY><code class=Dv id=BHND_NVRAM_TYPE_STRING_ARRAY>BHND_NVRAM_TYPE_STRING_ARRAY</code></a></dt><dd>array of UTF-8 NUL-terminated strings</dd><dt><a class=permalink href=#BHND_NVRAM_TYPE_BOOL_ARRAY><code class=Dv id=BHND_NVRAM_TYPE_BOOL_ARRAY>BHND_NVRAM_TYPE_BOOL_ARRAY</code></a></dt><dd>array of uint8 boolean values</dd></dl></div><p class=Pp>The <code class=Fn>bhnd_nvram_getvar_array</code>(), <code class=Fn>bhnd_nvram_getvar_int</code>(), <code class=Fn>bhnd_nvram_getvar_int8</code>(), <code class=Fn>bhnd_nvram_getvar_int16</code>(), <code class=Fn>bhnd_nvram_getvar_int32</code>(), <code class=Fn>bhnd_nvram_getvar_uint</code>(), <code class=Fn>bhnd_nvram_getvar_uint8</code>(), <code class=Fn>bhnd_nvram_getvar_uint16</code>(), <code class=Fn>bhnd_nvram_getvar_uint32</code>(), and <code class=Fn>bhnd_nvram_getvar_str</code>() functions are convenience wrappers for <code class=Fn>bhnd_nvram_getvar</code>().</p><p class=Pp>The <code class=Fn>bhnd_nvram_getvar_array</code>() function returns either a value of exactly <var class=Fa>size</var> in <var class=Fa>buf</var>, or returns an error code of <code class=Er>ENXIO</code> if the data representation is not exactly <var class=Fa>size</var> in length.</p><p class=Pp>The <code class=Fn>bhnd_nvram_getvar_int</code>() and <code class=Fn>bhnd_nvram_getvar_uint</code>() functions return the value of NVRAM variable <var class=Fa>name</var>, coerced to a signed or unsigned integer type of <var class=Fa>width</var> (1, 2, or 4 bytes).</p><p class=Pp>The <code class=Fn>bhnd_nvram_getvar_int8</code>(), <code class=Fn>bhnd_nvram_getvar_int16</code>(), <code class=Fn>bhnd_nvram_getvar_int32</code>(), <code class=Fn>bhnd_nvram_getvar_uint</code>(), <code class=Fn>bhnd_nvram_getvar_uint8</code>(), <code class=Fn>bhnd_nvram_getvar_uint16</code>(), and <code class=Fn>bhnd_nvram_getvar_uint32</code>() functions return the value of NVRAM variable <var class=Fa>name</var>, coerced to a signed or unsigned 8, 16, or 32-bit integer type.</p><p class=Pp>The <code class=Fn>bhnd_nvram_getvar_str</code>() functions return the value of NVRAM variable <var class=Fa>name</var>, coerced to a NUL-terminated string.</p><p class=Pp>The <code class=Fn>bhnd_nvram_string_array_next</code>() function iterates over all strings in the <var class=Fa>inp</var><code class=Dv>BHND_NVRAM_TYPE_STRING_ARRAY</code> value. The size of <var class=Fa>inp</var>, including any terminating NUL character(s), is specified using the <var class=Fa>ilen</var> argument. The <var class=Fa>prev</var> argument should be either a string pointer previously returned by <code class=Fn>bhnd_nvram_string_array_next</code>(), or <code class=Dv>NULL</code> to begin iteration. If <var class=Fa>prev is not</var><code class=Dv>NULL</code>, the <var class=Fa>olen</var> argument must be a pointer to the length previously returned by <code class=Fn>bhnd_nvram_string_array_next</code>(). On success, the next string element's length will be written to this pointer.</p></section><section class=Ss><h2 class=Ss id=Port/Region_Functions_2><a class=permalink href=#Port/Region_Functions_2>Port/Region Functions</a></h2> Per-device interconnect memory mappings are identified by a combination of <i class=Em>port type</i>, <i class=Em>port number</i>, and <i class=Em>region number</i>. Port and memory region identifiers are allocated in monotonically increasing order for each <i class=Em>port type</i>, starting with 0. <p class=Pp>The following port types are supported:</p><div class=Bd-indent><dl class=Bl-tag><dt><a class=permalink href=#BHND_PORT_DEVICE><code class=Dv id=BHND_PORT_DEVICE>BHND_PORT_DEVICE</code></a></dt><dd>Device memory. The device's control/status registers are always mapped by the first device port and region, and will be assigned a <code class=Dv>SYS_RES_MEMORY</code> resource ID of 0.</dd><dt><a class=permalink href=#BHND_PORT_BRIDGE><code class=Dv id=BHND_PORT_BRIDGE>BHND_PORT_BRIDGE</code></a></dt><dd>Bridge memory.</dd><dt><a class=permalink href=#BHND_PORT_AGENT><code class=Dv id=BHND_PORT_AGENT>BHND_PORT_AGENT</code></a></dt><dd>Interconnect agent/wrapper.</dd></dl></div><p class=Pp>The <code class=Fn>bhnd_decode_port_rid</code>() function is used to decode the resource ID <var class=Fa>rid</var> assigned to device <var class=Fa>dev</var>, of resource type <var class=Fa>type</var>, writing the port type to <var class=Fa>port_type</var>, port number to <var class=Fa>port</var>, and region number to <var class=Fa>region</var>.</p><p class=Pp>The <code class=Fn>bhnd_get_port_count</code>() function returns the number of ports of type <var class=Fa>type</var> assigned to device <var class=Fa>dev</var>.</p><p class=Pp>The <code class=Fn>bhnd_get_port_rid</code>() function returns the resource ID for the <code class=Dv>SYS_RES_MEMORY</code> resource mapping the <var class=Fa>port</var> of <var class=Fa>type</var> and <var class=Fa>region</var> on device <var class=Fa>dev</var>, or -1 if the port or region are invalid, or do not have an assigned resource ID.</p><p class=Pp>The <code class=Fn>bhnd_get_region_addr</code>() function is used to determine the base address and size of the memory <var class=Fa>region</var> on <var class=Fa>port</var> of <var class=Fa>type</var> assigned to <var class=Fa>dev</var>. The region's base device address will be written to <var class=Fa>region_addr</var>, and the region size to <var class=Fa>region_size</var>.</p><p class=Pp>The <code class=Fn>bhnd_get_region_count</code>() function returns the number of memory regions mapped to <var class=Fa>port</var> of <var class=Fa>type</var> on device <var class=Fa>dev</var>.</p><p class=Pp>The <code class=Fn>bhnd_is_region_valid</code>() function returns <code class=Dv>true</code> if <var class=Fa>region</var> is a valid region mapped by <var class=Fa>port</var> of <var class=Fa>type</var> on device <var class=Fa>dev</var>.</p></section><section class=Ss><h2 class=Ss id=Power_Management_Functions_2><a class=permalink href=#Power_Management_Functions_2>Power Management Functions</a></h2> Drivers must ask the parent <a class=Xr href=bhnd.4.html>bhnd(4)</a> bus to allocate device PMU state using <code class=Fn>bhnd_alloc_pmu</code>() before calling any another bhnd PMU functions. <p class=Pp>The <code class=Fn>bhnd_alloc_pmu</code>() function is used to allocate per-device PMU state and enable PMU request handling for device <var class=Fa>dev</var>. The memory region containing the device's PMU register block must be allocated using <a class=Xr href=bus_alloc_resource.9.html>bus_alloc_resource(9)</a> or <code class=Fn>bhnd_alloc_resource</code>() before calling <code class=Fn>bhnd_alloc_pmu</code>(), and must not be released until after calling <code class=Fn>bhnd_release_pmu</code>().</p><p class=Pp>On all supported BHND hardware, the PMU register block is mapped by the device's control/status registers in the first device port and region.</p><p class=Pp>The <code class=Fn>bhnd_release_pmu</code>() function releases the per-device PMU state previously allocated for device <var class=Fa>dev</var> using <code class=Fn>bhnd_alloc_pmu</code>(). Any outstanding clock and external resource requests will be discarded upon release of the device PMU state.</p><p class=Pp>The <code class=Fn>bhnd_enable_clocks</code>() function is used to request that <var class=Fa>clocks</var> be powered up and routed to the backplane on behalf of device <var class=Fa>dev</var>. This will power any clock sources required (e.g., XTAL, PLL, etc) and wait until the requested clocks are stable. If the request succeeds, any previous clock requests issued by <var class=Fa>dev</var> will be discarded.</p><p class=Pp>The following clocks are supported, and may be combined using bitwise OR to request multiple clocks:</p><div class=Bd-indent><dl class=Bl-tag><dt>BHND_CLOCK_DYN</dt><dd>Dynamically select an appropriate clock source based on all outstanding clock requests by any device attached to the parent <a class=Xr href=bhnd.4.html>bhnd(4)</a> bus.</dd><dt>BHND_CLOCK_ILP</dt><dd>Idle Low-Power (ILP) Clock. May be used if no register access is required, or long request latency is acceptable.</dd><dt>BHND_CLOCK_ALP</dt><dd>Active Low-Power (ALP) Clock. Supports low-latency register access and low-rate DMA.</dd><dt>BHND_CLOCK_HT</dt><dd>High Throughput (HT) Clock. Supports high bus throughput and lowest-latency register access.</dd></dl></div><p class=Pp>The <code class=Fn>bhnd_request_clock</code>() function is used to request that <var class=Fa>clock</var> (or faster) be powered up and routed to device <var class=Fa>dev</var>.</p><p class=Pp>The <code class=Fn>bhnd_get_clock_freq</code>() function is used to request the current clock frequency of <var class=Fa>clock</var>, writing the frequency in Hz to <var class=Fa>freq</var>.</p><p class=Pp>The <code class=Fn>bhnd_get_clock_latency</code>() function is used to determine the transition latency required for <var class=Fa>clock</var>, writing the latency in microseconds to <var class=Fa>latency</var>. The <code class=Dv>BHND_CLOCK_HT</code> latency value is suitable for use as the D11 Wi-Fi core <i class=Em>fastpwrup_dly</i> value.</p><p class=Pp>The <code class=Fn>bhnd_request_ext_rsrc</code>() function is used to request that the external PMU-managed resource assigned to device <var class=Fa>dev</var>, identified by device-specific identifier <var class=Fa>rsrc</var>, be powered up.</p><p class=Pp>The <code class=Fn>bhnd_release_ext_rsrc</code>() function releases any outstanding requests by device <var class=Fa>dev</var> for the PMU-managed resource identified by device-specific identifier <var class=Fa>rsrc</var>. If an external resource is shared by multiple devices, it will not be powered down until all device requests are released.</p></section><section class=Ss><h2 class=Ss id=Service_Provider_Functions_2><a class=permalink href=#Service_Provider_Functions_2>Service Provider Functions</a></h2> The <code class=Fn>bhnd_register_provider</code>() function is used to register device <var class=Fa>dev</var> as a provider for platform <var class=Fa>service</var> with the parent <a class=Xr href=bhnd.4.html>bhnd(4)</a> bus. <p class=Pp>The following service types are supported:</p><div class=Bd-indent><dl class=Bl-tag><dt><a class=permalink href=#BHND_SERVICE_CHIPC><code class=Dv id=BHND_SERVICE_CHIPC>BHND_SERVICE_CHIPC</code></a></dt><dd>ChipCommon service. The providing device must implement the bhnd_chipc interface.</dd><dt><a class=permalink href=#BHND_SERVICE_PWRCTL><code class=Dv id=BHND_SERVICE_PWRCTL>BHND_SERVICE_PWRCTL</code></a></dt><dd>Legacy PWRCTL service. The providing device must implement the bhnd_pwrctl interface.</dd><dt><a class=permalink href=#BHND_SERVICE_PMU><code class=Dv id=BHND_SERVICE_PMU>BHND_SERVICE_PMU</code></a></dt><dd>PMU service. The providing device must implement the bhnd_pmu interface.</dd><dt><a class=permalink href=#BHND_SERVICE_NVRAM><code class=Dv id=BHND_SERVICE_NVRAM>BHND_SERVICE_NVRAM</code></a></dt><dd>NVRAM service. The providing device must implement the bhnd_nvram interface.</dd><dt><a class=permalink href=#BHND_SERVICE_GPIO><code class=Dv id=BHND_SERVICE_GPIO>BHND_SERVICE_GPIO</code></a></dt><dd>GPIO service. The providing device must implement the standard <a class=Xr href=gpio.4.html>gpio(4)</a> interface.</dd><dt><a class=permalink href=#BHND_SERVICE_ANY><code class=Dv id=BHND_SERVICE_ANY>BHND_SERVICE_ANY</code></a></dt><dd>Matches on any service type. May be used with <code class=Fn>bhnd_deregister_provider</code>() to remove all service provider registrations for a device.</dd></dl></div><p class=Pp>The <code class=Fn>bhnd_deregister_provider</code>() function attempts to remove provider registration for the device <var class=Fa>dev</var> and <var class=Fa>service</var>. If a <var class=Fa>service</var> argument of <code class=Dv>BHND_SERVICE_ANY</code> is specified, this function will attempt to remove <i class=Em>all service provider registrations for</i><var class=Fa>dev</var>.</p><p class=Pp>The <code class=Fn>bhnd_retain_provider</code>() function retains and returns a reference to the provider registered for <var class=Fa>service</var> with the parent <a class=Xr href=bhnd.4.html>bhnd(4)</a> bus of devce <var class=Fa>dev</var>, if available. On success, the caller is responsible for releasing this provider reference using <code class=Fn>bhnd_release_provider</code>(). The service provider is guaranteed to remain available until the provider reference is released.</p><p class=Pp>The <code class=Fn>bhnd_release_provider</code>() function releases a reference to a <var class=Fa>provider</var> for <var class=Fa>service</var>, previously retained by device <var class=Fa>dev</var> using <code class=Fn>bhnd_retain_provider</code>().</p></section><section class=Ss><h2 class=Ss id=Utility_Functions_2><a class=permalink href=#Utility_Functions_2>Utility Functions</a></h2> The <code class=Fn>bhnd_driver_get_erom_class</code>() function returns the <a class=Xr href=bhnd_erom.9.html>bhnd_erom(9)</a> class for the device enumeration table format used by <a class=Xr href=bhnd.4.html>bhnd(4)</a> bus driver instance <var class=Fa>driver</var>. If the driver does not support <a class=Xr href=bhnd_erom.9.html>bhnd_erom(9)</a> device enumeration, <code class=Dv>NULL</code> is returned. <p class=Pp>The <code class=Fn>bhnd_find_core_class</code>() function looks up the BHND class, if known, for the BHND vendor ID <var class=Fa>vendor</var> and device ID <var class=Fa>device</var>.</p><p class=Pp>The <code class=Fn>bhnd_find_core_name</code>() function is used to fetch the human-readable name, if known, for the BHND core with a vendor ID of <var class=Fa>vendor</var> and device ID of <var class=Fa>device</var>.</p><p class=Pp>The <code class=Fn>bhnd_core_class</code>() and <code class=Fn>bhnd_core_name</code>() functions are convenience wrappers for <code class=Fn>bhnd_find_core_class</code>() and <code class=Fn>bhnd_find_core_name</code>(), that use the <var class=Fa>vendor</var> and <var class=Fa>device</var> fields of the core info structure <var class=Fa>ci</var>.</p><p class=Pp>The <code class=Fn>bhnd_format_chip_id</code>() function writes a NUL-terminated human-readable representation of the BHND <var class=Fa>chip_id</var> value to the specified <var class=Fa>buffer</var> with a capacity of <var class=Fa>size</var>. No more than <var class=Fa>size-1</var> characters will be written, with the <var class=Fa>size'th</var> character set to '\0'. A buffer size of <code class=Dv>BHND_CHIPID_MAX_NAMELEN</code> is sufficient for any string representation produced using <code class=Fn>bhnd_format_chip_id</code>().</p><p class=Pp>The <code class=Fn>bhnd_set_custom_core_desc</code>() function uses the <a class=Xr href=bhnd.4.html>bhnd(4)</a> device identification of <var class=Fa>dev</var>, overriding the core name with the specified <var class=Fa>dev_name</var>, to populate the device's verbose description using <a class=Xr href=device_set_desc.1.html>device_set_desc</a>.</p><p class=Pp>The <code class=Fn>bhnd_set_default_core_desc</code>() function uses the <a class=Xr href=bhnd.4.html>bhnd(4)</a> device identification of <var class=Fa>dev</var> to populate the device's verbose description using <a class=Xr href=device_set_desc.1.html>device_set_desc</a>.</p><p class=Pp>The <code class=Fn>bhnd_vendor_name</code>() function returns the human-readable name for the JEP-106, ARM 4-bit continuation encoded manufacturer ID <var class=Fa>vendor</var>, if known.</p></section></section><section class=Sh><h2 class=Sh id=RETURN_VALUES><a class=permalink href=#RETURN_VALUES>RETURN VALUES</a></h2><section class=Ss><h2 class=Ss id=Bus_Resource_Functions_3><a class=permalink href=#Bus_Resource_Functions_3>Bus Resource Functions</a></h2> The <code class=Fn>bhnd_activate_resource</code>(), <code class=Fn>bhnd_alloc_resources</code>(), <code class=Fn>bhnd_deactivate_resource</code>(), and <code class=Fn>bhnd_release_resource</code>() functions return 0 on success, otherwise an appropriate error code is returned. <p class=Pp>The <code class=Fn>bhnd_alloc_resource</code>() and <code class=Fn>bhnd_alloc_resource_any</code>() functions return a pointer to <var class=Vt>struct resource</var> on success, a null pointer otherwise.</p></section><section class=Ss><h2 class=Ss id=Device_Configuration_Functions_3><a class=permalink href=#Device_Configuration_Functions_3>Device Configuration Functions</a></h2> The <code class=Fn>bhnd_read_config</code>() and <code class=Fn>bhnd_write_config</code>() functions return 0 on success, or one of the following values on error: <dl class=Bl-tag><dt>[<code class=Er>EINVAL</code>]</dt><dd>The device is not a direct child of the <a class=Xr href=bhnd.4.html>bhnd(4)</a> bus</dd><dt>[<code class=Er>EINVAL</code>]</dt><dd>The requested width is not one of 1, 2, or 4 bytes.</dd><dt>[<code class=Er>ENODEV</code>]</dt><dd>Accessing agent/config space for the device is unsupported.</dd><dt>[<code class=Er>EFAULT</code>]</dt><dd>The requested offset or width exceeds the bounds of the mapped agent/config space.</dd></dl><p class=Pp>The <code class=Fn>bhnd_read_ioctl</code>(), <code class=Fn>bhnd_write_ioctl</code>(), <code class=Fn>bhnd_read_iost</code>(), <code class=Fn>bhnd_reset_hw</code>(), and <code class=Fn>bhnd_suspend_hw</code>() functions return 0 on success, otherwise an appropriate error code is returned.</p></section><section class=Ss><h2 class=Ss id=Device_Information_Functions_3><a class=permalink href=#Device_Information_Functions_3>Device Information Functions</a></h2> The <code class=Fn>bhnd_read_board_info</code>() function returns 0 on success, otherwise an appropriate error code is returned. </section><section class=Ss><h2 class=Ss id=DMA_Address_Translation_Functions_3><a class=permalink href=#DMA_Address_Translation_Functions_3>DMA Address Translation Functions</a></h2> The <code class=Fn>bhnd_get_dma_translation</code>() function returns 0 on success, or one of the following values on error: <dl class=Bl-tag><dt>[<code class=Er>ENODEV</code>]</dt><dd>DMA is not supported.</dd><dt>[<code class=Er>ENOENT</code>]</dt><dd>No DMA translation matching the requested address width and translation flags is available.</dd></dl><p class=Pp>If fetching the requested DMA address translation otherwise fails, an appropriate error code will be returned.</p></section><section class=Ss><h2 class=Ss id=Interrupt_Functions_3><a class=permalink href=#Interrupt_Functions_3>Interrupt Functions</a></h2> The <code class=Fn>bhnd_get_intr_ivec</code>() function returns 0 on success, or <code class=Er>ENXIO</code> if the requested interrupt line exceeds the number of interrupt lines assigned to the device. <p class=Pp>The <code class=Fn>bhnd_map_intr</code>() function returns 0 on success, otherwise an appropriate error code is returned.</p></section><section class=Ss><h2 class=Ss id=NVRAM_Functions_3><a class=permalink href=#NVRAM_Functions_3>NVRAM Functions</a></h2> The <code class=Fn>bhnd_nvram_getvar</code>(), <code class=Fn>bhnd_nvram_getvar_array</code>(), <code class=Fn>bhnd_nvram_getvar_int</code>(), <code class=Fn>bhnd_nvram_getvar_int8</code>(), <code class=Fn>bhnd_nvram_getvar_int16</code>(), <code class=Fn>bhnd_nvram_getvar_int32</code>(), <code class=Fn>bhnd_nvram_getvar_uint</code>(), <code class=Fn>bhnd_nvram_getvar_uint8</code>(), <code class=Fn>bhnd_nvram_getvar_uint16</code>(), and <code class=Fn>bhnd_nvram_getvar_uint32</code>() functions return 0 on success, or one of the following values on error: <dl class=Bl-tag><dt>[<code class=Er>ENODEV</code>]</dt><dd>If an NVRAM provider has not been registered with the bus.</dd><dt>[<code class=Er>ENOENT</code>]</dt><dd>The requested variable was not found.</dd><dt>[<code class=Er>ENOMEM</code>]</dt><dd>If the buffer of size is too small to hold the requested value.</dd><dt>[<code class=Er>EOPNOTSUPP</code>]</dt><dd>If the value's native type is incompatible with and cannot be coerced to the requested type.</dd><dt>[<code class=Er>ERANGE</code>]</dt><dd>If value coercion would overflow (or underflow) the requested type</dd></dl><p class=Pp>If reading the variable otherwise fails, an appropriate error code will be returned.</p></section><section class=Ss><h2 class=Ss id=Port/Region_Functions_3><a class=permalink href=#Port/Region_Functions_3>Port/Region Functions</a></h2> The <code class=Fn>bhnd_decode_port_rid</code>() function returns 0 on success, or an appropriate error code if no matching port/region is found. <p class=Pp>The <code class=Fn>bhnd_get_port_rid</code>() function returns the resource ID for the requested port and region, or -1 if the port or region are invalid, or do not have an assigned resource ID.</p><p class=Pp>The <code class=Fn>bhnd_get_region_addr</code>() function returns 0 on success, or an appropriate error code if no matching port/region is found.</p></section><section class=Ss><h2 class=Ss id=PMU_Functions><a class=permalink href=#PMU_Functions>PMU Functions</a></h2> The <code class=Fn>bhnd_alloc_pmu</code>() function returns 0 on success, otherwise an appropriate error code is returned. <p class=Pp>The <code class=Fn>bhnd_release_pmu</code>() function returns 0 on success, otherwise an appropriate error code is returned, and the core state will be left unmodified.</p><p class=Pp>The <code class=Fn>bhnd_enable_clocks</code>() and <code class=Fn>bhnd_request_clock</code>() functions return 0 on success, or one of the following values on error:</p><dl class=Bl-tag><dt>[<code class=Er>ENODEV</code>]</dt><dd>An unsupported clock was requested.</dd><dt>[<code class=Er>ENXIO</code>]</dt><dd>No PMU or PWRCTL provider has been registered with the bus.</dd></dl><p class=Pp>The <code class=Fn>bhnd_get_clock_freq</code>() function returns 0 on success, or <code class=Er>ENODEV</code> if the frequency for the specified clock is not available.</p><p class=Pp>The <code class=Fn>bhnd_get_clock_latency</code>() function returns 0 on success, or <code class=Er>ENODEV</code> if the transition latency for the specified clock is not available.</p><p class=Pp>The <code class=Fn>bhnd_request_ext_rsrc</code>() and <code class=Fn>bhnd_release_ext_rsrc</code>() functions return 0 on success, otherwise an appropriate error code is returned.</p></section><section class=Ss><h2 class=Ss id=Service_Provider_Functions_3><a class=permalink href=#Service_Provider_Functions_3>Service Provider Functions</a></h2> The <code class=Fn>bhnd_register_provider</code>() function returns 0 on success, <code class=Er>EEXIST</code> if an entry for service already exists, or an appropriate error code if service registration otherwise fails. <p class=Pp>The <code class=Fn>bhnd_deregister_provider</code>() function returns 0 on success, or <code class=Er>EBUSY</code> if active references to the service provider exist.</p><p class=Pp>The <code class=Fn>bhnd_retain_provider</code>() function returns a pointer to <var class=Vt>device_t</var> on success, a null pointer if the requested provider is not registered.</p></section><section class=Ss><h2 class=Ss id=Utility_Functions_3><a class=permalink href=#Utility_Functions_3>Utility Functions</a></h2> The <code class=Fn>bhnd_format_chip_id</code>() function returns the total number of bytes written on success, or a negative integer on failure. </section></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=bhnd.4.html>bhnd(4)</a><a class=Xr href=bhnd_erom.9.html>bhnd_erom(9)</a></section><section class=Sh><h2 class=Sh id=AUTHORS><a class=permalink href=#AUTHORS>AUTHORS</a></h2> The <code class=Nm>bhnd</code> driver programming interface and this manual page were written by <span class=An>Landon Fuller</span> &lt;<a class=Mt href=mailto:landonf@FreeBSD.org>landonf@FreeBSD.org</a>&gt;. </section></div><table class=foot><tr><td class=foot-date>March 26, 2018</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>