<!DOCTYPE html>
<html><head><meta charset=utf-8><title>sbuf_hexdump(9)</title><keywords content=man,sbuf_hexdump></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>sbuf_hexdump(9)</h1><table class=head><tr><td class=head-ltitle>SBUF(9)</td><td class=head-vol>FreeBSD Kernel Developer's Manual</td><td class=head-rtitle>SBUF(9)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>sbuf</code>, <code class=Nm>sbuf_new</code>, <code class=Nm>sbuf_new_auto</code>, <code class=Nm>sbuf_new_for_sysctl</code>, <code class=Nm>sbuf_clear</code>, <code class=Nm>sbuf_get_flags</code>, <code class=Nm>sbuf_set_flags</code>, <code class=Nm>sbuf_clear_flags</code>, <code class=Nm>sbuf_setpos</code>, <code class=Nm>sbuf_bcat</code>, <code class=Nm>sbuf_bcopyin</code>, <code class=Nm>sbuf_bcpy</code>, <code class=Nm>sbuf_cat</code>, <code class=Nm>sbuf_copyin</code>, <code class=Nm>sbuf_cpy</code>, <code class=Nm>sbuf_printf</code>, <code class=Nm>sbuf_vprintf</code>, <code class=Nm>sbuf_putc</code>, <code class=Nm>sbuf_set_drain</code>, <code class=Nm>sbuf_trim</code>, <code class=Nm>sbuf_error</code>, <code class=Nm>sbuf_finish</code>, <code class=Nm>sbuf_data</code>, <code class=Nm>sbuf_len</code>, <code class=Nm>sbuf_done</code>, <code class=Nm>sbuf_delete</code>, <code class=Nm>sbuf_start_section</code>, <code class=Nm>sbuf_end_section</code>, <code class=Nm>sbuf_hexdump</code>, <code class=Nm>sbuf_putbuf</code> — <div class=Nd>safe string composition</div></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/sys/types.h.html>sys/types.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/sys/sbuf.h.html>sys/sbuf.h</a>&gt;</code><p class=Pp><var class=Ft>typedef int</var> ( <br><var class=Ft>sbuf_drain_func</var>) ( <br><var class=Ft>void *arg, const char *data, int len</var>);</p><p class=Pp><br><var class=Ft>struct sbuf *</var><br><code class=Fn>sbuf_new</code>(<var class=Fa>struct sbuf *s</var>, <var class=Fa>char *buf</var>, <var class=Fa>int length</var>, <var class=Fa>int flags</var>);</p><p class=Pp><var class=Ft>struct sbuf *</var><br><code class=Fn>sbuf_new_auto</code>(<var class=Fa>void</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>sbuf_clear</code>(<var class=Fa>struct sbuf *s</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>sbuf_get_flags</code>(<var class=Fa>struct sbuf *s</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>sbuf_set_flags</code>(<var class=Fa>struct sbuf *s</var>, <var class=Fa>int flags</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>sbuf_clear_flags</code>(<var class=Fa>struct sbuf *s</var>, <var class=Fa>int flags</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>sbuf_setpos</code>(<var class=Fa>struct sbuf *s</var>, <var class=Fa>int pos</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>sbuf_bcat</code>(<var class=Fa>struct sbuf *s</var>, <var class=Fa>const void *buf</var>, <var class=Fa>size_t len</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>sbuf_bcpy</code>(<var class=Fa>struct sbuf *s</var>, <var class=Fa>const void *buf</var>, <var class=Fa>size_t len</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>sbuf_cat</code>(<var class=Fa>struct sbuf *s</var>, <var class=Fa>const char *str</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>sbuf_cpy</code>(<var class=Fa>struct sbuf *s</var>, <var class=Fa>const char *str</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>sbuf_printf</code>(<var class=Fa>struct sbuf *s</var>, <var class=Fa>const char *fmt</var>, <var class=Fa>...</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>sbuf_vprintf</code>(<var class=Fa>struct sbuf *s</var>, <var class=Fa>const char *fmt</var>, <var class=Fa>va_list ap</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>sbuf_putc</code>(<var class=Fa>struct sbuf *s</var>, <var class=Fa>int c</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>sbuf_set_drain</code>(<var class=Fa>struct sbuf *s</var>, <var class=Fa>sbuf_drain_func *func</var>, <var class=Fa>void *arg</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>sbuf_trim</code>(<var class=Fa>struct sbuf *s</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>sbuf_error</code>(<var class=Fa>struct sbuf *s</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>sbuf_finish</code>(<var class=Fa>struct sbuf *s</var>);</p><p class=Pp><var class=Ft>char *</var><br><code class=Fn>sbuf_data</code>(<var class=Fa>struct sbuf *s</var>);</p><p class=Pp><var class=Ft>ssize_t</var><br><code class=Fn>sbuf_len</code>(<var class=Fa>struct sbuf *s</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>sbuf_done</code>(<var class=Fa>struct sbuf *s</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>sbuf_delete</code>(<var class=Fa>struct sbuf *s</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>sbuf_start_section</code>(<var class=Fa>struct sbuf *s</var>, <var class=Fa>ssize_t *old_lenp</var>);</p><p class=Pp><var class=Ft>ssize_t</var><br><code class=Fn>sbuf_end_section</code>(<var class=Fa>struct sbuf *s</var>, <var class=Fa>ssize_t old_len</var>, <var class=Fa>size_t pad</var>, <var class=Fa>int c</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>sbuf_hexdump</code>(<var class=Fa>struct sbuf *sb</var>, <var class=Fa>void *ptr</var>, <var class=Fa>int length</var>, <var class=Fa>const char *hdr</var>, <var class=Fa>int flags</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>sbuf_putbuf</code>(<var class=Fa>struct sbuf *s</var>);</p><p class=Pp><code class=Fd>#ifdef _KERNEL</code></p><p class=Pp><code class=In>#include &lt;<a class=In href=../src/sys/types.h.html>sys/types.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/sys/sbuf.h.html>sys/sbuf.h</a>&gt;</code></p><p class=Pp><var class=Ft>int</var><br><code class=Fn>sbuf_bcopyin</code>(<var class=Fa>struct sbuf *s</var>, <var class=Fa>const void *uaddr</var>, <var class=Fa>size_t len</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>sbuf_copyin</code>(<var class=Fa>struct sbuf *s</var>, <var class=Fa>const void *uaddr</var>, <var class=Fa>size_t len</var>);</p><p class=Pp><code class=In>#include &lt;<a class=In href=../src/sys/sysctl.h.html>sys/sysctl.h</a>&gt;</code></p><p class=Pp><var class=Ft>struct sbuf *</var><br><code class=Fn>sbuf_new_for_sysctl</code>(<var class=Fa>struct sbuf *s</var>, <var class=Fa>char *buf</var>, <var class=Fa>int length</var>, <var class=Fa>struct sysctl_req *req</var>);</p><p class=Pp><code class=Fd>#endif /* _KERNEL */</code></p></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> The <code class=Nm>sbuf</code> family of functions allows one to safely allocate, compose and release strings in kernel or user space. <p class=Pp>Instead of arrays of characters, these functions operate on structures called <var class=Fa>sbufs</var>, defined in <code class=In>&lt;<a class=In href=../src/sys/sbuf.h.html>sys/sbuf.h</a>&gt;</code>.</p><p class=Pp>Any errors encountered during the allocation or composition of the string will be latched in the data structure, making a single error test at the end of the composition sufficient to determine success or failure of the entire process.</p><p class=Pp>The <code class=Fn>sbuf_new</code>() function initializes the <var class=Fa>sbuf</var> pointed to by its first argument. If that pointer is <code class=Dv>NULL</code>, <code class=Fn>sbuf_new</code>() allocates a <var class=Vt>struct sbuf</var> using <a class=Xr href=malloc.9.html>malloc(9)</a>. The <var class=Fa>buf</var> argument is a pointer to a buffer in which to store the actual string; if it is <code class=Dv>NULL</code>, <code class=Fn>sbuf_new</code>() will allocate one using <a class=Xr href=malloc.9.html>malloc(9)</a>. The <var class=Fa>length</var> is the initial size of the storage buffer. The fourth argument, <var class=Fa>flags</var>, may be comprised of the following flags:</p><dl class=Bl-tag><dt><a class=permalink href=#SBUF_FIXEDLEN><code class=Dv id=SBUF_FIXEDLEN>SBUF_FIXEDLEN</code></a></dt><dd>The storage buffer is fixed at its initial size. Attempting to extend the sbuf beyond this size results in an overflow condition.</dd><dt><a class=permalink href=#SBUF_AUTOEXTEND><code class=Dv id=SBUF_AUTOEXTEND>SBUF_AUTOEXTEND</code></a></dt><dd>This indicates that the storage buffer may be extended as necessary, so long as resources allow, to hold additional data.</dd><dt><a class=permalink href=#SBUF_INCLUDENUL><code class=Dv id=SBUF_INCLUDENUL>SBUF_INCLUDENUL</code></a></dt><dd>This causes the final nulterm byte to be counted in the length of the data.</dd><dt><a class=permalink href=#SBUF_DRAINTOEOR><code class=Dv id=SBUF_DRAINTOEOR>SBUF_DRAINTOEOR</code></a></dt><dd>Treat top-level sections started with <code class=Fn>sbuf_start_section</code>() as a record boundary marker that will be used during drain operations to avoid records being split. If a record grows sufficiently large such that it fills the <var class=Fa>sbuf</var> and therefore cannot be drained without being split, an error of EDEADLK is set.</dd></dl><p class=Pp>Note that if <var class=Fa>buf</var> is not <code class=Dv>NULL</code>, it must point to an array of at least <var class=Fa>length</var> characters. The result of accessing that array directly while it is in use by the sbuf is undefined.</p><p class=Pp>The <code class=Fn>sbuf_new_auto</code>() function is a shortcut for creating a completely dynamic <code class=Nm>sbuf</code>. It is the equivalent of calling <code class=Fn>sbuf_new</code>() with values <code class=Dv>NULL</code>, <code class=Dv>NULL</code>, <code class=Dv>0</code>, and <code class=Dv>SBUF_AUTOEXTEND</code>.</p><p class=Pp>The <code class=Fn>sbuf_new_for_sysctl</code>() function will set up an sbuf with a drain function to use <code class=Fn>SYSCTL_OUT</code>() when the internal buffer fills. Note that if the various functions which append to an sbuf are used while a non-sleepable lock is held, the user buffer should be wired using <code class=Fn>sysctl_wire_old_buffer</code>().</p><p class=Pp>The <code class=Fn>sbuf_delete</code>() function clears the <var class=Fa>sbuf</var> and frees any memory allocated for it. There must be a call to <code class=Fn>sbuf_delete</code>() for every call to <code class=Fn>sbuf_new</code>(). Any attempt to access the sbuf after it has been deleted will fail.</p><p class=Pp>The <code class=Fn>sbuf_clear</code>() function invalidates the contents of the <var class=Fa>sbuf</var> and resets its position to zero.</p><p class=Pp>The <code class=Fn>sbuf_get_flags</code>() function returns the current user flags. The <code class=Fn>sbuf_set_flags</code>() and <code class=Fn>sbuf_get_flags</code>() functions set or clear one or more user flags, respectively. The user flags are described under the <code class=Fn>sbuf_new</code>() function.</p><p class=Pp>The <code class=Fn>sbuf_setpos</code>() function sets the <var class=Fa>sbuf</var>'s end position to <var class=Fa>pos</var>, which is a value between zero and the current position in the buffer. It can only truncate the sbuf to the new position.</p><p class=Pp>The <code class=Fn>sbuf_bcat</code>() function appends the first <var class=Fa>len</var> bytes from the buffer <var class=Fa>buf</var> to the <var class=Fa>sbuf</var>.</p><p class=Pp>The <code class=Fn>sbuf_bcopyin</code>() function copies <var class=Fa>len</var> bytes from the specified userland address into the <var class=Fa>sbuf</var>.</p><p class=Pp>The <code class=Fn>sbuf_bcpy</code>() function replaces the contents of the <var class=Fa>sbuf</var> with the first <var class=Fa>len</var> bytes from the buffer <var class=Fa>buf</var>.</p><p class=Pp>The <code class=Fn>sbuf_cat</code>() function appends the NUL-terminated string <var class=Fa>str</var> to the <var class=Fa>sbuf</var> at the current position.</p><p class=Pp>The <code class=Fn>sbuf_set_drain</code>() function sets a drain function <var class=Fa>func</var> for the <var class=Fa>sbuf</var>, and records a pointer <var class=Fa>arg</var> to be passed to the drain on callback. The drain function cannot be changed while <var class=Fa>sbuf_len</var> is non-zero.</p><p class=Pp>The registered drain function <var class=Vt>sbuf_drain_func</var> will be called with the argument <var class=Fa>arg</var> provided to <code class=Fn>sbuf_set_drain</code>(), a pointer <var class=Fa>data</var> to a byte string that is the contents of the sbuf, and the length <var class=Fa>len</var> of the data. If the drain function exists, it will be called when the sbuf internal buffer is full, or on behalf of <code class=Fn>sbuf_finish</code>(). The drain function may drain some or all of the data, but must drain at least 1 byte. The return value from the drain function, if positive, indicates how many bytes were drained. If negative, the return value indicates the negative error code which will be returned from this or a later call to <code class=Fn>sbuf_finish</code>(). The returned drained length cannot be zero. To do unbuffered draining, initialize the sbuf with a two-byte buffer. The drain will be called for every byte added to the sbuf. The <code class=Fn>sbuf_bcopyin</code>(), <code class=Fn>sbuf_copyin</code>(), <code class=Fn>sbuf_trim</code>(), and <code class=Fn>sbuf_data</code>() functions cannot be used on an sbuf with a drain.</p><p class=Pp>The <code class=Fn>sbuf_copyin</code>() function copies a NUL-terminated string from the specified userland address into the <var class=Fa>sbuf</var>. If the <var class=Fa>len</var> argument is non-zero, no more than <var class=Fa>len</var> characters (not counting the terminating NUL) are copied; otherwise the entire string, or as much of it as can fit in the <var class=Fa>sbuf</var>, is copied.</p><p class=Pp>The <code class=Fn>sbuf_cpy</code>() function replaces the contents of the <var class=Fa>sbuf</var> with those of the NUL-terminated string <var class=Fa>str</var>. This is equivalent to calling <code class=Fn>sbuf_cat</code>() with a fresh <var class=Fa>sbuf</var> or one which position has been reset to zero with <code class=Fn>sbuf_clear</code>() or <code class=Fn>sbuf_setpos</code>().</p><p class=Pp>The <code class=Fn>sbuf_printf</code>() function formats its arguments according to the format string pointed to by <var class=Fa>fmt</var> and appends the resulting string to the <var class=Fa>sbuf</var> at the current position.</p><p class=Pp>The <code class=Fn>sbuf_vprintf</code>() function behaves the same as <code class=Fn>sbuf_printf</code>() except that the arguments are obtained from the variable-length argument list <var class=Fa>ap</var>.</p><p class=Pp>The <code class=Fn>sbuf_putc</code>() function appends the character <var class=Fa>c</var> to the <var class=Fa>sbuf</var> at the current position.</p><p class=Pp>The <code class=Fn>sbuf_trim</code>() function removes trailing whitespace from the <var class=Fa>sbuf</var>.</p><p class=Pp>The <code class=Fn>sbuf_error</code>() function returns any error value that the <var class=Fa>sbuf</var> may have accumulated, either from the drain function, or ENOMEM if the <var class=Fa>sbuf</var> overflowed. This function is generally not needed and instead the error code from <code class=Fn>sbuf_finish</code>() is the preferred way to discover whether an sbuf had an error.</p><p class=Pp>The <code class=Fn>sbuf_finish</code>() function will call the attached drain function if one exists until all the data in the <var class=Fa>sbuf</var> is flushed. If there is no attached drain, <code class=Fn>sbuf_finish</code>() NUL-terminates the <var class=Fa>sbuf</var>. In either case it marks the <var class=Fa>sbuf</var> as finished, which means that it may no longer be modified using <code class=Fn>sbuf_setpos</code>(), <code class=Fn>sbuf_cat</code>(), <code class=Fn>sbuf_cpy</code>(), <code class=Fn>sbuf_printf</code>() or <code class=Fn>sbuf_putc</code>(), until <code class=Fn>sbuf_clear</code>() is used to reset the sbuf.</p><p class=Pp>The <code class=Fn>sbuf_data</code>() function returns the actual string; <code class=Fn>sbuf_data</code>() only works on a finished <var class=Fa>sbuf</var>. The <code class=Fn>sbuf_len</code>() function returns the length of the string. For an <var class=Fa>sbuf</var> with an attached drain, <code class=Fn>sbuf_len</code>() returns the length of the un-drained data. <code class=Fn>sbuf_done</code>() returns non-zero if the <var class=Fa>sbuf</var> is finished.</p><p class=Pp>The <code class=Fn>sbuf_start_section</code>() and <code class=Fn>sbuf_end_section</code>() functions may be used for automatic section alignment. The arguments <var class=Fa>pad</var> and <var class=Fa>c</var> specify the padding size and a character used for padding. The arguments <var class=Fa>old_lenp</var> and <var class=Fa>old_len</var> are to save and restore the current section length when nested sections are used. For the top level section <code class=Dv>NULL</code> and -1 can be specified for <var class=Fa>old_lenp</var> and <var class=Fa>old_len</var> respectively.</p><p class=Pp>The <code class=Fn>sbuf_hexdump</code>() function prints an array of bytes to the supplied sbuf, along with an ASCII representation of the bytes if possible. See the <a class=Xr href=hexdump.3.html>hexdump(3)</a> man page for more details on the interface.</p><p class=Pp>The <code class=Fn>sbuf_putbuf</code>() function printfs the sbuf to stdout if in userland, and to the console and log if in the kernel. It does not drain the buffer or update any pointers.</p></section><section class=Sh><h2 class=Sh id=NOTES><a class=permalink href=#NOTES>NOTES</a></h2> If an operation caused an <var class=Fa>sbuf</var> to overflow, most subsequent operations on it will fail until the <var class=Fa>sbuf</var> is finished using <code class=Fn>sbuf_finish</code>() or reset using <code class=Fn>sbuf_clear</code>(), or its position is reset to a value between 0 and one less than the size of its storage buffer using <code class=Fn>sbuf_setpos</code>(), or it is reinitialized to a sufficiently short string using <code class=Fn>sbuf_cpy</code>(). <p class=Pp>Drains in user-space will not always function as indicated. While the drain function will be called immediately on overflow from the <var class=Fa>sbuf_putc</var>, <var class=Fa>sbuf_bcat</var>, <var class=Fa>sbuf_cat</var> functions, <var class=Fa>sbuf_printf</var> and <var class=Fa>sbuf_vprintf</var> currently have no way to determine whether there will be an overflow until after it occurs, and cannot do a partial expansion of the format string. Thus when using libsbuf the buffer may be extended to allow completion of a single printf call, even though a drain is attached.</p></section><section class=Sh><h2 class=Sh id=RETURN_VALUES><a class=permalink href=#RETURN_VALUES>RETURN VALUES</a></h2> The <code class=Fn>sbuf_new</code>() function returns <code class=Dv>NULL</code> if it failed to allocate a storage buffer, and a pointer to the new <var class=Fa>sbuf</var> otherwise. <p class=Pp>The <code class=Fn>sbuf_setpos</code>() function returns -1 if <var class=Fa>pos</var> was invalid, and zero otherwise.</p><p class=Pp>The <code class=Fn>sbuf_bcat</code>(), <code class=Fn>sbuf_cat</code>(), <code class=Fn>sbuf_cpy</code>(), <code class=Fn>sbuf_printf</code>(), <code class=Fn>sbuf_putc</code>(), and <code class=Fn>sbuf_trim</code>() functions all return -1 if the buffer overflowed, and zero otherwise.</p><p class=Pp>The <code class=Fn>sbuf_error</code>() function returns a non-zero value if the buffer has an overflow or drain error, and zero otherwise.</p><p class=Pp>The <code class=Fn>sbuf_len</code>() function returns -1 if the buffer overflowed.</p><p class=Pp>The <code class=Fn>sbuf_copyin</code>() function returns -1 if copying string from userland failed, and number of bytes copied otherwise.</p><p class=Pp>The <code class=Fn>sbuf_end_section</code>() function returns the section length or -1 if the buffer has an error.</p><p class=Pp>The <code class=Fn>sbuf_finish</code>(<var class=Fa>9</var>) function (the kernel version) returns ENOMEM if the sbuf overflowed before being finished, or returns the error code from the drain if one is attached.</p><p class=Pp>The <code class=Fn>sbuf_finish</code>(<var class=Fa>3</var>) function (the userland version) will return zero for success and -1 and set errno on error.</p></section><section class=Sh><h2 class=Sh id=EXAMPLES><a class=permalink href=#EXAMPLES>EXAMPLES</a></h2><div class=Bd><pre>
#include &lt;sys/types.h&gt;
#include &lt;sys/sbuf.h&gt;

struct sbuf *sb;

sb = sbuf_new_auto();
sbuf_cat(sb, "Customers found:\n");
TAILQ_FOREACH(foo, &amp;foolist, list) {
	sbuf_printf(sb, "   %4d %s\n", foo-&gt;index, foo-&gt;name);
	sbuf_printf(sb, "      Address: %s\n", foo-&gt;address);
	sbuf_printf(sb, "      Zip: %s\n", foo-&gt;zipcode);
}
if (sbuf_finish(sb) != 0) /* Check for any and all errors */
	err(1, "Could not generate message");
transmit_msg(sbuf_data(sb), sbuf_len(sb));
sbuf_delete(sb);
</pre></div></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=hexdump.3.html>hexdump(3)</a>, <a class=Xr href=printf.3.html>printf(3)</a>, <a class=Xr href=strcat.3.html>strcat(3)</a>, <a class=Xr href=strcpy.3.html>strcpy(3)</a>, <a class=Xr href=copyin.9.html>copyin(9)</a>, <a class=Xr href=copyinstr.9.html>copyinstr(9)</a>, <a class=Xr href=printf.9.html>printf(9)</a></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> The <code class=Nm>sbuf</code> family of functions first appeared in <span class=Ux>FreeBSD 4.4</span>. </section><section class=Sh><h2 class=Sh id=AUTHORS><a class=permalink href=#AUTHORS>AUTHORS</a></h2> The <code class=Nm>sbuf</code> family of functions was designed by <span class=An>Poul-Henning Kamp</span> &lt;<a class=Mt href=mailto:phk@FreeBSD.org>phk@FreeBSD.org</a>&gt; and implemented by <span class=An>Dag-Erling Smørgrav</span> &lt;<a class=Mt href=mailto:des@FreeBSD.org>des@FreeBSD.org</a>&gt;. Additional improvements were suggested by <span class=An>Justin T. Gibbs</span> &lt;<a class=Mt href=mailto:gibbs@FreeBSD.org>gibbs@FreeBSD.org</a>&gt;. Auto-extend support added by <span class=An>Kelly Yancey</span> &lt;<a class=Mt href=mailto:kbyanc@FreeBSD.org>kbyanc@FreeBSD.org</a>&gt;. Drain functionality added by <span class=An>Matthew Fleming</span> &lt;<a class=Mt href=mailto:mdf@FreeBSD.org>mdf@FreeBSD.org</a>&gt;. <p class=Pp>This manual page was written by <span class=An>Dag-Erling Smørgrav</span> &lt;<a class=Mt href=mailto:des@FreeBSD.org>des@FreeBSD.org</a>&gt;.</p></section></div><table class=foot><tr><td class=foot-date>August 26, 2020</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>