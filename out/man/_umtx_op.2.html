<!DOCTYPE html>
<html><head><meta charset=utf-8><title>_umtx_op(2)</title><keywords content=man,_umtx_op></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>_umtx_op(2)</h1><table class=head><tr><td class=head-ltitle>_UMTX_OP(2)</td><td class=head-vol>FreeBSD System Calls Manual</td><td class=head-rtitle>_UMTX_OP(2)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>_umtx_op</code> — <div class=Nd>interface for implementation of userspace threading synchronization primitives</div></section><section class=Sh><h2 class=Sh id=LIBRARY><a class=permalink href=#LIBRARY>LIBRARY</a></h2><span class=Lb>Standard C Library (libc, -lc)</span></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/sys/types.h.html>sys/types.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/sys/umtx.h.html>sys/umtx.h</a>&gt;</code><p class=Pp><var class=Ft>int</var><br><code class=Fn>_umtx_op</code>(<var class=Fa style="white-space: nowrap;">void *obj</var>, <var class=Fa style="white-space: nowrap;">int op</var>, <var class=Fa style="white-space: nowrap;">u_long val</var>, <var class=Fa style="white-space: nowrap;">void *uaddr</var>, <var class=Fa style="white-space: nowrap;">void *uaddr2</var>);</p></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> The <code class=Fn>_umtx_op</code>() system call provides kernel support for userspace implementation of the threading synchronization primitives. The <span class=Lb>1:1 Threading Library (libthr, -lthr)</span> uses the syscall to implement <span class=St>IEEE Std 1003.1-2001 (“POSIX.1”)</span> pthread locks, like mutexes, condition variables and so on. <section class=Ss><h2 class=Ss id=STRUCTURES><a class=permalink href=#STRUCTURES>STRUCTURES</a></h2> The operations, performed by the <code class=Fn>_umtx_op</code>() syscall, operate on userspace objects which are described by the following structures. Reserved fields and paddings are omitted. All objects require ABI-mandated alignment, but this is not currently enforced consistently on all architectures. <p class=Pp>The following flags are defined for flag fields of all structures:</p><dl class=Bl-tag><dt><a class=permalink href=#USYNC_PROCESS_SHARED><code class=Dv id=USYNC_PROCESS_SHARED>USYNC_PROCESS_SHARED</code></a></dt><dd>Allow selection of the process-shared sleep queue for the thread sleep container, when the lock ownership cannot be granted immediately, and the operation must sleep. The process-shared or process-private sleep queue is selected based on the attributes of the memory mapping which contains the first byte of the structure, see <a class=Xr href=mmap.2.html>mmap(2)</a>. Otherwise, if the flag is not specified, the process-private sleep queue is selected regardless of the memory mapping attributes, as an optimization. <p class=Pp>See the <a class=Sx href=#SLEEP_QUEUES>SLEEP QUEUES</a> subsection below for more details on sleep queues.</p></dd></dl><dl class="Bl-hang Bd-indent"><dt><b class=Sy>Mutex</b></dt><dd><div class="Bd Pp"><pre>
struct umutex {
	volatile lwpid_t m_owner;
	uint32_t         m_flags;
	uint32_t         m_ceilings[2];
	uintptr_t        m_rb_lnk;
};
    </pre></div><p class=Pp>The <code class=Dv>m_owner</code> field is the actual lock. It contains either the thread identifier of the lock owner in the locked state, or zero when the lock is unowned. The highest bit set indicates that there is contention on the lock. The constants are defined for special values:</p><dl class=Bl-tag><dt><a class=permalink href=#UMUTEX_UNOWNED><code class=Dv id=UMUTEX_UNOWNED>UMUTEX_UNOWNED</code></a></dt><dd>Zero, the value stored in the unowned lock.</dd><dt><a class=permalink href=#UMUTEX_CONTESTED><code class=Dv id=UMUTEX_CONTESTED>UMUTEX_CONTESTED</code></a></dt><dd>The contention indicator.</dd><dt><a class=permalink href=#UMUTEX_RB_OWNERDEAD><code class=Dv id=UMUTEX_RB_OWNERDEAD>UMUTEX_RB_OWNERDEAD</code></a></dt><dd>A thread owning the robust mutex terminated. The mutex is in unlocked state.</dd><dt><a class=permalink href=#UMUTEX_RB_NOTRECOV><code class=Dv id=UMUTEX_RB_NOTRECOV>UMUTEX_RB_NOTRECOV</code></a></dt><dd>The robust mutex is in a non-recoverable state. It cannot be locked until reinitialized.</dd></dl><p class=Pp>The <code class=Dv>m_flags</code> field may contain the following umutex-specific flags, in addition to the common flags:</p><dl class=Bl-tag><dt><a class=permalink href=#UMUTEX_PRIO_INHERIT><code class=Dv id=UMUTEX_PRIO_INHERIT>UMUTEX_PRIO_INHERIT</code></a></dt><dd>Mutex implements <i class=Em>Priority Inheritance</i> protocol.</dd><dt><a class=permalink href=#UMUTEX_PRIO_PROTECT><code class=Dv id=UMUTEX_PRIO_PROTECT>UMUTEX_PRIO_PROTECT</code></a></dt><dd>Mutex implements <i class=Em>Priority Protection</i> protocol.</dd><dt><a class=permalink href=#UMUTEX_ROBUST><code class=Dv id=UMUTEX_ROBUST>UMUTEX_ROBUST</code></a></dt><dd>Mutex is robust, as described in the <a class=Sx href=#ROBUST_UMUTEXES>ROBUST UMUTEXES</a> section below.</dd><dt><a class=permalink href=#UMUTEX_NONCONSISTENT><code class=Dv id=UMUTEX_NONCONSISTENT>UMUTEX_NONCONSISTENT</code></a></dt><dd>Robust mutex is in a transient non-consistent state. Not used by kernel.</dd></dl><p class=Pp>In the manual page, mutexes not having <code class=Dv>UMUTEX_PRIO_INHERIT</code> and <code class=Dv>UMUTEX_PRIO_PROTECT</code> flags set, are called normal mutexes. Each type of mutex (normal, priority-inherited, and priority-protected) has a separate sleep queue associated with the given key.</p><p class=Pp>For priority protected mutexes, the <code class=Dv>m_ceilings</code> array contains priority ceiling values. The <code class=Dv>m_ceilings[0]</code> is the ceiling value for the mutex, as specified by <span class=St>IEEE Std 1003.1-2008 (“POSIX.1”)</span> for the <i class=Em>Priority Protected</i> mutex protocol. The <code class=Dv>m_ceilings[1]</code> is used only for the unlock of a priority protected mutex, when unlock is done in an order other than the reversed lock order. In this case, <code class=Dv>m_ceilings[1]</code> must contain the ceiling value for the last locked priority protected mutex, for proper priority reassignment. If, instead, the unlocking mutex was the last priority propagated mutex locked by the thread, <code class=Dv>m_ceilings[1]</code> should contain -1. This is required because kernel does not maintain the ordered lock list.</p></dd><dt><b class=Sy>Condition variable</b></dt><dd><div class="Bd Pp"><pre>
struct ucond {
	volatile uint32_t c_has_waiters;
	uint32_t          c_flags;
	uint32_t          c_clockid;
};
    </pre></div><p class=Pp>A non-zero <code class=Dv>c_has_waiters</code> value indicates that there are in-kernel waiters for the condition, executing the <code class=Dv>UMTX_OP_CV_WAIT</code> request.</p><p class=Pp>The <code class=Dv>c_flags</code> field contains flags. Only the common flags (<code class=Dv>USYNC_PROCESS_SHARED</code>) are defined for ucond.</p><p class=Pp>The <code class=Dv>c_clockid</code> member provides the clock identifier to use for timeout, when the <code class=Dv>UMTX_OP_CV_WAIT</code> request has both the <code class=Dv>CVWAIT_CLOCKID</code> flag and the timeout specified. Valid clock identifiers are a subset of those for <a class=Xr href=clock_gettime.2.html>clock_gettime(2)</a>:</p><ul class="Bl-bullet Bl-compact"><li><a class=permalink href=#CLOCK_MONOTONIC><code class=Dv id=CLOCK_MONOTONIC>CLOCK_MONOTONIC</code></a></li><li><a class=permalink href=#CLOCK_MONOTONIC_FAST><code class=Dv id=CLOCK_MONOTONIC_FAST>CLOCK_MONOTONIC_FAST</code></a></li><li><a class=permalink href=#CLOCK_MONOTONIC_PRECISE><code class=Dv id=CLOCK_MONOTONIC_PRECISE>CLOCK_MONOTONIC_PRECISE</code></a></li><li><a class=permalink href=#CLOCK_PROF><code class=Dv id=CLOCK_PROF>CLOCK_PROF</code></a></li><li><a class=permalink href=#CLOCK_REALTIME><code class=Dv id=CLOCK_REALTIME>CLOCK_REALTIME</code></a></li><li><a class=permalink href=#CLOCK_REALTIME_FAST><code class=Dv id=CLOCK_REALTIME_FAST>CLOCK_REALTIME_FAST</code></a></li><li><a class=permalink href=#CLOCK_REALTIME_PRECISE><code class=Dv id=CLOCK_REALTIME_PRECISE>CLOCK_REALTIME_PRECISE</code></a></li><li><a class=permalink href=#CLOCK_SECOND><code class=Dv id=CLOCK_SECOND>CLOCK_SECOND</code></a></li><li><a class=permalink href=#CLOCK_UPTIME><code class=Dv id=CLOCK_UPTIME>CLOCK_UPTIME</code></a></li><li><a class=permalink href=#CLOCK_UPTIME_FAST><code class=Dv id=CLOCK_UPTIME_FAST>CLOCK_UPTIME_FAST</code></a></li><li><a class=permalink href=#CLOCK_UPTIME_PRECISE><code class=Dv id=CLOCK_UPTIME_PRECISE>CLOCK_UPTIME_PRECISE</code></a></li><li><a class=permalink href=#CLOCK_VIRTUAL><code class=Dv id=CLOCK_VIRTUAL>CLOCK_VIRTUAL</code></a></li></ul></dd><dt><b class=Sy>Reader/writer lock</b></dt><dd><div class="Bd Pp"><pre>
struct urwlock {
	volatile int32_t rw_state;
	uint32_t         rw_flags;
	uint32_t         rw_blocked_readers;
	uint32_t         rw_blocked_writers;
};
    </pre></div><p class=Pp>The <code class=Dv>rw_state</code> field is the actual lock. It contains both the flags and counter of the read locks which were granted. Names of the <code class=Dv>rw_state</code> bits are following:</p><dl class=Bl-tag><dt><a class=permalink href=#URWLOCK_WRITE_OWNER><code class=Dv id=URWLOCK_WRITE_OWNER>URWLOCK_WRITE_OWNER</code></a></dt><dd>Write lock was granted.</dd><dt><a class=permalink href=#URWLOCK_WRITE_WAITERS><code class=Dv id=URWLOCK_WRITE_WAITERS>URWLOCK_WRITE_WAITERS</code></a></dt><dd>There are write lock waiters.</dd><dt><a class=permalink href=#URWLOCK_READ_WAITERS><code class=Dv id=URWLOCK_READ_WAITERS>URWLOCK_READ_WAITERS</code></a></dt><dd>There are read lock waiters.</dd><dt><a class=permalink href=#URWLOCK_READER_COUNT(c)><code class=Dv id=URWLOCK_READER_COUNT(c)>URWLOCK_READER_COUNT(c)</code></a></dt><dd>Returns the count of currently granted read locks.</dd></dl><p class=Pp>At any given time there may be only one thread to which the writer lock is granted on the <var class=Vt>struct rwlock</var>, and no threads are granted read lock. Or, at the given time, up to <code class=Dv>URWLOCK_MAX_READERS</code> threads may be granted the read lock simultaneously, but write lock is not granted to any thread.</p><p class=Pp>The following flags for the <code class=Dv>rw_flags</code> member of <var class=Vt>struct urwlock</var> are defined, in addition to the common flags:</p><dl class=Bl-tag><dt><a class=permalink href=#URWLOCK_PREFER_READER><code class=Dv id=URWLOCK_PREFER_READER>URWLOCK_PREFER_READER</code></a></dt><dd>If specified, immediately grant read lock requests when <code class=Dv>urwlock</code> is already read-locked, even in presence of unsatisfied write lock requests. By default, if there is a write lock waiter, further read requests are not granted, to prevent unfair write lock waiter starvation.</dd></dl><p class=Pp>The <code class=Dv>rw_blocked_readers</code> and <code class=Dv>rw_blocked_writers</code> members contain the count of threads which are sleeping in kernel, waiting for the associated request type to be granted. The fields are used by kernel to update the <code class=Dv>URWLOCK_READ_WAITERS</code> and <code class=Dv>URWLOCK_WRITE_WAITERS</code> flags of the <code class=Dv>rw_state</code> lock after requesting thread was woken up.</p></dd><dt><b class=Sy>Semaphore</b></dt><dd><div class="Bd Pp"><pre>
struct _usem2 {
	volatile uint32_t _count;
	uint32_t          _flags;
};
    </pre></div><p class=Pp>The <code class=Dv>_count</code> word represents a counting semaphore. A non-zero value indicates an unlocked (posted) semaphore, while zero represents the locked state. The maximal supported semaphore count is <code class=Dv>USEM_MAX_COUNT</code>.</p><p class=Pp>The <code class=Dv>_count</code> word, besides the counter of posts (unlocks), also contains the <code class=Dv>USEM_HAS_WAITERS</code> bit, which indicates that locked semaphore has waiting threads.</p><p class=Pp>The <code class=Dv>USEM_COUNT()</code> macro, applied to the <code class=Dv>_count</code> word, returns the current semaphore counter, which is the number of posts issued on the semaphore.</p><p class=Pp>The following bits for the <code class=Dv>_flags</code> member of <var class=Vt>struct _usem2</var> are defined, in addition to the common flags:</p><dl class=Bl-tag><dt><a class=permalink href=#USEM_NAMED><code class=Dv id=USEM_NAMED>USEM_NAMED</code></a></dt><dd>Flag is ignored by kernel.</dd></dl></dd><dt><b class=Sy>Timeout parameter</b></dt><dd><div class="Bd Pp"><pre>
struct _umtx_time {
	struct timespec _timeout;
	uint32_t        _flags;
	uint32_t        _clockid;
};
    </pre></div><p class=Pp>Several <code class=Fn>_umtx_op</code>() operations allow the blocking time to be limited, failing the request if it cannot be satisfied in the specified time period. The timeout is specified by passing either the address of <var class=Vt>struct timespec</var>, or its extended variant, <var class=Vt>struct _umtx_time</var>, as the <var class=Fa>uaddr2</var> argument of <code class=Fn>_umtx_op</code>(). They are distinguished by the <var class=Fa>uaddr</var> value, which must be equal to the size of the structure pointed to by <var class=Fa>uaddr2</var>, casted to <var class=Vt>uintptr_t</var>.</p><p class=Pp>The <code class=Dv>_timeout</code> member specifies the time when the timeout should occur. Legal values for clock identifier <code class=Dv>_clockid</code> are shared with the <var class=Fa>clock_id</var> argument to the <a class=Xr href=clock_gettime.2.html>clock_gettime(2)</a> function, and use the same underlying clocks. The specified clock is used to obtain the current time value. Interval counting is always performed by the monotonic wall clock.</p><p class=Pp>The <code class=Dv>_flags</code> argument allows the following flags to further define the timeout behaviour:</p><dl class=Bl-tag><dt><a class=permalink href=#UMTX_ABSTIME><code class=Dv id=UMTX_ABSTIME>UMTX_ABSTIME</code></a></dt><dd>The <code class=Dv>_timeout</code> value is the absolute time. The thread will be unblocked and the request failed when specified clock value is equal or exceeds the <code class=Dv>_timeout.</code><p class=Pp>If the flag is absent, the timeout value is relative, that is the amount of time, measured by the monotonic wall clock from the moment of the request start.</p></dd></dl></dd></dl></section><section class=Ss><h2 class=Ss id=SLEEP_QUEUES><a class=permalink href=#SLEEP_QUEUES>SLEEP QUEUES</a></h2> When a locking request cannot be immediately satisfied, the thread is typically put to <i class=Em>sleep</i>, which is a non-runnable state terminated by the <i class=Em>wake</i> operation. Lock operations include a <i class=Em>try</i> variant which returns an error rather than sleeping if the lock cannot be obtained. Also, <code class=Fn>_umtx_op</code>() provides requests which explicitly put the thread to sleep. <p class=Pp>Wakes need to know which threads to make runnable, so sleeping threads are grouped into containers called <i class=Em>sleep queues</i>. A sleep queue is identified by a key, which for <code class=Fn>_umtx_op</code>() is defined as the physical address of some variable. Note that the <i class=Em>physical</i> address is used, which means that same variable mapped multiple times will give one key value. This mechanism enables the construction of <i class=Em>process-shared</i> locks.</p><p class=Pp>A related attribute of the key is shareability. Some requests always interpret keys as private for the current process, creating sleep queues with the scope of the current process even if the memory is shared. Others either select the shareability automatically from the mapping attributes, or take additional input as the <code class=Dv>USYNC_PROCESS_SHARED</code> common flag. This is done as optimization, allowing the lock scope to be limited regardless of the kind of backing memory.</p><p class=Pp>Only the address of the start byte of the variable specified as key is important for determining corresponding sleep queue. The size of the variable does not matter, so, for example, sleep on the same address interpeted as <var class=Vt>uint32_t</var> and <var class=Vt>long</var> on a little-endian 64-bit platform would collide.</p><p class=Pp>The last attribute of the key is the object type. The sleep queue to which a sleeping thread is assigned is an individual one for simple wait requests, mutexes, rwlocks, condvars and other primitives, even when the physical address of the key is same.</p><p class=Pp>When waking up a limited number of threads from a given sleep queue, the highest priority threads that have been blocked for the longest on the queue are selected.</p></section><section class=Ss><h2 class=Ss id=ROBUST_UMUTEXES><a class=permalink href=#ROBUST_UMUTEXES>ROBUST UMUTEXES</a></h2> The <i class=Em>robust umutexes</i> are provided as a substrate for a userspace library to implement POSIX robust mutexes. A robust umutex must have the <code class=Dv>UMUTEX_ROBUST</code> flag set. <p class=Pp>On thread termination, the kernel walks two lists of mutexes. The two lists head addresses must be provided by a prior call to <code class=Dv>UMTX_OP_ROBUST_LISTS</code> request. The lists are singly-linked. The link to next element is provided by the <code class=Dv>m_rb_lnk</code> member of the <var class=Vt>struct umutex</var>.</p><p class=Pp>Robust list processing is aborted if the kernel finds a mutex with any of the following conditions:</p><ul class="Bl-dash Bd-indent Bl-compact"><li>the <code class=Dv>UMUTEX_ROBUST</code> flag is not set</li><li>not owned by the current thread, except when the mutex is pointed to by the <code class=Dv>robust_inactive</code> member of the <var class=Vt>struct umtx_robust_lists_params</var>, registered for the current thread</li><li>the combination of mutex flags is invalid</li><li>read of the umutex memory faults</li><li>the list length limit described in <a class=Xr href=libthr.3.html>libthr(3)</a> is reached.</li></ul><p class=Pp>Every mutex in both lists is unlocked as if the <code class=Dv>UMTX_OP_MUTEX_UNLOCK</code> request is performed on it, but instead of the <code class=Dv>UMUTEX_UNOWNED</code> value, the <code class=Dv>m_owner</code> field is written with the <code class=Dv>UMUTEX_RB_OWNERDEAD</code> value. When a mutex in the <code class=Dv>UMUTEX_RB_OWNERDEAD</code> state is locked by kernel due to the <code class=Dv>UMTX_OP_MUTEX_TRYLOCK</code> and <code class=Dv>UMTX_OP_MUTEX_LOCK</code> requests, the lock is granted and <code class=Er>EOWNERDEAD</code> error is returned.</p><p class=Pp>Also, the kernel handles the <code class=Dv>UMUTEX_RB_NOTRECOV</code> value of <code class=Dv>the m_owner</code> field specially, always returning the <code class=Er>ENOTRECOVERABLE</code> error for lock attempts, without granting the lock.</p></section><section class=Ss><h2 class=Ss id=OPERATIONS><a class=permalink href=#OPERATIONS>OPERATIONS</a></h2> The following operations, requested by the <var class=Fa>op</var> argument to the function, are implemented: <dl class=Bl-tag><dt><a class=permalink href=#UMTX_OP_WAIT><code class=Dv id=UMTX_OP_WAIT>UMTX_OP_WAIT</code></a></dt><dd>Wait. The arguments for the request are: <dl class=Bl-tag><dt><var class=Fa>obj</var></dt><dd>Pointer to a variable of type <var class=Vt>long</var>.</dd><dt><var class=Fa>val</var></dt><dd>Current value of the <code class=Dv>*obj</code>.</dd></dl><p class=Pp>The current value of the variable pointed to by the <var class=Fa>obj</var> argument is compared with the <var class=Fa>val</var>. If they are equal, the requesting thread is put to interruptible sleep until woken up or the optionally specified timeout expires.</p><p class=Pp>The comparison and sleep are atomic. In other words, if another thread writes a new value to <code class=Dv>*obj</code> and then issues <code class=Dv>UMTX_OP_WAKE</code>, the request is guaranteed to not miss the wakeup, which might otherwise happen between comparison and blocking.</p><p class=Pp>The physical address of memory where the <var class=Fa>*obj</var> variable is located, is used as a key to index sleeping threads.</p><p class=Pp>The read of the current value of the <code class=Dv>*obj</code> variable is not guarded by barriers. In particular, it is the user's duty to ensure the lock acquire and release memory semantics, if the <code class=Dv>UMTX_OP_WAIT</code> and <code class=Dv>UMTX_OP_WAKE</code> requests are used as a substrate for implementing a simple lock.</p><p class=Pp>The request is not restartable. An unblocked signal delivered during the wait always results in sleep interruption and <code class=Er>EINTR</code> error.</p><p class=Pp>Optionally, a timeout for the request may be specified.</p></dd><dt><a class=permalink href=#UMTX_OP_WAKE><code class=Dv id=UMTX_OP_WAKE>UMTX_OP_WAKE</code></a></dt><dd>Wake the threads possibly sleeping due to <code class=Dv>UMTX_OP_WAIT</code>. The arguments for the request are: <dl class=Bl-tag><dt><var class=Fa>obj</var></dt><dd>Pointer to a variable, used as a key to find sleeping threads.</dd><dt><var class=Fa>val</var></dt><dd>Up to <var class=Fa>val</var> threads are woken up by this request. Specify <code class=Dv>INT_MAX</code> to wake up all waiters.</dd></dl></dd><dt><a class=permalink href=#UMTX_OP_MUTEX_TRYLOCK><code class=Dv id=UMTX_OP_MUTEX_TRYLOCK>UMTX_OP_MUTEX_TRYLOCK</code></a></dt><dd>Try to lock umutex. The arguments to the request are: <dl class=Bl-tag><dt><var class=Fa>obj</var></dt><dd>Pointer to the umutex.</dd></dl><p class=Pp>Operates same as the <code class=Dv>UMTX_OP_MUTEX_LOCK</code> request, but returns <code class=Er>EBUSY</code> instead of sleeping if the lock cannot be obtained immediately.</p></dd><dt><a class=permalink href=#UMTX_OP_MUTEX_LOCK><code class=Dv id=UMTX_OP_MUTEX_LOCK>UMTX_OP_MUTEX_LOCK</code></a></dt><dd>Lock umutex. The arguments to the request are: <dl class=Bl-tag><dt><var class=Fa>obj</var></dt><dd>Pointer to the umutex.</dd></dl><p class=Pp>Locking is performed by writing the current thread id into the <code class=Dv>m_owner</code> word of the <var class=Vt>struct umutex</var>. The write is atomic, preserves the <code class=Dv>UMUTEX_CONTESTED</code> contention indicator, and provides the acquire barrier for lock entrance semantic.</p><p class=Pp>If the lock cannot be obtained immediately because another thread owns the lock, the current thread is put to sleep, with <code class=Dv>UMUTEX_CONTESTED</code> bit set before. Upon wake up, the lock conditions are re-tested.</p><p class=Pp>The request adheres to the priority protection or inheritance protocol of the mutex, specified by the <code class=Dv>UMUTEX_PRIO_PROTECT</code> or <code class=Dv>UMUTEX_PRIO_INHERIT</code> flag, respectively.</p><p class=Pp>Optionally, a timeout for the request may be specified.</p><p class=Pp>A request with a timeout specified is not restartable. An unblocked signal delivered during the wait always results in sleep interruption and <code class=Er>EINTR</code> error. A request without timeout specified is always restarted after return from a signal handler.</p></dd><dt><a class=permalink href=#UMTX_OP_MUTEX_UNLOCK><code class=Dv id=UMTX_OP_MUTEX_UNLOCK>UMTX_OP_MUTEX_UNLOCK</code></a></dt><dd>Unlock umutex. The arguments to the request are: <dl class=Bl-tag><dt><var class=Fa>obj</var></dt><dd>Pointer to the umutex.</dd></dl><p class=Pp>Unlocks the mutex, by writing <code class=Dv>UMUTEX_UNOWNED</code> (zero) value into <code class=Dv>m_owner</code> word of the <var class=Vt>struct umutex</var>. The write is done with a release barrier, to provide lock leave semantic.</p><p class=Pp>If there are threads sleeping in the sleep queue associated with the umutex, one thread is woken up. If more than one thread sleeps in the sleep queue, the <code class=Dv>UMUTEX_CONTESTED</code> bit is set together with the write of the <code class=Dv>UMUTEX_UNOWNED</code> value into <code class=Dv>m_owner</code>.</p><p class=Pp>The request adheres to the priority protection or inheritance protocol of the mutex, specified by the <code class=Dv>UMUTEX_PRIO_PROTECT</code> or <code class=Dv>UMUTEX_PRIO_INHERIT</code> flag, respectively. See description of the <code class=Dv>m_ceilings</code> member of the <var class=Vt>struct umutex</var> structure for additional details of the request operation on the priority protected protocol mutex.</p></dd><dt><a class=permalink href=#UMTX_OP_SET_CEILING><code class=Dv id=UMTX_OP_SET_CEILING>UMTX_OP_SET_CEILING</code></a></dt><dd>Set ceiling for the priority protected umutex. The arguments to the request are: <dl class=Bl-tag><dt><var class=Fa>obj</var></dt><dd>Pointer to the umutex.</dd><dt><var class=Fa>val</var></dt><dd>New ceiling value.</dd><dt><var class=Fa>uaddr</var></dt><dd>Address of a variable of type <var class=Vt>uint32_t</var>. If not <code class=Dv>NULL</code> and the update was successful, the previous ceiling value is written to the location pointed to by <var class=Fa>uaddr</var>.</dd></dl><p class=Pp>The request locks the umutex pointed to by the <var class=Fa>obj</var> parameter, waiting for the lock if not immediately available. After the lock is obtained, the new ceiling value <var class=Fa>val</var> is written to the <code class=Dv>m_ceilings[0]</code> member of the <var class=Vt>struct umutex,</var> after which the umutex is unlocked.</p><p class=Pp>The locking does not adhere to the priority protect protocol, to conform to the POSIX requirements for the <a class=Xr href=pthread_mutex_setprioceiling.3.html>pthread_mutex_setprioceiling(3)</a> interface.</p></dd><dt><a class=permalink href=#UMTX_OP_CV_WAIT><code class=Dv id=UMTX_OP_CV_WAIT>UMTX_OP_CV_WAIT</code></a></dt><dd>Wait for a condition. The arguments to the request are: <dl class=Bl-tag><dt><var class=Fa>obj</var></dt><dd>Pointer to the <var class=Vt>struct ucond</var>.</dd><dt><var class=Fa>val</var></dt><dd>Request flags, see below.</dd><dt><var class=Fa>uaddr</var></dt><dd>Pointer to the umutex.</dd><dt><var class=Fa>uaddr2</var></dt><dd>Optional pointer to a <var class=Vt>struct timespec</var> for timeout specification.</dd></dl><p class=Pp>The request must be issued by the thread owning the mutex pointed to by the <var class=Fa>uaddr</var> argument. The <code class=Dv>c_hash_waiters</code> member of the <var class=Vt>struct ucond</var>, pointed to by the <var class=Fa>obj</var> argument, is set to an arbitrary non-zero value, after which the <var class=Fa>uaddr</var> mutex is unlocked (following the appropriate protocol), and the current thread is put to sleep on the sleep queue keyed by the <var class=Fa>obj</var> argument. The operations are performed atomically. It is guaranteed to not miss a wakeup from <code class=Dv>UMTX_OP_CV_SIGNAL</code> or <code class=Dv>UMTX_OP_CV_BROADCAST</code> sent between mutex unlock and putting the current thread on the sleep queue.</p><p class=Pp>Upon wakeup, if the timeout expired and no other threads are sleeping in the same sleep queue, the <code class=Dv>c_hash_waiters</code> member is cleared. After wakeup, the <var class=Fa>uaddr</var> umutex is not relocked.</p><p class=Pp>The following flags are defined:</p><dl class=Bl-tag><dt><a class=permalink href=#CVWAIT_ABSTIME><code class=Dv id=CVWAIT_ABSTIME>CVWAIT_ABSTIME</code></a></dt><dd>Timeout is absolute.</dd><dt><a class=permalink href=#CVWAIT_CLOCKID><code class=Dv id=CVWAIT_CLOCKID>CVWAIT_CLOCKID</code></a></dt><dd>Clockid is provided.</dd></dl><p class=Pp>Optionally, a timeout for the request may be specified. Unlike other requests, the timeout value is specified directly by a <var class=Vt>struct timespec</var>, pointed to by the <var class=Fa>uaddr2</var> argument. If the <code class=Dv>CVWAIT_CLOCKID</code> flag is provided, the timeout uses the clock from the <code class=Dv>c_clockid</code> member of the <var class=Vt>struct ucond</var>, pointed to by <var class=Fa>obj</var> argument. Otherwise, <code class=Dv>CLOCK_REALTIME</code> is used, regardless of the clock identifier possibly specified in the <var class=Vt>struct _umtx_time</var>. If the <code class=Dv>CVWAIT_ABSTIME</code> flag is supplied, the timeout specifies absolute time value, otherwise it denotes a relative time interval.</p><p class=Pp>The request is not restartable. An unblocked signal delivered during the wait always results in sleep interruption and <code class=Er>EINTR</code> error.</p></dd><dt><a class=permalink href=#UMTX_OP_CV_SIGNAL><code class=Dv id=UMTX_OP_CV_SIGNAL>UMTX_OP_CV_SIGNAL</code></a></dt><dd>Wake up one condition waiter. The arguments to the request are: <dl class=Bl-tag><dt><var class=Fa>obj</var></dt><dd>Pointer to <var class=Vt>struct ucond</var>.</dd></dl><p class=Pp>The request wakes up at most one thread sleeping on the sleep queue keyed by the <var class=Fa>obj</var> argument. If the woken up thread was the last on the sleep queue, the <code class=Dv>c_has_waiters</code> member of the <var class=Vt>struct ucond</var> is cleared.</p></dd><dt><a class=permalink href=#UMTX_OP_CV_BROADCAST><code class=Dv id=UMTX_OP_CV_BROADCAST>UMTX_OP_CV_BROADCAST</code></a></dt><dd>Wake up all condition waiters. The arguments to the request are: <dl class=Bl-tag><dt><var class=Fa>obj</var></dt><dd>Pointer to <var class=Vt>struct ucond</var>.</dd></dl><p class=Pp>The request wakes up all threads sleeping on the sleep queue keyed by the <var class=Fa>obj</var> argument. The <code class=Dv>c_has_waiters</code> member of the <var class=Vt>struct ucond</var> is cleared.</p></dd><dt><a class=permalink href=#UMTX_OP_WAIT_UINT><code class=Dv id=UMTX_OP_WAIT_UINT>UMTX_OP_WAIT_UINT</code></a></dt><dd>Same as <code class=Dv>UMTX_OP_WAIT</code>, but the type of the variable pointed to by <var class=Fa>obj</var> is <var class=Vt>u_int</var> (a 32-bit integer).</dd><dt><a class=permalink href=#UMTX_OP_RW_RDLOCK><code class=Dv id=UMTX_OP_RW_RDLOCK>UMTX_OP_RW_RDLOCK</code></a></dt><dd>Read-lock a <var class=Vt>struct rwlock</var> lock. The arguments to the request are: <dl class=Bl-tag><dt><var class=Fa>obj</var></dt><dd>Pointer to the lock (of type <var class=Vt>struct rwlock</var>) to be read-locked.</dd><dt><var class=Fa>val</var></dt><dd>Additional flags to augment locking behaviour. The valid flags in the <var class=Fa>val</var> argument are: <dl class=Bl-tag><dt><a class=permalink href=#URWLOCK_PREFER_READER_2><code class=Dv id=URWLOCK_PREFER_READER_2>URWLOCK_PREFER_READER</code></a></dt><dd style="width: auto;"> </dd></dl></dd></dl><p class=Pp>The request obtains the read lock on the specified <var class=Vt>struct rwlock</var> by incrementing the count of readers in the <code class=Dv>rw_state</code> word of the structure. If the <code class=Dv>URWLOCK_WRITE_OWNER</code> bit is set in the word <code class=Dv>rw_state</code>, the lock was granted to a writer which has not yet relinquished its ownership. In this case the current thread is put to sleep until it makes sense to retry.</p><p class=Pp>If the <code class=Dv>URWLOCK_PREFER_READER</code> flag is set either in the <code class=Dv>rw_flags</code> word of the structure, or in the <var class=Fa>val</var> argument of the request, the presence of the threads trying to obtain the write lock on the same structure does not prevent the current thread from trying to obtain the read lock. Otherwise, if the flag is not set, and the <code class=Dv>URWLOCK_WRITE_WAITERS</code> flag is set in <code class=Dv>rw_state</code>, the current thread does not attempt to obtain read-lock. Instead it sets the <code class=Dv>URWLOCK_READ_WAITERS</code> in the <code class=Dv>rw_state</code> word and puts itself to sleep on corresponding sleep queue. Upon wakeup, the locking conditions are re-evaluated.</p><p class=Pp>Optionally, a timeout for the request may be specified.</p><p class=Pp>The request is not restartable. An unblocked signal delivered during the wait always results in sleep interruption and <code class=Er>EINTR</code> error.</p></dd><dt><a class=permalink href=#UMTX_OP_RW_WRLOCK><code class=Dv id=UMTX_OP_RW_WRLOCK>UMTX_OP_RW_WRLOCK</code></a></dt><dd>Write-lock a <var class=Vt>struct rwlock</var> lock. The arguments to the request are: <dl class=Bl-tag><dt><var class=Fa>obj</var></dt><dd>Pointer to the lock (of type <var class=Vt>struct rwlock</var>) to be write-locked.</dd></dl><p class=Pp>The request obtains a write lock on the specified <var class=Vt>struct rwlock</var>, by setting the <code class=Dv>URWLOCK_WRITE_OWNER</code> bit in the <code class=Dv>rw_state</code> word of the structure. If there is already a write lock owner, as indicated by the <code class=Dv>URWLOCK_WRITE_OWNER</code> bit being set, or there are read lock owners, as indicated by the read-lock counter, the current thread does not attempt to obtain the write-lock. Instead it sets the <code class=Dv>URWLOCK_WRITE_WAITERS</code> in the <code class=Dv>rw_state</code> word and puts itself to sleep on corresponding sleep queue. Upon wakeup, the locking conditions are re-evaluated.</p><p class=Pp>Optionally, a timeout for the request may be specified.</p><p class=Pp>The request is not restartable. An unblocked signal delivered during the wait always results in sleep interruption and <code class=Er>EINTR</code> error.</p></dd><dt><a class=permalink href=#UMTX_OP_RW_UNLOCK><code class=Dv id=UMTX_OP_RW_UNLOCK>UMTX_OP_RW_UNLOCK</code></a></dt><dd>Unlock rwlock. The arguments to the request are: <dl class=Bl-tag><dt><var class=Fa>obj</var></dt><dd>Pointer to the lock (of type <var class=Vt>struct rwlock</var>) to be unlocked.</dd></dl><p class=Pp>The unlock type (read or write) is determined by the current lock state. Note that the <var class=Vt>struct rwlock</var> does not save information about the identity of the thread which acquired the lock.</p><p class=Pp>If there are pending writers after the unlock, and the <code class=Dv>URWLOCK_PREFER_READER</code> flag is not set in the <code class=Dv>rw_flags</code> member of the <var class=Fa>*obj</var> structure, one writer is woken up, selected as described in the <a class=Sx href=#SLEEP_QUEUES>SLEEP QUEUES</a> subsection. If the <code class=Dv>URWLOCK_PREFER_READER</code> flag is set, a pending writer is woken up only if there is no pending readers.</p><p class=Pp>If there are no pending writers, or, in the case that the <code class=Dv>URWLOCK_PREFER_READER</code> flag is set, then all pending readers are woken up by unlock.</p></dd><dt><a class=permalink href=#UMTX_OP_WAIT_UINT_PRIVATE><code class=Dv id=UMTX_OP_WAIT_UINT_PRIVATE>UMTX_OP_WAIT_UINT_PRIVATE</code></a></dt><dd>Same as <code class=Dv>UMTX_OP_WAIT_UINT</code>, but unconditionally select the process-private sleep queue.</dd><dt><a class=permalink href=#UMTX_OP_WAKE_PRIVATE><code class=Dv id=UMTX_OP_WAKE_PRIVATE>UMTX_OP_WAKE_PRIVATE</code></a></dt><dd>Same as <code class=Dv>UMTX_OP_WAKE</code>, but unconditionally select the process-private sleep queue.</dd><dt><a class=permalink href=#UMTX_OP_MUTEX_WAIT><code class=Dv id=UMTX_OP_MUTEX_WAIT>UMTX_OP_MUTEX_WAIT</code></a></dt><dd>Wait for mutex availability. The arguments to the request are: <dl class=Bl-tag><dt><var class=Fa>obj</var></dt><dd>Address of the mutex.</dd></dl><p class=Pp>Similarly to the <code class=Dv>UMTX_OP_MUTEX_LOCK</code>, put the requesting thread to sleep if the mutex lock cannot be obtained immediately. The <code class=Dv>UMUTEX_CONTESTED</code> bit is set in the <code class=Dv>m_owner</code> word of the mutex to indicate that there is a waiter, before the thread is added to the sleep queue. Unlike the <code class=Dv>UMTX_OP_MUTEX_LOCK</code> request, the lock is not obtained.</p><p class=Pp>The operation is not implemented for priority protected and priority inherited protocol mutexes.</p><p class=Pp>Optionally, a timeout for the request may be specified.</p><p class=Pp>A request with a timeout specified is not restartable. An unblocked signal delivered during the wait always results in sleep interruption and <code class=Er>EINTR</code> error. A request without a timeout automatically restarts if the signal disposition requested restart via the <code class=Dv>SA_RESTART</code> flag in <var class=Vt>struct sigaction</var> member <code class=Dv>sa_flags</code>.</p></dd><dt><a class=permalink href=#UMTX_OP_NWAKE_PRIVATE><code class=Dv id=UMTX_OP_NWAKE_PRIVATE>UMTX_OP_NWAKE_PRIVATE</code></a></dt><dd>Wake up a batch of sleeping threads. The arguments to the request are: <dl class=Bl-tag><dt><var class=Fa>obj</var></dt><dd>Pointer to the array of pointers.</dd><dt><var class=Fa>val</var></dt><dd>Number of elements in the array pointed to by <var class=Fa>obj</var>.</dd></dl><p class=Pp>For each element in the array pointed to by <var class=Fa>obj</var>, wakes up all threads waiting on the <i class=Em>private</i> sleep queue with the key being the byte addressed by the array element.</p></dd><dt><a class=permalink href=#UMTX_OP_MUTEX_WAKE><code class=Dv id=UMTX_OP_MUTEX_WAKE>UMTX_OP_MUTEX_WAKE</code></a></dt><dd>Check if a normal umutex is unlocked and wake up a waiter. The arguments for the request are: <dl class=Bl-tag><dt><var class=Fa>obj</var></dt><dd>Pointer to the umutex.</dd></dl><p class=Pp>If the <code class=Dv>m_owner</code> word of the mutex pointed to by the <var class=Fa>obj</var> argument indicates unowned mutex, which has its contention indicator bit <code class=Dv>UMUTEX_CONTESTED</code> set, clear the bit and wake up one waiter in the sleep queue associated with the byte addressed by the <var class=Fa>obj</var>, if any. Only normal mutexes are supported by the request. The sleep queue is always one for a normal mutex type.</p><p class=Pp>This request is deprecated in favor of <code class=Dv>UMTX_OP_MUTEX_WAKE2</code> since mutexes using it cannot synchronize their own destruction. That is, the <code class=Dv>m_owner</code> word has already been set to <code class=Dv>UMUTEX_UNOWNED</code> when this request is made, so that another thread can lock, unlock and destroy the mutex (if no other thread uses the mutex afterwards). Clearing the <code class=Dv>UMUTEX_CONTESTED</code> bit may then modify freed memory.</p></dd><dt><a class=permalink href=#UMTX_OP_MUTEX_WAKE2><code class=Dv id=UMTX_OP_MUTEX_WAKE2>UMTX_OP_MUTEX_WAKE2</code></a></dt><dd>Check if a umutex is unlocked and wake up a waiter. The arguments for the request are: <dl class=Bl-tag><dt><var class=Fa>obj</var></dt><dd>Pointer to the umutex.</dd><dt><var class=Fa>val</var></dt><dd>The umutex flags.</dd></dl><p class=Pp>The request does not read the <code class=Dv>m_flags</code> member of the <var class=Vt>struct umutex</var>; instead, the <var class=Fa>val</var> argument supplies flag information, in particular, to determine the sleep queue where the waiters are found for wake up.</p><p class=Pp>If the mutex is unowned, one waiter is woken up.</p><p class=Pp>If the mutex memory cannot be accessed, all waiters are woken up.</p><p class=Pp>If there is more than one waiter on the sleep queue, or there is only one waiter but the mutex is owned by a thread, the <code class=Dv>UMUTEX_CONTESTED</code> bit is set in the <code class=Dv>m_owner</code> word of the <var class=Vt>struct umutex</var>.</p></dd><dt><a class=permalink href=#UMTX_OP_SEM2_WAIT><code class=Dv id=UMTX_OP_SEM2_WAIT>UMTX_OP_SEM2_WAIT</code></a></dt><dd>Wait until semaphore is available. The arguments to the request are: <dl class=Bl-tag><dt><var class=Fa>obj</var></dt><dd>Pointer to the semaphore (of type <var class=Vt>struct _usem2</var>).</dd><dt><var class=Fa>uaddr</var></dt><dd>Size of the memory passed in via the <var class=Fa>uaddr2</var> argument.</dd><dt><var class=Fa>uaddr2</var></dt><dd>Optional pointer to a structure of type <var class=Vt>struct _umtx_time</var>, which may be followed by a structure of type <var class=Vt>struct timespec</var>.</dd></dl><p class=Pp>Put the requesting thread onto a sleep queue if the semaphore counter is zero. If the thread is put to sleep, the <code class=Dv>USEM_HAS_WAITERS</code> bit is set in the <code class=Dv>_count</code> word to indicate waiters. The function returns either due to <code class=Dv>_count</code> indicating the semaphore is available (non-zero count due to post), or due to a wakeup. The return does not guarantee that the semaphore is available, nor does it consume the semaphore lock on successful return.</p><p class=Pp>Optionally, a timeout for the request may be specified.</p><p class=Pp>A request with non-absolute timeout value is not restartable. An unblocked signal delivered during such wait results in sleep interruption and <code class=Er>EINTR</code> error.</p><p class=Pp>If <code class=Dv>UMTX_ABSTIME</code> was not set, and the operation was interrupted and the caller passed in a <var class=Fa>uaddr2</var> large enough to hold a <var class=Vt>struct timespec</var> following the initial <var class=Vt>struct _umtx_time</var>, then the <var class=Vt>struct timespec</var> is updated to contain the unslept amount.</p></dd><dt><a class=permalink href=#UMTX_OP_SEM2_WAKE><code class=Dv id=UMTX_OP_SEM2_WAKE>UMTX_OP_SEM2_WAKE</code></a></dt><dd>Wake up waiters on semaphore lock. The arguments to the request are: <dl class=Bl-tag><dt><var class=Fa>obj</var></dt><dd>Pointer to the semaphore (of type <var class=Vt>struct _usem2</var>).</dd></dl><p class=Pp>The request wakes up one waiter for the semaphore lock. The function does not increment the semaphore lock count. If the <code class=Dv>USEM_HAS_WAITERS</code> bit was set in the <code class=Dv>_count</code> word, and the last sleeping thread was woken up, the bit is cleared.</p></dd><dt><a class=permalink href=#UMTX_OP_SHM><code class=Dv id=UMTX_OP_SHM>UMTX_OP_SHM</code></a></dt><dd>Manage anonymous POSIX shared memory objects (see <a class=Xr href=shm_open.2.html>shm_open(2)</a>), which can be attached to a byte of physical memory, mapped into the process address space. The objects are used to implement process-shared locks in <code class=Dv>libthr</code>. <p class=Pp>The <var class=Fa>val</var> argument specifies the sub-request of the <code class=Dv>UMTX_OP_SHM</code> request:</p><dl class=Bl-tag><dt><a class=permalink href=#UMTX_SHM_CREAT><code class=Dv id=UMTX_SHM_CREAT>UMTX_SHM_CREAT</code></a></dt><dd>Creates the anonymous shared memory object, which can be looked up with the specified key <var class=Fa>uaddr</var>. If the object associated with the <var class=Fa>uaddr</var> key already exists, it is returned instead of creating a new object. The object's size is one page. On success, the file descriptor referencing the object is returned. The descriptor can be used for mapping the object using <a class=Xr href=mmap.2.html>mmap(2)</a>, or for other shared memory operations.</dd><dt><a class=permalink href=#UMTX_SHM_LOOKUP><code class=Dv id=UMTX_SHM_LOOKUP>UMTX_SHM_LOOKUP</code></a></dt><dd>Same as <code class=Dv>UMTX_SHM_CREATE</code> request, but if there is no shared memory object associated with the specified key <var class=Fa>uaddr</var>, an error is returned, and no new object is created.</dd><dt><a class=permalink href=#UMTX_SHM_DESTROY><code class=Dv id=UMTX_SHM_DESTROY>UMTX_SHM_DESTROY</code></a></dt><dd>De-associate the shared object with the specified key <var class=Fa>uaddr</var>. The object is destroyed after the last open file descriptor is closed and the last mapping for it is destroyed.</dd><dt><a class=permalink href=#UMTX_SHM_ALIVE><code class=Dv id=UMTX_SHM_ALIVE>UMTX_SHM_ALIVE</code></a></dt><dd>Checks whether there is a live shared object associated with the supplied key <var class=Fa>uaddr</var>. Returns zero if there is, and an error otherwise. This request is an optimization of the <code class=Dv>UMTX_SHM_LOOKUP</code> request. It is cheaper when only the liveness of the associated object is asked for, since no file descriptor is installed in the process fd table on success.</dd></dl><p class=Pp>The <var class=Fa>uaddr</var> argument specifies the virtual address, which backing physical memory byte identity is used as a key for the anonymous shared object creation or lookup.</p></dd><dt><a class=permalink href=#UMTX_OP_ROBUST_LISTS><code class=Dv id=UMTX_OP_ROBUST_LISTS>UMTX_OP_ROBUST_LISTS</code></a></dt><dd>Register the list heads for the current thread's robust mutex lists. The arguments to the request are: <dl class=Bl-tag><dt><var class=Fa>val</var></dt><dd>Size of the structure passed in the <var class=Fa>uaddr</var> argument.</dd><dt><var class=Fa>uaddr</var></dt><dd>Pointer to the structure of type <var class=Vt>struct umtx_robust_lists_params</var>.</dd></dl><p class=Pp>The structure is defined as</p><div class="Bd Pp"><pre>
struct umtx_robust_lists_params {
	uintptr_t	robust_list_offset;
	uintptr_t	robust_priv_list_offset;
	uintptr_t	robust_inact_offset;
};
    </pre></div><p class=Pp>The <code class=Dv>robust_list_offset</code> member contains address of the first element in the list of locked robust shared mutexes. The <code class=Dv>robust_priv_list_offset</code> member contains address of the first element in the list of locked robust private mutexes. The private and shared robust locked lists are split to allow fast termination of the shared list on fork, in the child.</p><p class=Pp>The <code class=Dv>robust_inact_offset</code> contains a pointer to the mutex which might be locked in nearby future, or might have been just unlocked. It is typically set by the lock or unlock mutex implementation code around the whole operation, since lists can be only changed race-free when the thread owns the mutex. The kernel inspects the <code class=Dv>robust_inact_offset</code> in addition to walking the shared and private lists. Also, the mutex pointed to by <code class=Dv>robust_inact_offset</code> is handled more loosely at the thread termination time, than other mutexes on the list. That mutex is allowed to be not owned by the current thread, in which case list processing is continued. See <a class=Sx href=#ROBUST_UMUTEXES>ROBUST UMUTEXES</a> subsection for details.</p></dd></dl><p class=Pp>The <var class=Fa>op</var> argument may be a bitwise OR of a single command from above with one or more of the following flags:</p><dl class=Bl-tag><dt><a class=permalink href=#UMTX_OP__I386><code class=Dv id=UMTX_OP__I386>UMTX_OP__I386</code></a></dt><dd>Request i386 ABI compatibility from the native <code class=Nm>_umtx_op</code> system call. Specifically, this implies that: <dl class="Bl-hang Bd-indent"><dt></dt><dd><var class=Fa>obj</var> arguments that point to a word, point to a 32-bit integer.</dd><dt></dt><dd>The <code class=Dv>UMTX_OP_NWAKE_PRIVATE</code><var class=Fa>obj</var> argument is a pointer to an array of 32-bit pointers.</dd><dt></dt><dd>The <code class=Dv>m_rb_lnk</code> member of <var class=Vt>struct umutex</var> is a 32-bit pointer.</dd><dt></dt><dd><var class=Vt>struct timespec</var> uses a 32-bit time_t.</dd></dl><p class=Pp><code class=Dv>UMTX_OP__32BIT</code> has no effect if this flag is set. This flag is valid for all architectures, but it is ignored on i386.</p></dd><dt><a class=permalink href=#UMTX_OP__32BIT><code class=Dv id=UMTX_OP__32BIT>UMTX_OP__32BIT</code></a></dt><dd>Request non-i386, 32-bit ABI compatibility from the native <code class=Nm>_umtx_op</code> system call. Specifically, this implies that: <dl class="Bl-hang Bd-indent"><dt></dt><dd><var class=Fa>obj</var> arguments that point to a word, point to a 32-bit integer.</dd><dt></dt><dd>The <code class=Dv>UMTX_OP_NWAKE_PRIVATE</code><var class=Fa>obj</var> argument is a pointer to an array of 32-bit pointers.</dd><dt></dt><dd>The <code class=Dv>m_rb_lnk</code> member of <var class=Vt>struct umutex</var> is a 32-bit pointer.</dd><dt></dt><dd><var class=Vt>struct timespec</var> uses a 64-bit time_t.</dd></dl><p class=Pp>This flag has no effect if <code class=Dv>UMTX_OP__I386</code> is set. This flag is valid for all architectures.</p></dd></dl><p class=Pp>Note that if any 32-bit ABI compatibility is being requested, then care must be taken with robust lists. A single thread may not mix 32-bit compatible robust lists with native robust lists. The first <code class=Dv>UMTX_OP_ROBUST_LISTS</code> call in a given thread determines which ABI that thread will use for robust lists going forward.</p></section></section><section class=Sh><h2 class=Sh id=RETURN_VALUES><a class=permalink href=#RETURN_VALUES>RETURN VALUES</a></h2> If successful, all requests, except <code class=Dv>UMTX_SHM_CREAT</code> and <code class=Dv>UMTX_SHM_LOOKUP</code> sub-requests of the <code class=Dv>UMTX_OP_SHM</code> request, will return zero. The <code class=Dv>UMTX_SHM_CREAT</code> and <code class=Dv>UMTX_SHM_LOOKUP</code> return a shared memory file descriptor on success. On error -1 is returned, and the <var class=Va>errno</var> variable is set to indicate the error. </section><section class=Sh><h2 class=Sh id=ERRORS><a class=permalink href=#ERRORS>ERRORS</a></h2> The <code class=Fn>_umtx_op</code>() operations can fail with the following errors: <dl class=Bl-tag><dt>[<a class=permalink href=#EFAULT><code class=Er id=EFAULT>EFAULT</code></a>]</dt><dd>One of the arguments point to invalid memory.</dd><dt>[<a class=permalink href=#EINVAL><code class=Er id=EINVAL>EINVAL</code></a>]</dt><dd>The clock identifier, specified for the <var class=Vt>struct _umtx_time</var> timeout parameter, or in the <code class=Dv>c_clockid</code> member of <var class=Vt>struct ucond,</var> is invalid.</dd><dt>[<a class=permalink href=#EINVAL_2><code class=Er id=EINVAL_2>EINVAL</code></a>]</dt><dd>The type of the mutex, encoded by the <code class=Dv>m_flags</code> member of <var class=Vt>struct umutex</var>, is invalid.</dd><dt>[<a class=permalink href=#EINVAL_3><code class=Er id=EINVAL_3>EINVAL</code></a>]</dt><dd>The <code class=Dv>m_owner</code> member of the <var class=Vt>struct umutex</var> has changed the lock owner thread identifier during unlock.</dd><dt>[<a class=permalink href=#EINVAL_4><code class=Er id=EINVAL_4>EINVAL</code></a>]</dt><dd>The <code class=Dv>timeout.tv_sec</code> or <code class=Dv>timeout.tv_nsec</code> member of <var class=Vt>struct _umtx_time</var> is less than zero, or <code class=Dv>timeout.tv_nsec</code> is greater than 1000000000.</dd><dt>[<a class=permalink href=#EINVAL_5><code class=Er id=EINVAL_5>EINVAL</code></a>]</dt><dd>The <var class=Fa>op</var> argument specifies invalid operation.</dd><dt>[<a class=permalink href=#EINVAL_6><code class=Er id=EINVAL_6>EINVAL</code></a>]</dt><dd>The <var class=Fa>uaddr</var> argument for the <code class=Dv>UMTX_OP_SHM</code> request specifies invalid operation.</dd><dt>[<a class=permalink href=#EINVAL_7><code class=Er id=EINVAL_7>EINVAL</code></a>]</dt><dd>The <code class=Dv>UMTX_OP_SET_CEILING</code> request specifies non priority protected mutex.</dd><dt>[<a class=permalink href=#EINVAL_8><code class=Er id=EINVAL_8>EINVAL</code></a>]</dt><dd>The new ceiling value for the <code class=Dv>UMTX_OP_SET_CEILING</code> request, or one or more of the values read from the <code class=Dv>m_ceilings</code> array during lock or unlock operations, is greater than <code class=Dv>RTP_PRIO_MAX</code>.</dd><dt>[<a class=permalink href=#EPERM><code class=Er id=EPERM>EPERM</code></a>]</dt><dd>Unlock attempted on an object not owned by the current thread.</dd><dt>[<a class=permalink href=#EOWNERDEAD><code class=Er id=EOWNERDEAD>EOWNERDEAD</code></a>]</dt><dd>The lock was requested on an umutex where the <code class=Dv>m_owner</code> field was set to the <code class=Dv>UMUTEX_RB_OWNERDEAD</code> value, indicating terminated robust mutex. The lock was granted to the caller, so this error in fact indicates success with additional conditions.</dd><dt>[<a class=permalink href=#ENOTRECOVERABLE><code class=Er id=ENOTRECOVERABLE>ENOTRECOVERABLE</code></a>]</dt><dd>The lock was requested on an umutex which <code class=Dv>m_owner</code> field is equal to the <code class=Dv>UMUTEX_RB_NOTRECOV</code> value, indicating abandoned robust mutex after termination. The lock was not granted to the caller.</dd><dt>[<a class=permalink href=#ENOTTY><code class=Er id=ENOTTY>ENOTTY</code></a>]</dt><dd>The shared memory object, associated with the address passed to the <code class=Dv>UMTX_SHM_ALIVE</code> sub-request of <code class=Dv>UMTX_OP_SHM</code> request, was destroyed.</dd><dt>[<a class=permalink href=#ESRCH><code class=Er id=ESRCH>ESRCH</code></a>]</dt><dd>For the <code class=Dv>UMTX_SHM_LOOKUP</code>, <code class=Dv>UMTX_SHM_DESTROY</code>, and <code class=Dv>UMTX_SHM_ALIVE</code> sub-requests of the <code class=Dv>UMTX_OP_SHM</code> request, there is no shared memory object associated with the provided key.</dd><dt>[<a class=permalink href=#ENOMEM><code class=Er id=ENOMEM>ENOMEM</code></a>]</dt><dd>The <code class=Dv>UMTX_SHM_CREAT</code> sub-request of the <code class=Dv>UMTX_OP_SHM</code> request cannot be satisfied, because allocation of the shared memory object would exceed the <code class=Dv>RLIMIT_UMTXP</code> resource limit, see <a class=Xr href=setrlimit.2.html>setrlimit(2)</a>.</dd><dt>[<a class=permalink href=#EAGAIN><code class=Er id=EAGAIN>EAGAIN</code></a>]</dt><dd>The maximum number of readers (<code class=Dv>URWLOCK_MAX_READERS</code>) were already granted ownership of the given <var class=Vt>struct rwlock</var> for read.</dd><dt>[<a class=permalink href=#EBUSY><code class=Er id=EBUSY>EBUSY</code></a>]</dt><dd>A try mutex lock operation was not able to obtain the lock.</dd><dt>[<a class=permalink href=#ETIMEDOUT><code class=Er id=ETIMEDOUT>ETIMEDOUT</code></a>]</dt><dd>The request specified a timeout in the <var class=Fa>uaddr</var> and <var class=Fa>uaddr2</var> arguments, and timed out before obtaining the lock or being woken up.</dd><dt>[<a class=permalink href=#EINTR><code class=Er id=EINTR>EINTR</code></a>]</dt><dd>A signal was delivered during wait, for a non-restartable operation. Operations with timeouts are typically non-restartable, but timeouts specified in absolute time may be restartable.</dd><dt>[<a class=permalink href=#ERESTART><code class=Er id=ERESTART>ERESTART</code></a>]</dt><dd>A signal was delivered during wait, for a restartable operation. Mutex lock requests without timeout specified are restartable. The error is not returned to userspace code since restart is handled by usual adjustment of the instruction counter.</dd></dl></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=clock_gettime.2.html>clock_gettime(2)</a>, <a class=Xr href=mmap.2.html>mmap(2)</a>, <a class=Xr href=setrlimit.2.html>setrlimit(2)</a>, <a class=Xr href=shm_open.2.html>shm_open(2)</a>, <a class=Xr href=sigaction.2.html>sigaction(2)</a>, <a class=Xr href=thr_exit.2.html>thr_exit(2)</a>, <a class=Xr href=thr_kill.2.html>thr_kill(2)</a>, <a class=Xr href=thr_kill2.2.html>thr_kill2(2)</a>, <a class=Xr href=thr_new.2.html>thr_new(2)</a>, <a class=Xr href=thr_self.2.html>thr_self(2)</a>, <a class=Xr href=thr_set_name.2.html>thr_set_name(2)</a>, <a class=Xr href=signal.3.html>signal(3)</a></section><section class=Sh><h2 class=Sh id=STANDARDS><a class=permalink href=#STANDARDS>STANDARDS</a></h2> The <code class=Fn>_umtx_op</code>() system call is non-standard and is used by the <span class=Lb>1:1 Threading Library (libthr, -lthr)</span> to implement <span class=St>IEEE Std 1003.1-2001 (“POSIX.1”)</span><a class=Xr href=pthread.3.html>pthread(3)</a> functionality. </section><section class=Sh><h2 class=Sh id=BUGS><a class=permalink href=#BUGS>BUGS</a></h2> A window between a unlocking robust mutex and resetting the pointer in the <code class=Dv>robust_inact_offset</code> member of the registered <var class=Vt>struct umtx_robust_lists_params</var> allows another thread to destroy the mutex, thus making the kernel inspect freed or reused memory. The <code class=Li>libthr</code> implementation is only vulnerable to this race when operating on a shared mutex. A possible fix for the current implementation is to strengthen the checks for shared mutexes before terminating them, in particular, verifying that the mutex memory is mapped from a shared memory object allocated by the <code class=Dv>UMTX_OP_SHM</code> request. This is not done because it is believed that the race is adequately covered by other consistency checks, while adding the check would prevent alternative implementations of <code class=Li>libpthread</code>. </section></div><table class=foot><tr><td class=foot-date>November 23, 2020</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>