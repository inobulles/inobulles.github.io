<!DOCTYPE html>
<html><head><meta charset=utf-8><title>ptrace(2)</title><keywords content=man,ptrace></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>ptrace(2)</h1><table class=head><tr><td class=head-ltitle>PTRACE(2)</td><td class=head-vol>FreeBSD System Calls Manual</td><td class=head-rtitle>PTRACE(2)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>ptrace</code> — <div class=Nd>process tracing and debugging</div></section><section class=Sh><h2 class=Sh id=LIBRARY><a class=permalink href=#LIBRARY>LIBRARY</a></h2><span class=Lb>Standard C Library (libc, -lc)</span></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/sys/types.h.html>sys/types.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/sys/ptrace.h.html>sys/ptrace.h</a>&gt;</code><p class=Pp><var class=Ft>int</var><br><code class=Fn>ptrace</code>(<var class=Fa style="white-space: nowrap;">int request</var>, <var class=Fa style="white-space: nowrap;">pid_t pid</var>, <var class=Fa style="white-space: nowrap;">caddr_t addr</var>, <var class=Fa style="white-space: nowrap;">int data</var>);</p></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> The <code class=Fn>ptrace</code>() system call provides tracing and debugging facilities. It allows one process (the <i class=Em>tracing</i> process) to control another (the <i class=Em>traced</i> process). The tracing process must first attach to the traced process, and then issue a series of <code class=Fn>ptrace</code>() system calls to control the execution of the process, as well as access process memory and register state. For the duration of the tracing session, the traced process will be “re-parented”, with its parent process ID (and resulting behavior) changed to the tracing process. It is permissible for a tracing process to attach to more than one other process at a time. When the tracing process has completed its work, it must detach the traced process; if a tracing process exits without first detaching all processes it has attached, those processes will be killed. <p class=Pp>Most of the time, the traced process runs normally, but when it receives a signal (see <a class=Xr href=sigaction.2.html>sigaction(2)</a>), it stops. The tracing process is expected to notice this via <a class=Xr href=wait.2.html>wait(2)</a> or the delivery of a <code class=Dv>SIGCHLD</code> signal, examine the state of the stopped process, and cause it to terminate or continue as appropriate. The signal may be a normal process signal, generated as a result of traced process behavior, or use of the <a class=Xr href=kill.2.html>kill(2)</a> system call; alternatively, it may be generated by the tracing facility as a result of attaching, stepping by the tracing process, or an event in the traced process. The tracing process may choose to intercept the signal, using it to observe process behavior (such as <code class=Dv>SIGTRAP</code>), or forward the signal to the process if appropriate. The <code class=Fn>ptrace</code>() system call is the mechanism by which all this happens.</p><p class=Pp>A traced process may report additional signal stops corresponding to events in the traced process. These additional signal stops are reported as <code class=Dv>SIGTRAP</code> or <code class=Dv>SIGSTOP</code> signals. The tracing process can use the <code class=Dv>PT_LWPINFO</code> request to determine which events are associated with a <code class=Dv>SIGTRAP</code> or <code class=Dv>SIGSTOP</code> signal. Note that multiple events may be associated with a single signal. For example, events indicated by the <code class=Dv>PL_FLAG_BORN</code>, <code class=Dv>PL_FLAG_FORKED</code>, and <code class=Dv>PL_FLAG_EXEC</code> flags are also reported as a system call exit event (<code class=Dv>PL_FLAG_SCX</code>). The signal stop for a new child process enabled via <code class=Dv>PTRACE_FORK</code> will report a <code class=Dv>SIGSTOP</code> signal. All other additional signal stops use <code class=Dv>SIGTRAP</code>.</p></section><section class=Sh><h2 class=Sh id=DETACH_AND_TERMINATION><a class=permalink href=#DETACH_AND_TERMINATION>DETACH AND TERMINATION</a></h2> Normally, exiting tracing process should wait for all pending debugging events and then detach from all alive traced processes before exiting using <code class=Dv>PT_DETACH</code> request. If tracing process exits without detaching, for instance due to abnormal termination, the destiny of the traced children processes is determined by the <code class=Dv>kern.kill_on_debugger_exit</code> sysctl control. <p class=Pp>If the control is set to the default value 1, such traced processes are terminated. If set to zero, kernel implicitly detaches traced processes. Traced processes are un-stopped if needed, and then continue the execution without tracing. Kernel drops any <code class=Dv>SIGTRAP</code> signals queued to the traced children, which could be either generated by not yet consumed debug events, or sent by other means, the later should not be done anyway.</p></section><section class=Sh><h2 class=Sh id=DISABLING_PTRACE><a class=permalink href=#DISABLING_PTRACE>DISABLING PTRACE</a></h2> The <code class=Nm>ptrace</code> subsystem provides rich facilities to manipulate other processes state. Sometimes it may be desirable to disallow it either completely, or limit its scope. The following controls are provided for this: <dl class=Bl-tag><dt><a class=permalink href=#security.bsd.allow_ptrace><code class=Dv id=security.bsd.allow_ptrace>security.bsd.allow_ptrace</code></a></dt><dd>Setting this sysctl to zero value makes <a class=Xr href=ptrace.2.html>ptrace(2)</a> return <code class=Er>ENOSYS</code> always as if the syscall is not implemented by the kernel.</dd><dt><a class=permalink href=#security.bsd.unprivileged_proc_debug><code class=Dv id=security.bsd.unprivileged_proc_debug>security.bsd.unprivileged_proc_debug</code></a></dt><dd>Setting this sysctl to zero disallows use of <code class=Fn>ptrace</code>() by unprivileged processes.</dd><dt><a class=permalink href=#security.bsd.see_other_uids><code class=Dv id=security.bsd.see_other_uids>security.bsd.see_other_uids</code></a></dt><dd>Setting this sysctl to zero value disallows <code class=Fn>ptrace</code>() requests from targeting processes with the real user identifier different from the real user identifier of the caller. The requests return <code class=Er>ESRCH</code> if policy is not met.</dd><dt><a class=permalink href=#security.bsd.see_other_gids><code class=Dv id=security.bsd.see_other_gids>security.bsd.see_other_gids</code></a></dt><dd>Setting this sysctl to zero value disallows <code class=Fn>ptrace</code>() requests from process belonging to a group that is not also one of the group of the target process. The requests return <code class=Er>ESRCH</code> if policy is not met.</dd><dt><a class=permalink href=#securelevel_and_init><code class=Dv id=securelevel_and_init>securelevel and init</code></a></dt><dd>The <a class=Xr href=init.1.html>init(1)</a> process can only be traced with <code class=Nm>ptrace</code> if securelevel is zero.</dd><dt><a class=permalink href=#procctl(2)_PROC_TRACE_CTL><code class=Dv id=procctl(2)_PROC_TRACE_CTL>procctl(2) PROC_TRACE_CTL</code></a></dt><dd>Process can deny attempts to trace itself with <a class=Xr href=procctl.2.html>procctl(2)</a><code class=Dv>PROC_TRACE_CTL</code> request. In this case requests return <a class=Xr href=EPERM.1.html>EPERM</a> error.</dd></dl></section><section class=Sh><h2 class=Sh id=TRACING_EVENTS><a class=permalink href=#TRACING_EVENTS>TRACING EVENTS</a></h2> Each traced process has a tracing event mask. An event in the traced process only reports a signal stop if the corresponding flag is set in the tracing event mask. The current set of tracing event flags include: <dl class=Bl-tag><dt><a class=permalink href=#PTRACE_EXEC><code class=Dv id=PTRACE_EXEC>PTRACE_EXEC</code></a></dt><dd>Report a stop for a successful invocation of <a class=Xr href=execve.2.html>execve(2)</a>. This event is indicated by the <code class=Dv>PL_FLAG_EXEC</code> flag in the <var class=Va>pl_flags</var> member of <var class=Vt>struct ptrace_lwpinfo</var>.</dd><dt><a class=permalink href=#PTRACE_SCE><code class=Dv id=PTRACE_SCE>PTRACE_SCE</code></a></dt><dd>Report a stop on each system call entry. This event is indicated by the <code class=Dv>PL_FLAG_SCE</code> flag in the <var class=Va>pl_flags</var> member of <var class=Vt>struct ptrace_lwpinfo</var>.</dd><dt><a class=permalink href=#PTRACE_SCX><code class=Dv id=PTRACE_SCX>PTRACE_SCX</code></a></dt><dd>Report a stop on each system call exit. This event is indicated by the <code class=Dv>PL_FLAG_SCX</code> flag in the <var class=Va>pl_flags</var> member of <var class=Vt>struct ptrace_lwpinfo</var>.</dd><dt><a class=permalink href=#PTRACE_SYSCALL><code class=Dv id=PTRACE_SYSCALL>PTRACE_SYSCALL</code></a></dt><dd>Report stops for both system call entry and exit.</dd><dt><a class=permalink href=#PTRACE_FORK><code class=Dv id=PTRACE_FORK>PTRACE_FORK</code></a></dt><dd>This event flag controls tracing for new child processes of a traced process. <p class=Pp>When this event flag is enabled, new child processes will enable tracing and stop before executing their first instruction. The new child process will include the <code class=Dv>PL_FLAG_CHILD</code> flag in the <var class=Va>pl_flags</var> member of <var class=Vt>struct ptrace_lwpinfo</var>. The traced process will report a stop that includes the <code class=Dv>PL_FLAG_FORKED</code> flag. The process ID of the new child process will also be present in the <var class=Va>pl_child_pid</var> member of <var class=Vt>struct ptrace_lwpinfo</var>. If the new child process was created via <a class=Xr href=vfork.2.html>vfork(2)</a>, the traced process's stop will also include the <code class=Dv>PL_FLAG_VFORKED</code> flag. Note that new child processes will be attached with the default tracing event mask; they do not inherit the event mask of the traced process.</p><p class=Pp>When this event flag is not enabled, new child processes will execute without tracing enabled.</p></dd><dt><a class=permalink href=#PTRACE_LWP><code class=Dv id=PTRACE_LWP>PTRACE_LWP</code></a></dt><dd>This event flag controls tracing of LWP (kernel thread) creation and destruction. When this event is enabled, new LWPs will stop and report an event with <code class=Dv>PL_FLAG_BORN</code> set before executing their first instruction, and exiting LWPs will stop and report an event with <code class=Dv>PL_FLAG_EXITED</code> set before completing their termination. <p class=Pp>Note that new processes do not report an event for the creation of their initial thread, and exiting processes do not report an event for the termination of the last thread.</p></dd><dt><a class=permalink href=#PTRACE_VFORK><code class=Dv id=PTRACE_VFORK>PTRACE_VFORK</code></a></dt><dd>Report a stop event when a parent process resumes after a <a class=Xr href=vfork.2.html>vfork(2)</a>. <p class=Pp>When a thread in the traced process creates a new child process via <a class=Xr href=vfork.2.html>vfork(2)</a>, the stop that reports <code class=Dv>PL_FLAG_FORKED</code> and <code class=Dv>PL_FLAG_SCX</code> occurs just after the child process is created, but before the thread waits for the child process to stop sharing process memory. If a debugger is not tracing the new child process, it must ensure that no breakpoints are enabled in the shared process memory before detaching from the new child process. This means that no breakpoints are enabled in the parent process either.</p><p class=Pp>The <code class=Dv>PTRACE_VFORK</code> flag enables a new stop that indicates when the new child process stops sharing the process memory of the parent process. A debugger can reinsert breakpoints in the parent process and resume it in response to this event. This event is indicated by setting the <code class=Dv>PL_FLAG_VFORK_DONE</code> flag.</p></dd></dl><p class=Pp>The default tracing event mask when attaching to a process via <code class=Dv>PT_ATTACH</code>, <code class=Dv>PT_TRACE_ME</code>, or <code class=Dv>PTRACE_FORK</code> includes only <code class=Dv>PTRACE_EXEC</code> events. All other event flags are disabled.</p></section><section class=Sh><h2 class=Sh id=PTRACE_REQUESTS><a class=permalink href=#PTRACE_REQUESTS>PTRACE REQUESTS</a></h2> The <var class=Fa>request</var> argument specifies what operation is being performed; the meaning of the rest of the arguments depends on the operation, but except for one special case noted below, all <code class=Fn>ptrace</code>() calls are made by the tracing process, and the <var class=Fa>pid</var> argument specifies the process ID of the traced process or a corresponding thread ID. The <var class=Fa>request</var> argument can be: <dl class=Bl-tag><dt><a class=permalink href=#PT_TRACE_ME><code class=Dv id=PT_TRACE_ME>PT_TRACE_ME</code></a></dt><dd>This request is the only one used by the traced process; it declares that the process expects to be traced by its parent. All the other arguments are ignored. (If the parent process does not expect to trace the child, it will probably be rather confused by the results; once the traced process stops, it cannot be made to continue except via <code class=Fn>ptrace</code>().) When a process has used this request and calls <a class=Xr href=execve.2.html>execve(2)</a> or any of the routines built on it (such as <a class=Xr href=execv.3.html>execv(3)</a>), it will stop before executing the first instruction of the new image. Also, any setuid or setgid bits on the executable being executed will be ignored. If the child was created by <a class=Xr href=vfork.2.html>vfork(2)</a> system call or <a class=Xr href=rfork.2.html>rfork(2)</a> call with the <code class=Dv>RFMEM</code> flag specified, the debugging events are reported to the parent only after the <a class=Xr href=execve.2.html>execve(2)</a> is executed.</dd><dt><a class=permalink href=#PT_READ_I><code class=Dv id=PT_READ_I>PT_READ_I</code></a>, <code class=Dv>PT_READ_D</code></dt><dd>These requests read a single <var class=Vt>int</var> of data from the traced process's address space. Traditionally, <code class=Fn>ptrace</code>() has allowed for machines with distinct address spaces for instruction and data, which is why there are two requests: conceptually, <code class=Dv>PT_READ_I</code> reads from the instruction space and <code class=Dv>PT_READ_D</code> reads from the data space. In the current <span class=Ux>FreeBSD</span> implementation, these two requests are completely identical. The <var class=Fa>addr</var> argument specifies the address (in the traced process's virtual address space) at which the read is to be done. This address does not have to meet any alignment constraints. The value read is returned as the return value from <code class=Fn>ptrace</code>().</dd><dt><a class=permalink href=#PT_WRITE_I><code class=Dv id=PT_WRITE_I>PT_WRITE_I</code></a>, <code class=Dv>PT_WRITE_D</code></dt><dd>These requests parallel <code class=Dv>PT_READ_I</code> and <code class=Dv>PT_READ_D</code>, except that they write rather than read. The <var class=Fa>data</var> argument supplies the value to be written.</dd><dt><a class=permalink href=#PT_IO><code class=Dv id=PT_IO>PT_IO</code></a></dt><dd>This request allows reading and writing arbitrary amounts of data in the traced process's address space. The <var class=Fa>addr</var> argument specifies a pointer to a <var class=Vt>struct ptrace_io_desc</var>, which is defined as follows: <div class="Bd Pp"><pre>
struct ptrace_io_desc {
	int	piod_op;	/* I/O operation */
	void	*piod_offs;	/* child offset */
	void	*piod_addr;	/* parent offset */
	size_t	piod_len;	/* request length */
};

/*
 * Operations in piod_op.
 */
#define PIOD_READ_D	1	/* Read from D space */
#define PIOD_WRITE_D	2	/* Write to D space */
#define PIOD_READ_I	3	/* Read from I space */
#define PIOD_WRITE_I	4	/* Write to I space */
    </pre></div><p class=Pp>The <var class=Fa>data</var> argument is ignored. The actual number of bytes read or written is stored in <var class=Va>piod_len</var> upon return.</p></dd><dt><a class=permalink href=#PT_CONTINUE><code class=Dv id=PT_CONTINUE>PT_CONTINUE</code></a></dt><dd>The traced process continues execution. The <var class=Fa>addr</var> argument is an address specifying the place where execution is to be resumed (a new value for the program counter), or (<var class=Vt>caddr_t</var>)1 to indicate that execution is to pick up where it left off. The <var class=Fa>data</var> argument provides a signal number to be delivered to the traced process as it resumes execution, or 0 if no signal is to be sent.</dd><dt><a class=permalink href=#PT_STEP><code class=Dv id=PT_STEP>PT_STEP</code></a></dt><dd>The traced process is single stepped one instruction. The <var class=Fa>addr</var> argument should be passed (<var class=Vt>caddr_t</var>)1. The <var class=Fa>data</var> argument provides a signal number to be delivered to the traced process as it resumes execution, or 0 if no signal is to be sent.</dd><dt><a class=permalink href=#PT_KILL><code class=Dv id=PT_KILL>PT_KILL</code></a></dt><dd>The traced process terminates, as if <code class=Dv>PT_CONTINUE</code> had been used with <code class=Dv>SIGKILL</code> given as the signal to be delivered.</dd><dt><a class=permalink href=#PT_ATTACH><code class=Dv id=PT_ATTACH>PT_ATTACH</code></a></dt><dd>This request allows a process to gain control of an otherwise unrelated process and begin tracing it. It does not need any cooperation from the to-be-traced process. In this case, <var class=Fa>pid</var> specifies the process ID of the to-be-traced process, and the other two arguments are ignored. This request requires that the target process must have the same real UID as the tracing process, and that it must not be executing a setuid or setgid executable. (If the tracing process is running as root, these restrictions do not apply.) The tracing process will see the newly-traced process stop and may then control it as if it had been traced all along.</dd><dt><a class=permalink href=#PT_DETACH><code class=Dv id=PT_DETACH>PT_DETACH</code></a></dt><dd>This request is like PT_CONTINUE, except that it does not allow specifying an alternate place to continue execution, and after it succeeds, the traced process is no longer traced and continues execution normally.</dd><dt><a class=permalink href=#PT_GETREGS><code class=Dv id=PT_GETREGS>PT_GETREGS</code></a></dt><dd>This request reads the traced process's machine registers into the “<var class=Vt>struct reg</var>” (defined in <code class=In>&lt;<a class=In href=../src/machine/reg.h.html>machine/reg.h</a>&gt;</code>) pointed to by <var class=Fa>addr</var>.</dd><dt><a class=permalink href=#PT_SETREGS><code class=Dv id=PT_SETREGS>PT_SETREGS</code></a></dt><dd>This request is the converse of <code class=Dv>PT_GETREGS</code>; it loads the traced process's machine registers from the “<var class=Vt>struct reg</var>” (defined in <code class=In>&lt;<a class=In href=../src/machine/reg.h.html>machine/reg.h</a>&gt;</code>) pointed to by <var class=Fa>addr</var>.</dd><dt><a class=permalink href=#PT_GETFPREGS><code class=Dv id=PT_GETFPREGS>PT_GETFPREGS</code></a></dt><dd>This request reads the traced process's floating-point registers into the “<var class=Vt>struct fpreg</var>” (defined in <code class=In>&lt;<a class=In href=../src/machine/reg.h.html>machine/reg.h</a>&gt;</code>) pointed to by <var class=Fa>addr</var>.</dd><dt><a class=permalink href=#PT_SETFPREGS><code class=Dv id=PT_SETFPREGS>PT_SETFPREGS</code></a></dt><dd>This request is the converse of <code class=Dv>PT_GETFPREGS</code>; it loads the traced process's floating-point registers from the “<var class=Vt>struct fpreg</var>” (defined in <code class=In>&lt;<a class=In href=../src/machine/reg.h.html>machine/reg.h</a>&gt;</code>) pointed to by <var class=Fa>addr</var>.</dd><dt><a class=permalink href=#PT_GETDBREGS><code class=Dv id=PT_GETDBREGS>PT_GETDBREGS</code></a></dt><dd>This request reads the traced process's debug registers into the “<var class=Vt>struct dbreg</var>” (defined in <code class=In>&lt;<a class=In href=../src/machine/reg.h.html>machine/reg.h</a>&gt;</code>) pointed to by <var class=Fa>addr</var>.</dd><dt><a class=permalink href=#PT_SETDBREGS><code class=Dv id=PT_SETDBREGS>PT_SETDBREGS</code></a></dt><dd>This request is the converse of <code class=Dv>PT_GETDBREGS</code>; it loads the traced process's debug registers from the “<var class=Vt>struct dbreg</var>” (defined in <code class=In>&lt;<a class=In href=../src/machine/reg.h.html>machine/reg.h</a>&gt;</code>) pointed to by <var class=Fa>addr</var>.</dd><dt><a class=permalink href=#PT_GETREGSET><code class=Dv id=PT_GETREGSET>PT_GETREGSET</code></a></dt><dd>This request reads the registers from the traced process. The <var class=Fa>data</var> argument specifies the register set to read, with the <var class=Fa>addr</var> argument pointing at a <var class=Vt>struct iovec</var> where the <var class=Va>iov_base</var> field points to a register set specific structure to hold the registers, and the <var class=Va>iov_len</var> field holds the length of the structure.</dd><dt><a class=permalink href=#PT_SETREGSET><code class=Dv id=PT_SETREGSET>PT_SETREGSET</code></a></dt><dd>This request writes to the registers of the traced process. The <var class=Fa>data</var> argument specifies the register set to write to, with the <var class=Fa>addr</var> argument pointing at a <var class=Vt>struct iovec</var> where the <var class=Va>iov_base</var> field points to a register set specific structure to hold the registers, and the <var class=Va>iov_len</var> field holds the length of the structure. If <var class=Va>iov_base</var> is NULL the kernel will return the expected length of the register set specific structure in the <var class=Va>iov_len</var> field and not change the target register set.</dd><dt><a class=permalink href=#PT_LWPINFO><code class=Dv id=PT_LWPINFO>PT_LWPINFO</code></a></dt><dd>This request can be used to obtain information about the kernel thread, also known as light-weight process, that caused the traced process to stop. The <var class=Fa>addr</var> argument specifies a pointer to a <var class=Vt>struct ptrace_lwpinfo</var>, which is defined as follows: <div class="Bd Pp"><pre>
struct ptrace_lwpinfo {
	lwpid_t pl_lwpid;
	int	pl_event;
	int	pl_flags;
	sigset_t pl_sigmask;
	sigset_t pl_siglist;
	siginfo_t pl_siginfo;
	char	pl_tdname[MAXCOMLEN + 1];
	pid_t	pl_child_pid;
	u_int	pl_syscall_code;
	u_int	pl_syscall_narg;
};
    </pre></div><p class=Pp>The <var class=Fa>data</var> argument is to be set to the size of the structure known to the caller. This allows the structure to grow without affecting older programs.</p><p class=Pp>The fields in the <var class=Vt>struct ptrace_lwpinfo</var> have the following meaning:</p><dl class="Bl-tag Bl-compact"><dt><var class=Va>pl_lwpid</var></dt><dd>LWP id of the thread</dd><dt><var class=Va>pl_event</var></dt><dd>Event that caused the stop. Currently defined events are: <dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#PL_EVENT_NONE><code class=Dv id=PL_EVENT_NONE>PL_EVENT_NONE</code></a></dt><dd>No reason given</dd><dt><a class=permalink href=#PL_EVENT_SIGNAL><code class=Dv id=PL_EVENT_SIGNAL>PL_EVENT_SIGNAL</code></a></dt><dd>Thread stopped due to the pending signal</dd></dl></dd><dt><var class=Va>pl_flags</var></dt><dd>Flags that specify additional details about observed stop. Currently defined flags are: <dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#PL_FLAG_SCE><code class=Dv id=PL_FLAG_SCE>PL_FLAG_SCE</code></a></dt><dd>The thread stopped due to system call entry, right after the kernel is entered. The debugger may examine syscall arguments that are stored in memory and registers according to the ABI of the current process, and modify them, if needed.</dd><dt><a class=permalink href=#PL_FLAG_SCX><code class=Dv id=PL_FLAG_SCX>PL_FLAG_SCX</code></a></dt><dd>The thread is stopped immediately before syscall is returning to the usermode. The debugger may examine system call return values in the ABI-defined registers and/or memory.</dd><dt><a class=permalink href=#PL_FLAG_EXEC><code class=Dv id=PL_FLAG_EXEC>PL_FLAG_EXEC</code></a></dt><dd>When <code class=Dv>PL_FLAG_SCX</code> is set, this flag may be additionally specified to inform that the program being executed by debuggee process has been changed by successful execution of a system call from the <code class=Fn>execve</code>(<var class=Fa>2</var>) family.</dd><dt><a class=permalink href=#PL_FLAG_SI><code class=Dv id=PL_FLAG_SI>PL_FLAG_SI</code></a></dt><dd>Indicates that <var class=Va>pl_siginfo</var> member of <var class=Vt>struct ptrace_lwpinfo</var> contains valid information.</dd><dt><a class=permalink href=#PL_FLAG_FORKED><code class=Dv id=PL_FLAG_FORKED>PL_FLAG_FORKED</code></a></dt><dd>Indicates that the process is returning from a call to <code class=Fn>fork</code>(<var class=Fa>2</var>) that created a new child process. The process identifier of the new process is available in the <var class=Va>pl_child_pid</var> member of <var class=Vt>struct ptrace_lwpinfo</var>.</dd><dt><a class=permalink href=#PL_FLAG_CHILD><code class=Dv id=PL_FLAG_CHILD>PL_FLAG_CHILD</code></a></dt><dd>The flag is set for first event reported from a new child which is automatically attached when <code class=Dv>PTRACE_FORK</code> is enabled.</dd><dt><a class=permalink href=#PL_FLAG_BORN><code class=Dv id=PL_FLAG_BORN>PL_FLAG_BORN</code></a></dt><dd>This flag is set for the first event reported from a new LWP when <code class=Dv>PTRACE_LWP</code> is enabled. It is reported along with <code class=Dv>PL_FLAG_SCX</code>.</dd><dt><a class=permalink href=#PL_FLAG_EXITED><code class=Dv id=PL_FLAG_EXITED>PL_FLAG_EXITED</code></a></dt><dd>This flag is set for the last event reported by an exiting LWP when <code class=Dv>PTRACE_LWP</code> is enabled. Note that this event is not reported when the last LWP in a process exits. The termination of the last thread is reported via a normal process exit event.</dd><dt><a class=permalink href=#PL_FLAG_VFORKED><code class=Dv id=PL_FLAG_VFORKED>PL_FLAG_VFORKED</code></a></dt><dd>Indicates that the thread is returning from a call to <a class=Xr href=vfork.2.html>vfork(2)</a> that created a new child process. This flag is set in addition to <code class=Dv>PL_FLAG_FORKED</code>.</dd><dt><a class=permalink href=#PL_FLAG_VFORK_DONE><code class=Dv id=PL_FLAG_VFORK_DONE>PL_FLAG_VFORK_DONE</code></a></dt><dd>Indicates that the thread has resumed after a child process created via <a class=Xr href=vfork.2.html>vfork(2)</a> has stopped sharing its address space with the traced process.</dd></dl></dd><dt><var class=Va>pl_sigmask</var></dt><dd>The current signal mask of the LWP</dd><dt><var class=Va>pl_siglist</var></dt><dd>The current pending set of signals for the LWP. Note that signals that are delivered to the process would not appear on an LWP siglist until the thread is selected for delivery.</dd><dt><var class=Va>pl_siginfo</var></dt><dd>The siginfo that accompanies the signal pending. Only valid for <code class=Dv>PL_EVENT_SIGNAL</code> stop when <code class=Dv>PL_FLAG_SI</code> is set in <var class=Va>pl_flags</var>.</dd><dt><var class=Va>pl_tdname</var></dt><dd>The name of the thread.</dd><dt><var class=Va>pl_child_pid</var></dt><dd>The process identifier of the new child process. Only valid for a <code class=Dv>PL_EVENT_SIGNAL</code> stop when <code class=Dv>PL_FLAG_FORKED</code> is set in <var class=Va>pl_flags</var>.</dd><dt><var class=Va>pl_syscall_code</var></dt><dd>The ABI-specific identifier of the current system call. Note that for indirect system calls this field reports the indirected system call. Only valid when <code class=Dv>PL_FLAG_SCE</code> or <code class=Dv>PL_FLAG_SCX</code> is set in <var class=Va>pl_flags</var>.</dd><dt><var class=Va>pl_syscall_narg</var></dt><dd>The number of arguments passed to the current system call not counting the system call identifier. Note that for indirect system calls this field reports the arguments passed to the indirected system call. Only valid when <code class=Dv>PL_FLAG_SCE</code> or <code class=Dv>PL_FLAG_SCX</code> is set in <var class=Va>pl_flags</var>.</dd></dl></dd><dt><a class=permalink href=#PT_GETNUMLWPS><code class=Dv id=PT_GETNUMLWPS>PT_GETNUMLWPS</code></a></dt><dd>This request returns the number of kernel threads associated with the traced process.</dd><dt><a class=permalink href=#PT_GETLWPLIST><code class=Dv id=PT_GETLWPLIST>PT_GETLWPLIST</code></a></dt><dd>This request can be used to get the current thread list. A pointer to an array of type <var class=Vt>lwpid_t</var> should be passed in <var class=Fa>addr</var>, with the array size specified by <var class=Fa>data</var>. The return value from <code class=Fn>ptrace</code>() is the count of array entries filled in.</dd><dt><a class=permalink href=#PT_SETSTEP><code class=Dv id=PT_SETSTEP>PT_SETSTEP</code></a></dt><dd>This request will turn on single stepping of the specified process. Stepping is automatically disabled when a single step trap is caught.</dd><dt><a class=permalink href=#PT_CLEARSTEP><code class=Dv id=PT_CLEARSTEP>PT_CLEARSTEP</code></a></dt><dd>This request will turn off single stepping of the specified process.</dd><dt><a class=permalink href=#PT_SUSPEND><code class=Dv id=PT_SUSPEND>PT_SUSPEND</code></a></dt><dd>This request will suspend the specified thread.</dd><dt><a class=permalink href=#PT_RESUME><code class=Dv id=PT_RESUME>PT_RESUME</code></a></dt><dd>This request will resume the specified thread.</dd><dt><a class=permalink href=#PT_TO_SCE><code class=Dv id=PT_TO_SCE>PT_TO_SCE</code></a></dt><dd>This request will set the <code class=Dv>PTRACE_SCE</code> event flag to trace all future system call entries and continue the process. The <var class=Fa>addr</var> and <var class=Fa>data</var> arguments are used the same as for <code class=Dv>PT_CONTINUE</code>.</dd><dt><a class=permalink href=#PT_TO_SCX><code class=Dv id=PT_TO_SCX>PT_TO_SCX</code></a></dt><dd>This request will set the <code class=Dv>PTRACE_SCX</code> event flag to trace all future system call exits and continue the process. The <var class=Fa>addr</var> and <var class=Fa>data</var> arguments are used the same as for <code class=Dv>PT_CONTINUE</code>.</dd><dt><a class=permalink href=#PT_SYSCALL><code class=Dv id=PT_SYSCALL>PT_SYSCALL</code></a></dt><dd>This request will set the <code class=Dv>PTRACE_SYSCALL</code> event flag to trace all future system call entries and exits and continue the process. The <var class=Fa>addr</var> and <var class=Fa>data</var> arguments are used the same as for <code class=Dv>PT_CONTINUE</code>.</dd><dt><a class=permalink href=#PT_GET_SC_ARGS><code class=Dv id=PT_GET_SC_ARGS>PT_GET_SC_ARGS</code></a></dt><dd>For the thread which is stopped in either <code class=Dv>PL_FLAG_SCE</code> or <code class=Dv>PL_FLAG_SCX</code> state, that is, on entry or exit to a syscall, this request fetches the syscall arguments. <p class=Pp>The arguments are copied out into the buffer pointed to by the <var class=Fa>addr</var> pointer, sequentially. Each syscall argument is stored as the machine word. Kernel copies out as many arguments as the syscall accepts, see the <var class=Va>pl_syscall_narg</var> member of the <var class=Vt>struct ptrace_lwpinfo</var>, but not more than the <var class=Fa>data</var> bytes in total are copied.</p></dd><dt><a class=permalink href=#PT_GET_SC_RET><code class=Dv id=PT_GET_SC_RET>PT_GET_SC_RET</code></a></dt><dd>Fetch the system call return values on exit from a syscall. This request is only valid for threads stopped in a syscall exit (the <code class=Dv>PL_FLAG_SCX</code> state). The <var class=Fa>addr</var> argument specifies a pointer to a <var class=Vt>struct ptrace_sc_ret</var>, which is defined as follows: <div class="Bd Pp"><pre>
struct ptrace_sc_ret {
	register_t	sr_retval[2];
	int		sr_error;
};
    </pre></div><p class=Pp>The <var class=Fa>data</var> argument is set to the size of the structure.</p><p class=Pp>If the system call completed successfully, <var class=Va>sr_error</var> is set to zero and the return values of the system call are saved in <var class=Va>sr_retval</var>. If the system call failed to execute, <var class=Va>sr_error</var> field is set to a positive <a class=Xr href=errno.2.html>errno(2)</a> value. If the system call completed in an unusual fashion, <var class=Va>sr_error</var> is set to a negative value:</p><dl class=Bl-tag><dt><a class=permalink href=#ERESTART><code class=Dv id=ERESTART>ERESTART</code></a></dt><dd>System call will be restarted.</dd><dt><a class=permalink href=#EJUSTRETURN><code class=Dv id=EJUSTRETURN>EJUSTRETURN</code></a></dt><dd>System call completed sucessfully but did not set a return value (for example, <a class=Xr href=setcontext.2.html>setcontext(2)</a> and <a class=Xr href=sigreturn.2.html>sigreturn(2)</a>).</dd></dl></dd><dt><a class=permalink href=#PT_FOLLOW_FORK><code class=Dv id=PT_FOLLOW_FORK>PT_FOLLOW_FORK</code></a></dt><dd>This request controls tracing for new child processes of a traced process. If <var class=Fa>data</var> is non-zero, <code class=Dv>PTRACE_FORK</code> is set in the traced process's event tracing mask. If <var class=Fa>data</var> is zero, <code class=Dv>PTRACE_FORK</code> is cleared from the traced process's event tracing mask.</dd><dt><a class=permalink href=#PT_LWP_EVENTS><code class=Dv id=PT_LWP_EVENTS>PT_LWP_EVENTS</code></a></dt><dd>This request controls tracing of LWP creation and destruction. If <var class=Fa>data</var> is non-zero, <code class=Dv>PTRACE_LWP</code> is set in the traced process's event tracing mask. If <var class=Fa>data</var> is zero, <code class=Dv>PTRACE_LWP</code> is cleared from the traced process's event tracing mask.</dd><dt><a class=permalink href=#PT_GET_EVENT_MASK><code class=Dv id=PT_GET_EVENT_MASK>PT_GET_EVENT_MASK</code></a></dt><dd>This request reads the traced process's event tracing mask into the integer pointed to by <var class=Fa>addr</var>. The size of the integer must be passed in <var class=Fa>data</var>.</dd><dt><a class=permalink href=#PT_SET_EVENT_MASK><code class=Dv id=PT_SET_EVENT_MASK>PT_SET_EVENT_MASK</code></a></dt><dd>This request sets the traced process's event tracing mask from the integer pointed to by <var class=Fa>addr</var>. The size of the integer must be passed in <var class=Fa>data</var>.</dd><dt><a class=permalink href=#PT_VM_TIMESTAMP><code class=Dv id=PT_VM_TIMESTAMP>PT_VM_TIMESTAMP</code></a></dt><dd>This request returns the generation number or timestamp of the memory map of the traced process as the return value from <code class=Fn>ptrace</code>(). This provides a low-cost way for the tracing process to determine if the VM map changed since the last time this request was made.</dd><dt><a class=permalink href=#PT_VM_ENTRY><code class=Dv id=PT_VM_ENTRY>PT_VM_ENTRY</code></a></dt><dd>This request is used to iterate over the entries of the VM map of the traced process. The <var class=Fa>addr</var> argument specifies a pointer to a <var class=Vt>struct ptrace_vm_entry</var>, which is defined as follows: <div class="Bd Pp"><pre>
struct ptrace_vm_entry {
	int		pve_entry;
	int		pve_timestamp;
	u_long		pve_start;
	u_long		pve_end;
	u_long		pve_offset;
	u_int		pve_prot;
	u_int		pve_pathlen;
	long		pve_fileid;
	uint32_t	pve_fsid;
	char		*pve_path;
};
    </pre></div><p class=Pp>The first entry is returned by setting <var class=Va>pve_entry</var> to zero. Subsequent entries are returned by leaving <var class=Va>pve_entry</var> unmodified from the value returned by previous requests. The <var class=Va>pve_timestamp</var> field can be used to detect changes to the VM map while iterating over the entries. The tracing process can then take appropriate action, such as restarting. By setting <var class=Va>pve_pathlen</var> to a non-zero value on entry, the pathname of the backing object is returned in the buffer pointed to by <var class=Va>pve_path</var>, provided the entry is backed by a vnode. The <var class=Va>pve_pathlen</var> field is updated with the actual length of the pathname (including the terminating null character). The <var class=Va>pve_offset</var> field is the offset within the backing object at which the range starts. The range is located in the VM space at <var class=Va>pve_start</var> and extends up to <var class=Va>pve_end</var> (inclusive).</p><p class=Pp>The <var class=Fa>data</var> argument is ignored.</p></dd><dt><a class=permalink href=#PT_COREDUMP><code class=Dv id=PT_COREDUMP>PT_COREDUMP</code></a></dt><dd>This request creates a coredump for the stopped program. The <var class=Fa>addr</var> argument specifies a pointer to a <var class=Vt>struct ptrace_coredump</var>, which is defined as follows: <div class="Bd Pp"><pre>
struct ptrace_coredump {
	int		pc_fd;
	uint32_t	pc_flags;
	off_t		pc_limit;
};
    </pre></div> The fields of the structure are: <dl class=Bl-tag><dt><a class=permalink href=#pc_fd><code class=Dv id=pc_fd>pc_fd</code></a></dt><dd>File descriptor to write the dump to. It must refer to a regular file, opened for writing.</dd><dt><a class=permalink href=#pc_flags><code class=Dv id=pc_flags>pc_flags</code></a></dt><dd>Flags. The following flags are defined: <dl class=Bl-tag><dt><a class=permalink href=#PC_COMPRESS><code class=Dv id=PC_COMPRESS>PC_COMPRESS</code></a></dt><dd>Request compression of the dump.</dd><dt><a class=permalink href=#PC_ALL><code class=Dv id=PC_ALL>PC_ALL</code></a></dt><dd>Include non-dumpable entries into the dump. The dumper ignores <code class=Dv>MAP_NOCORE</code> flag of the process map entry, but device mappings are not dumped even with <code class=Dv>PC_ALL</code> set.</dd></dl></dd><dt><a class=permalink href=#pc_limit><code class=Dv id=pc_limit>pc_limit</code></a></dt><dd>Maximum size of the coredump. Specify zero for no limit.</dd></dl><p class=Pp>The size of <var class=Vt>struct ptrace_coredump</var> must be passed in <var class=Fa>data</var>.</p><p class=Pp>The process must be stopped before dumping core. A single thread in the target process is temporarily unsuspended in kernel to write the dump. If the <code class=Nm>ptrace</code> call fails before a thread is unsuspended, there is no event to <a class=Xr href=waitpid.2.html>waitpid(2)</a> for. If a thread was unsuspended, it will stop again before the <code class=Nm>ptrace</code> call returns, and the process must be waited upon using <a class=Xr href=waitpid.2.html>waitpid(2)</a> to consume the new stop event. Since it is hard to deduce whether a thread was unsuspended before an error occurred, it is recommended to unconditionally perform <a class=Xr href=waitpid.2.html>waitpid(2)</a> with <code class=Dv>WNOHANG</code> flag after <code class=Dv>PT_COREDUMP</code>, and silently accept zero result from it.</p></dd></dl></section><section class=Sh><h2 class=Sh id=ARM_MACHINE_SPECIFIC_REQUESTS><a class=permalink href=#ARM_MACHINE_SPECIFIC_REQUESTS>ARM MACHINE-SPECIFIC REQUESTS</a></h2><dl class=Bl-tag><dt><a class=permalink href=#PT_GETVFPREGS><code class=Dv id=PT_GETVFPREGS>PT_GETVFPREGS</code></a></dt><dd>Return the thread's <code class=Dv>VFP</code> machine state in the buffer pointed to by <var class=Fa>addr</var>. <p class=Pp>The <var class=Fa>data</var> argument is ignored.</p></dd><dt><a class=permalink href=#PT_SETVFPREGS><code class=Dv id=PT_SETVFPREGS>PT_SETVFPREGS</code></a></dt><dd>Set the thread's <code class=Dv>VFP</code> machine state from the buffer pointed to by <var class=Fa>addr</var>. <p class=Pp>The <var class=Fa>data</var> argument is ignored.</p></dd></dl></section><section class=Sh><h2 class=Sh id=x86_MACHINE_SPECIFIC_REQUESTS><a class=permalink href=#x86_MACHINE_SPECIFIC_REQUESTS>x86 MACHINE-SPECIFIC REQUESTS</a></h2><dl class=Bl-tag><dt><a class=permalink href=#PT_GETXMMREGS><code class=Dv id=PT_GETXMMREGS>PT_GETXMMREGS</code></a></dt><dd>Copy the XMM FPU state into the buffer pointed to by the argument <var class=Fa>addr</var>. The buffer has the same layout as the 32-bit save buffer for the machine instruction <code class=Dv>FXSAVE</code>. <p class=Pp>This request is only valid for i386 programs, both on native 32-bit systems and on amd64 kernels. For 64-bit amd64 programs, the XMM state is reported as part of the FPU state returned by the <code class=Dv>PT_GETFPREGS</code> request.</p><p class=Pp>The <var class=Fa>data</var> argument is ignored.</p></dd><dt><a class=permalink href=#PT_SETXMMREGS><code class=Dv id=PT_SETXMMREGS>PT_SETXMMREGS</code></a></dt><dd>Load the XMM FPU state for the thread from the buffer pointed to by the argument <var class=Fa>addr</var>. The buffer has the same layout as the 32-bit load buffer for the machine instruction <code class=Dv>FXRSTOR</code>. <p class=Pp>As with <code class=Dv>PT_GETXMMREGS</code>, this request is only valid for i386 programs.</p><p class=Pp>The <var class=Fa>data</var> argument is ignored.</p></dd><dt><a class=permalink href=#PT_GETXSTATE_INFO><code class=Dv id=PT_GETXSTATE_INFO>PT_GETXSTATE_INFO</code></a></dt><dd>Report which XSAVE FPU extensions are supported by the CPU and allowed in userspace programs. The <var class=Fa>addr</var> argument must point to a variable of type <var class=Vt>struct ptrace_xstate_info</var>, which contains the information on the request return. <var class=Vt>struct ptrace_xstate_info</var> is defined as follows: <div class="Bd Pp"><pre>
struct ptrace_xstate_info {
	uint64_t	xsave_mask;
	uint32_t	xsave_len;
};
    </pre></div> The <code class=Dv>xsave_mask</code> field is a bitmask of the currently enabled extensions. The meaning of the bits is defined in the Intel and AMD processor documentation. The <code class=Dv>xsave_len</code> field reports the length of the XSAVE area for storing the hardware state for currently enabled extensions in the format defined by the x86 <code class=Dv>XSAVE</code> machine instruction. <p class=Pp>The <var class=Fa>data</var> argument value must be equal to the size of the <var class=Vt>struct ptrace_xstate_info</var>.</p></dd><dt><a class=permalink href=#PT_GETXSTATE><code class=Dv id=PT_GETXSTATE>PT_GETXSTATE</code></a></dt><dd>Return the content of the XSAVE area for the thread. The <var class=Fa>addr</var> argument points to the buffer where the content is copied, and the <var class=Fa>data</var> argument specifies the size of the buffer. The kernel copies out as much content as allowed by the buffer size. The buffer layout is specified by the layout of the save area for the <code class=Dv>XSAVE</code> machine instruction.</dd><dt><a class=permalink href=#PT_SETXSTATE><code class=Dv id=PT_SETXSTATE>PT_SETXSTATE</code></a></dt><dd>Load the XSAVE state for the thread from the buffer specified by the <var class=Fa>addr</var> pointer. The buffer size is passed in the <var class=Fa>data</var> argument. The buffer must be at least as large as the <var class=Vt>struct savefpu</var> (defined in <span class=Pa>x86/fpu.h</span>) to allow the complete x87 FPU and XMM state load. It must not be larger than the XSAVE state length, as reported by the <code class=Dv>xsave_len</code> field from the <var class=Vt>struct ptrace_xstate_info</var> of the <code class=Dv>PT_GETXSTATE_INFO</code> request. Layout of the buffer is identical to the layout of the load area for the <code class=Dv>XRSTOR</code> machine instruction.</dd><dt><a class=permalink href=#PT_GETFSBASE><code class=Dv id=PT_GETFSBASE>PT_GETFSBASE</code></a></dt><dd>Return the value of the base used when doing segmented memory addressing using the %fs segment register. The <var class=Fa>addr</var> argument points to an <var class=Vt>unsigned long</var> variable where the base value is stored. <p class=Pp>The <var class=Fa>data</var> argument is ignored.</p></dd><dt><a class=permalink href=#PT_GETGSBASE><code class=Dv id=PT_GETGSBASE>PT_GETGSBASE</code></a></dt><dd>Like the <code class=Dv>PT_GETFSBASE</code> request, but returns the base for the %gs segment register.</dd><dt><a class=permalink href=#PT_SETFSBASE><code class=Dv id=PT_SETFSBASE>PT_SETFSBASE</code></a></dt><dd>Set the base for the %fs segment register to the value pointed to by the <var class=Fa>addr</var> argument. <var class=Fa>addr</var> must point to the <var class=Vt>unsigned long</var> variable containing the new base. <p class=Pp>The <var class=Fa>data</var> argument is ignored.</p></dd><dt><a class=permalink href=#PT_SETGSBASE><code class=Dv id=PT_SETGSBASE>PT_SETGSBASE</code></a></dt><dd>Like the <code class=Dv>PT_SETFSBASE</code> request, but sets the base for the %gs segment register.</dd></dl></section><section class=Sh><h2 class=Sh id=PowerPC_MACHINE_SPECIFIC_REQUESTS><a class=permalink href=#PowerPC_MACHINE_SPECIFIC_REQUESTS>PowerPC MACHINE-SPECIFIC REQUESTS</a></h2><dl class=Bl-tag><dt><a class=permalink href=#PT_GETVRREGS><code class=Dv id=PT_GETVRREGS>PT_GETVRREGS</code></a></dt><dd>Return the thread's <code class=Dv>ALTIVEC</code> machine state in the buffer pointed to by <var class=Fa>addr</var>. <p class=Pp>The <var class=Fa>data</var> argument is ignored.</p></dd><dt><a class=permalink href=#PT_SETVRREGS><code class=Dv id=PT_SETVRREGS>PT_SETVRREGS</code></a></dt><dd>Set the thread's <code class=Dv>ALTIVEC</code> machine state from the buffer pointed to by <var class=Fa>addr</var>. <p class=Pp>The <var class=Fa>data</var> argument is ignored.</p></dd><dt><a class=permalink href=#PT_GETVSRREGS><code class=Dv id=PT_GETVSRREGS>PT_GETVSRREGS</code></a></dt><dd>Return doubleword 1 of the thread's <code class=Dv>VSX</code> registers VSR0-VSR31 in the buffer pointed to by <var class=Fa>addr</var>. <p class=Pp>The <var class=Fa>data</var> argument is ignored.</p></dd><dt><a class=permalink href=#PT_SETVSRREGS><code class=Dv id=PT_SETVSRREGS>PT_SETVSRREGS</code></a></dt><dd>Set doubleword 1 of the thread's <code class=Dv>VSX</code> registers VSR0-VSR31 from the buffer pointed to by <var class=Fa>addr</var>. <p class=Pp>The <var class=Fa>data</var> argument is ignored.</p></dd></dl><p class=Pp>Additionally, other machine-specific requests can exist.</p></section><section class=Sh><h2 class=Sh id=RETURN_VALUES><a class=permalink href=#RETURN_VALUES>RETURN VALUES</a></h2> Most requests return 0 on success and -1 on error. Some requests can cause <code class=Fn>ptrace</code>() to return -1 as a non-error value, among them are <code class=Dv>PT_READ_I</code> and <code class=Dv>PT_READ_D</code>, which return the value read from the process memory on success. To disambiguate, <var class=Va>errno</var> can be set to 0 before the call and checked afterwards. <p class=Pp>The current <code class=Fn>ptrace</code>() implementation always sets <var class=Va>errno</var> to 0 before calling into the kernel, both for historic reasons and for consistency with other operating systems. It is recommended to assign zero to <var class=Va>errno</var> explicitly for forward compatibility.</p></section><section class=Sh><h2 class=Sh id=ERRORS><a class=permalink href=#ERRORS>ERRORS</a></h2> The <code class=Fn>ptrace</code>() system call may fail if: <dl class=Bl-tag><dt>[<a class=permalink href=#ESRCH><code class=Er id=ESRCH>ESRCH</code></a>]</dt><dd><ul class="Bl-bullet Bl-compact"><li>No process having the specified process ID exists.</li></ul></dd><dt>[<a class=permalink href=#EINVAL><code class=Er id=EINVAL>EINVAL</code></a>]</dt><dd><ul class="Bl-bullet Bl-compact"><li>A process attempted to use <code class=Dv>PT_ATTACH</code> on itself.</li><li>The <var class=Fa>request</var> argument was not one of the legal requests.</li><li>The signal number (in <var class=Fa>data</var>) to <code class=Dv>PT_CONTINUE</code> was neither 0 nor a legal signal number.</li><li><a class=permalink href=#PT_GETREGS_2><code class=Dv id=PT_GETREGS_2>PT_GETREGS</code></a>, <code class=Dv>PT_SETREGS</code>, <code class=Dv>PT_GETFPREGS</code>, <code class=Dv>PT_SETFPREGS</code>, <code class=Dv>PT_GETDBREGS</code>, or <code class=Dv>PT_SETDBREGS</code> was attempted on a process with no valid register set. (This is normally true only of system processes.)</li><li><a class=permalink href=#PT_VM_ENTRY_2><code class=Dv id=PT_VM_ENTRY_2>PT_VM_ENTRY</code></a> was given an invalid value for <var class=Fa>pve_entry</var>. This can also be caused by changes to the VM map of the process.</li><li>The size (in <var class=Fa>data</var>) provided to <code class=Dv>PT_LWPINFO</code> was less than or equal to zero, or larger than the <var class=Vt>ptrace_lwpinfo</var> structure known to the kernel.</li><li>The size (in <var class=Fa>data</var>) provided to the x86-specific <code class=Dv>PT_GETXSTATE_INFO</code> request was not equal to the size of the <var class=Vt>struct ptrace_xstate_info</var>.</li><li>The size (in <var class=Fa>data</var>) provided to the x86-specific <code class=Dv>PT_SETXSTATE</code> request was less than the size of the x87 plus the XMM save area.</li><li>The size (in <var class=Fa>data</var>) provided to the x86-specific <code class=Dv>PT_SETXSTATE</code> request was larger than returned in the <code class=Dv>xsave_len</code> member of the <var class=Vt>struct ptrace_xstate_info</var> from the <code class=Dv>PT_GETXSTATE_INFO</code> request.</li><li>The base value, provided to the amd64-specific requests <code class=Dv>PT_SETFSBASE</code> or <code class=Dv>PT_SETGSBASE</code>, pointed outside of the valid user address space. This error will not occur in 32-bit programs.</li></ul></dd><dt>[<a class=permalink href=#EBUSY><code class=Er id=EBUSY>EBUSY</code></a>]</dt><dd><ul class="Bl-bullet Bl-compact"><li><a class=permalink href=#PT_ATTACH_2><code class=Dv id=PT_ATTACH_2>PT_ATTACH</code></a> was attempted on a process that was already being traced.</li><li>A request attempted to manipulate a process that was being traced by some process other than the one making the request.</li><li>A request (other than <code class=Dv>PT_ATTACH</code>) specified a process that was not stopped.</li></ul></dd><dt>[<a class=permalink href=#EPERM><code class=Er id=EPERM>EPERM</code></a>]</dt><dd><ul class="Bl-bullet Bl-compact"><li>A request (other than <code class=Dv>PT_ATTACH</code>) attempted to manipulate a process that was not being traced at all.</li><li>An attempt was made to use <code class=Dv>PT_ATTACH</code> on a process in violation of the requirements listed under <code class=Dv>PT_ATTACH</code> above.</li></ul></dd><dt>[<a class=permalink href=#ENOENT><code class=Er id=ENOENT>ENOENT</code></a>]</dt><dd><ul class="Bl-bullet Bl-compact"><li><a class=permalink href=#PT_VM_ENTRY_3><code class=Dv id=PT_VM_ENTRY_3>PT_VM_ENTRY</code></a> previously returned the last entry of the memory map. No more entries exist.</li></ul></dd><dt>[<a class=permalink href=#ENOMEM><code class=Er id=ENOMEM>ENOMEM</code></a>]</dt><dd><ul class="Bl-bullet Bl-compact"><li>A <code class=Dv>PT_READ_I,</code><code class=Dv>PT_READ_D,</code><code class=Dv>PT_WRITE_I, or</code><code class=Dv>PT_WRITE_D</code> request attempted to access an invalid address, or a memory allocation failure occurred when accessing process memory.</li></ul></dd><dt>[<a class=permalink href=#ENAMETOOLONG><code class=Er id=ENAMETOOLONG>ENAMETOOLONG</code></a>]</dt><dd><ul class="Bl-bullet Bl-compact"><li><a class=permalink href=#PT_VM_ENTRY_4><code class=Dv id=PT_VM_ENTRY_4>PT_VM_ENTRY</code></a> cannot return the pathname of the backing object because the buffer is not big enough. <var class=Fa>pve_pathlen</var> holds the minimum buffer size required on return.</li></ul></dd></dl></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=execve.2.html>execve(2)</a>, <a class=Xr href=sigaction.2.html>sigaction(2)</a>, <a class=Xr href=wait.2.html>wait(2)</a>, <a class=Xr href=execv.3.html>execv(3)</a>, <a class=Xr href=i386_clr_watch.3.html>i386_clr_watch(3)</a>, <a class=Xr href=i386_set_watch.3.html>i386_set_watch(3)</a></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> The <code class=Fn>ptrace</code>() function appeared in <span class=Ux>Version 6 AT&amp;T UNIX</span>. </section></div><table class=foot><tr><td class=foot-date>January 27, 2022</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>