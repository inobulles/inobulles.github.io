<!DOCTYPE html>
<html><head><meta charset=utf-8><title>ieee80211_ifdetach(9)</title><keywords content=man,ieee80211_ifdetach></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>ieee80211_ifdetach(9)</h1><table class=head><tr><td class=head-ltitle>IEEE80211(9)</td><td class=head-vol>FreeBSD Kernel Developer's Manual</td><td class=head-rtitle>IEEE80211(9)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>IEEE80211</code> — <div class=Nd>802.11 network layer</div></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/net80211/ieee80211_var.h.html>net80211/ieee80211_var.h</a>&gt;</code><p class=Pp><var class=Ft>void</var><br><code class=Fn>ieee80211_ifattach</code>(<var class=Fa style="white-space: nowrap;">struct ieee80211com *ic</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>ieee80211_ifdetach</code>(<var class=Fa style="white-space: nowrap;">struct ieee80211com *ic</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>ieee80211_mhz2ieee</code>(<var class=Fa style="white-space: nowrap;">u_int freq</var>, <var class=Fa style="white-space: nowrap;">u_int flags</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>ieee80211_chan2ieee</code>(<var class=Fa style="white-space: nowrap;">struct ieee80211com *ic</var>, <var class=Fa style="white-space: nowrap;">const struct ieee80211_channel *c</var>);</p><p class=Pp><var class=Ft>u_int</var><br><code class=Fn>ieee80211_ieee2mhz</code>(<var class=Fa style="white-space: nowrap;">u_int chan</var>, <var class=Fa style="white-space: nowrap;">u_int flags</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>ieee80211_media_change</code>(<var class=Fa style="white-space: nowrap;">struct ifnet *ifp</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>ieee80211_media_status</code>(<var class=Fa style="white-space: nowrap;">struct ifnet *ifp</var>, <var class=Fa style="white-space: nowrap;">struct ifmediareq *imr</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>ieee80211_setmode</code>(<var class=Fa style="white-space: nowrap;">struct ieee80211com *ic</var>, <var class=Fa style="white-space: nowrap;">enum ieee80211_phymode mode</var>);</p><p class=Pp><var class=Ft>enum ieee80211_phymode</var><br><code class=Fn>ieee80211_chan2mode</code>(<var class=Fa>const struct ieee80211_channel *chan</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>ieee80211_rate2media</code>(<var class=Fa>struct ieee80211com *ic</var>, <var class=Fa>int rate</var>, <var class=Fa>enum ieee80211_phymode mode</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>ieee80211_media2rate</code>(<var class=Fa style="white-space: nowrap;">int mword</var>);</p></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> IEEE 802.11 device drivers are written to use the infrastructure provided by the <code class=Nm>IEEE80211</code> software layer. This software provides a support framework for drivers that includes ifnet cloning, state management, and a user management API by which applications interact with 802.11 devices. Most drivers depend on the <code class=Nm>IEEE80211</code> layer for protocol services but devices that off-load functionality may bypass the layer to connect directly to the device (e.g. the <a class=Xr href=ndis.4.html>ndis(4)</a> emulation support does this). <p class=Pp>A <code class=Nm>IEEE80211</code> device driver implements a virtual radio API that is exported to users through network interfaces (aka vaps) that are cloned from the underlying device. These interfaces have an operating mode (station, adhoc, hostap, wds, monitor, etc.) that is fixed for the lifetime of the interface. Devices that can support multiple concurrent interfaces allow multiple vaps to be cloned. This enables construction of interesting applications such as an AP vap and one or more WDS vaps or multiple AP vaps, each with a different security model. The <code class=Nm>IEEE80211</code> layer virtualizes most 802.11 state and coordinates vap state changes including scheduling multiple vaps. State that is not virtualized includes the current channel and WME/WMM parameters. Protocol processing is typically handled entirely in the <code class=Nm>IEEE80211</code> layer with drivers responsible purely for moving data between the host and device. Similarly, <code class=Nm>IEEE80211</code> handles most <a class=Xr href=ioctl.2.html>ioctl(2)</a> requests without entering the driver; instead drivers are notified of state changes that require their involvement.</p><p class=Pp>The virtual radio interface defined by the <code class=Nm>IEEE80211</code> layer means that drivers must be structured to follow specific rules. Drivers that support only a single interface at any time must still follow these rules.</p><p class=Pp>Most of these functions require that attachment to the stack is performed before calling.</p><p class=Pp>The <code class=Fn>ieee80211_ifattach</code>() function attaches the wireless network interface <var class=Fa>ic</var> to the 802.11 network stack layer. This function must be called before using any of the <code class=Nm>IEEE80211</code> functions which need to store driver state across invocations.</p><p class=Pp>The <code class=Fn>ieee80211_ifdetach</code>() function frees any <code class=Nm>IEEE80211</code> structures associated with the driver, and performs Ethernet and BPF detachment on behalf of the caller.</p><p class=Pp>The <code class=Fn>ieee80211_mhz2ieee</code>() utility function converts the frequency <var class=Fa>freq</var> (specified in MHz) to an IEEE 802.11 channel number. The <var class=Fa>flags</var> argument is a hint which specifies whether the frequency is in the 2GHz ISM band (<var class=Vt>IEEE80211_CHAN_2GHZ</var>) or the 5GHz band (<var class=Vt>IEEE80211_CHAN_5GHZ</var>); appropriate clipping of the result is then performed.</p><p class=Pp>The <code class=Fn>ieee80211_chan2ieee</code>() function converts the channel specified in <var class=Fa>*c</var> to an IEEE channel number for the driver <var class=Fa>ic</var>. If the conversion would be invalid, an error message is printed to the system console. This function REQUIRES that the driver is hooked up to the <code class=Nm>IEEE80211</code> subsystem.</p><p class=Pp>The <code class=Fn>ieee80211_ieee2mhz</code>() utility function converts the IEEE channel number <var class=Ft>chan</var> to a frequency (in MHz). The <var class=Fa>flags</var> argument is a hint which specifies whether the frequency is in the 2GHz ISM band (<var class=Vt>IEEE80211_CHAN_2GHZ</var>) or the 5GHz band (<var class=Vt>IEEE80211_CHAN_5GHZ</var>); appropriate clipping of the result is then performed.</p><p class=Pp>The <code class=Fn>ieee80211_media_status</code>() and <code class=Fn>ieee80211_media_change</code>() functions are device-independent handlers for <var class=Vt>ifmedia</var> commands and are not intended to be called directly.</p><p class=Pp>The <code class=Fn>ieee80211_setmode</code>() function is called from within the 802.11 stack to change the mode of the driver's PHY; it is not intended to be called directly.</p><p class=Pp>The <code class=Fn>ieee80211_chan2mode</code>() function returns the PHY mode required for use with the channel <var class=Fa>chan</var>. This is typically used when selecting a rate set, to be advertised in beacons, for example.</p><p class=Pp>The <code class=Fn>ieee80211_rate2media</code>() function converts the bit rate <var class=Fa>rate</var> (measured in units of 0.5Mbps) to an <var class=Vt>ifmedia</var> sub-type, for the device <var class=Fa>ic</var> running in PHY mode <var class=Fa>mode</var>. The <code class=Fn>ieee80211_media2rate</code>() performs the reverse of this conversion, returning the bit rate (in 0.5Mbps units) corresponding to an <var class=Vt>ifmedia</var> sub-type.</p></section><section class=Sh><h2 class=Sh id=DATA_STRUCTURES><a class=permalink href=#DATA_STRUCTURES>DATA STRUCTURES</a></h2> The virtual radio architecture splits state between a single per-device <var class=Vt>ieee80211com</var> structure and one or more <var class=Vt>ieee80211vap</var> structures. Drivers are expected to setup various shared state in these structures at device attach and during vap creation but otherwise should treat them as read-only. The <var class=Vt>ieee80211com</var> structure is allocated by the <code class=Nm>IEEE80211</code> layer as adjunct data to a device's <var class=Vt>ifnet</var>; it is accessed through the <var class=Vt>if_l2com</var> structure member. The <var class=Vt>ieee80211vap</var> structure is allocated by the driver in the “vap create” method and should be extended with any driver-private state. This technique of giving the driver control to allocate data structures is used for other <code class=Nm>IEEE80211</code> data structures and should be exploited to maintain driver-private state together with public <code class=Nm>IEEE80211</code> state. <p class=Pp>The other main data structures are the station, or node, table that tracks peers in the local BSS, and the channel table that defines the current set of available radio channels. Both tables are bound to the <var class=Vt>ieee80211com</var> structure and shared by all vaps. Long-lasting references to a node are counted to guard against premature reclamation. In particular every packet sent/received holds a node reference (either explicitly for transmit or implicitly on receive).</p><p class=Pp>The <var class=Vt>ieee80211com</var> and <var class=Vt>ieee80211vap</var> structures also hold a collection of method pointers that drivers fill-in and/or override to take control of certain operations. These methods are the primary way drivers are bound to the <code class=Nm>IEEE80211</code> layer and are described below.</p></section><section class=Sh><h2 class=Sh id=DRIVER_ATTACH/DETACH><a class=permalink href=#DRIVER_ATTACH/DETACH>DRIVER ATTACH/DETACH</a></h2> Drivers attach to the <code class=Nm>IEEE80211</code> layer with the <code class=Fn>ieee80211_ifattach</code>() function. The driver is expected to allocate and setup any device-private data structures before passing control. The <var class=Vt>ieee80211com</var> structure must be pre-initialized with state required to setup the <code class=Nm>IEEE80211</code> layer: <dl class=Bl-tag><dt><a class=permalink href=#ic_ifp><code class=Dv id=ic_ifp>ic_ifp</code></a></dt><dd>Backpointer to the physical device's ifnet.</dd><dt><a class=permalink href=#ic_caps><code class=Dv id=ic_caps>ic_caps</code></a></dt><dd>Device/driver capabilities; see below for a complete description.</dd><dt><a class=permalink href=#ic_channels><code class=Dv id=ic_channels>ic_channels</code></a></dt><dd>Table of channels the device is capable of operating on. This is initially provided by the driver but may be changed through calls that change the regulatory state.</dd><dt><a class=permalink href=#ic_nchan><code class=Dv id=ic_nchan>ic_nchan</code></a></dt><dd>Number of entries in <code class=Dv>ic_channels</code>.</dd></dl><p class=Pp>On return from <code class=Fn>ieee80211_ifattach</code>() the driver is expected to override default callback functions in the <var class=Vt>ieee80211com</var> structure to register it's private routines. Methods marked with a “*” must be provided by the driver.</p><dl class=Bl-tag><dt><a class=permalink href=#ic_vap_create*><code class=Dv id=ic_vap_create*>ic_vap_create*</code></a></dt><dd>Create a vap instance of the specified type (operating mode). Any fixed BSSID and/or MAC address is provided. Drivers that support multi-bssid operation may honor the requested BSSID or assign their own.</dd><dt><a class=permalink href=#ic_vap_delete*><code class=Dv id=ic_vap_delete*>ic_vap_delete*</code></a></dt><dd>Destroy a vap instance created with <code class=Dv>ic_vap_create</code>.</dd><dt><a class=permalink href=#ic_getradiocaps><code class=Dv id=ic_getradiocaps>ic_getradiocaps</code></a></dt><dd>Return the list of calibrated channels for the radio. The default method returns the current list of channels (space permitting).</dd><dt><a class=permalink href=#ic_setregdomain><code class=Dv id=ic_setregdomain>ic_setregdomain</code></a></dt><dd>Process a request to change regulatory state. The routine may reject a request or constrain changes (e.g. reduce transmit power caps). The default method accepts all proposed changes.</dd><dt><a class=permalink href=#ic_send_mgmt><code class=Dv id=ic_send_mgmt>ic_send_mgmt</code></a></dt><dd>Send an 802.11 management frame. The default method fabricates the frame using <code class=Nm>IEEE80211</code> state and passes it to the driver through the <code class=Dv>ic_raw_xmit</code> method.</dd><dt><a class=permalink href=#ic_raw_xmit><code class=Dv id=ic_raw_xmit>ic_raw_xmit</code></a></dt><dd>Transmit a raw 802.11 frame. The default method drops the frame and generates a message on the console.</dd><dt><a class=permalink href=#ic_updateslot><code class=Dv id=ic_updateslot>ic_updateslot</code></a></dt><dd>Update hardware state after an 802.11 IFS slot time change. There is no default method; the pointer may be NULL in which case it will not be used.</dd><dt><a class=permalink href=#ic_update_mcast><code class=Dv id=ic_update_mcast>ic_update_mcast</code></a></dt><dd>Update hardware for a change in the multicast packet filter. The default method prints a console message.</dd><dt><a class=permalink href=#ic_update_promisc><code class=Dv id=ic_update_promisc>ic_update_promisc</code></a></dt><dd>Update hardware for a change in the promiscuous mode setting. The default method prints a console message.</dd><dt><a class=permalink href=#ic_newassoc><code class=Dv id=ic_newassoc>ic_newassoc</code></a></dt><dd>Update driver/device state for association to a new AP (in station mode) or when a new station associates (e.g. in AP mode). There is no default method; the pointer may be NULL in which case it will not be used.</dd><dt><a class=permalink href=#ic_node_alloc><code class=Dv id=ic_node_alloc>ic_node_alloc</code></a></dt><dd>Allocate and initialize a <var class=Vt>ieee80211_node</var> structure. This method cannot sleep. The default method allocates zero'd memory using <a class=Xr href=malloc.9.html>malloc(9)</a>. Drivers should override this method to allocate extended storage for their own needs. Memory allocated by the driver must be tagged with <code class=Dv>M_80211_NODE</code> to balance the memory allocation statistics.</dd><dt><a class=permalink href=#ic_node_free><code class=Dv id=ic_node_free>ic_node_free</code></a></dt><dd>Reclaim storage of a node allocated by <code class=Dv>ic_node_alloc</code>. Drivers are expected to <i class=Em>interpose</i> their own method to cleanup private state but must call through this method to allow <code class=Nm>IEEE80211</code> to reclaim it's private state.</dd><dt><a class=permalink href=#ic_node_cleanup><code class=Dv id=ic_node_cleanup>ic_node_cleanup</code></a></dt><dd>Cleanup state in a <var class=Vt>ieee80211_node</var> created by <code class=Dv>ic_node_alloc</code>. This operation is distinguished from <code class=Dv>ic_node_free</code> in that it may be called long before the node is actually reclaimed to cleanup adjunct state. This can happen, for example, when a node must not be reclaimed due to references held by packets in the transmit queue. Drivers typically interpose <code class=Dv>ic_node_cleanup</code> instead of <code class=Dv>ic_node_free</code>.</dd><dt><a class=permalink href=#ic_node_age><code class=Dv id=ic_node_age>ic_node_age</code></a></dt><dd>Age, and potentially reclaim, resources associated with a node. The default method ages frames on the power-save queue (in AP mode) and pending frames in the receive reorder queues (for stations using A-MPDU).</dd><dt><a class=permalink href=#ic_node_drain><code class=Dv id=ic_node_drain>ic_node_drain</code></a></dt><dd>Reclaim all optional resources associated with a node. This call is used to free up resources when they are in short supply.</dd><dt><a class=permalink href=#ic_node_getrssi><code class=Dv id=ic_node_getrssi>ic_node_getrssi</code></a></dt><dd>Return the Receive Signal Strength Indication (RSSI) in .5 dBm units for the specified node. This interface returns a subset of the information returned by <code class=Dv>ic_node_getsignal</code>. The default method calculates a filtered average over the last ten samples passed in to <a class=Xr href=ieee80211_input.9.html>ieee80211_input(9)</a> or <a class=Xr href=ieee80211_input_all.9.html>ieee80211_input_all(9)</a>.</dd><dt><a class=permalink href=#ic_node_getsignal><code class=Dv id=ic_node_getsignal>ic_node_getsignal</code></a></dt><dd>Return the RSSI and noise floor (in .5 dBm units) for a station. The default method calculates RSSI as described above; the noise floor returned is the last value supplied to <a class=Xr href=ieee80211_input.9.html>ieee80211_input(9)</a> or <a class=Xr href=ieee80211_input_all.9.html>ieee80211_input_all(9)</a>.</dd><dt><a class=permalink href=#ic_node_getmimoinfo><code class=Dv id=ic_node_getmimoinfo>ic_node_getmimoinfo</code></a></dt><dd>Return MIMO radio state for a station in support of the <code class=Dv>IEEE80211_IOC_STA_INFO</code> ioctl request. The default method returns nothing.</dd><dt><a class=permalink href=#ic_scan_start*><code class=Dv id=ic_scan_start*>ic_scan_start*</code></a></dt><dd>Prepare driver/hardware state for scanning. This callback is done in a sleepable context.</dd><dt><a class=permalink href=#ic_scan_end*><code class=Dv id=ic_scan_end*>ic_scan_end*</code></a></dt><dd>Restore driver/hardware state after scanning completes. This callback is done in a sleepable context.</dd><dt><a class=permalink href=#ic_set_channel*><code class=Dv id=ic_set_channel*>ic_set_channel*</code></a></dt><dd>Set the current radio channel using <var class=Vt>ic_curchan</var>. This callback is done in a sleepable context.</dd><dt><a class=permalink href=#ic_scan_curchan><code class=Dv id=ic_scan_curchan>ic_scan_curchan</code></a></dt><dd>Start scanning on a channel. This method is called immediately after each channel change and must initiate the work to scan a channel and schedule a timer to advance to the next channel in the scan list. This callback is done in a sleepable context. The default method handles active scan work (e.g. sending ProbeRequest frames), and schedules a call to <a class=Xr href=ieee80211_scan_next.9.html>ieee80211_scan_next(9)</a> according to the maximum dwell time for the channel. Drivers that off-load scan work to firmware typically use this method to trigger per-channel scan activity.</dd><dt><a class=permalink href=#ic_scan_mindwell><code class=Dv id=ic_scan_mindwell>ic_scan_mindwell</code></a></dt><dd>Handle reaching the minimum dwell time on a channel when scanning. This event is triggered when one or more stations have been found on a channel and the minimum dwell time has been reached. This callback is done in a sleepable context. The default method signals the scan machinery to advance to the next channel as soon as possible. Drivers can use this method to preempt further work (e.g. if scanning is handled by firmware) or ignore the request to force maximum dwell time on a channel.</dd><dt><a class=permalink href=#ic_recv_action><code class=Dv id=ic_recv_action>ic_recv_action</code></a></dt><dd>Process a received Action frame. The default method points to <a class=Xr href=ieee80211_recv_action.9.html>ieee80211_recv_action(9)</a> which provides a mechanism for setting up handlers for each Action frame class.</dd><dt><a class=permalink href=#ic_send_action><code class=Dv id=ic_send_action>ic_send_action</code></a></dt><dd>Transmit an Action frame. The default method points to <a class=Xr href=ieee80211_send_action.9.html>ieee80211_send_action(9)</a> which provides a mechanism for setting up handlers for each Action frame class.</dd><dt><a class=permalink href=#ic_ampdu_enable><code class=Dv id=ic_ampdu_enable>ic_ampdu_enable</code></a></dt><dd>Check if transmit A-MPDU should be enabled for the specified station and AC. The default method checks a per-AC traffic rate against a per-vap threshold to decide if A-MPDU should be enabled. This method also rate-limits ADDBA requests so that requests are not made too frequently when a receiver has limited resources.</dd><dt><a class=permalink href=#ic_addba_request><code class=Dv id=ic_addba_request>ic_addba_request</code></a></dt><dd>Request A-MPDU transmit aggregation. The default method sets up local state and issues an ADDBA Request Action frame. Drivers may interpose this method if they need to setup private state for handling transmit A-MPDU.</dd><dt><a class=permalink href=#ic_addb_response><code class=Dv id=ic_addb_response>ic_addb_response</code></a></dt><dd>Process a received ADDBA Response Action frame and setup resources as needed for doing transmit A-MPDU.</dd><dt><a class=permalink href=#ic_addb_stop><code class=Dv id=ic_addb_stop>ic_addb_stop</code></a></dt><dd>Shutdown an A-MPDU transmit stream for the specified station and AC. The default method reclaims local state after sending a DelBA Action frame.</dd><dt><a class=permalink href=#ic_bar_response><code class=Dv id=ic_bar_response>ic_bar_response</code></a></dt><dd>Process a response to a transmitted BAR control frame.</dd><dt><a class=permalink href=#ic_ampdu_rx_start><code class=Dv id=ic_ampdu_rx_start>ic_ampdu_rx_start</code></a></dt><dd>Prepare to receive A-MPDU data from the specified station for the TID.</dd><dt><a class=permalink href=#ic_ampdu_rx_stop><code class=Dv id=ic_ampdu_rx_stop>ic_ampdu_rx_stop</code></a></dt><dd>Terminate receipt of A-MPDU data from the specified station for the TID.</dd></dl><p class=Pp>Once the <code class=Nm>IEEE80211</code> layer is attached to a driver there are two more steps typically done to complete the work:</p><ol class=Bl-enum><li>Setup “radiotap support” for capturing raw 802.11 packets that pass through the device. This is done with a call to <a class=Xr href=ieee80211_radiotap_attach.9.html>ieee80211_radiotap_attach(9)</a>.</li><li>Do any final device setup like enabling interrupts.</li></ol><p class=Pp>State is torn down and reclaimed with a call to <code class=Fn>ieee80211_ifdetach</code>(). Note this call may result in multiple callbacks into the driver so it should be done before any critical driver state is reclaimed. On return from <code class=Fn>ieee80211_ifdetach</code>() all associated vaps and ifnet structures are reclaimed or inaccessible to user applications so it is safe to teardown driver state without worry about being re-entered. The driver is responsible for calling <a class=Xr href=if_free.9.html>if_free(9)</a> on the ifnet it allocated for the physical device.</p></section><section class=Sh><h2 class=Sh id=DRIVER_CAPABILITIES><a class=permalink href=#DRIVER_CAPABILITIES>DRIVER CAPABILITIES</a></h2> Driver/device capabilities are specified using several sets of flags in the <var class=Vt>ieee80211com</var> structure. General capabilities are specified by <var class=Vt>ic_caps</var>. Hardware cryptographic capabilities are specified by <var class=Vt>ic_cryptocaps</var>. 802.11n capabilities, if any, are specified by <var class=Vt>ic_htcaps</var>. The <code class=Nm>IEEE80211</code> layer propagates a subset of these capabilities to each vap through the equivalent fields: <var class=Vt>iv_caps</var>, <var class=Vt>iv_cryptocaps</var>, and <var class=Vt>iv_htcaps</var>. The following general capabilities are defined: <dl class=Bl-tag><dt><a class=permalink href=#IEEE80211_C_STA><code class=Dv id=IEEE80211_C_STA>IEEE80211_C_STA</code></a></dt><dd>Device is capable of operating in station (aka Infrastructure) mode.</dd><dt><a class=permalink href=#IEEE80211_C_8023ENCAP><code class=Dv id=IEEE80211_C_8023ENCAP>IEEE80211_C_8023ENCAP</code></a></dt><dd>Device requires 802.3-encapsulated frames be passed for transmit. By default <code class=Nm>IEEE80211</code> will encapsulate all outbound frames as 802.11 frames (without a PLCP header).</dd><dt><a class=permalink href=#IEEE80211_C_FF><code class=Dv id=IEEE80211_C_FF>IEEE80211_C_FF</code></a></dt><dd>Device supports Atheros Fast-Frames.</dd><dt><a class=permalink href=#IEEE80211_C_TURBOP><code class=Dv id=IEEE80211_C_TURBOP>IEEE80211_C_TURBOP</code></a></dt><dd>Device supports Atheros Dynamic Turbo mode.</dd><dt><a class=permalink href=#IEEE80211_C_IBSS><code class=Dv id=IEEE80211_C_IBSS>IEEE80211_C_IBSS</code></a></dt><dd>Device is capable of operating in adhoc/IBSS mode.</dd><dt><a class=permalink href=#IEEE80211_C_PMGT><code class=Dv id=IEEE80211_C_PMGT>IEEE80211_C_PMGT</code></a></dt><dd>Device supports dynamic power-management (aka power save) in station mode.</dd><dt><a class=permalink href=#IEEE80211_C_HOSTAP><code class=Dv id=IEEE80211_C_HOSTAP>IEEE80211_C_HOSTAP</code></a></dt><dd>Device is capable of operating as an Access Point in Infrastructure mode.</dd><dt><a class=permalink href=#IEEE80211_C_AHDEMO><code class=Dv id=IEEE80211_C_AHDEMO>IEEE80211_C_AHDEMO</code></a></dt><dd>Device is capable of operating in Adhoc Demo mode. In this mode the device is used purely to send/receive raw 802.11 frames.</dd><dt><a class=permalink href=#IEEE80211_C_SWRETRY><code class=Dv id=IEEE80211_C_SWRETRY>IEEE80211_C_SWRETRY</code></a></dt><dd>Device supports software retry of transmitted frames.</dd><dt><a class=permalink href=#IEEE80211_C_TXPMGT><code class=Dv id=IEEE80211_C_TXPMGT>IEEE80211_C_TXPMGT</code></a></dt><dd>Device support dynamic transmit power changes on transmitted frames; also known as Transmit Power Control (TPC).</dd><dt><a class=permalink href=#IEEE80211_C_SHSLOT><code class=Dv id=IEEE80211_C_SHSLOT>IEEE80211_C_SHSLOT</code></a></dt><dd>Device supports short slot time operation (for 802.11g).</dd><dt><a class=permalink href=#IEEE80211_C_SHPREAMBLE><code class=Dv id=IEEE80211_C_SHPREAMBLE>IEEE80211_C_SHPREAMBLE</code></a></dt><dd>Device supports short preamble operation (for 802.11g).</dd><dt><a class=permalink href=#IEEE80211_C_MONITOR><code class=Dv id=IEEE80211_C_MONITOR>IEEE80211_C_MONITOR</code></a></dt><dd>Device is capable of operating in monitor mode.</dd><dt><a class=permalink href=#IEEE80211_C_DFS><code class=Dv id=IEEE80211_C_DFS>IEEE80211_C_DFS</code></a></dt><dd>Device supports radar detection and/or DFS. DFS protocol support can be handled by <code class=Nm>IEEE80211</code> but the device must be capable of detecting radar events.</dd><dt><a class=permalink href=#IEEE80211_C_MBSS><code class=Dv id=IEEE80211_C_MBSS>IEEE80211_C_MBSS</code></a></dt><dd>Device is capable of operating in MeshBSS (MBSS) mode (as defined by 802.11s Draft 3.0).</dd><dt><a class=permalink href=#IEEE80211_C_WPA1><code class=Dv id=IEEE80211_C_WPA1>IEEE80211_C_WPA1</code></a></dt><dd>Device supports WPA1 operation.</dd><dt><a class=permalink href=#IEEE80211_C_WPA2><code class=Dv id=IEEE80211_C_WPA2>IEEE80211_C_WPA2</code></a></dt><dd>Device supports WPA2/802.11i operation.</dd><dt><a class=permalink href=#IEEE80211_C_BURST><code class=Dv id=IEEE80211_C_BURST>IEEE80211_C_BURST</code></a></dt><dd>Device supports frame bursting.</dd><dt><a class=permalink href=#IEEE80211_C_WME><code class=Dv id=IEEE80211_C_WME>IEEE80211_C_WME</code></a></dt><dd>Device supports WME/WMM operation (at the moment this is mostly support for sending and receiving QoS frames with EDCF).</dd><dt><a class=permalink href=#IEEE80211_C_WDS><code class=Dv id=IEEE80211_C_WDS>IEEE80211_C_WDS</code></a></dt><dd>Device supports transmit/receive of 4-address frames.</dd><dt><a class=permalink href=#IEEE80211_C_BGSCAN><code class=Dv id=IEEE80211_C_BGSCAN>IEEE80211_C_BGSCAN</code></a></dt><dd>Device supports background scanning.</dd><dt><a class=permalink href=#IEEE80211_C_TXFRAG><code class=Dv id=IEEE80211_C_TXFRAG>IEEE80211_C_TXFRAG</code></a></dt><dd>Device supports transmit of fragmented 802.11 frames.</dd><dt><a class=permalink href=#IEEE80211_C_TDMA><code class=Dv id=IEEE80211_C_TDMA>IEEE80211_C_TDMA</code></a></dt><dd>Device is capable of operating in TDMA mode.</dd></dl><p class=Pp>The follow general crypto capabilities are defined. In general <code class=Nm>IEEE80211</code> will fall-back to software support when a device is not capable of hardware acceleration of a cipher. This can be done on a per-key basis. <code class=Nm>IEEE80211</code> can also handle software <code class=Dv>Michael</code> calculation combined with hardware <code class=Dv>AES</code> acceleration.</p><dl class=Bl-tag><dt><a class=permalink href=#IEEE80211_CRYPTO_WEP><code class=Dv id=IEEE80211_CRYPTO_WEP>IEEE80211_CRYPTO_WEP</code></a></dt><dd>Device supports hardware WEP cipher.</dd><dt><a class=permalink href=#IEEE80211_CRYPTO_TKIP><code class=Dv id=IEEE80211_CRYPTO_TKIP>IEEE80211_CRYPTO_TKIP</code></a></dt><dd>Device supports hardware TKIP cipher.</dd><dt><a class=permalink href=#IEEE80211_CRYPTO_AES_OCB><code class=Dv id=IEEE80211_CRYPTO_AES_OCB>IEEE80211_CRYPTO_AES_OCB</code></a></dt><dd>Device supports hardware AES-OCB cipher.</dd><dt><a class=permalink href=#IEEE80211_CRYPTO_AES_CCM><code class=Dv id=IEEE80211_CRYPTO_AES_CCM>IEEE80211_CRYPTO_AES_CCM</code></a></dt><dd>Device supports hardware AES-CCM cipher.</dd><dt><a class=permalink href=#IEEE80211_CRYPTO_TKIPMIC><code class=Dv id=IEEE80211_CRYPTO_TKIPMIC>IEEE80211_CRYPTO_TKIPMIC</code></a></dt><dd>Device supports hardware Michael for use with TKIP.</dd><dt><a class=permalink href=#IEEE80211_CRYPTO_CKIP><code class=Dv id=IEEE80211_CRYPTO_CKIP>IEEE80211_CRYPTO_CKIP</code></a></dt><dd>Devices supports hardware CKIP cipher.</dd></dl><p class=Pp>The follow general 802.11n capabilities are defined. The first capabilities are defined exactly as they appear in the 802.11n specification. Capabilities beginning with IEEE80211_HTC_AMPDU are used solely by the <code class=Nm>IEEE80211</code> layer.</p><dl class=Bl-tag><dt><a class=permalink href=#IEEE80211_HTCAP_CHWIDTH40><code class=Dv id=IEEE80211_HTCAP_CHWIDTH40>IEEE80211_HTCAP_CHWIDTH40</code></a></dt><dd>Device supports 20/40 channel width operation.</dd><dt><a class=permalink href=#IEEE80211_HTCAP_SMPS_DYNAMIC><code class=Dv id=IEEE80211_HTCAP_SMPS_DYNAMIC>IEEE80211_HTCAP_SMPS_DYNAMIC</code></a></dt><dd>Device supports dynamic SM power save operation.</dd><dt><a class=permalink href=#IEEE80211_HTCAP_SMPS_ENA><code class=Dv id=IEEE80211_HTCAP_SMPS_ENA>IEEE80211_HTCAP_SMPS_ENA</code></a></dt><dd>Device supports static SM power save operation.</dd><dt><a class=permalink href=#IEEE80211_HTCAP_GREENFIELD><code class=Dv id=IEEE80211_HTCAP_GREENFIELD>IEEE80211_HTCAP_GREENFIELD</code></a></dt><dd>Device supports Greenfield preamble.</dd><dt><a class=permalink href=#IEEE80211_HTCAP_SHORTGI20><code class=Dv id=IEEE80211_HTCAP_SHORTGI20>IEEE80211_HTCAP_SHORTGI20</code></a></dt><dd>Device supports Short Guard Interval on 20MHz channels.</dd><dt><a class=permalink href=#IEEE80211_HTCAP_SHORTGI40><code class=Dv id=IEEE80211_HTCAP_SHORTGI40>IEEE80211_HTCAP_SHORTGI40</code></a></dt><dd>Device supports Short Guard Interval on 40MHz channels.</dd><dt><a class=permalink href=#IEEE80211_HTCAP_TXSTBC><code class=Dv id=IEEE80211_HTCAP_TXSTBC>IEEE80211_HTCAP_TXSTBC</code></a></dt><dd>Device supports Space Time Block Convolution (STBC) for transmit.</dd><dt><a class=permalink href=#IEEE80211_HTCAP_RXSTBC_1STREAM><code class=Dv id=IEEE80211_HTCAP_RXSTBC_1STREAM>IEEE80211_HTCAP_RXSTBC_1STREAM</code></a></dt><dd>Device supports 1 spatial stream for STBC receive.</dd><dt><a class=permalink href=#IEEE80211_HTCAP_RXSTBC_2STREAM><code class=Dv id=IEEE80211_HTCAP_RXSTBC_2STREAM>IEEE80211_HTCAP_RXSTBC_2STREAM</code></a></dt><dd>Device supports 1-2 spatial streams for STBC receive.</dd><dt><a class=permalink href=#IEEE80211_HTCAP_RXSTBC_3STREAM><code class=Dv id=IEEE80211_HTCAP_RXSTBC_3STREAM>IEEE80211_HTCAP_RXSTBC_3STREAM</code></a></dt><dd>Device supports 1-3 spatial streams for STBC receive.</dd><dt><a class=permalink href=#IEEE80211_HTCAP_MAXAMSDU_7935><code class=Dv id=IEEE80211_HTCAP_MAXAMSDU_7935>IEEE80211_HTCAP_MAXAMSDU_7935</code></a></dt><dd>Device supports A-MSDU frames up to 7935 octets.</dd><dt><a class=permalink href=#IEEE80211_HTCAP_MAXAMSDU_3839><code class=Dv id=IEEE80211_HTCAP_MAXAMSDU_3839>IEEE80211_HTCAP_MAXAMSDU_3839</code></a></dt><dd>Device supports A-MSDU frames up to 3839 octets.</dd><dt><a class=permalink href=#IEEE80211_HTCAP_DSSSCCK40><code class=Dv id=IEEE80211_HTCAP_DSSSCCK40>IEEE80211_HTCAP_DSSSCCK40</code></a></dt><dd>Device supports use of DSSS/CCK on 40MHz channels.</dd><dt><a class=permalink href=#IEEE80211_HTCAP_PSMP><code class=Dv id=IEEE80211_HTCAP_PSMP>IEEE80211_HTCAP_PSMP</code></a></dt><dd>Device supports PSMP.</dd><dt><a class=permalink href=#IEEE80211_HTCAP_40INTOLERANT><code class=Dv id=IEEE80211_HTCAP_40INTOLERANT>IEEE80211_HTCAP_40INTOLERANT</code></a></dt><dd>Device is intolerant of 40MHz wide channel use.</dd><dt><a class=permalink href=#IEEE80211_HTCAP_LSIGTXOPPROT><code class=Dv id=IEEE80211_HTCAP_LSIGTXOPPROT>IEEE80211_HTCAP_LSIGTXOPPROT</code></a></dt><dd>Device supports L-SIG TXOP protection.</dd><dt><a class=permalink href=#IEEE80211_HTC_AMPDU><code class=Dv id=IEEE80211_HTC_AMPDU>IEEE80211_HTC_AMPDU</code></a></dt><dd>Device supports A-MPDU aggregation. Note that any 802.11n compliant device must support A-MPDU receive so this implicitly means support for <i class=Em>transmit</i> of A-MPDU frames.</dd><dt><a class=permalink href=#IEEE80211_HTC_AMSDU><code class=Dv id=IEEE80211_HTC_AMSDU>IEEE80211_HTC_AMSDU</code></a></dt><dd>Device supports A-MSDU aggregation. Note that any 802.11n compliant device must support A-MSDU receive so this implicitly means support for <i class=Em>transmit</i> of A-MSDU frames.</dd><dt><a class=permalink href=#IEEE80211_HTC_HT><code class=Dv id=IEEE80211_HTC_HT>IEEE80211_HTC_HT</code></a></dt><dd>Device supports High Throughput (HT) operation. This capability must be set to enable 802.11n functionality in <code class=Nm>IEEE80211</code>.</dd><dt><a class=permalink href=#IEEE80211_HTC_SMPS><code class=Dv id=IEEE80211_HTC_SMPS>IEEE80211_HTC_SMPS</code></a></dt><dd>Device supports MIMO Power Save operation.</dd><dt><a class=permalink href=#IEEE80211_HTC_RIFS><code class=Dv id=IEEE80211_HTC_RIFS>IEEE80211_HTC_RIFS</code></a></dt><dd>Device supports Reduced Inter Frame Spacing (RIFS).</dd></dl></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=ioctl.2.html>ioctl(2)</a>, <a class=Xr href=ndis.4.html>ndis(4)</a>, <a class=Xr href=ieee80211_amrr.9.html>ieee80211_amrr(9)</a>, <a class=Xr href=ieee80211_beacon.9.html>ieee80211_beacon(9)</a>, <a class=Xr href=ieee80211_bmiss.9.html>ieee80211_bmiss(9)</a>, <a class=Xr href=ieee80211_crypto.9.html>ieee80211_crypto(9)</a>, <a class=Xr href=ieee80211_ddb.9.html>ieee80211_ddb(9)</a>, <a class=Xr href=ieee80211_input.9.html>ieee80211_input(9)</a>, <a class=Xr href=ieee80211_node.9.html>ieee80211_node(9)</a>, <a class=Xr href=ieee80211_output.9.html>ieee80211_output(9)</a>, <a class=Xr href=ieee80211_proto.9.html>ieee80211_proto(9)</a>, <a class=Xr href=ieee80211_radiotap.9.html>ieee80211_radiotap(9)</a>, <a class=Xr href=ieee80211_regdomain.9.html>ieee80211_regdomain(9)</a>, <a class=Xr href=ieee80211_scan.9.html>ieee80211_scan(9)</a>, <a class=Xr href=ieee80211_vap.9.html>ieee80211_vap(9)</a>, <a class=Xr href=ifnet.9.html>ifnet(9)</a>, <a class=Xr href=malloc.9.html>malloc(9)</a></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> The <code class=Nm>IEEE80211</code> series of functions first appeared in <span class=Ux>NetBSD 1.5</span>, and were later ported to <span class=Ux>FreeBSD 4.6</span>. This man page was updated with the information from <span class=Ux>NetBSD</span><code class=Nm>IEEE80211</code> man page. </section><section class=Sh><h2 class=Sh id=AUTHORS><a class=permalink href=#AUTHORS>AUTHORS</a></h2> The original <span class=Ux>NetBSD</span><code class=Nm>IEEE80211</code> man page was written by <span class=An>Bruce M. Simpson</span> &lt;<a class=Mt href=mailto:bms@FreeBSD.org>bms@FreeBSD.org</a>&gt; and <span class=An>Darron Broad</span> &lt;<a class=Mt href=mailto:darron@kewl.org>darron@kewl.org</a>&gt;. </section></div><table class=foot><tr><td class=foot-date>December 31, 2017</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>