<!DOCTYPE html>
<html><head><meta charset=utf-8><title>MCLGET(9)</title><keywords content=man,MCLGET></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>MCLGET(9)</h1><table class=head><tr><td class=head-ltitle>MBUF(9)</td><td class=head-vol>FreeBSD Kernel Developer's Manual</td><td class=head-rtitle>MBUF(9)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>mbuf</code> — <div class=Nd>memory management in the kernel IPC subsystem</div></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/sys/param.h.html>sys/param.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/sys/systm.h.html>sys/systm.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/sys/mbuf.h.html>sys/mbuf.h</a>&gt;</code><section class=Ss><h2 class=Ss id=Mbuf_allocation_macros><a class=permalink href=#Mbuf_allocation_macros>Mbuf allocation macros</a></h2><code class=Fn>MGET</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">int how</var>, <var class=Fa style="white-space: nowrap;">short type</var>); <p class=Pp><code class=Fn>MGETHDR</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">int how</var>, <var class=Fa style="white-space: nowrap;">short type</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>MCLGET</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">int how</var>);</p><p class=Pp><code class=Fn>MEXTADD</code>(<var class=Fa>struct mbuf *mbuf</var>, <var class=Fa>char *buf</var>, <var class=Fa>u_int size</var>, <var class=Fa>void (*free)(struct mbuf *)</var>, <var class=Fa>void *opt_arg1</var>, <var class=Fa>void *opt_arg2</var>, <var class=Fa>int flags</var>, <var class=Fa>int type</var>);</p></section><section class=Ss><h2 class=Ss id=Mbuf_utility_macros><a class=permalink href=#Mbuf_utility_macros>Mbuf utility macros</a></h2><code class=Fn>mtod</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">type</var>); <p class=Pp><code class=Fn>M_ALIGN</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">u_int len</var>);</p><p class=Pp><code class=Fn>MH_ALIGN</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">u_int len</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>M_LEADINGSPACE</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>M_TRAILINGSPACE</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>);</p><p class=Pp><code class=Fn>M_MOVE_PKTHDR</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *to</var>, <var class=Fa style="white-space: nowrap;">struct mbuf *from</var>);</p><p class=Pp><code class=Fn>M_PREPEND</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">int len</var>, <var class=Fa style="white-space: nowrap;">int how</var>);</p><p class=Pp><code class=Fn>MCHTYPE</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">short type</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>M_WRITABLE</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>);</p></section><section class=Ss><h2 class=Ss id=Mbuf_allocation_functions><a class=permalink href=#Mbuf_allocation_functions>Mbuf allocation functions</a></h2><var class=Ft>struct mbuf *</var><br><code class=Fn>m_get</code>(<var class=Fa style="white-space: nowrap;">int how</var>, <var class=Fa style="white-space: nowrap;">short type</var>); <p class=Pp><var class=Ft>struct mbuf *</var><br><code class=Fn>m_get2</code>(<var class=Fa style="white-space: nowrap;">int size</var>, <var class=Fa style="white-space: nowrap;">int how</var>, <var class=Fa style="white-space: nowrap;">short type</var>, <var class=Fa style="white-space: nowrap;">int flags</var>);</p><p class=Pp><var class=Ft>struct mbuf *</var><br><code class=Fn>m_getm</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *orig</var>, <var class=Fa style="white-space: nowrap;">int len</var>, <var class=Fa style="white-space: nowrap;">int how</var>, <var class=Fa style="white-space: nowrap;">short type</var>);</p><p class=Pp><var class=Ft>struct mbuf *</var><br><code class=Fn>m_getjcl</code>(<var class=Fa style="white-space: nowrap;">int how</var>, <var class=Fa style="white-space: nowrap;">short type</var>, <var class=Fa style="white-space: nowrap;">int flags</var>, <var class=Fa style="white-space: nowrap;">int size</var>);</p><p class=Pp><var class=Ft>struct mbuf *</var><br><code class=Fn>m_getcl</code>(<var class=Fa style="white-space: nowrap;">int how</var>, <var class=Fa style="white-space: nowrap;">short type</var>, <var class=Fa style="white-space: nowrap;">int flags</var>);</p><p class=Pp><var class=Ft>struct mbuf *</var><br><code class=Fn>m_gethdr</code>(<var class=Fa style="white-space: nowrap;">int how</var>, <var class=Fa style="white-space: nowrap;">short type</var>);</p><p class=Pp><var class=Ft>struct mbuf *</var><br><code class=Fn>m_free</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>m_freem</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>);</p></section><section class=Ss><h2 class=Ss id=Mbuf_utility_functions><a class=permalink href=#Mbuf_utility_functions>Mbuf utility functions</a></h2><var class=Ft>void</var><br><code class=Fn>m_adj</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">int len</var>); <p class=Pp><var class=Ft>void</var><br><code class=Fn>m_align</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">int len</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>m_append</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">int len</var>, <var class=Fa style="white-space: nowrap;">c_caddr_t cp</var>);</p><p class=Pp><var class=Ft>struct mbuf *</var><br><code class=Fn>m_prepend</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">int len</var>, <var class=Fa style="white-space: nowrap;">int how</var>);</p><p class=Pp><var class=Ft>struct mbuf *</var><br><code class=Fn>m_copyup</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">int len</var>, <var class=Fa style="white-space: nowrap;">int dstoff</var>);</p><p class=Pp><var class=Ft>struct mbuf *</var><br><code class=Fn>m_pullup</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">int len</var>);</p><p class=Pp><var class=Ft>struct mbuf *</var><br><code class=Fn>m_pulldown</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">int offset</var>, <var class=Fa style="white-space: nowrap;">int len</var>, <var class=Fa style="white-space: nowrap;">int *offsetp</var>);</p><p class=Pp><var class=Ft>struct mbuf *</var><br><code class=Fn>m_copym</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">int offset</var>, <var class=Fa style="white-space: nowrap;">int len</var>, <var class=Fa style="white-space: nowrap;">int how</var>);</p><p class=Pp><var class=Ft>struct mbuf *</var><br><code class=Fn>m_copypacket</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">int how</var>);</p><p class=Pp><var class=Ft>struct mbuf *</var><br><code class=Fn>m_dup</code>(<var class=Fa style="white-space: nowrap;">const struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">int how</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>m_copydata</code>(<var class=Fa style="white-space: nowrap;">const struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">int offset</var>, <var class=Fa style="white-space: nowrap;">int len</var>, <var class=Fa style="white-space: nowrap;">caddr_t buf</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>m_copyback</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">int offset</var>, <var class=Fa style="white-space: nowrap;">int len</var>, <var class=Fa style="white-space: nowrap;">caddr_t buf</var>);</p><p class=Pp><var class=Ft>struct mbuf *</var><br><code class=Fn>m_devget</code>(<var class=Fa>char *buf</var>, <var class=Fa>int len</var>, <var class=Fa>int offset</var>, <var class=Fa>struct ifnet *ifp</var>, <var class=Fa>void (*copy)(char *from, caddr_t to, u_int len)</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>m_cat</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *m</var>, <var class=Fa style="white-space: nowrap;">struct mbuf *n</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>m_catpkt</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *m</var>, <var class=Fa style="white-space: nowrap;">struct mbuf *n</var>);</p><p class=Pp><var class=Ft>u_int</var><br><code class=Fn>m_fixhdr</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>m_dup_pkthdr</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *to</var>, <var class=Fa style="white-space: nowrap;">const struct mbuf *from</var>, <var class=Fa style="white-space: nowrap;">int how</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>m_move_pkthdr</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *to</var>, <var class=Fa style="white-space: nowrap;">struct mbuf *from</var>);</p><p class=Pp><var class=Ft>u_int</var><br><code class=Fn>m_length</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">struct mbuf **last</var>);</p><p class=Pp><var class=Ft>struct mbuf *</var><br><code class=Fn>m_split</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">int len</var>, <var class=Fa style="white-space: nowrap;">int how</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>m_apply</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">int off</var>, <var class=Fa style="white-space: nowrap;">int len</var>, <var class=Fa style="white-space: nowrap;">int (*f)(void *arg, void *data, u_int len)</var>, <var class=Fa style="white-space: nowrap;">void *arg</var>);</p><p class=Pp><var class=Ft>struct mbuf *</var><br><code class=Fn>m_getptr</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *mbuf</var>, <var class=Fa style="white-space: nowrap;">int loc</var>, <var class=Fa style="white-space: nowrap;">int *off</var>);</p><p class=Pp><var class=Ft>struct mbuf *</var><br><code class=Fn>m_defrag</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *m0</var>, <var class=Fa style="white-space: nowrap;">int how</var>);</p><p class=Pp><var class=Ft>struct mbuf *</var><br><code class=Fn>m_collapse</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *m0</var>, <var class=Fa style="white-space: nowrap;">int how</var>, <var class=Fa style="white-space: nowrap;">int maxfrags</var>);</p><p class=Pp><var class=Ft>struct mbuf *</var><br><code class=Fn>m_unshare</code>(<var class=Fa style="white-space: nowrap;">struct mbuf *m0</var>, <var class=Fa style="white-space: nowrap;">int how</var>);</p></section></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> An <var class=Vt>mbuf</var> is a basic unit of memory management in the kernel IPC subsystem. Network packets and socket buffers are stored in <var class=Vt>mbufs</var>. A network packet may span multiple <var class=Vt>mbufs</var> arranged into a <var class=Vt>mbuf chain</var> (linked list), which allows adding or trimming network headers with little overhead. <p class=Pp>While a developer should not bother with <var class=Vt>mbuf</var> internals without serious reason in order to avoid incompatibilities with future changes, it is useful to understand the general structure of an <var class=Vt>mbuf</var>.</p><p class=Pp>An <var class=Vt>mbuf</var> consists of a variable-sized header and a small internal buffer for data. The total size of an <var class=Vt>mbuf</var>, <code class=Dv>MSIZE</code>, is a constant defined in <code class=In>&lt;<a class=In href=../src/sys/param.h.html>sys/param.h</a>&gt;</code>. The <var class=Vt>mbuf</var> header includes:</p><div class=Bd-indent><dl class=Bl-tag><dt><var class=Va>m_next</var></dt><dd>(<var class=Vt>struct mbuf *</var>) A pointer to the next <var class=Vt>mbuf</var> in the <var class=Vt>mbuf chain</var>.</dd><dt><var class=Va>m_nextpkt</var></dt><dd>(<var class=Vt>struct mbuf *</var>) A pointer to the next <var class=Vt>mbuf chain</var> in the queue.</dd><dt><var class=Va>m_data</var></dt><dd>(<var class=Vt>caddr_t</var>) A pointer to data attached to this <var class=Vt>mbuf</var>.</dd><dt><var class=Va>m_len</var></dt><dd>(<var class=Vt>int</var>) The length of the data.</dd><dt><var class=Va>m_type</var></dt><dd>(<var class=Vt>short</var>) The type of the data.</dd><dt><var class=Va>m_flags</var></dt><dd>(<var class=Vt>int</var>) The <var class=Vt>mbuf</var> flags.</dd></dl></div><p class=Pp>The <var class=Vt>mbuf</var> flag bits are defined as follows:</p><div class="Bd Pp"><pre>
/* mbuf flags */
#define	M_EXT		0x00000001 /* has associated external storage */
#define	M_PKTHDR	0x00000002 /* start of record */
#define	M_EOR		0x00000004 /* end of record */
#define	M_RDONLY	0x00000008 /* associated data marked read-only */
#define	M_PROTO1	0x00001000 /* protocol-specific */
#define	M_PROTO2	0x00002000 /* protocol-specific */
#define	M_PROTO3	0x00004000 /* protocol-specific */
#define	M_PROTO4	0x00008000 /* protocol-specific */
#define	M_PROTO5	0x00010000 /* protocol-specific */
#define	M_PROTO6	0x00020000 /* protocol-specific */
#define	M_PROTO7	0x00040000 /* protocol-specific */
#define	M_PROTO8	0x00080000 /* protocol-specific */
#define	M_PROTO9	0x00100000 /* protocol-specific */
#define	M_PROTO10	0x00200000 /* protocol-specific */
#define	M_PROTO11	0x00400000 /* protocol-specific */
#define	M_PROTO12	0x00800000 /* protocol-specific */

/* mbuf pkthdr flags (also stored in m_flags) */
#define	M_BCAST		0x00000010 /* send/received as link-level broadcast */
#define	M_MCAST		0x00000020 /* send/received as link-level multicast */
</pre></div><p class=Pp>The available <var class=Vt>mbuf</var> types are defined as follows:</p><div class="Bd Pp"><pre>
/* mbuf types */
#define	MT_DATA		1	/* dynamic (data) allocation */
#define	MT_HEADER	MT_DATA	/* packet header */
#define	MT_SONAME	8	/* socket name */
#define	MT_CONTROL	14	/* extra-data protocol message */
#define	MT_OOBDATA	15	/* expedited data */
</pre></div><p class=Pp>The available external buffer types are defined as follows:</p><div class="Bd Pp"><pre>
/* external buffer types */
#define EXT_CLUSTER	1	/* mbuf cluster */
#define EXT_SFBUF	2	/* sendfile(2)'s sf_bufs */
#define EXT_JUMBOP	3	/* jumbo cluster 4096 bytes */
#define EXT_JUMBO9	4	/* jumbo cluster 9216 bytes */
#define EXT_JUMBO16	5	/* jumbo cluster 16184 bytes */
#define EXT_PACKET	6	/* mbuf+cluster from packet zone */
#define EXT_MBUF	7	/* external mbuf reference */
#define EXT_NET_DRV	252	/* custom ext_buf provided by net driver(s) */
#define EXT_MOD_TYPE	253	/* custom module's ext_buf type */
#define EXT_DISPOSABLE	254	/* can throw this buffer away w/page flipping */
#define EXT_EXTREF	255	/* has externally maintained ref_cnt ptr */
</pre></div><p class=Pp>If the <code class=Dv>M_PKTHDR</code> flag is set, a <var class=Vt>struct pkthdr</var><var class=Va>m_pkthdr</var> is added to the <var class=Vt>mbuf</var> header. It contains a pointer to the interface the packet has been received from (<var class=Vt>struct ifnet</var><var class=Va>*rcvif</var>), and the total packet length (<var class=Vt>int</var><var class=Va>len</var>). Optionally, it may also contain an attached list of packet tags (<var class=Vt>struct m_tag</var>). See <a class=Xr href=mbuf_tags.9.html>mbuf_tags(9)</a> for details. Fields used in offloading checksum calculation to the hardware are kept in <var class=Va>m_pkthdr</var> as well. See <a class=Sx href=#HARDWARE_ASSISTED_CHECKSUM_CALCULATION>HARDWARE-ASSISTED CHECKSUM CALCULATION</a> for details.</p><p class=Pp>If small enough, data is stored in the internal data buffer of an <var class=Vt>mbuf</var>. If the data is sufficiently large, another <var class=Vt>mbuf</var> may be added to the <var class=Vt>mbuf chain</var>, or external storage may be associated with the <var class=Vt>mbuf</var>. <code class=Dv>MHLEN</code> bytes of data can fit into an <var class=Vt>mbuf</var> with the <code class=Dv>M_PKTHDR</code> flag set, <code class=Dv>MLEN</code> bytes can otherwise.</p><p class=Pp>If external storage is being associated with an <var class=Vt>mbuf</var>, the <var class=Va>m_ext</var> header is added at the cost of losing the internal data buffer. It includes a pointer to external storage, the size of the storage, a pointer to a function used for freeing the storage, a pointer to an optional argument that can be passed to the function, and a pointer to a reference counter. An <var class=Vt>mbuf</var> using external storage has the <code class=Dv>M_EXT</code> flag set.</p><p class=Pp>The system supplies a macro for allocating the desired external storage buffer, <code class=Dv>MEXTADD</code>.</p><p class=Pp>The allocation and management of the reference counter is handled by the subsystem.</p><p class=Pp>The system also supplies a default type of external storage buffer called an <var class=Vt>mbuf cluster</var>. <var class=Vt>Mbuf clusters</var> can be allocated and configured with the use of the <code class=Dv>MCLGET</code> macro. Each <var class=Vt>mbuf cluster</var> is <code class=Dv>MCLBYTES</code> in size, where MCLBYTES is a machine-dependent constant. The system defines an advisory macro <code class=Dv>MINCLSIZE</code>, which is the smallest amount of data to put into an <var class=Vt>mbuf cluster</var>. It is equal to <code class=Dv>MHLEN</code> plus one. It is typically preferable to store data into the data region of an <var class=Vt>mbuf</var>, if size permits, as opposed to allocating a separate <var class=Vt>mbuf cluster</var> to hold the same data.</p><section class=Ss><h2 class=Ss id=Macros_and_Functions><a class=permalink href=#Macros_and_Functions>Macros and Functions</a></h2> There are numerous predefined macros and functions that provide the developer with common utilities. <dl class="Bl-ohang Bd-indent"><dt><code class=Fn>mtod</code>(<var class=Fa>mbuf</var>, <var class=Fa>type</var>)</dt><dd>Convert an <var class=Fa>mbuf</var> pointer to a data pointer. The macro expands to the data pointer cast to the specified <var class=Fa>type</var>. <b class=Sy>Note</b>: It is advisable to ensure that there is enough contiguous data in <var class=Fa>mbuf</var>. See <code class=Fn>m_pullup</code>() for details.</dd><dt><code class=Fn>MGET</code>(<var class=Fa>mbuf</var>, <var class=Fa>how</var>, <var class=Fa>type</var>)</dt><dd>Allocate an <var class=Vt>mbuf</var> and initialize it to contain internal data. <var class=Fa>mbuf</var> will point to the allocated <var class=Vt>mbuf</var> on success, or be set to <code class=Dv>NULL</code> on failure. The <var class=Fa>how</var> argument is to be set to <code class=Dv>M_WAITOK</code> or <code class=Dv>M_NOWAIT</code>. It specifies whether the caller is willing to block if necessary. A number of other functions and macros related to <var class=Vt>mbufs</var> have the same argument because they may at some point need to allocate new <var class=Vt>mbufs</var>.</dd><dt><code class=Fn>MGETHDR</code>(<var class=Fa>mbuf</var>, <var class=Fa>how</var>, <var class=Fa>type</var>)</dt><dd>Allocate an <var class=Vt>mbuf</var> and initialize it to contain a packet header and internal data. See <code class=Fn>MGET</code>() for details.</dd><dt><code class=Fn>MEXTADD</code>(<var class=Fa>mbuf</var>, <var class=Fa>buf</var>, <var class=Fa>size</var>, <var class=Fa>free</var>, <var class=Fa>opt_arg1</var>, <var class=Fa>opt_arg2</var>, <var class=Fa>flags</var>, <var class=Fa>type</var>)</dt><dd>Associate externally managed data with <var class=Fa>mbuf</var>. Any internal data contained in the mbuf will be discarded, and the <code class=Dv>M_EXT</code> flag will be set. The <var class=Fa>buf</var> and <var class=Fa>size</var> arguments are the address and length, respectively, of the data. The <var class=Fa>free</var> argument points to a function which will be called to free the data when the mbuf is freed; it is only used if <var class=Fa>type</var> is <code class=Dv>EXT_EXTREF</code>. The <var class=Fa>opt_arg1</var> and <var class=Fa>opt_arg2</var> arguments will be saved in <var class=Va>ext_arg1</var> and <var class=Va>ext_arg2</var> fields of the <var class=Va>struct m_ext</var> of the mbuf. The <var class=Fa>flags</var> argument specifies additional <var class=Vt>mbuf</var> flags; it is not necessary to specify <code class=Dv>M_EXT</code>. Finally, the <var class=Fa>type</var> argument specifies the type of external data, which controls how it will be disposed of when the <var class=Vt>mbuf</var> is freed. In most cases, the correct value is <code class=Dv>EXT_EXTREF</code>.</dd><dt><code class=Fn>MCLGET</code>(<var class=Fa>mbuf</var>, <var class=Fa>how</var>)</dt><dd>Allocate and attach an <var class=Vt>mbuf cluster</var> to <var class=Fa>mbuf</var>. On success, a non-zero value returned; otherwise, 0. Historically, consumers would check for success by testing the <code class=Dv>M_EXT</code> flag on the mbuf, but this is now discouraged to avoid unnecessary awareness of the implementation of external storage in protocol stacks and device drivers.</dd><dt><code class=Fn>M_ALIGN</code>(<var class=Fa>mbuf</var>, <var class=Fa>len</var>)</dt><dd>Set the pointer <var class=Fa>mbuf-&gt;m_data</var> to place an object of the size <var class=Fa>len</var> at the end of the internal data area of <var class=Fa>mbuf</var>, long word aligned. Applicable only if <var class=Fa>mbuf</var> is newly allocated with <code class=Fn>MGET</code>() or <code class=Fn>m_get</code>().</dd><dt><code class=Fn>MH_ALIGN</code>(<var class=Fa>mbuf</var>, <var class=Fa>len</var>)</dt><dd>Serves the same purpose as <code class=Fn>M_ALIGN</code>() does, but only for <var class=Fa>mbuf</var> newly allocated with <code class=Fn>MGETHDR</code>() or <code class=Fn>m_gethdr</code>(), or initialized by <code class=Fn>m_dup_pkthdr</code>() or <code class=Fn>m_move_pkthdr</code>().</dd><dt><code class=Fn>m_align</code>(<var class=Fa>mbuf</var>, <var class=Fa>len</var>)</dt><dd>Services the same purpose as <code class=Fn>M_ALIGN</code>() but handles any type of mbuf.</dd><dt><code class=Fn>M_LEADINGSPACE</code>(<var class=Fa>mbuf</var>)</dt><dd>Returns the number of bytes available before the beginning of data in <var class=Fa>mbuf</var>.</dd><dt><code class=Fn>M_TRAILINGSPACE</code>(<var class=Fa>mbuf</var>)</dt><dd>Returns the number of bytes available after the end of data in <var class=Fa>mbuf</var>.</dd><dt><code class=Fn>M_PREPEND</code>(<var class=Fa>mbuf</var>, <var class=Fa>len</var>, <var class=Fa>how</var>)</dt><dd>This macro operates on an <var class=Vt>mbuf chain</var>. It is an optimized wrapper for <code class=Fn>m_prepend</code>() that can make use of possible empty space before data (e.g. left after trimming of a link-layer header). The new <var class=Vt>mbuf chain</var> pointer or <code class=Dv>NULL</code> is in <var class=Fa>mbuf</var> after the call.</dd><dt><code class=Fn>M_MOVE_PKTHDR</code>(<var class=Fa>to</var>, <var class=Fa>from</var>)</dt><dd>Using this macro is equivalent to calling <code class=Fn>m_move_pkthdr</code>(<var class=Fa>to</var>, <var class=Fa>from</var>).</dd><dt><code class=Fn>M_WRITABLE</code>(<var class=Fa>mbuf</var>)</dt><dd>This macro will evaluate true if <var class=Fa>mbuf</var> is not marked <code class=Dv>M_RDONLY</code> and if either <var class=Fa>mbuf</var> does not contain external storage or, if it does, then if the reference count of the storage is not greater than 1. The <code class=Dv>M_RDONLY</code> flag can be set in <var class=Fa>mbuf-&gt;m_flags</var>. This can be achieved during setup of the external storage, by passing the <code class=Dv>M_RDONLY</code> bit as a <var class=Fa>flags</var> argument to the <code class=Fn>MEXTADD</code>() macro, or can be directly set in individual <var class=Vt>mbufs</var>.</dd><dt><code class=Fn>MCHTYPE</code>(<var class=Fa>mbuf</var>, <var class=Fa>type</var>)</dt><dd>Change the type of <var class=Fa>mbuf</var> to <var class=Fa>type</var>. This is a relatively expensive operation and should be avoided.</dd></dl><p class=Pp>The functions are:</p><dl class="Bl-ohang Bd-indent"><dt><code class=Fn>m_get</code>(<var class=Fa>how</var>, <var class=Fa>type</var>)</dt><dd>A function version of <code class=Fn>MGET</code>() for non-critical paths.</dd><dt><code class=Fn>m_get2</code>(<var class=Fa>size</var>, <var class=Fa>how</var>, <var class=Fa>type</var>, <var class=Fa>flags</var>)</dt><dd>Allocate an <var class=Vt>mbuf</var> with enough space to hold specified amount of data.</dd><dt><code class=Fn>m_getm</code>(<var class=Fa>orig</var>, <var class=Fa>len</var>, <var class=Fa>how</var>, <var class=Fa>type</var>)</dt><dd>Allocate <var class=Fa>len</var> bytes worth of <var class=Vt>mbufs</var> and <var class=Vt>mbuf clusters</var> if necessary and append the resulting allocated <var class=Vt>mbuf chain</var> to the <var class=Vt>mbuf chain</var><var class=Fa>orig</var>, if it is <span class=No>non-</span><code class=Dv>NULL</code>. If the allocation fails at any point, free whatever was allocated and return <code class=Dv>NULL</code>. If <var class=Fa>orig</var> is <span class=No>non-</span><code class=Dv>NULL</code>, it will not be freed. It is possible to use <code class=Fn>m_getm</code>() to either append <var class=Fa>len</var> bytes to an existing <var class=Vt>mbuf</var> or <var class=Vt>mbuf chain</var> (for example, one which may be sitting in a pre-allocated ring) or to simply perform an all-or-nothing <var class=Vt>mbuf</var> and <var class=Vt>mbuf cluster</var> allocation.</dd><dt><code class=Fn>m_gethdr</code>(<var class=Fa>how</var>, <var class=Fa>type</var>)</dt><dd>A function version of <code class=Fn>MGETHDR</code>() for non-critical paths.</dd><dt><code class=Fn>m_getcl</code>(<var class=Fa>how</var>, <var class=Fa>type</var>, <var class=Fa>flags</var>)</dt><dd>Fetch an <var class=Vt>mbuf</var> with a <var class=Vt>mbuf cluster</var> attached to it. If one of the allocations fails, the entire allocation fails. This routine is the preferred way of fetching both the <var class=Vt>mbuf</var> and <var class=Vt>mbuf cluster</var> together, as it avoids having to unlock/relock between allocations. Returns <code class=Dv>NULL</code> on failure.</dd><dt><code class=Fn>m_getjcl</code>(<var class=Fa>how</var>, <var class=Fa>type</var>, <var class=Fa>flags</var>, <var class=Fa>size</var>)</dt><dd>This is like <code class=Fn>m_getcl</code>() but it the size of the cluster allocated will be large enough for <var class=Fa>size</var> bytes.</dd><dt><code class=Fn>m_free</code>(<var class=Fa>mbuf</var>)</dt><dd>Frees <var class=Vt>mbuf</var>. Returns <var class=Va>m_next</var> of the freed <var class=Vt>mbuf</var>.</dd></dl><p class=Pp>The functions below operate on <var class=Vt>mbuf chains</var>.</p><dl class="Bl-ohang Bd-indent"><dt><code class=Fn>m_freem</code>(<var class=Fa>mbuf</var>)</dt><dd>Free an entire <var class=Vt>mbuf chain</var>, including any external storage.</dd><dt><code class=Fn>m_adj</code>(<var class=Fa>mbuf</var>, <var class=Fa>len</var>)</dt><dd>Trim <var class=Fa>len</var> bytes from the head of an <var class=Vt>mbuf chain</var> if <var class=Fa>len</var> is positive, from the tail otherwise.</dd><dt><code class=Fn>m_append</code>(<var class=Fa>mbuf</var>, <var class=Fa>len</var>, <var class=Fa>cp</var>)</dt><dd>Append <var class=Vt>len</var> bytes of data <var class=Vt>cp</var> to the <var class=Vt>mbuf chain</var>. Extend the mbuf chain if the new data does not fit in existing space.</dd><dt><code class=Fn>m_prepend</code>(<var class=Fa>mbuf</var>, <var class=Fa>len</var>, <var class=Fa>how</var>)</dt><dd>Allocate a new <var class=Vt>mbuf</var> and prepend it to the <var class=Vt>mbuf chain</var>, handle <code class=Dv>M_PKTHDR</code> properly. <b class=Sy>Note</b>: It does not allocate any <var class=Vt>mbuf clusters</var>, so <var class=Fa>len</var> must be less than <code class=Dv>MLEN</code> or <code class=Dv>MHLEN</code>, depending on the <code class=Dv>M_PKTHDR</code> flag setting.</dd><dt><code class=Fn>m_copyup</code>(<var class=Fa>mbuf</var>, <var class=Fa>len</var>, <var class=Fa>dstoff</var>)</dt><dd>Similar to <code class=Fn>m_pullup</code>() but copies <var class=Fa>len</var> bytes of data into a new mbuf at <var class=Fa>dstoff</var> bytes into the mbuf. The <var class=Fa>dstoff</var> argument aligns the data and leaves room for a link layer header. Returns the new <var class=Vt>mbuf chain</var> on success, and frees the <var class=Vt>mbuf chain</var> and returns <code class=Dv>NULL</code> on failure. <b class=Sy>Note</b>: The function does not allocate <var class=Vt>mbuf clusters</var>, so <var class=Fa>len + dstoff</var> must be less than <code class=Dv>MHLEN</code>.</dd><dt><code class=Fn>m_pullup</code>(<var class=Fa>mbuf</var>, <var class=Fa>len</var>)</dt><dd>Arrange that the first <var class=Fa>len</var> bytes of an <var class=Vt>mbuf chain</var> are contiguous and lay in the data area of <var class=Fa>mbuf</var>, so they are accessible with <code class=Fn>mtod</code>(<var class=Fa>mbuf</var>, <var class=Fa>type</var>). It is important to remember that this may involve reallocating some mbufs and moving data so all pointers referencing data within the old mbuf chain must be recalculated or made invalid. Return the new <var class=Vt>mbuf chain</var> on success, <code class=Dv>NULL</code> on failure (the <var class=Vt>mbuf chain</var> is freed in this case). <b class=Sy>Note</b>: It does not allocate any <var class=Vt>mbuf clusters</var>, so <var class=Fa>len</var> must be less than or equal to <code class=Dv>MHLEN</code>.</dd><dt><code class=Fn>m_pulldown</code>(<var class=Fa>mbuf</var>, <var class=Fa>offset</var>, <var class=Fa>len</var>, <var class=Fa>offsetp</var>)</dt><dd>Arrange that <var class=Fa>len</var> bytes between <var class=Fa>offset</var> and <var class=Fa>offset + len</var> in the <var class=Vt>mbuf chain</var> are contiguous and lay in the data area of <var class=Fa>mbuf</var>, so they are accessible with <code class=Fn>mtod</code>(<var class=Fa>mbuf</var>, <var class=Fa>type</var>). <var class=Fa>len</var> must be smaller than, or equal to, the size of an <var class=Vt>mbuf cluster</var>. Return a pointer to an intermediate <var class=Vt>mbuf</var> in the chain containing the requested region; the offset in the data region of the <var class=Vt>mbuf chain</var> to the data contained in the returned mbuf is stored in <var class=Fa>*offsetp</var>. If <var class=Fa>offsetp</var> is NULL, the region may be accessed using <code class=Fn>mtod</code>(<var class=Fa>mbuf</var>, <var class=Fa>type</var>). If <var class=Fa>offsetp</var> is non-NULL, the region may be accessed using <code class=Fn>mtod</code>(<var class=Fa>mbuf</var>, <var class=Fa>uint8_t</var>) + *offsetp. The region of the mbuf chain between its beginning and <var class=Fa>offset</var> is not modified, therefore it is safe to hold pointers to data within this region before calling <code class=Fn>m_pulldown</code>().</dd><dt><code class=Fn>m_copym</code>(<var class=Fa>mbuf</var>, <var class=Fa>offset</var>, <var class=Fa>len</var>, <var class=Fa>how</var>)</dt><dd>Make a copy of an <var class=Vt>mbuf chain</var> starting <var class=Fa>offset</var> bytes from the beginning, continuing for <var class=Fa>len</var> bytes. If <var class=Fa>len</var> is <code class=Dv>M_COPYALL</code>, copy to the end of the <var class=Vt>mbuf chain</var>. <b class=Sy>Note</b>: The copy is read-only, because the <var class=Vt>mbuf clusters</var> are not copied, only their reference counts are incremented.</dd><dt><code class=Fn>m_copypacket</code>(<var class=Fa>mbuf</var>, <var class=Fa>how</var>)</dt><dd>Copy an entire packet including header, which must be present. This is an optimized version of the common case <code class=Fn>m_copym</code>(<var class=Fa>mbuf</var>, <var class=Fa>0</var>, <var class=Fa>M_COPYALL</var>, <var class=Fa>how</var>). <b class=Sy>Note</b>: the copy is read-only, because the <var class=Vt>mbuf clusters</var> are not copied, only their reference counts are incremented.</dd><dt><code class=Fn>m_dup</code>(<var class=Fa>mbuf</var>, <var class=Fa>how</var>)</dt><dd>Copy a packet header <var class=Vt>mbuf chain</var> into a completely new <var class=Vt>mbuf chain</var>, including copying any <var class=Vt>mbuf clusters</var>. Use this instead of <code class=Fn>m_copypacket</code>() when you need a writable copy of an <var class=Vt>mbuf chain</var>.</dd><dt><code class=Fn>m_copydata</code>(<var class=Fa>mbuf</var>, <var class=Fa>offset</var>, <var class=Fa>len</var>, <var class=Fa>buf</var>)</dt><dd>Copy data from an <var class=Vt>mbuf chain</var> starting <var class=Fa>off</var> bytes from the beginning, continuing for <var class=Fa>len</var> bytes, into the indicated buffer <var class=Fa>buf</var>.</dd><dt><code class=Fn>m_copyback</code>(<var class=Fa>mbuf</var>, <var class=Fa>offset</var>, <var class=Fa>len</var>, <var class=Fa>buf</var>)</dt><dd>Copy <var class=Fa>len</var> bytes from the buffer <var class=Fa>buf</var> back into the indicated <var class=Vt>mbuf chain</var>, starting at <var class=Fa>offset</var> bytes from the beginning of the <var class=Vt>mbuf chain</var>, extending the <var class=Vt>mbuf chain</var> if necessary. <b class=Sy>Note</b>: It does not allocate any <var class=Vt>mbuf clusters</var>, just adds <var class=Vt>mbufs</var> to the <var class=Vt>mbuf chain</var>. It is safe to set <var class=Fa>offset</var> beyond the current <var class=Vt>mbuf chain</var> end: zeroed <var class=Vt>mbufs</var> will be allocated to fill the space.</dd><dt><code class=Fn>m_length</code>(<var class=Fa>mbuf</var>, <var class=Fa>last</var>)</dt><dd>Return the length of the <var class=Vt>mbuf chain</var>, and optionally a pointer to the last <var class=Vt>mbuf</var>.</dd><dt><code class=Fn>m_dup_pkthdr</code>(<var class=Fa>to</var>, <var class=Fa>from</var>, <var class=Fa>how</var>)</dt><dd>Upon the function's completion, the <var class=Vt>mbuf</var><var class=Fa>to</var> will contain an identical copy of <var class=Fa>from-&gt;m_pkthdr</var> and the per-packet attributes found in the <var class=Vt>mbuf chain</var><var class=Fa>from</var>. The <var class=Vt>mbuf</var><var class=Fa>from</var> must have the flag <code class=Dv>M_PKTHDR</code> initially set, and <var class=Fa>to</var> must be empty on entry.</dd><dt><code class=Fn>m_move_pkthdr</code>(<var class=Fa>to</var>, <var class=Fa>from</var>)</dt><dd>Move <var class=Va>m_pkthdr</var> and the per-packet attributes from the <var class=Vt>mbuf chain</var><var class=Fa>from</var> to the <var class=Vt>mbuf</var><var class=Fa>to</var>. The <var class=Vt>mbuf</var><var class=Fa>from</var> must have the flag <code class=Dv>M_PKTHDR</code> initially set, and <var class=Fa>to</var> must be empty on entry. Upon the function's completion, <var class=Fa>from</var> will have the flag <code class=Dv>M_PKTHDR</code> and the per-packet attributes cleared.</dd><dt><code class=Fn>m_fixhdr</code>(<var class=Fa>mbuf</var>)</dt><dd>Set the packet-header length to the length of the <var class=Vt>mbuf chain</var>.</dd><dt><code class=Fn>m_devget</code>(<var class=Fa>buf</var>, <var class=Fa>len</var>, <var class=Fa>offset</var>, <var class=Fa>ifp</var>, <var class=Fa>copy</var>)</dt><dd>Copy data from a device local memory pointed to by <var class=Fa>buf</var> to an <var class=Vt>mbuf chain</var>. The copy is done using a specified copy routine <var class=Fa>copy</var>, or <code class=Fn>bcopy</code>() if <var class=Fa>copy</var> is <code class=Dv>NULL</code>.</dd><dt><code class=Fn>m_cat</code>(<var class=Fa>m</var>, <var class=Fa>n</var>)</dt><dd>Concatenate <var class=Fa>n</var> to <var class=Fa>m</var>. Both <var class=Vt>mbuf chains</var> must be of the same type. <var class=Fa>n</var> is not guaranteed to be valid after <code class=Fn>m_cat</code>() returns. <code class=Fn>m_cat</code>() does not update any packet header fields or free mbuf tags.</dd><dt><code class=Fn>m_catpkt</code>(<var class=Fa>m</var>, <var class=Fa>n</var>)</dt><dd>A variant of <code class=Fn>m_cat</code>() that operates on packets. Both <var class=Fa>m</var> and <var class=Fa>n</var> must contain packet headers. <var class=Fa>n</var> is not guaranteed to be valid after <code class=Fn>m_catpkt</code>() returns.</dd><dt><code class=Fn>m_split</code>(<var class=Fa>mbuf</var>, <var class=Fa>len</var>, <var class=Fa>how</var>)</dt><dd>Partition an <var class=Vt>mbuf chain</var> in two pieces, returning the tail: all but the first <var class=Fa>len</var> bytes. In case of failure, it returns <code class=Dv>NULL</code> and attempts to restore the <var class=Vt>mbuf chain</var> to its original state.</dd><dt><code class=Fn>m_apply</code>(<var class=Fa>mbuf</var>, <var class=Fa>off</var>, <var class=Fa>len</var>, <var class=Fa>f</var>, <var class=Fa>arg</var>)</dt><dd>Apply a function to an <var class=Vt>mbuf chain</var>, at offset <var class=Fa>off</var>, for length <var class=Fa>len</var> bytes. Typically used to avoid calls to <code class=Fn>m_pullup</code>() which would otherwise be unnecessary or undesirable. <var class=Fa>arg</var> is a convenience argument which is passed to the callback function <var class=Fa>f</var>. <p class=Pp>Each time <code class=Fn>f</code>() is called, it will be passed <var class=Fa>arg</var>, a pointer to the <var class=Fa>data</var> in the current mbuf, and the length <var class=Fa>len</var> of the data in this mbuf to which the function should be applied.</p><p class=Pp>The function should return zero to indicate success; otherwise, if an error is indicated, then <code class=Fn>m_apply</code>() will return the error and stop iterating through the <var class=Vt>mbuf chain</var>.</p></dd><dt><code class=Fn>m_getptr</code>(<var class=Fa>mbuf</var>, <var class=Fa>loc</var>, <var class=Fa>off</var>)</dt><dd>Return a pointer to the mbuf containing the data located at <var class=Fa>loc</var> bytes from the beginning of the <var class=Vt>mbuf chain</var>. The corresponding offset into the mbuf will be stored in <var class=Fa>*off</var>.</dd><dt><code class=Fn>m_defrag</code>(<var class=Fa>m0</var>, <var class=Fa>how</var>)</dt><dd>Defragment an mbuf chain, returning the shortest possible chain of mbufs and clusters. If allocation fails and this can not be completed, <code class=Dv>NULL</code> will be returned and the original chain will be unchanged. Upon success, the original chain will be freed and the new chain will be returned. <var class=Fa>how</var> should be either <code class=Dv>M_WAITOK</code> or <code class=Dv>M_NOWAIT</code>, depending on the caller's preference. <p class=Pp>This function is especially useful in network drivers, where certain long mbuf chains must be shortened before being added to TX descriptor lists.</p></dd><dt><code class=Fn>m_collapse</code>(<var class=Fa>m0</var>, <var class=Fa>how</var>, <var class=Fa>maxfrags</var>)</dt><dd>Defragment an mbuf chain, returning a chain of at most <var class=Fa>maxfrags</var> mbufs and clusters. If allocation fails or the chain cannot be collapsed as requested, <code class=Dv>NULL</code> will be returned, with the original chain possibly modified. As with <code class=Fn>m_defrag</code>(), <var class=Fa>how</var> should be one of <code class=Dv>M_WAITOK</code> or <code class=Dv>M_NOWAIT</code>.</dd><dt><code class=Fn>m_unshare</code>(<var class=Fa>m0</var>, <var class=Fa>how</var>)</dt><dd>Create a version of the specified mbuf chain whose contents can be safely modified without affecting other users. If allocation fails and this operation can not be completed, <code class=Dv>NULL</code> will be returned. The original mbuf chain is always reclaimed and the reference count of any shared mbuf clusters is decremented. <var class=Fa>how</var> should be either <code class=Dv>M_WAITOK</code> or <code class=Dv>M_NOWAIT</code>, depending on the caller's preference. As a side-effect of this process the returned mbuf chain may be compacted. <p class=Pp>This function is especially useful in the transmit path of network code, when data must be encrypted or otherwise altered prior to transmission.</p></dd></dl></section></section><section class=Sh><h2 class=Sh id=HARDWARE_ASSISTED_CHECKSUM_CALCULATION><a class=permalink href=#HARDWARE_ASSISTED_CHECKSUM_CALCULATION>HARDWARE-ASSISTED CHECKSUM CALCULATION</a></h2> This section currently applies to TCP/IP only. In order to save the host CPU resources, computing checksums is offloaded to the network interface hardware if possible. The <var class=Va>m_pkthdr</var> member of the leading <var class=Vt>mbuf</var> of a packet contains two fields used for that purpose, <var class=Vt>int</var><var class=Va>csum_flags</var> and <var class=Vt>int</var><var class=Va>csum_data</var>. The meaning of those fields depends on the direction a packet flows in, and on whether the packet is fragmented. Henceforth, <var class=Va>csum_flags</var> or <var class=Va>csum_data</var> of a packet will denote the corresponding field of the <var class=Va>m_pkthdr</var> member of the leading <var class=Vt>mbuf</var> in the <var class=Vt>mbuf chain</var> containing the packet. <p class=Pp>On output, checksum offloading is attempted after the outgoing interface has been determined for a packet. The interface-specific field <var class=Va>ifnet.if_data.ifi_hwassist</var> (see <a class=Xr href=ifnet.9.html>ifnet(9)</a>) is consulted for the capabilities of the interface to assist in computing checksums. The <var class=Va>csum_flags</var> field of the packet header is set to indicate which actions the interface is supposed to perform on it. The actions unsupported by the network interface are done in the software prior to passing the packet down to the interface driver; such actions will never be requested through <var class=Va>csum_flags</var>.</p><p class=Pp>The flags demanding a particular action from an interface are as follows:</p><div class=Bd-indent><dl class=Bl-tag><dt><a class=permalink href=#CSUM_IP><code class=Dv id=CSUM_IP>CSUM_IP</code></a></dt><dd>The IP header checksum is to be computed and stored in the corresponding field of the packet. The hardware is expected to know the format of an IP header to determine the offset of the IP checksum field.</dd><dt><a class=permalink href=#CSUM_TCP><code class=Dv id=CSUM_TCP>CSUM_TCP</code></a></dt><dd>The TCP checksum is to be computed. (See below.)</dd><dt><a class=permalink href=#CSUM_UDP><code class=Dv id=CSUM_UDP>CSUM_UDP</code></a></dt><dd>The UDP checksum is to be computed. (See below.)</dd></dl></div><p class=Pp>Should a TCP or UDP checksum be offloaded to the hardware, the field <var class=Va>csum_data</var> will contain the byte offset of the checksum field relative to the end of the IP header. In this case, the checksum field will be initially set by the TCP/IP module to the checksum of the pseudo header defined by the TCP and UDP specifications.</p><p class=Pp>On input, an interface indicates the actions it has performed on a packet by setting one or more of the following flags in <var class=Va>csum_flags</var> associated with the packet:</p><div class=Bd-indent><dl class=Bl-tag><dt><a class=permalink href=#CSUM_IP_CHECKED><code class=Dv id=CSUM_IP_CHECKED>CSUM_IP_CHECKED</code></a></dt><dd>The IP header checksum has been computed.</dd><dt><a class=permalink href=#CSUM_IP_VALID><code class=Dv id=CSUM_IP_VALID>CSUM_IP_VALID</code></a></dt><dd>The IP header has a valid checksum. This flag can appear only in combination with <code class=Dv>CSUM_IP_CHECKED</code>.</dd><dt><a class=permalink href=#CSUM_DATA_VALID><code class=Dv id=CSUM_DATA_VALID>CSUM_DATA_VALID</code></a></dt><dd>The checksum of the data portion of the IP packet has been computed and stored in the field <var class=Va>csum_data</var> in network byte order.</dd><dt><a class=permalink href=#CSUM_PSEUDO_HDR><code class=Dv id=CSUM_PSEUDO_HDR>CSUM_PSEUDO_HDR</code></a></dt><dd>Can be set only along with <code class=Dv>CSUM_DATA_VALID</code> to indicate that the IP data checksum found in <var class=Va>csum_data</var> allows for the pseudo header defined by the TCP and UDP specifications. Otherwise the checksum of the pseudo header must be calculated by the host CPU and added to <var class=Va>csum_data</var> to obtain the final checksum to be used for TCP or UDP validation purposes.</dd></dl></div><p class=Pp>If a particular network interface just indicates success or failure of TCP or UDP checksum validation without returning the exact value of the checksum to the host CPU, its driver can mark <code class=Dv>CSUM_DATA_VALID</code> and <code class=Dv>CSUM_PSEUDO_HDR</code> in <var class=Va>csum_flags</var>, and set <var class=Va>csum_data</var> to <code class=Li>0xFFFF</code> hexadecimal to indicate a valid checksum. It is a peculiarity of the algorithm used that the Internet checksum calculated over any valid packet will be <code class=Li>0xFFFF</code> as long as the original checksum field is included.</p></section><section class=Sh><h2 class=Sh id=STRESS_TESTING><a class=permalink href=#STRESS_TESTING>STRESS TESTING</a></h2> When running a kernel compiled with the option <code class=Dv>MBUF_STRESS_TEST</code>, the following <a class=Xr href=sysctl.8.html>sysctl(8)</a>-controlled options may be used to create various failure/extreme cases for testing of network drivers and other parts of the kernel that rely on <var class=Vt>mbufs</var>. <dl class=Bl-tag><dt><var class=Va>net.inet.ip.mbuf_frag_size</var></dt><dd>Causes <code class=Fn>ip_output</code>() to fragment outgoing <var class=Vt>mbuf chains</var> into fragments of the specified size. Setting this variable to 1 is an excellent way to test the long <var class=Vt>mbuf chain</var> handling ability of network drivers.</dd><dt><var class=Va>kern.ipc.m_defragrandomfailures</var></dt><dd>Causes the function <code class=Fn>m_defrag</code>() to randomly fail, returning <code class=Dv>NULL</code>. Any piece of code which uses <code class=Fn>m_defrag</code>() should be tested with this feature.</dd></dl></section><section class=Sh><h2 class=Sh id=RETURN_VALUES><a class=permalink href=#RETURN_VALUES>RETURN VALUES</a></h2> See above. </section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=ifnet.9.html>ifnet(9)</a>, <a class=Xr href=mbuf_tags.9.html>mbuf_tags(9)</a></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2><var class=Vt>Mbufs</var> appeared in an early version of <span class=Ux>BSD</span>. Besides being used for network packets, they were used to store various dynamic structures, such as routing table entries, interface addresses, protocol control blocks, etc. In more recent <span class=Ux>FreeBSD</span> use of <var class=Vt>mbufs</var> is almost entirely limited to packet storage, with <a class=Xr href=uma.9.html>uma(9)</a> zones being used directly to store other network-related memory. <p class=Pp>Historically, the <var class=Vt>mbuf</var> allocator has been a special-purpose memory allocator able to run in interrupt contexts and allocating from a special kernel address space map. As of <span class=Ux>FreeBSD 5.3</span>, the <var class=Vt>mbuf</var> allocator is a wrapper around <a class=Xr href=uma.9.html>uma(9)</a>, allowing caching of <var class=Vt>mbufs</var>, clusters, and <var class=Vt>mbuf</var> + cluster pairs in per-CPU caches, as well as bringing other benefits of slab allocation.</p></section><section class=Sh><h2 class=Sh id=AUTHORS><a class=permalink href=#AUTHORS>AUTHORS</a></h2> The original <code class=Nm>mbuf</code> manual page was written by <span class=An>Yar Tikhiy</span>. The <a class=Xr href=uma.9.html>uma(9)</a><var class=Vt>mbuf</var> allocator was written by <br><span class=An>Bosko Milekic</span>. </section></div><table class=foot><tr><td class=foot-date>September 27, 2017</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>