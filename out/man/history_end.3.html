<!DOCTYPE html>
<html><head><meta charset=utf-8><title>history_end(3)</title><keywords content=man,history_end></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>history_end(3)</h1><table class=head><tr><td class=head-ltitle>EDITLINE(3)</td><td class=head-vol>FreeBSD Library Functions Manual</td><td class=head-rtitle>EDITLINE(3)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>editline</code>, <code class=Nm>el_init</code>, <code class=Nm>el_init_fd</code>, <code class=Nm>el_end</code>, <code class=Nm>el_reset</code>, <code class=Nm>el_gets</code>, <code class=Nm>el_wgets</code>, <code class=Nm>el_getc</code>, <code class=Nm>el_wgetc</code>, <code class=Nm>el_push</code>, <code class=Nm>el_wpush</code>, <code class=Nm>el_parse</code>, <code class=Nm>el_wparse</code>, <code class=Nm>el_set</code>, <code class=Nm>el_wset</code>, <code class=Nm>el_get</code>, <code class=Nm>el_wget</code>, <code class=Nm>el_source</code>, <code class=Nm>el_resize</code>, <code class=Nm>el_cursor</code>, <code class=Nm>el_line</code>, <code class=Nm>el_wline</code>, <code class=Nm>el_insertstr</code>, <code class=Nm>el_winsertstr</code>, <code class=Nm>el_deletestr</code>, <code class=Nm>el_wdeletestr</code>, <code class=Nm>history_init</code>, <code class=Nm>history_winit</code>, <code class=Nm>history_end</code>, <code class=Nm>history_wend</code>, <code class=Nm>history</code>, <code class=Nm>history_w</code>, <code class=Nm>tok_init</code>, <code class=Nm>tok_winit</code>, <code class=Nm>tok_end</code>, <code class=Nm>tok_wend</code>, <code class=Nm>tok_reset</code>, <code class=Nm>tok_wreset</code>, <code class=Nm>tok_line</code>, <code class=Nm>tok_wline</code>, <code class=Nm>tok_str</code>, <code class=Nm>tok_wstr</code> — <div class=Nd>line editor, history and tokenization functions</div></section><section class=Sh><h2 class=Sh id=LIBRARY><a class=permalink href=#LIBRARY>LIBRARY</a></h2><span class=Lb>Command Line Editor Library (libedit, -ledit)</span></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/histedit.h.html>histedit.h</a>&gt;</code><p class=Pp><var class=Ft>EditLine *</var><br><code class=Fn>el_init</code>(<var class=Fa style="white-space: nowrap;">const char *prog</var>, <var class=Fa style="white-space: nowrap;">FILE *fin</var>, <var class=Fa style="white-space: nowrap;">FILE *fout</var>, <var class=Fa style="white-space: nowrap;">FILE *ferr</var>);</p><p class=Pp><var class=Ft>EditLine *</var><br><code class=Fn>el_init_fd</code>(<var class=Fa style="white-space: nowrap;">const char *prog</var>, <var class=Fa style="white-space: nowrap;">FILE *fin</var>, <var class=Fa style="white-space: nowrap;">FILE *fout</var>, <var class=Fa style="white-space: nowrap;">FILE *ferr</var>, <var class=Fa style="white-space: nowrap;">int fdin</var>, <var class=Fa style="white-space: nowrap;">int fdout</var>, <var class=Fa style="white-space: nowrap;">int fderr</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>el_end</code>(<var class=Fa style="white-space: nowrap;">EditLine *e</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>el_reset</code>(<var class=Fa style="white-space: nowrap;">EditLine *e</var>);</p><p class=Pp><var class=Ft>const char *</var><br><code class=Fn>el_gets</code>(<var class=Fa style="white-space: nowrap;">EditLine *e</var>, <var class=Fa style="white-space: nowrap;">int *count</var>);</p><p class=Pp><var class=Ft>const wchar_t *</var><br><code class=Fn>el_wgets</code>(<var class=Fa style="white-space: nowrap;">EditLine *e</var>, <var class=Fa style="white-space: nowrap;">int *count</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>el_getc</code>(<var class=Fa style="white-space: nowrap;">EditLine *e</var>, <var class=Fa style="white-space: nowrap;">char *ch</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>el_wgetc</code>(<var class=Fa style="white-space: nowrap;">EditLine *e</var>, <var class=Fa style="white-space: nowrap;">wchar_t *wc</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>el_push</code>(<var class=Fa style="white-space: nowrap;">EditLine *e</var>, <var class=Fa style="white-space: nowrap;">const char *mbs</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>el_wpush</code>(<var class=Fa style="white-space: nowrap;">EditLine *e</var>, <var class=Fa style="white-space: nowrap;">const wchar_t *wcs</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>el_parse</code>(<var class=Fa style="white-space: nowrap;">EditLine *e</var>, <var class=Fa style="white-space: nowrap;">int argc</var>, <var class=Fa style="white-space: nowrap;">const char *argv[]</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>el_wparse</code>(<var class=Fa style="white-space: nowrap;">EditLine *e</var>, <var class=Fa style="white-space: nowrap;">int argc</var>, <var class=Fa style="white-space: nowrap;">const wchar_t *argv[]</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>el_set</code>(<var class=Fa style="white-space: nowrap;">EditLine *e</var>, <var class=Fa style="white-space: nowrap;">int op</var>, <var class=Fa style="white-space: nowrap;">...</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>el_wset</code>(<var class=Fa style="white-space: nowrap;">EditLine *e</var>, <var class=Fa style="white-space: nowrap;">int op</var>, <var class=Fa style="white-space: nowrap;">...</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>el_get</code>(<var class=Fa style="white-space: nowrap;">EditLine *e</var>, <var class=Fa style="white-space: nowrap;">int op</var>, <var class=Fa style="white-space: nowrap;">...</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>el_wget</code>(<var class=Fa style="white-space: nowrap;">EditLine *e</var>, <var class=Fa style="white-space: nowrap;">int op</var>, <var class=Fa style="white-space: nowrap;">...</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>el_source</code>(<var class=Fa style="white-space: nowrap;">EditLine *e</var>, <var class=Fa style="white-space: nowrap;">const char *file</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>el_resize</code>(<var class=Fa style="white-space: nowrap;">EditLine *e</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>el_cursor</code>(<var class=Fa style="white-space: nowrap;">EditLine *e</var>, <var class=Fa style="white-space: nowrap;">int count</var>);</p><p class=Pp><var class=Ft>const LineInfo *</var><br><code class=Fn>el_line</code>(<var class=Fa style="white-space: nowrap;">EditLine *e</var>);</p><p class=Pp><var class=Ft>const LineInfoW *</var><br><code class=Fn>el_wline</code>(<var class=Fa style="white-space: nowrap;">EditLine *e</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>el_insertstr</code>(<var class=Fa style="white-space: nowrap;">EditLine *e</var>, <var class=Fa style="white-space: nowrap;">const char *str</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>el_winsertstr</code>(<var class=Fa style="white-space: nowrap;">EditLine *e</var>, <var class=Fa style="white-space: nowrap;">const wchar_t *str</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>el_deletestr</code>(<var class=Fa style="white-space: nowrap;">EditLine *e</var>, <var class=Fa style="white-space: nowrap;">int count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>el_wdeletestr</code>(<var class=Fa style="white-space: nowrap;">EditLine *e</var>, <var class=Fa style="white-space: nowrap;">int count</var>);</p><p class=Pp><var class=Ft>History *</var><br><code class=Fn>history_init</code>(<var class=Fa style="white-space: nowrap;">void</var>);</p><p class=Pp><var class=Ft>HistoryW *</var><br><code class=Fn>history_winit</code>(<var class=Fa style="white-space: nowrap;">void</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>history_end</code>(<var class=Fa style="white-space: nowrap;">History *h</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>history_wend</code>(<var class=Fa style="white-space: nowrap;">HistoryW *h</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>history</code>(<var class=Fa style="white-space: nowrap;">History *h</var>, <var class=Fa style="white-space: nowrap;">HistEvent *ev</var>, <var class=Fa style="white-space: nowrap;">int op</var>, <var class=Fa style="white-space: nowrap;">...</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>history_w</code>(<var class=Fa style="white-space: nowrap;">HistoryW *h</var>, <var class=Fa style="white-space: nowrap;">HistEventW *ev</var>, <var class=Fa style="white-space: nowrap;">int op</var>, <var class=Fa style="white-space: nowrap;">...</var>);</p><p class=Pp><var class=Ft>Tokenizer *</var><br><code class=Fn>tok_init</code>(<var class=Fa style="white-space: nowrap;">const char *IFS</var>);</p><p class=Pp><var class=Ft>TokenizerW *</var><br><code class=Fn>tok_winit</code>(<var class=Fa style="white-space: nowrap;">const wchar_t *IFS</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>tok_end</code>(<var class=Fa style="white-space: nowrap;">Tokenizer *t</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>tok_wend</code>(<var class=Fa style="white-space: nowrap;">TokenizerW *t</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>tok_reset</code>(<var class=Fa style="white-space: nowrap;">Tokenizer *t</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>tok_wreset</code>(<var class=Fa style="white-space: nowrap;">TokenizerW *t</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>tok_line</code>(<var class=Fa style="white-space: nowrap;">Tokenizer *t</var>, <var class=Fa style="white-space: nowrap;">const LineInfo *li</var>, <var class=Fa style="white-space: nowrap;">int *argc</var>, <var class=Fa style="white-space: nowrap;">const char **argv[]</var>, <var class=Fa style="white-space: nowrap;">int *cursorc</var>, <var class=Fa style="white-space: nowrap;">int *cursoro</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>tok_wline</code>(<var class=Fa style="white-space: nowrap;">TokenizerW *t</var>, <var class=Fa style="white-space: nowrap;">const LineInfoW *li</var>, <var class=Fa style="white-space: nowrap;">int *argc</var>, <var class=Fa style="white-space: nowrap;">const wchar_t **argv[]</var>, <var class=Fa style="white-space: nowrap;">int *cursorc</var>, <var class=Fa style="white-space: nowrap;">int *cursoro</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>tok_str</code>(<var class=Fa style="white-space: nowrap;">Tokenizer *t</var>, <var class=Fa style="white-space: nowrap;">const char *str</var>, <var class=Fa style="white-space: nowrap;">int *argc</var>, <var class=Fa style="white-space: nowrap;">const char **argv[]</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>tok_wstr</code>(<var class=Fa style="white-space: nowrap;">TokenizerW *t</var>, <var class=Fa style="white-space: nowrap;">const wchar_t *str</var>, <var class=Fa style="white-space: nowrap;">int *argc</var>, <var class=Fa style="white-space: nowrap;">const wchar_t **argv[]</var>);</p></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> The <code class=Nm>editline</code> library provides generic line editing, history and tokenization functions, similar to those found in <a class=Xr href=sh.1.html>sh(1)</a>. <p class=Pp>These functions are available in the <code class=Nm>libedit</code> library (which needs the <code class=Nm>libtermcap</code> library). Programs should be linked with <code class=Fl>-ledit</code><code class=Fl>-ltermcap</code>.</p><p class=Pp>The <code class=Nm>editline</code> library respects the <code class=Ev>LC_CTYPE</code> locale set by the application program and never uses <a class=Xr href=setlocale.3.html>setlocale(3)</a> to change the locale.</p></section><section class=Sh><h2 class=Sh id=LINE_EDITING_FUNCTIONS><a class=permalink href=#LINE_EDITING_FUNCTIONS>LINE EDITING FUNCTIONS</a></h2> The line editing functions use a common data structure, <var class=Fa>EditLine</var>, which is created by <code class=Fn>el_init</code>() or <code class=Fn>el_init_fd</code>() and freed by <code class=Fn>el_end</code>(). <p class=Pp>The wide-character functions behave the same way as their narrow counterparts.</p><p class=Pp>The following functions are available:</p><dl class=Bl-tag><dt><code class=Fn>el_init</code>()</dt><dd>Initialize the line editor, and return a data structure to be used by all other line editing functions, or <code class=Dv>NULL</code> on failure. <var class=Fa>prog</var> is the name of the invoking program, used when reading the <a class=Xr href=editrc.5.html>editrc(5)</a> file to determine which settings to use. <var class=Fa>fin</var>, <var class=Fa>fout</var> and <var class=Fa>ferr</var> are the input, output, and error streams (respectively) to use. In this documentation, references to “the tty” are actually to this input/output stream combination.</dd><dt><code class=Fn>el_init_fd</code>()</dt><dd>Like <code class=Fn>el_init</code>() but allows specifying file descriptors for the <a class=Xr href=stdio.3.html>stdio(3)</a> corresponding streams, in case those were created with <a class=Xr href=funopen.3.html>funopen(3)</a>.</dd><dt><code class=Fn>el_end</code>()</dt><dd>Clean up and finish with <var class=Fa>e</var>, assumed to have been created with <code class=Fn>el_init</code>() or <code class=Fn>el_init_fd</code>().</dd><dt><code class=Fn>el_reset</code>()</dt><dd>Reset the tty and the parser. This should be called after an error which may have upset the tty's state.</dd><dt><code class=Fn>el_gets</code>()</dt><dd>Read a line from the tty. <var class=Fa>count</var> is modified to contain the number of characters read. Returns the line read if successful, or <code class=Dv>NULL</code> if no characters were read or if an error occurred. If an error occurred, <var class=Fa>count</var> is set to -1 and <code class=Dv>errno</code> contains the error code that caused it. The return value may not remain valid across calls to <code class=Fn>el_gets</code>() and must be copied if the data is to be retained.</dd><dt><code class=Fn>el_wgetc</code>()</dt><dd>Read a wide character from the tty, respecting the current locale, or from the input queue described in <a class=Xr href=editline.7.html>editline(7)</a> if that is not empty, and store it in <var class=Fa>wc</var>. If an invalid or incomplete character is found, it is discarded, <var class=Va>errno</var> is set to <code class=Er>EILSEQ</code>, and the next character is read and stored in <var class=Fa>wc</var>. Returns 1 if a valid character was read, 0 on end of file, or -1 on <a class=Xr href=read.2.html>read(2)</a> failure. In the latter case, <var class=Va>errno</var> is set to indicate the error.</dd><dt><code class=Fn>el_getc</code>()</dt><dd>Read a wide character as described for <code class=Fn>el_wgetc</code>() and return 0 on end of file or -1 on failure. If the wide character can be represented as a single-byte character, convert it with <a class=Xr href=wctob.3.html>wctob(3)</a>, store the result in <var class=Fa>ch</var>, and return 1; otherwise, set <var class=Va>errno</var> to <code class=Er>ERANGE</code> and return -1. In the C or POSIX locale, this simply reads a byte, but for any other locale, including UTF-8, this is rarely useful.</dd><dt><code class=Fn>el_wpush</code>()</dt><dd>Push the wide character string <var class=Fa>wcs</var> back onto the input queue described in <a class=Xr href=editline.7.html>editline(7)</a>. If the queue overflows, for example due to a recursive macro, or if an error occurs, for example because <var class=Fa>wcs</var> is <code class=Dv>NULL</code> or memory allocation fails, the function beeps at the user, but does not report the problem to the caller.</dd><dt><code class=Fn>el_push</code>()</dt><dd>Use the current locale to convert the multibyte string <var class=Fa>mbs</var> to a wide character string, and pass the result to <code class=Fn>el_wpush</code>().</dd><dt><code class=Fn>el_parse</code>()</dt><dd>Parses the <var class=Fa>argv</var> array (which is <var class=Fa>argc</var> elements in size) to execute builtin <code class=Nm>editline</code> commands. If the command is prefixed with “prog”: then <code class=Fn>el_parse</code>() will only execute the command if “prog” matches the <var class=Fa>prog</var> argument supplied to <code class=Fn>el_init</code>(). The return value is -1 if the command is unknown, 0 if there was no error or “prog” didn't match, or 1 if the command returned an error. Refer to <a class=Xr href=editrc.5.html>editrc(5)</a> for more information.</dd><dt><code class=Fn>el_set</code>()</dt><dd>Set <code class=Nm>editline</code> parameters. <var class=Fa>op</var> determines which parameter to set, and each operation has its own parameter list. Returns 0 on success, -1 on failure. <p class=Pp>The following values for <var class=Fa>op</var> are supported, along with the required argument list:</p><dl class=Bl-tag><dt><a class=permalink href=#EL_PROMPT><code class=Dv id=EL_PROMPT>EL_PROMPT</code></a>, <var class=Fa>char *(*f)(EditLine *)</var></dt><dd>Define prompt printing function as <var class=Fa>f</var>, which is to return a string that contains the prompt.</dd><dt><a class=permalink href=#EL_PROMPT_ESC><code class=Dv id=EL_PROMPT_ESC>EL_PROMPT_ESC</code></a>, <var class=Fa>char *(*f)(EditLine *)</var>, <var class=Fa>char c</var></dt><dd>Same as <code class=Dv>EL_PROMPT</code>, but the <var class=Fa>c</var> argument indicates the start/stop literal prompt character. <p class=Pp>If a start/stop literal character is found in the prompt, the character itself is not printed, but characters after it are printed directly to the terminal without affecting the state of the current line. A subsequent second start/stop literal character ends this behavior. This is typically used to embed literal escape sequences that change the color/style of the terminal in the prompt. Note that the literal escape character cannot be the last character in the prompt, as the escape sequence is attached to the next character in the prompt. <code class=Dv>0</code> unsets it.</p></dd><dt><a class=permalink href=#EL_REFRESH><code class=Dv id=EL_REFRESH>EL_REFRESH</code></a></dt><dd>Re-display the current line on the next terminal line.</dd><dt><a class=permalink href=#EL_RPROMPT><code class=Dv id=EL_RPROMPT>EL_RPROMPT</code></a>, <var class=Fa>char *(*f)(EditLine *)</var></dt><dd>Define right side prompt printing function as <var class=Fa>f</var>, which is to return a string that contains the prompt.</dd><dt><a class=permalink href=#EL_RPROMPT_ESC><code class=Dv id=EL_RPROMPT_ESC>EL_RPROMPT_ESC</code></a>, <var class=Fa>char *(*f)(EditLine *)</var>, <var class=Fa>char c</var></dt><dd>Define the right prompt printing function but with a literal escape character.</dd><dt><a class=permalink href=#EL_TERMINAL><code class=Dv id=EL_TERMINAL>EL_TERMINAL</code></a>, <var class=Fa>const char *type</var></dt><dd>Define terminal type of the tty to be <var class=Fa>type</var>, or to <code class=Ev>TERM</code> if <var class=Fa>type</var> is <code class=Dv>NULL</code>.</dd><dt><a class=permalink href=#EL_EDITOR><code class=Dv id=EL_EDITOR>EL_EDITOR</code></a>, <var class=Fa>const char *mode</var></dt><dd>Set editing mode to <var class=Fa>mode</var>, which must be one of “emacs” or “vi”.</dd><dt><a class=permalink href=#EL_SIGNAL><code class=Dv id=EL_SIGNAL>EL_SIGNAL</code></a>, <var class=Fa>int flag</var></dt><dd>If <var class=Fa>flag</var> is non-zero, <code class=Nm>editline</code> will install its own signal handler for the following signals when reading command input: <code class=Dv>SIGCONT</code>, <code class=Dv>SIGHUP</code>, <code class=Dv>SIGINT</code>, <code class=Dv>SIGQUIT</code>, <code class=Dv>SIGSTOP</code>, <code class=Dv>SIGTERM</code>, <code class=Dv>SIGTSTP</code>, and <code class=Dv>SIGWINCH</code>. Otherwise, the current signal handlers will be used.</dd><dt><a class=permalink href=#EL_BIND><code class=Dv id=EL_BIND>EL_BIND</code></a>, <var class=Fa>const char *</var>, <var class=Fa>...</var>, <code class=Dv>NULL</code></dt><dd>Perform the <code class=Ic>bind</code> builtin command. Refer to <a class=Xr href=editrc.5.html>editrc(5)</a> for more information.</dd><dt><a class=permalink href=#EL_ECHOTC><code class=Dv id=EL_ECHOTC>EL_ECHOTC</code></a>, <var class=Fa>const char *</var>, <var class=Fa>...</var>, <code class=Dv>NULL</code></dt><dd>Perform the <code class=Ic>echotc</code> builtin command. Refer to <a class=Xr href=editrc.5.html>editrc(5)</a> for more information.</dd><dt><a class=permalink href=#EL_SETTC><code class=Dv id=EL_SETTC>EL_SETTC</code></a>, <var class=Fa>const char *</var>, <var class=Fa>...</var>, <code class=Dv>NULL</code></dt><dd>Perform the <code class=Ic>settc</code> builtin command. Refer to <a class=Xr href=editrc.5.html>editrc(5)</a> for more information.</dd><dt><a class=permalink href=#EL_SETTY><code class=Dv id=EL_SETTY>EL_SETTY</code></a>, <var class=Fa>const char *</var>, <var class=Fa>...</var>, <code class=Dv>NULL</code></dt><dd>Perform the <code class=Ic>setty</code> builtin command. Refer to <a class=Xr href=editrc.5.html>editrc(5)</a> for more information.</dd><dt><a class=permalink href=#EL_TELLTC><code class=Dv id=EL_TELLTC>EL_TELLTC</code></a>, <var class=Fa>const char *</var>, <var class=Fa>...</var>, <code class=Dv>NULL</code></dt><dd>Perform the <code class=Ic>telltc</code> builtin command. Refer to <a class=Xr href=editrc.5.html>editrc(5)</a> for more information.</dd><dt><a class=permalink href=#EL_ADDFN><code class=Dv id=EL_ADDFN>EL_ADDFN</code></a>, <var class=Fa>const char *name</var>, <var class=Fa>const char *help</var>, <var class=Fa>unsigned char (*func)(EditLine *e, int ch)</var></dt><dd>Add a user defined function, <code class=Fn>func</code>(), referred to as <var class=Fa>name</var> which is invoked when a key which is bound to <var class=Fa>name</var> is entered. <var class=Fa>help</var> is a description of <var class=Fa>name</var>. At invocation time, <var class=Fa>ch</var> is the key which caused the invocation. The return value of <code class=Fn>func</code>() should be one of: <dl class=Bl-tag><dt><a class=permalink href=#CC_NORM><code class=Dv id=CC_NORM>CC_NORM</code></a></dt><dd>Add a normal character.</dd><dt><a class=permalink href=#CC_NEWLINE><code class=Dv id=CC_NEWLINE>CC_NEWLINE</code></a></dt><dd>End of line was entered.</dd><dt><a class=permalink href=#CC_EOF><code class=Dv id=CC_EOF>CC_EOF</code></a></dt><dd>EOF was entered.</dd><dt><a class=permalink href=#CC_ARGHACK><code class=Dv id=CC_ARGHACK>CC_ARGHACK</code></a></dt><dd>Expecting further command input as arguments, do nothing visually.</dd><dt><a class=permalink href=#CC_REFRESH><code class=Dv id=CC_REFRESH>CC_REFRESH</code></a></dt><dd>Refresh display.</dd><dt><a class=permalink href=#CC_REFRESH_BEEP><code class=Dv id=CC_REFRESH_BEEP>CC_REFRESH_BEEP</code></a></dt><dd>Refresh display, and beep.</dd><dt><a class=permalink href=#CC_CURSOR><code class=Dv id=CC_CURSOR>CC_CURSOR</code></a></dt><dd>Cursor moved, so update and perform <code class=Dv>CC_REFRESH</code>.</dd><dt><a class=permalink href=#CC_REDISPLAY><code class=Dv id=CC_REDISPLAY>CC_REDISPLAY</code></a></dt><dd>Redisplay entire input line. This is useful if a key binding outputs extra information.</dd><dt><a class=permalink href=#CC_ERROR><code class=Dv id=CC_ERROR>CC_ERROR</code></a></dt><dd>An error occurred. Beep, and flush tty.</dd><dt><a class=permalink href=#CC_FATAL><code class=Dv id=CC_FATAL>CC_FATAL</code></a></dt><dd>Fatal error, reset tty to known state.</dd></dl></dd><dt><a class=permalink href=#EL_HIST><code class=Dv id=EL_HIST>EL_HIST</code></a>, <var class=Fa>History *(*func)(History *, int op, ...)</var>, <var class=Fa>const char *ptr</var></dt><dd>Defines which history function to use, which is usually <code class=Fn>history</code>(). <var class=Fa>ptr</var> should be the value returned by <code class=Fn>history_init</code>().</dd><dt><a class=permalink href=#EL_EDITMODE><code class=Dv id=EL_EDITMODE>EL_EDITMODE</code></a>, <var class=Fa>int flag</var></dt><dd>If <var class=Fa>flag</var> is non-zero, editing is enabled (the default). Note that this is only an indication, and does not affect the operation of <code class=Nm>editline</code>. At this time, it is the caller's responsibility to check this (using <code class=Fn>el_get</code>()) to determine if editing should be enabled or not.</dd><dt><a class=permalink href=#EL_UNBUFFERED><code class=Dv id=EL_UNBUFFERED>EL_UNBUFFERED</code></a>, <var class=Fa>int flag</var></dt><dd>If <var class=Fa>flag</var> is zero, unbuffered mode is disabled (the default). In unbuffered mode, <code class=Fn>el_gets</code>() will return immediately after processing a single character.</dd><dt><a class=permalink href=#EL_GETCFN><code class=Dv id=EL_GETCFN>EL_GETCFN</code></a>, <var class=Fa>el_rfunc_t f</var></dt><dd>Whenever reading a character, use the function <div class="Bd Bd-indent"><var class=Ft>int</var><code class=Fn>f</code>(<var class=Fa>EditLine *e</var>, <var class=Fa>wchar_t *wc</var>);</div> which stores the character in <var class=Fa>wc</var> and returns 1 on success, 0 on end of file, or -1 on I/O or encoding errors. Functions internally using it include <code class=Fn>el_wgets</code>(), <code class=Fn>el_wgetc</code>(), <code class=Fn>el_gets</code>(), and <code class=Fn>el_getc</code>(). Initially, a builtin function is installed, and replacing it is discouraged because writing such a function is very error prone. The builtin function can be restored at any time by passing the special value <code class=Dv>EL_BUILTIN_GETCFN</code> instead of a function pointer.</dd><dt><a class=permalink href=#EL_CLIENTDATA><code class=Dv id=EL_CLIENTDATA>EL_CLIENTDATA</code></a>, <var class=Fa>void *data</var></dt><dd>Register <var class=Fa>data</var> to be associated with this EditLine structure. It can be retrieved with the corresponding <code class=Fn>el_get</code>() call.</dd><dt><a class=permalink href=#EL_SETFP><code class=Dv id=EL_SETFP>EL_SETFP</code></a>, <var class=Fa>int fd</var>, <var class=Fa>FILE *fp</var></dt><dd>Set the current <code class=Nm>editline</code> file pointer for “input” <var class=Fa>fd</var> = <code class=Dv>0</code>, “output” <var class=Fa>fd</var> = <code class=Dv>1</code>, or “error” <var class=Fa>fd</var> = <code class=Dv>2</code> from <var class=Fa>fp</var>.</dd></dl></dd><dt><code class=Fn>el_get</code>()</dt><dd>Get <code class=Nm>editline</code> parameters. <var class=Fa>op</var> determines which parameter to retrieve into <var class=Fa>result</var>. Returns 0 if successful, -1 otherwise. <p class=Pp>The following values for <var class=Fa>op</var> are supported, along with actual type of <var class=Fa>result</var>:</p><dl class=Bl-tag><dt><a class=permalink href=#EL_PROMPT_2><code class=Dv id=EL_PROMPT_2>EL_PROMPT</code></a>, <var class=Fa>char *(*f)(EditLine *)</var>, <var class=Fa>char *c</var></dt><dd>Set <var class=Fa>f</var> to a pointer to the function that displays the prompt. If <var class=Fa>c</var> is not <code class=Dv>NULL</code>, set it to the start/stop literal prompt character.</dd><dt><a class=permalink href=#EL_RPROMPT_2><code class=Dv id=EL_RPROMPT_2>EL_RPROMPT</code></a>, <var class=Fa>char *(*f)(EditLine *)</var>, <var class=Fa>char *c</var></dt><dd>Set <var class=Fa>f</var> to a pointer to the function that displays the prompt. If <var class=Fa>c</var> is not <code class=Dv>NULL</code>, set it to the start/stop literal prompt character.</dd><dt><a class=permalink href=#EL_EDITOR_2><code class=Dv id=EL_EDITOR_2>EL_EDITOR</code></a>, <var class=Fa>const char **n</var></dt><dd>Set the name of the editor in <var class=Fa>n</var>, which will be one of “emacs” or “vi”.</dd><dt><a class=permalink href=#EL_GETTC><code class=Dv id=EL_GETTC>EL_GETTC</code></a>, <var class=Fa>const char *name</var>, <var class=Fa>void *value</var></dt><dd>If <var class=Fa>name</var> is a valid <a class=Xr href=termcap.5.html>termcap(5)</a> capability set <var class=Fa>value</var> to the current value of that capability.</dd><dt><a class=permalink href=#EL_SIGNAL_2><code class=Dv id=EL_SIGNAL_2>EL_SIGNAL</code></a>, <var class=Fa>int *s</var></dt><dd>Set <var class=Fa>s</var> to non-zero if <code class=Nm>editline</code> has installed private signal handlers (see <code class=Fn>el_get</code>() above).</dd><dt><a class=permalink href=#EL_EDITMODE_2><code class=Dv id=EL_EDITMODE_2>EL_EDITMODE</code></a>, <var class=Fa>int *c</var></dt><dd>Set <var class=Fa>c</var> to non-zero if editing is enabled.</dd><dt><a class=permalink href=#EL_GETCFN_2><code class=Dv id=EL_GETCFN_2>EL_GETCFN</code></a>, <var class=Fa>el_rfunc_t *f</var></dt><dd>Set <var class=Fa>f</var> to a pointer to the function that reads characters, or to <code class=Dv>EL_BUILTIN_GETCFN</code> if the builtin function is in use.</dd><dt><a class=permalink href=#EL_CLIENTDATA_2><code class=Dv id=EL_CLIENTDATA_2>EL_CLIENTDATA</code></a>, <var class=Fa>void **data</var></dt><dd>Set <var class=Fa>data</var> to the previously registered client data set by an <code class=Fn>el_set</code>() call.</dd><dt><a class=permalink href=#EL_UNBUFFERED_2><code class=Dv id=EL_UNBUFFERED_2>EL_UNBUFFERED</code></a>, <var class=Fa>int *c</var></dt><dd>Set <var class=Fa>c</var> to non-zero if unbuffered mode is enabled.</dd><dt><a class=permalink href=#EL_GETFP><code class=Dv id=EL_GETFP>EL_GETFP</code></a>, <var class=Fa>int fd</var>, <var class=Fa>FILE **fp</var></dt><dd>Set <var class=Fa>fp</var> to the current <code class=Nm>editline</code> file pointer for “input” <var class=Fa>fd</var> = <code class=Dv>0</code>, “output” <var class=Fa>fd</var> = <code class=Dv>1</code>, or “error” <var class=Fa>fd</var> = <code class=Dv>2</code>.</dd></dl></dd><dt><code class=Fn>el_source</code>()</dt><dd>Initialize <code class=Nm>editline</code> by reading the contents of <var class=Fa>file</var>. <code class=Fn>el_parse</code>() is called for each line in <var class=Fa>file</var>. If <var class=Fa>file</var> is <code class=Dv>NULL</code>, try <span class=Pa>$EDITRC</span> and if that is not set <span class=Pa>$HOME/.editrc</span>. Refer to <a class=Xr href=editrc.5.html>editrc(5)</a> for details on the format of <var class=Fa>file</var>. <code class=Fn>el_source</code>() returns 0 on success and -1 on error.</dd><dt><code class=Fn>el_resize</code>()</dt><dd>Must be called if the terminal size changes. If <code class=Dv>EL_SIGNAL</code> has been set with <code class=Fn>el_set</code>(), then this is done automatically. Otherwise, it's the responsibility of the application to call <code class=Fn>el_resize</code>() on the appropriate occasions.</dd><dt><code class=Fn>el_cursor</code>()</dt><dd>Move the cursor to the right (if positive) or to the left (if negative) <var class=Fa>count</var> characters. Returns the resulting offset of the cursor from the beginning of the line.</dd><dt><code class=Fn>el_line</code>()</dt><dd>Return the editing information for the current line in a <var class=Fa>LineInfo</var> structure, which is defined as follows: <div class="Bd Pp"><pre>
typedef struct lineinfo {
    const char *buffer;    /* address of buffer */
    const char *cursor;    /* address of cursor */
    const char *lastchar;  /* address of last character */
} LineInfo;
    </pre></div><p class=Pp><var class=Fa>buffer</var> is not NUL terminated. This function may be called after <code class=Fn>el_gets</code>() to obtain the <var class=Fa>LineInfo</var> structure pertaining to line returned by that function, and from within user defined functions added with <code class=Dv>EL_ADDFN</code>.</p></dd><dt><code class=Fn>el_insertstr</code>()</dt><dd>Insert <var class=Fa>str</var> into the line at the cursor. Returns -1 if <var class=Fa>str</var> is empty or won't fit, and 0 otherwise.</dd><dt><code class=Fn>el_deletestr</code>()</dt><dd>Delete <var class=Fa>count</var> characters before the cursor.</dd></dl></section><section class=Sh><h2 class=Sh id=HISTORY_LIST_FUNCTIONS><a class=permalink href=#HISTORY_LIST_FUNCTIONS>HISTORY LIST FUNCTIONS</a></h2> The history functions use a common data structure, <var class=Fa>History</var>, which is created by <code class=Fn>history_init</code>() and freed by <code class=Fn>history_end</code>(). <p class=Pp>The following functions are available:</p><dl class=Bl-tag><dt><code class=Fn>history_init</code>()</dt><dd>Initialize the history list, and return a data structure to be used by all other history list functions, or <code class=Dv>NULL</code> on failure.</dd><dt><code class=Fn>history_end</code>()</dt><dd>Clean up and finish with <var class=Fa>h</var>, assumed to have been created with <code class=Fn>history_init</code>().</dd><dt><code class=Fn>history</code>()</dt><dd>Perform operation <var class=Fa>op</var> on the history list, with optional arguments as needed by the operation. <var class=Fa>ev</var> is changed accordingly to operation. The following values for <var class=Fa>op</var> are supported, along with the required argument list: <dl class=Bl-tag><dt><a class=permalink href=#H_SETSIZE><code class=Dv id=H_SETSIZE>H_SETSIZE</code></a>, <var class=Fa>int size</var></dt><dd>Set size of history to <var class=Fa>size</var> elements.</dd><dt><a class=permalink href=#H_GETSIZE><code class=Dv id=H_GETSIZE>H_GETSIZE</code></a></dt><dd>Get number of events currently in history.</dd><dt><a class=permalink href=#H_END><code class=Dv id=H_END>H_END</code></a></dt><dd>Cleans up and finishes with <var class=Fa>h</var>, assumed to be created with <code class=Fn>history_init</code>().</dd><dt><a class=permalink href=#H_CLEAR><code class=Dv id=H_CLEAR>H_CLEAR</code></a></dt><dd>Clear the history.</dd><dt><a class=permalink href=#H_FUNC><code class=Dv id=H_FUNC>H_FUNC</code></a>, <var class=Fa>void *ptr</var>, <var class=Fa>history_gfun_t first</var>, <var class=Fa>history_gfun_t next</var>, <var class=Fa>history_gfun_t last</var>, <var class=Fa>history_gfun_t prev</var>, <var class=Fa>history_gfun_t curr</var>, <var class=Fa>history_sfun_t set</var>, <var class=Fa>history_vfun_t clear</var>, <var class=Fa>history_efun_t enter</var>, <var class=Fa>history_efun_t add</var></dt><dd>Define functions to perform various history operations. <var class=Fa>ptr</var> is the argument given to a function when it's invoked.</dd><dt><a class=permalink href=#H_FIRST><code class=Dv id=H_FIRST>H_FIRST</code></a></dt><dd>Return the first element in the history.</dd><dt><a class=permalink href=#H_LAST><code class=Dv id=H_LAST>H_LAST</code></a></dt><dd>Return the last element in the history.</dd><dt><a class=permalink href=#H_PREV><code class=Dv id=H_PREV>H_PREV</code></a></dt><dd>Return the previous element in the history. It is newer than the current one.</dd><dt><a class=permalink href=#H_NEXT><code class=Dv id=H_NEXT>H_NEXT</code></a></dt><dd>Return the next element in the history. It is older than the current one.</dd><dt><a class=permalink href=#H_CURR><code class=Dv id=H_CURR>H_CURR</code></a></dt><dd>Return the current element in the history.</dd><dt><a class=permalink href=#H_SET><code class=Dv id=H_SET>H_SET</code></a>, <var class=Fa>int position</var></dt><dd>Set the cursor to point to the requested element.</dd><dt><a class=permalink href=#H_ADD><code class=Dv id=H_ADD>H_ADD</code></a>, <var class=Fa>const char *str</var></dt><dd>Append <var class=Fa>str</var> to the current element of the history, or perform the <code class=Dv>H_ENTER</code> operation with argument <var class=Fa>str</var> if there is no current element.</dd><dt><a class=permalink href=#H_APPEND><code class=Dv id=H_APPEND>H_APPEND</code></a>, <var class=Fa>const char *str</var></dt><dd>Append <var class=Fa>str</var> to the last new element of the history.</dd><dt><a class=permalink href=#H_ENTER><code class=Dv id=H_ENTER>H_ENTER</code></a>, <var class=Fa>const char *str</var></dt><dd>Add <var class=Fa>str</var> as a new element to the history and, if necessary, removing the oldest entry to keep the list to the created size. If <code class=Dv>H_SETUNIQUE</code> has been called with a non-zero argument, the element will not be entered into the history if its contents match the ones of the current history element. If the element is entered <code class=Fn>history</code>() returns 1; if it is ignored as a duplicate returns 0. Finally <code class=Fn>history</code>() returns -1 if an error occurred.</dd><dt><a class=permalink href=#H_PREV_STR><code class=Dv id=H_PREV_STR>H_PREV_STR</code></a>, <var class=Fa>const char *str</var></dt><dd>Return the closest previous event that starts with <var class=Fa>str</var>.</dd><dt><a class=permalink href=#H_NEXT_STR><code class=Dv id=H_NEXT_STR>H_NEXT_STR</code></a>, <var class=Fa>const char *str</var></dt><dd>Return the closest next event that starts with <var class=Fa>str</var>.</dd><dt><a class=permalink href=#H_PREV_EVENT><code class=Dv id=H_PREV_EVENT>H_PREV_EVENT</code></a>, <var class=Fa>int e</var></dt><dd>Return the previous event numbered <var class=Fa>e</var>.</dd><dt><a class=permalink href=#H_NEXT_EVENT><code class=Dv id=H_NEXT_EVENT>H_NEXT_EVENT</code></a>, <var class=Fa>int e</var></dt><dd>Return the next event numbered <var class=Fa>e</var>.</dd><dt><a class=permalink href=#H_LOAD><code class=Dv id=H_LOAD>H_LOAD</code></a>, <var class=Fa>const char *file</var></dt><dd>Load the history list stored in <var class=Fa>file</var>.</dd><dt><a class=permalink href=#H_SAVE><code class=Dv id=H_SAVE>H_SAVE</code></a>, <var class=Fa>const char *file</var></dt><dd>Save the history list to <var class=Fa>file</var>.</dd><dt><a class=permalink href=#H_SAVE_FP><code class=Dv id=H_SAVE_FP>H_SAVE_FP</code></a>, <var class=Fa>FILE *fp</var></dt><dd>Save the history list to the opened <var class=Ft>FILE</var> pointer <var class=Fa>fp</var>.</dd><dt><a class=permalink href=#H_NSAVE_FP><code class=Dv id=H_NSAVE_FP>H_NSAVE_FP</code></a>, <var class=Fa>size_t n</var>, <var class=Fa>FILE *fp</var></dt><dd>Save the last <var class=Ft>n</var> history entries to the opened <var class=Ft>FILE</var> pointer <var class=Fa>fp</var>.</dd><dt><a class=permalink href=#H_SETUNIQUE><code class=Dv id=H_SETUNIQUE>H_SETUNIQUE</code></a>, <var class=Fa>int unique</var></dt><dd>Set flag that adjacent identical event strings should not be entered into the history.</dd><dt><a class=permalink href=#H_GETUNIQUE><code class=Dv id=H_GETUNIQUE>H_GETUNIQUE</code></a></dt><dd>Retrieve the current setting if adjacent identical elements should be entered into the history.</dd><dt><a class=permalink href=#H_DEL><code class=Dv id=H_DEL>H_DEL</code></a>, <var class=Fa>int e</var></dt><dd>Delete the event numbered <var class=Fa>e</var>. This function is only provided for <code class=Nm>readline</code> compatibility. The caller is responsible for free'ing the string in the returned <var class=Fa>HistEvent</var>.</dd></dl><p class=Pp><code class=Fn>history</code>() returns &gt;= 0 if the operation <var class=Fa>op</var> succeeds. Otherwise, -1 is returned and <var class=Fa>ev</var> is updated to contain more details about the error.</p></dd></dl></section><section class=Sh><h2 class=Sh id=TOKENIZATION_FUNCTIONS><a class=permalink href=#TOKENIZATION_FUNCTIONS>TOKENIZATION FUNCTIONS</a></h2> The tokenization functions use a common data structure, <var class=Fa>Tokenizer</var>, which is created by <code class=Fn>tok_init</code>() and freed by <code class=Fn>tok_end</code>(). <p class=Pp>The following functions are available:</p><dl class=Bl-tag><dt><code class=Fn>tok_init</code>()</dt><dd>Initialize the tokenizer, and return a data structure to be used by all other tokenizer functions. <var class=Fa>IFS</var> contains the Input Field Separators, which defaults to ⟨space⟩, ⟨tab⟩, and ⟨newline⟩ if <code class=Dv>NULL</code>.</dd><dt><code class=Fn>tok_end</code>()</dt><dd>Clean up and finish with <var class=Fa>t</var>, assumed to have been created with <code class=Fn>tok_init</code>().</dd><dt><code class=Fn>tok_reset</code>()</dt><dd>Reset the tokenizer state. Use after a line has been successfully tokenized by <code class=Fn>tok_line</code>() or <code class=Fn>tok_str</code>() and before a new line is to be tokenized.</dd><dt><code class=Fn>tok_line</code>()</dt><dd>Tokenize <var class=Fa>li</var>, If successful, modify: <var class=Fa>argv</var> to contain the words, <var class=Fa>argc</var> to contain the number of words, <var class=Fa>cursorc</var> (if not <code class=Dv>NULL</code>) to contain the index of the word containing the cursor, and <var class=Fa>cursoro</var> (if not <code class=Dv>NULL</code>) to contain the offset within <var class=Fa>argv[cursorc]</var> of the cursor. <p class=Pp>Returns 0 if successful, -1 for an internal error, 1 for an unmatched single quote, 2 for an unmatched double quote, and 3 for a backslash quoted ⟨newline⟩. A positive exit code indicates that another line should be read and tokenization attempted again.</p></dd><dt><code class=Fn>tok_str</code>()</dt><dd>A simpler form of <code class=Fn>tok_line</code>(); <var class=Fa>str</var> is a NUL terminated string to tokenize.</dd></dl></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=sh.1.html>sh(1)</a>, <a class=Xr href=signal.3.html>signal(3)</a>, <a class=Xr href=termcap.3.html>termcap(3)</a>, <a class=Xr href=editrc.5.html>editrc(5)</a>, <a class=Xr href=termcap.5.html>termcap(5)</a>, <a class=Xr href=editline.7.html>editline(7)</a></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> The <code class=Nm>editline</code> library first appeared in <span class=Ux>4.4BSD</span>. <code class=Dv>CC_REDISPLAY</code> appeared in <span class=Ux>NetBSD 1.3</span>. <code class=Dv>CC_REFRESH_BEEP</code>, <code class=Dv>EL_EDITMODE</code> and the readline emulation appeared in <span class=Ux>NetBSD 1.4</span>. <code class=Dv>EL_RPROMPT</code> appeared in <span class=Ux>NetBSD 1.5</span>. </section><section class=Sh><h2 class=Sh id=AUTHORS><a class=permalink href=#AUTHORS>AUTHORS</a></h2> The <code class=Nm>editline</code> library was written by <span class=An>Christos Zoulas</span>. <span class=An>Luke Mewburn</span> wrote this manual and implemented <code class=Dv>CC_REDISPLAY</code>, <code class=Dv>CC_REFRESH_BEEP</code>, <code class=Dv>EL_EDITMODE</code>, and <code class=Dv>EL_RPROMPT</code>. <span class=An>Jaromir Dolecek</span> implemented the readline emulation. <span class=An>Johny Mattsson</span> implemented wide-character support. </section><section class=Sh><h2 class=Sh id=BUGS><a class=permalink href=#BUGS>BUGS</a></h2> At this time, it is the responsibility of the caller to check the result of the <code class=Dv>EL_EDITMODE</code> operation of <code class=Fn>el_get</code>() (after an <code class=Fn>el_source</code>() or <code class=Fn>el_parse</code>()) to determine if <code class=Nm>editline</code> should be used for further input. I.e., <code class=Dv>EL_EDITMODE</code> is purely an indication of the result of the most recent <a class=Xr href=editrc.5.html>editrc(5)</a><code class=Ic>edit</code> command. </section></div><table class=foot><tr><td class=foot-date>November 9, 2018</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>