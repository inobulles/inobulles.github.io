<!DOCTYPE html>
<html><head><meta charset=utf-8><title>pmap_getmaps(3)</title><keywords content=man,pmap_getmaps></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>pmap_getmaps(3)</h1><table class=head><tr><td class=head-ltitle>RPC_SOC(3)</td><td class=head-vol>FreeBSD Library Functions Manual</td><td class=head-rtitle>RPC_SOC(3)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>rpc_soc</code>, <code class=Nm>auth_destroy</code>, <code class=Nm>authnone_create</code>, <code class=Nm>authunix_create</code>, <code class=Nm>authunix_create_default</code>, <code class=Nm>callrpc</code>, <code class=Nm>clnt_broadcast</code>, <code class=Nm>clnt_call</code>, <code class=Nm>clnt_control</code>, <code class=Nm>clnt_create</code>, <code class=Nm>clnt_destroy</code>, <code class=Nm>clnt_freeres</code>, <code class=Nm>clnt_geterr</code>, <code class=Nm>clnt_pcreateerror</code>, <code class=Nm>clnt_perrno</code>, <code class=Nm>clnt_perror</code>, <code class=Nm>clnt_spcreateerror</code>, <code class=Nm>clnt_sperrno</code>, <code class=Nm>clnt_sperror</code>, <code class=Nm>clntraw_create</code>, <code class=Nm>clnttcp_create</code>, <code class=Nm>clntudp_bufcreate</code>, <code class=Nm>clntudp_create</code>, <code class=Nm>clntunix_create</code>, <code class=Nm>get_myaddress</code>, <code class=Nm>pmap_getmaps</code>, <code class=Nm>pmap_getport</code>, <code class=Nm>pmap_rmtcall</code>, <code class=Nm>pmap_set</code>, <code class=Nm>pmap_unset</code>, <code class=Nm>registerrpc</code>, <code class=Nm>rpc_createerr</code>, <code class=Nm>svc_destroy</code>, <code class=Nm>svc_fds</code>, <code class=Nm>svc_fdset</code>, <code class=Nm>svc_getargs</code>, <code class=Nm>svc_getcaller</code>, <code class=Nm>svc_getreq</code>, <code class=Nm>svc_getreqset</code>, <code class=Nm>svc_register</code>, <code class=Nm>svc_run</code>, <code class=Nm>svc_sendreply</code>, <code class=Nm>svc_unregister</code>, <code class=Nm>svcerr_auth</code>, <code class=Nm>svcerr_decode</code>, <code class=Nm>svcerr_noproc</code>, <code class=Nm>svcerr_noprog</code>, <code class=Nm>svcerr_progvers</code>, <code class=Nm>svcerr_systemerr</code>, <code class=Nm>svcerr_weakauth</code>, <code class=Nm>svcfd_create</code>, <code class=Nm>svcunixfd_create</code>, <code class=Nm>svcraw_create</code>, <code class=Nm>svcunix_create</code>, <code class=Nm>xdr_accepted_reply</code>, <code class=Nm>xdr_authunix_parms</code>, <code class=Nm>xdr_callhdr</code>, <code class=Nm>xdr_callmsg</code>, <code class=Nm>xdr_opaque_auth</code>, <code class=Nm>xdr_pmap</code>, <code class=Nm>xdr_pmaplist</code>, <code class=Nm>xdr_rejected_reply</code>, <code class=Nm>xdr_replymsg</code>, <code class=Nm>xprt_register</code>, <code class=Nm>xprt_unregister</code> — <div class=Nd>library routines for remote procedure calls</div></section><section class=Sh><h2 class=Sh id=LIBRARY><a class=permalink href=#LIBRARY>LIBRARY</a></h2><span class=Lb>Standard C Library (libc, -lc)</span></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/rpc/rpc.h.html>rpc/rpc.h</a>&gt;</code><p class=Pp>See <a class=Sx href=#DESCRIPTION>DESCRIPTION</a> for function declarations.</p></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2><div class="Bf Sy">The <code class=Fn>svc_*</code>() and <code class=Fn>clnt_*</code>() functions described in this page are the old, TS-RPC interface to the XDR and RPC library, and exist for backward compatibility. The new interface is described in the pages referenced from <a class=Xr href=rpc.3.html>rpc(3)</a>.</div><p class=Pp>These routines allow C programs to make procedure calls on other machines across the network. First, the client calls a procedure to send a data packet to the server. Upon receipt of the packet, the server calls a dispatch routine to perform the requested service, and then sends back a reply. Finally, the procedure call returns to the client.</p><p class=Pp>Routines that are used for Secure RPC (DES authentication) are described in <a class=Xr href=rpc_secure.3.html>rpc_secure(3)</a>. Secure RPC can be used only if DES encryption is available.</p><p class=Pp></p><dl class="Bl-tag Bl-compact"><dt><var class=Ft>void</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>auth_destroy</code>(<var class=Fa>AUTH *auth</var>)</dt><dd><p class=Pp>A macro that destroys the authentication information associated with <var class=Fa>auth</var>. Destruction usually involves deallocation of private data structures. The use of <var class=Fa>auth</var> is undefined after calling <code class=Fn>auth_destroy</code>().</p><p class=Pp></p></dd><dt><var class=Ft>AUTH *</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>authnone_create</code>()</dt><dd><p class=Pp>Create and return an RPC authentication handle that passes nonusable authentication information with each remote procedure call. This is the default authentication used by RPC.</p><p class=Pp></p></dd><dt><var class=Ft>AUTH *</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>authunix_create</code>(<var class=Fa>char *host</var>, <var class=Fa>u_int uid</var>, <var class=Fa>u_int gid</var>, <var class=Fa>int len</var>, <var class=Fa>u_int *aup_gids</var>)</dt><dd><p class=Pp>Create and return an RPC authentication handle that contains <span class=Ux>UNIX</span> authentication information. The <var class=Fa>host</var> argument is the name of the machine on which the information was created; <var class=Fa>uid</var> is the user's user ID; <var class=Fa>gid</var> is the user's current group ID; <var class=Fa>len</var> and <var class=Fa>aup_gids</var> refer to a counted array of groups to which the user belongs. It is easy to impersonate a user.</p><p class=Pp></p></dd><dt><var class=Ft>AUTH *</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>authunix_create_default</code>()</dt><dd><p class=Pp>Calls <code class=Fn>authunix_create</code>() with the appropriate arguments.</p><p class=Pp></p></dd><dt><var class=Ft>int</var><code class=Fn>callrpc</code>(<var class=Fa>char *host</var>, <var class=Fa>u_long prognum</var>, <var class=Fa>u_long versnum</var>, <var class=Fa>u_long procnum</var>, <var class=Fa>xdrproc_t inproc</var>, <var class=Fa>void *in</var>, <var class=Fa>xdrproc_t outproc</var>, <var class=Fa>void *out</var>);</dt><dd><p class=Pp>Call the remote procedure associated with <var class=Fa>prognum</var>, <var class=Fa>versnum</var>, and <var class=Fa>procnum</var> on the machine <var class=Fa>host</var>. The <var class=Fa>in</var> argument is the address of the procedure's argument(s), and <var class=Fa>out</var> is the address of where to place the result(s); <var class=Fa>inproc</var> is used to encode the procedure's arguments, and <var class=Fa>outproc</var> is used to decode the procedure's results. This routine returns zero if it succeeds, or the value of <var class=Vt>enum clnt_stat</var> cast to an integer if it fails. The routine <code class=Fn>clnt_perrno</code>() is handy for translating failure statuses into messages.</p><p class=Pp>Warning: calling remote procedures with this routine uses UDP/IP as a transport; see <code class=Fn>clntudp_create</code>() for restrictions. You do not have control of timeouts or authentication using this routine.</p><p class=Pp></p></dd><dt><var class=Ft>enum clnt_stat</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>clnt_broadcast</code>(<var class=Fa>u_long prognum</var>, <var class=Fa>u_long versnum</var>, <var class=Fa>u_long procnum</var>, <var class=Fa>xdrproc_t inproc</var>, <var class=Fa>char *in</var>, <var class=Fa>xdrproc_t outproc</var>, <var class=Fa>char *out</var>, <var class=Fa>bool_t (*eachresult)(caddr_t, struct sockaddr_in *)</var>);</dt><dd><p class=Pp>Like <code class=Fn>callrpc</code>(), except the call message is broadcast to all locally connected broadcast nets. Each time it receives a response, this routine calls <code class=Fn>eachresult</code>(), whose form is:</p><div class="Bd Pp Bd-indent"><var class=Ft>bool_t</var><code class=Fn>eachresult</code>(<var class=Fa>caddr_t out</var>, <var class=Fa>struct sockaddr_in *addr</var>)</div><p class=Pp>where <var class=Fa>out</var> is the same as <var class=Fa>out</var> passed to <code class=Fn>clnt_broadcast</code>(), except that the remote procedure's output is decoded there; <var class=Fa>addr</var> points to the address of the machine that sent the results. If <code class=Fn>eachresult</code>() returns zero, <code class=Fn>clnt_broadcast</code>() waits for more replies; otherwise it returns with appropriate status.</p><p class=Pp>Warning: broadcast sockets are limited in size to the maximum transfer unit of the data link. For ethernet, this value is 1500 bytes.</p><p class=Pp></p></dd><dt><var class=Ft>enum clnt_stat</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>clnt_call</code>(<var class=Fa>CLIENT *clnt</var>, <var class=Fa>u_long procnum</var>, <var class=Fa>xdrproc_t inproc</var>, <var class=Fa>char *in</var>, <var class=Fa>xdrproc_t outproc</var>, <var class=Fa>char *out</var>, <var class=Fa>struct timeval tout</var>);</dt><dd><p class=Pp>A macro that calls the remote procedure <var class=Fa>procnum</var> associated with the client handle, <var class=Fa>clnt</var>, which is obtained with an RPC client creation routine such as <code class=Fn>clnt_create</code>(). The <var class=Fa>in</var> argument is the address of the procedure's argument(s), and <var class=Fa>out</var> is the address of where to place the result(s); <var class=Fa>inproc</var> is used to encode the procedure's arguments, and <var class=Fa>outproc</var> is used to decode the procedure's results; <var class=Fa>tout</var> is the time allowed for results to come back.</p><p class=Pp></p></dd><dt><var class=Ft>void</var><code class=Fn>clnt_destroy</code>(<var class=Fa>CLIENT *clnt</var>)</dt><dd><p class=Pp>A macro that destroys the client's RPC handle. Destruction usually involves deallocation of private data structures, including <var class=Fa>clnt</var> itself. Use of <var class=Fa>clnt</var> is undefined after calling <code class=Fn>clnt_destroy</code>(). If the RPC library opened the associated socket, it will close it also. Otherwise, the socket remains open.</p><p class=Pp></p></dd><dt><var class=Ft>CLIENT *</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>clnt_create</code>(<var class=Fa>char *host</var>, <var class=Fa>u_long prog</var>, <var class=Fa>u_long vers</var>, <var class=Fa>char *proto</var>)</dt><dd><p class=Pp>Generic client creation routine. The <var class=Fa>host</var> argument identifies the name of the remote host where the server is located. The <var class=Fa>proto</var> argument indicates which kind of transport protocol to use. The currently supported values for this field are “<code class=Li>udp</code>” and “<code class=Li>tcp</code>”. Default timeouts are set, but can be modified using <code class=Fn>clnt_control</code>().</p><p class=Pp>Warning: Using UDP has its shortcomings. Since UDP-based RPC messages can only hold up to 8 Kbytes of encoded data, this transport cannot be used for procedures that take large arguments or return huge results.</p><p class=Pp></p></dd><dt><var class=Ft>bool_t</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>clnt_control</code>(<var class=Fa>CLIENT *cl</var>, <var class=Fa>u_int req</var>, <var class=Fa>char *info</var>)</dt><dd><p class=Pp>A macro used to change or retrieve various information about a client object. The <var class=Fa>req</var> argument indicates the type of operation, and <var class=Fa>info</var> is a pointer to the information. For both UDP and TCP, the supported values of <var class=Fa>req</var> and their argument types and what they do are:</p><table class=Bl-column><tr><td><a class=permalink href=#CLSET_TIMEOUT><code class=Dv id=CLSET_TIMEOUT>CLSET_TIMEOUT</code></a></td><td><var class=Vt>struct timeval</var></td><td>set total timeout</td></tr><tr><td><a class=permalink href=#CLGET_TIMEOUT><code class=Dv id=CLGET_TIMEOUT>CLGET_TIMEOUT</code></a></td><td><var class=Vt>struct timeval</var></td><td>get total timeout</td></tr></table><p class=Pp>Note: if you set the timeout using <code class=Fn>clnt_control</code>(), the timeout argument passed to <code class=Fn>clnt_call</code>() will be ignored in all future calls.</p><table class=Bl-column><tr><td><a class=permalink href=#CLGET_SERVER_ADDR><code class=Dv id=CLGET_SERVER_ADDR>CLGET_SERVER_ADDR</code></a></td><td><var class=Vt>struct sockaddr_in</var></td><td>get server's address</td></tr></table><p class=Pp>The following operations are valid for UDP only:</p><table class=Bl-column><tr><td><a class=permalink href=#CLSET_RETRY_TIMEOUT><code class=Dv id=CLSET_RETRY_TIMEOUT>CLSET_RETRY_TIMEOUT</code></a></td><td><var class=Vt>struct timeval</var></td><td>set the retry timeout</td></tr><tr><td><a class=permalink href=#CLGET_RETRY_TIMEOUT><code class=Dv id=CLGET_RETRY_TIMEOUT>CLGET_RETRY_TIMEOUT</code></a></td><td><var class=Vt>struct timeval</var></td><td>get the retry timeout</td></tr></table><p class=Pp>The retry timeout is the time that UDP RPC waits for the server to reply before retransmitting the request.</p><p class=Pp></p></dd><dt><var class=Ft>bool_t</var><code class=Fn>clnt_freeres</code>(<var class=Fa>CLIENT *clnt</var>, <var class=Fa>xdrproc_t outproc</var>, <var class=Fa>char *out</var>)</dt><dd><p class=Pp>A macro that frees any data allocated by the RPC/XDR system when it decoded the results of an RPC call. The <var class=Fa>out</var> argument is the address of the results, and <var class=Fa>outproc</var> is the XDR routine describing the results. This routine returns one if the results were successfully freed, and zero otherwise.</p><p class=Pp></p></dd><dt><var class=Ft>void</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>clnt_geterr</code>(<var class=Fa>CLIENT *clnt</var>, <var class=Fa>struct rpc_err *errp</var>)</dt><dd><p class=Pp>A macro that copies the error structure out of the client handle to the structure at address <var class=Fa>errp</var>.</p><p class=Pp></p></dd><dt><var class=Ft>void</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>clnt_pcreateerror</code>(<var class=Fa>char *s</var>)</dt><dd><p class=Pp>prints a message to standard error indicating why a client RPC handle could not be created. The message is prepended with string <var class=Fa>s</var> and a colon. A newline is appended at the end of the message. Used when a <code class=Fn>clnt_create</code>(), <code class=Fn>clntraw_create</code>(), <code class=Fn>clnttcp_create</code>(), or <code class=Fn>clntudp_create</code>() call fails.</p><p class=Pp></p></dd><dt><var class=Ft>void</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>clnt_perrno</code>(<var class=Fa>enum clnt_stat stat</var>)</dt><dd><p class=Pp>Print a message to standard error corresponding to the condition indicated by <var class=Fa>stat</var>. A newline is appended at the end of the message. Used after <code class=Fn>callrpc</code>().</p><p class=Pp></p></dd><dt><var class=Ft>void</var><code class=Fn>clnt_perror</code>(<var class=Fa>CLIENT *clnt</var>, <var class=Fa>char *s</var>)</dt><dd><p class=Pp>Print a message to standard error indicating why an RPC call failed; <var class=Fa>clnt</var> is the handle used to do the call. The message is prepended with string <var class=Fa>s</var> and a colon. A newline is appended at the end of the message. Used after <code class=Fn>clnt_call</code>().</p><p class=Pp></p></dd><dt><var class=Ft>char *</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>clnt_spcreateerror</code>(<var class=Fa>char *s</var>)</dt><dd><p class=Pp>Like <code class=Fn>clnt_pcreateerror</code>(), except that it returns a string instead of printing to the standard error.</p><p class=Pp>Bugs: returns pointer to static data that is overwritten on each call.</p><p class=Pp></p></dd><dt><var class=Ft>char *</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>clnt_sperrno</code>(<var class=Fa>enum clnt_stat stat</var>)</dt><dd><p class=Pp>Take the same arguments as <code class=Fn>clnt_perrno</code>(), but instead of sending a message to the standard error indicating why an RPC call failed, return a pointer to a string which contains the message.</p><p class=Pp>The <code class=Fn>clnt_sperrno</code>() function is used instead of <code class=Fn>clnt_perrno</code>() if the program does not have a standard error (as a program running as a server quite likely does not), or if the programmer does not want the message to be output with <code class=Fn>printf</code>(), or if a message format different from that supported by <code class=Fn>clnt_perrno</code>() is to be used.</p><p class=Pp>Note: unlike <code class=Fn>clnt_sperror</code>() and <code class=Fn>clnt_spcreateerror</code>(), <code class=Fn>clnt_sperrno</code>() returns pointer to static data, but the result will not get overwritten on each call.</p><p class=Pp></p></dd><dt><var class=Ft>char *</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>clnt_sperror</code>(<var class=Fa>CLIENT *rpch</var>, <var class=Fa>char *s</var>)</dt><dd><p class=Pp>Like <code class=Fn>clnt_perror</code>(), except that (like <code class=Fn>clnt_sperrno</code>()) it returns a string instead of printing to standard error.</p><p class=Pp>Bugs: returns pointer to static data that is overwritten on each call.</p><p class=Pp></p></dd><dt><var class=Ft>CLIENT *</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>clntraw_create</code>(<var class=Fa>u_long prognum</var>, <var class=Fa>u_long versnum</var>)</dt><dd><p class=Pp>This routine creates a toy RPC client for the remote program <var class=Fa>prognum</var>, version <var class=Fa>versnum</var>. The transport used to pass messages to the service is actually a buffer within the process's address space, so the corresponding RPC server should live in the same address space; see <code class=Fn>svcraw_create</code>(). This allows simulation of RPC and acquisition of RPC overheads, such as round trip times, without any kernel interference. This routine returns <code class=Dv>NULL</code> if it fails.</p><p class=Pp></p></dd><dt><var class=Ft>CLIENT *</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>clnttcp_create</code>(<var class=Fa>struct sockaddr_in *addr</var>, <var class=Fa>u_long prognum</var>, <var class=Fa>u_long versnum</var>, <var class=Fa>int *sockp</var>, <var class=Fa>u_int sendsz</var>, <var class=Fa>u_int recvsz</var>);</dt><dd><p class=Pp>This routine creates an RPC client for the remote program <var class=Fa>prognum</var>, version <var class=Fa>versnum</var>; the client uses TCP/IP as a transport. The remote program is located at Internet address <var class=Fa>addr</var>. If <var class=Fa>addr-&gt;sin_port</var> is zero, then it is set to the actual port that the remote program is listening on (the remote <a class=Xr href=rpcbind.8.html>rpcbind(8)</a> service is consulted for this information). The <var class=Fa>sockp</var> argument is a socket; if it is <code class=Dv>RPC_ANYSOCK</code>, then this routine opens a new one and sets <var class=Fa>sockp</var>. Since TCP-based RPC uses buffered I/O, the user may specify the size of the send and receive buffers with the <var class=Fa>sendsz</var> and <var class=Fa>recvsz</var> arguments; values of zero choose suitable defaults. This routine returns <code class=Dv>NULL</code> if it fails.</p><p class=Pp></p></dd><dt><var class=Ft>CLIENT *</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>clntudp_create</code>(<var class=Fa>struct sockaddr_in *addr</var>, <var class=Fa>u_long prognum</var>, <var class=Fa>u_long versnum</var>, <var class=Fa>struct timeval wait</var>, <var class=Fa>int *sockp</var>);</dt><dd><p class=Pp>This routine creates an RPC client for the remote program <var class=Fa>prognum</var>, version <var class=Fa>versnum</var>; the client uses UDP/IP as a transport. The remote program is located at Internet address <var class=Fa>addr</var>. If <var class=Fa>addr-&gt;sin_port</var> is zero, then it is set to actual port that the remote program is listening on (the remote <a class=Xr href=rpcbind.8.html>rpcbind(8)</a> service is consulted for this information). The <var class=Fa>sockp</var> argument is a socket; if it is <code class=Dv>RPC_ANYSOCK</code>, then this routine opens a new one and sets <var class=Fa>sockp</var>. The UDP transport resends the call message in intervals of <var class=Fa>wait</var> time until a response is received or until the call times out. The total time for the call to time out is specified by <code class=Fn>clnt_call</code>().</p><p class=Pp>Warning: since UDP-based RPC messages can only hold up to 8 Kbytes of encoded data, this transport cannot be used for procedures that take large arguments or return huge results.</p><p class=Pp></p></dd><dt><var class=Ft>CLIENT *</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>clntudp_bufcreate</code>(<var class=Fa>struct sockaddr_in *addr</var>, <var class=Fa>u_long prognum</var>, <var class=Fa>u_long versnum</var>, <var class=Fa>struct timeval wait</var>, <var class=Fa>int *sockp</var>, <var class=Fa>unsigned int sendsize</var>, <var class=Fa>unsigned int recosize</var>);</dt><dd><p class=Pp>This routine creates an RPC client for the remote program <var class=Fa>prognum</var>, on <var class=Fa>versnum</var>; the client uses UDP/IP as a transport. The remote program is located at Internet address <var class=Fa>addr</var>. If <var class=Fa>addr-&gt;sin_port</var> is zero, then it is set to actual port that the remote program is listening on (the remote <a class=Xr href=rpcbind.8.html>rpcbind(8)</a> service is consulted for this information). The <var class=Fa>sockp</var> argument is a socket; if it is <code class=Dv>RPC_ANYSOCK</code>, then this routine opens a new one and sets <var class=Fa>sockp</var>. The UDP transport resends the call message in intervals of <var class=Fa>wait</var> time until a response is received or until the call times out. The total time for the call to time out is specified by <code class=Fn>clnt_call</code>().</p><p class=Pp>This allows the user to specify the maximum packet size for sending and receiving UDP-based RPC messages.</p><p class=Pp></p></dd><dt><var class=Ft>CLIENT *</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>clntunix_create</code>(<var class=Fa>struct sockaddr_un *raddr</var>, <var class=Fa>u_long prognum</var>, <var class=Fa>u_long versnum</var>, <var class=Fa>int *sockp</var>, <var class=Fa>u_int sendsz</var>, <var class=Fa>u_int recvsz</var>);</dt><dd><p class=Pp>This routine creates an RPC client for the local program <var class=Fa>prognum</var>, version <var class=Fa>versnum</var>; the client uses <span class=Ux>UNIX</span>-domain sockets as a transport. The local program is located at the <var class=Fa>*raddr</var>. The <var class=Fa>sockp</var> argument is a socket; if it is <code class=Dv>RPC_ANYSOCK</code>, then this routine opens a new one and sets <var class=Fa>sockp</var>. Since <span class=Ux>UNIX</span>-based RPC uses buffered I/O, the user may specify the size of the send and receive buffers with the <var class=Fa>sendsz</var> and <var class=Fa>recvsz</var> arguments; values of zero choose suitable defaults. This routine returns <code class=Dv>NULL</code> if it fails.</p><p class=Pp></p></dd><dt><var class=Ft>int</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>get_myaddress</code>(<var class=Fa>struct sockaddr_in *addr</var>)</dt><dd><p class=Pp>Stuff the machine's IP address into <var class=Fa>addr</var>, without consulting the library routines that deal with <span class=Pa>/etc/hosts</span>. The port number is always set to <code class=Fn>htons</code>(<var class=Fa>PMAPPORT</var>). Returns zero on success, non-zero on failure.</p><p class=Pp></p></dd><dt><var class=Ft>struct pmaplist *</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>pmap_getmaps</code>(<var class=Fa>struct sockaddr_in *addr</var>)</dt><dd><p class=Pp>A user interface to the <a class=Xr href=rpcbind.8.html>rpcbind(8)</a> service, which returns a list of the current RPC program-to-port mappings on the host located at IP address <var class=Fa>addr</var>. This routine can return <code class=Dv>NULL</code>. The command “<code class=Nm>rpcinfo</code><code class=Fl>-p</code>” uses this routine.</p><p class=Pp></p></dd><dt><var class=Ft>u_short</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>pmap_getport</code>(<var class=Fa>struct sockaddr_in *addr</var>, <var class=Fa>u_long prognum</var>, <var class=Fa>u_long versnum</var>, <var class=Fa>u_long protocol</var>);</dt><dd><p class=Pp>A user interface to the <a class=Xr href=rpcbind.8.html>rpcbind(8)</a> service, which returns the port number on which waits a service that supports program number <var class=Fa>prognum</var>, version <var class=Fa>versnum</var>, and speaks the transport protocol associated with <var class=Fa>protocol</var>. The value of <var class=Fa>protocol</var> is most likely <code class=Dv>IPPROTO_UDP</code> or <code class=Dv>IPPROTO_TCP</code>. A return value of zero means that the mapping does not exist or that the RPC system failed to contact the remote <a class=Xr href=rpcbind.8.html>rpcbind(8)</a> service. In the latter case, the global variable <var class=Va>rpc_createerr</var> contains the RPC status.</p><p class=Pp></p></dd><dt><var class=Ft>enum clnt_stat</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>pmap_rmtcall</code>(<var class=Fa>struct sockaddr_in *addr</var>, <var class=Fa>u_long prognum</var>, <var class=Fa>u_long versnum</var>, <var class=Fa>u_long procnum</var>, <var class=Fa>xdrproc_t inproc</var>, <var class=Fa>char *in</var>, <var class=Fa>xdrproc_t outproc</var>, <var class=Fa>char *out</var>, <var class=Fa>struct timeval tout</var>, <var class=Fa>u_long *portp</var>);</dt><dd><p class=Pp>A user interface to the <a class=Xr href=rpcbind.8.html>rpcbind(8)</a> service, which instructs <a class=Xr href=rpcbind.8.html>rpcbind(8)</a> on the host at IP address <var class=Fa>addr</var> to make an RPC call on your behalf to a procedure on that host. The <var class=Fa>portp</var> argument will be modified to the program's port number if the procedure succeeds. The definitions of other arguments are discussed in <code class=Fn>callrpc</code>() and <code class=Fn>clnt_call</code>(). This procedure should be used for a “ping” and nothing else. See also <code class=Fn>clnt_broadcast</code>().</p><p class=Pp></p></dd><dt><var class=Ft>bool_t</var><code class=Fn>pmap_set</code>(<var class=Fa>u_long prognum</var>, <var class=Fa>u_long versnum</var>, <var class=Fa>u_long protocol</var>, <var class=Fa>u_short port</var>)</dt><dd><p class=Pp>A user interface to the <a class=Xr href=rpcbind.8.html>rpcbind(8)</a> service, which establishes a mapping between the triple (<var class=Fa>prognum</var>, <var class=Fa>versnum</var>, <var class=Fa>protocol</var>) and <var class=Fa>port</var> on the machine's <a class=Xr href=rpcbind.8.html>rpcbind(8)</a> service. The value of <var class=Fa>protocol</var> is most likely <code class=Dv>IPPROTO_UDP</code> or <code class=Dv>IPPROTO_TCP</code>. This routine returns one if it succeeds, zero otherwise. Automatically done by <code class=Fn>svc_register</code>().</p><p class=Pp></p></dd><dt><var class=Ft>bool_t</var><code class=Fn>pmap_unset</code>(<var class=Fa>u_long prognum</var>, <var class=Fa>u_long versnum</var>)</dt><dd><p class=Pp>A user interface to the <a class=Xr href=rpcbind.8.html>rpcbind(8)</a> service, which destroys all mapping between the triple (<var class=Fa>prognum</var>, <var class=Fa>versnum</var>, <var class=Fa>*</var>) and <var class=Fa>ports</var> on the machine's <a class=Xr href=rpcbind.8.html>rpcbind(8)</a> service. This routine returns one if it succeeds, zero otherwise.</p><p class=Pp></p></dd><dt><var class=Ft>bool_t</var><code class=Fn>registerrpc</code>(<var class=Fa>u_long prognum</var>, <var class=Fa>u_long versnum</var>, <var class=Fa>u_long procnum</var>, <var class=Fa>char *(*procname)(void)</var>, <var class=Fa>xdrproc_t inproc</var>, <var class=Fa>xdrproc_t outproc</var>);</dt><dd><p class=Pp>Register procedure <var class=Fa>procname</var> with the RPC service package. If a request arrives for program <var class=Fa>prognum</var>, version <var class=Fa>versnum</var>, and procedure <var class=Fa>procnum</var>, <var class=Fa>procname</var> is called with a pointer to its argument(s); <var class=Fa>progname</var> should return a pointer to its static result(s); <var class=Fa>inproc</var> is used to decode the arguments while <var class=Fa>outproc</var> is used to encode the results. This routine returns zero if the registration succeeded, -1 otherwise.</p><p class=Pp>Warning: remote procedures registered in this form are accessed using the UDP/IP transport; see <code class=Fn>svcudp_create</code>() for restrictions.</p><p class=Pp></p></dd><dt><var class=Vt>struct rpc_createerr rpc_createerr</var>;</dt><dd><p class=Pp>A global variable whose value is set by any RPC client creation routine that does not succeed. Use the routine <code class=Fn>clnt_pcreateerror</code>() to print the reason why.</p><p class=Pp></p></dd><dt><var class=Ft>bool_t</var><code class=Fn>svc_destroy</code>(<var class=Fa>SVCXPRT * xprt</var>)</dt><dd><p class=Pp>A macro that destroys the RPC service transport handle, <var class=Fa>xprt</var>. Destruction usually involves deallocation of private data structures, including <var class=Fa>xprt</var> itself. Use of <var class=Fa>xprt</var> is undefined after calling this routine.</p><p class=Pp></p></dd><dt><var class=Vt>fd_set svc_fdset</var>;</dt><dd><p class=Pp>A global variable reflecting the RPC service side's read file descriptor bit mask; it is suitable as a template argument to the <a class=Xr href=select.2.html>select(2)</a> system call. This is only of interest if a service implementor does not call <code class=Fn>svc_run</code>(), but rather does his own asynchronous event processing. This variable is read-only (do not pass its address to <a class=Xr href=select.2.html>select(2)</a>!), yet it may change after calls to <code class=Fn>svc_getreqset</code>() or any creation routines. As well, note that if the process has descriptor limits which are extended beyond <code class=Dv>FD_SETSIZE</code>, this variable will only be usable for the first <code class=Dv>FD_SETSIZE</code> descriptors.</p><p class=Pp></p></dd><dt><var class=Vt>int svc_fds</var>;</dt><dd><p class=Pp>Similar to <var class=Va>svc_fdset</var>, but limited to 32 descriptors. This interface is obsoleted by <var class=Va>svc_fdset</var>.</p><p class=Pp></p></dd><dt><var class=Ft>bool_t</var><code class=Fn>svc_freeargs</code>(<var class=Fa>SVCXPRT *xprt</var>, <var class=Fa>xdrproc_t inproc</var>, <var class=Fa>char *in</var>)</dt><dd><p class=Pp>A macro that frees any data allocated by the RPC/XDR system when it decoded the arguments to a service procedure using <code class=Fn>svc_getargs</code>(). This routine returns 1 if the results were successfully freed, and zero otherwise.</p><p class=Pp></p></dd><dt><var class=Ft>bool_t</var><code class=Fn>svc_getargs</code>(<var class=Fa>SVCXPRT *xprt</var>, <var class=Fa>xdrproc_t inproc</var>, <var class=Fa>char *in</var>)</dt><dd><p class=Pp>A macro that decodes the arguments of an RPC request associated with the RPC service transport handle, <var class=Fa>xprt</var>. The <var class=Fa>in</var> argument is the address where the arguments will be placed; <var class=Fa>inproc</var> is the XDR routine used to decode the arguments. This routine returns one if decoding succeeds, and zero otherwise.</p><p class=Pp></p></dd><dt><var class=Ft>struct sockaddr_in *</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>svc_getcaller</code>(<var class=Fa>SVCXPRT *xprt</var>)</dt><dd><p class=Pp>The approved way of getting the network address of the caller of a procedure associated with the RPC service transport handle, <var class=Fa>xprt</var>.</p><p class=Pp></p></dd><dt><var class=Ft>void</var><code class=Fn>svc_getreqset</code>(<var class=Fa>fd_set *rdfds</var>)</dt><dd><p class=Pp>This routine is only of interest if a service implementor does not call <code class=Fn>svc_run</code>(), but instead implements custom asynchronous event processing. It is called when the <a class=Xr href=select.2.html>select(2)</a> system call has determined that an RPC request has arrived on some RPC socket(s); <var class=Fa>rdfds</var> is the resultant read file descriptor bit mask. The routine returns when all sockets associated with the value of <var class=Fa>rdfds</var> have been serviced.</p><p class=Pp></p></dd><dt><var class=Ft>void</var><code class=Fn>svc_getreq</code>(<var class=Fa>int rdfds</var>)</dt><dd><p class=Pp>Similar to <code class=Fn>svc_getreqset</code>(), but limited to 32 descriptors. This interface is obsoleted by <code class=Fn>svc_getreqset</code>().</p><p class=Pp></p></dd><dt><var class=Ft>bool_t</var><code class=Fn>svc_register</code>(<var class=Fa>SVCXPRT *xprt</var>, <var class=Fa>u_long prognum</var>, <var class=Fa>u_long versnum</var>, <var class=Fa>void (*dispatch)(struct svc_req *, SVCXPRT *)</var>, <var class=Fa>int protocol</var>);</dt><dd><p class=Pp>Associates <var class=Fa>prognum</var> and <var class=Fa>versnum</var> with the service dispatch procedure, <code class=Fn>dispatch</code>(). If <var class=Fa>protocol</var> is zero, the service is not registered with the <a class=Xr href=rpcbind.8.html>rpcbind(8)</a> service. If <var class=Fa>protocol</var> is non-zero, then a mapping of the triple (<var class=Fa>prognum</var>, <var class=Fa>versnum</var>, <var class=Fa>protocol</var>) to <var class=Fa>xprt-&gt;xp_port</var> is established with the local <a class=Xr href=rpcbind.8.html>rpcbind(8)</a> service (generally <var class=Fa>protocol</var> is zero, <code class=Dv>IPPROTO_UDP</code> or <code class=Dv>IPPROTO_TCP</code>). The procedure <code class=Fn>dispatch</code>() has the following form:</p><div class="Bd Pp Bd-indent"><var class=Ft>bool_t</var><code class=Fn>dispatch</code>(<var class=Fa>struct svc_req *request</var>, <var class=Fa>SVCXPRT *xprt</var>)</div><p class=Pp>The <code class=Fn>svc_register</code>() routine returns one if it succeeds, and zero otherwise.</p><p class=Pp></p></dd><dt><code class=Fn>svc_run</code>()</dt><dd><p class=Pp>This routine never returns. It waits for RPC requests to arrive, and calls the appropriate service procedure using <code class=Fn>svc_getreq</code>() when one arrives. This procedure is usually waiting for a <a class=Xr href=select.2.html>select(2)</a> system call to return.</p><p class=Pp></p></dd><dt><var class=Ft>bool_t</var><code class=Fn>svc_sendreply</code>(<var class=Fa>SVCXPRT *xprt</var>, <var class=Fa>xdrproc_t outproc</var>, <var class=Fa>char *out</var>)</dt><dd><p class=Pp>Called by an RPC service's dispatch routine to send the results of a remote procedure call. The <var class=Fa>xprt</var> argument is the request's associated transport handle; <var class=Fa>outproc</var> is the XDR routine which is used to encode the results; and <var class=Fa>out</var> is the address of the results. This routine returns one if it succeeds, zero otherwise.</p><p class=Pp></p></dd><dt><var class=Ft>void</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>svc_unregister</code>(<var class=Fa>u_long prognum</var>, <var class=Fa>u_long versnum</var>)</dt><dd><p class=Pp>Remove all mapping of the double (<var class=Fa>prognum</var>, <var class=Fa>versnum</var>) to dispatch routines, and of the triple (<var class=Fa>prognum</var>, <var class=Fa>versnum</var>, <var class=Fa>*</var>) to port number.</p><p class=Pp></p></dd><dt><var class=Ft>void</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>svcerr_auth</code>(<var class=Fa>SVCXPRT *xprt</var>, <var class=Fa>enum auth_stat why</var>)</dt><dd><p class=Pp>Called by a service dispatch routine that refuses to perform a remote procedure call due to an authentication error.</p><p class=Pp></p></dd><dt><var class=Ft>void</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>svcerr_decode</code>(<var class=Fa>SVCXPRT *xprt</var>)</dt><dd><p class=Pp>Called by a service dispatch routine that cannot successfully decode its arguments. See also <code class=Fn>svc_getargs</code>().</p><p class=Pp></p></dd><dt><var class=Ft>void</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>svcerr_noproc</code>(<var class=Fa>SVCXPRT *xprt</var>)</dt><dd><p class=Pp>Called by a service dispatch routine that does not implement the procedure number that the caller requests.</p><p class=Pp></p></dd><dt><var class=Ft>void</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>svcerr_noprog</code>(<var class=Fa>SVCXPRT *xprt</var>)</dt><dd><p class=Pp>Called when the desired program is not registered with the RPC package. Service implementors usually do not need this routine.</p><p class=Pp></p></dd><dt><var class=Ft>void</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>svcerr_progvers</code>(<var class=Fa>SVCXPRT *xprt</var>, <var class=Fa>u_long low_vers</var>, <var class=Fa>u_long high_vers</var>)</dt><dd><p class=Pp>Called when the desired version of a program is not registered with the RPC package. Service implementors usually do not need this routine.</p><p class=Pp></p></dd><dt><var class=Ft>void</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>svcerr_systemerr</code>(<var class=Fa>SVCXPRT *xprt</var>)</dt><dd><p class=Pp>Called by a service dispatch routine when it detects a system error not covered by any particular protocol. For example, if a service can no longer allocate storage, it may call this routine.</p><p class=Pp></p></dd><dt><var class=Ft>void</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>svcerr_weakauth</code>(<var class=Fa>SVCXPRT *xprt</var>)</dt><dd><p class=Pp>Called by a service dispatch routine that refuses to perform a remote procedure call due to insufficient authentication arguments. The routine calls <code class=Fn>svcerr_auth</code>(<var class=Fa>xprt</var>, <var class=Fa>AUTH_TOOWEAK</var>).</p><p class=Pp></p></dd><dt><var class=Ft>SVCXPRT *</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>svcraw_create</code>(<var class=Fa>void</var>)</dt><dd><p class=Pp>This routine creates a toy RPC service transport, to which it returns a pointer. The transport is really a buffer within the process's address space, so the corresponding RPC client should live in the same address space; see <code class=Fn>clntraw_create</code>(). This routine allows simulation of RPC and acquisition of RPC overheads (such as round trip times), without any kernel interference. This routine returns <code class=Dv>NULL</code> if it fails.</p><p class=Pp></p></dd><dt><var class=Ft>SVCXPRT *</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>svctcp_create</code>(<var class=Fa>int sock</var>, <var class=Fa>u_int send_buf_size</var>, <var class=Fa>u_int recv_buf_size</var>)</dt><dd><p class=Pp>This routine creates a TCP/IP-based RPC service transport, to which it returns a pointer. The transport is associated with the socket <var class=Fa>sock</var>, which may be <code class=Dv>RPC_ANYSOCK</code>, in which case a new socket is created. If the socket is not bound to a local TCP port, then this routine binds it to an arbitrary port. Upon completion, <var class=Fa>xprt-&gt;xp_fd</var> is the transport's socket descriptor, and <var class=Fa>xprt-&gt;xp_port</var> is the transport's port number. This routine returns <code class=Dv>NULL</code> if it fails. Since TCP-based RPC uses buffered I/O, users may specify the size of buffers; values of zero choose suitable defaults.</p><p class=Pp></p></dd><dt><var class=Ft>SVCXPRT *</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>svcunix_create</code>(<var class=Fa>int sock</var>, <var class=Fa>u_int send_buf_size</var>, <var class=Fa>u_int recv_buf_size</var>, <var class=Fa>char *path</var>)</dt><dd><p class=Pp>This routine creates a <span class=Ux>UNIX</span>-based RPC service transport, to which it returns a pointer. The transport is associated with the socket <var class=Fa>sock</var>, which may be <code class=Dv>RPC_ANYSOCK</code>, in which case a new socket is created. The <var class=Fa>*path</var> argument is a variable-length file system pathname of at most 104 characters. This file is <i class=Em>not</i> removed when the socket is closed. The <a class=Xr href=unlink.2.html>unlink(2)</a> system call must be used to remove the file. Upon completion, <var class=Fa>xprt-&gt;xp_fd</var> is the transport's socket descriptor. This routine returns <code class=Dv>NULL</code> if it fails. Since <span class=Ux>UNIX</span>-based RPC uses buffered I/O, users may specify the size of buffers; values of zero choose suitable defaults.</p><p class=Pp></p></dd><dt><var class=Ft>SVCXPRT *</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>svcunixfd_create</code>(<var class=Fa>int fd</var>, <var class=Fa>u_int sendsize</var>, <var class=Fa>u_int recvsize</var>)</dt><dd><p class=Pp>Create a service on top of any open descriptor. The <var class=Fa>sendsize</var> and <var class=Fa>recvsize</var> arguments indicate sizes for the send and receive buffers. If they are zero, a reasonable default is chosen.</p><p class=Pp></p></dd><dt><var class=Ft>SVCXPRT *</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>svcfd_create</code>(<var class=Fa>int fd</var>, <var class=Fa>u_int sendsize</var>, <var class=Fa>u_int recvsize</var>)</dt><dd><p class=Pp>Create a service on top of any open descriptor. Typically, this descriptor is a connected socket for a stream protocol such as TCP. The <var class=Fa>sendsize</var> and <var class=Fa>recvsize</var> arguments indicate sizes for the send and receive buffers. If they are zero, a reasonable default is chosen.</p><p class=Pp></p></dd><dt><var class=Ft>SVCXPRT *</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>svcudp_bufcreate</code>(<var class=Fa>int sock</var>, <var class=Fa>u_int sendsize</var>, <var class=Fa>u_int recvsize</var>)</dt><dd><p class=Pp>This routine creates a UDP/IP-based RPC service transport, to which it returns a pointer. The transport is associated with the socket <var class=Fa>sock</var>, which may be <code class=Dv>RPC_ANYSOCK</code>, in which case a new socket is created. If the socket is not bound to a local UDP port, then this routine binds it to an arbitrary port. Upon completion, <var class=Fa>xprt-&gt;xp_fd</var> is the transport's socket descriptor, and <var class=Fa>xprt-&gt;xp_port</var> is the transport's port number. This routine returns <code class=Dv>NULL</code> if it fails.</p><p class=Pp>This allows the user to specify the maximum packet size for sending and receiving UDP-based RPC messages.</p><p class=Pp></p></dd><dt><var class=Ft>bool_t</var><code class=Fn>xdr_accepted_reply</code>(<var class=Fa>XDR *xdrs</var>, <var class=Fa>struct accepted_reply *ar</var>)</dt><dd><p class=Pp>Used for encoding RPC reply messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.</p><p class=Pp></p></dd><dt><var class=Ft>bool_t</var><code class=Fn>xdr_authunix_parms</code>(<var class=Fa>XDR *xdrs</var>, <var class=Fa>struct authunix_parms *aupp</var>)</dt><dd><p class=Pp>Used for describing <span class=Ux>UNIX</span> credentials. This routine is useful for users who wish to generate these credentials without using the RPC authentication package.</p><p class=Pp></p></dd><dt><var class=Ft>void</var></dt><dd style="width: auto;"> </dd><dt><var class=Ft>bool_t</var><code class=Fn>xdr_callhdr</code>(<var class=Fa>XDR *xdrs</var>, <var class=Fa>struct rpc_msg *chdr</var>)</dt><dd><p class=Pp>Used for describing RPC call header messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.</p><p class=Pp></p></dd><dt><var class=Ft>bool_t</var><code class=Fn>xdr_callmsg</code>(<var class=Fa>XDR *xdrs</var>, <var class=Fa>struct rpc_msg *cmsg</var>)</dt><dd><p class=Pp>Used for describing RPC call messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.</p><p class=Pp></p></dd><dt><var class=Ft>bool_t</var><code class=Fn>xdr_opaque_auth</code>(<var class=Fa>XDR *xdrs</var>, <var class=Fa>struct opaque_auth *ap</var>)</dt><dd><p class=Pp>Used for describing RPC authentication information messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.</p><p class=Pp></p></dd><dt><var class=Vt>struct pmap</var>;</dt><dd style="width: auto;"> </dd><dt><var class=Ft>bool_t</var><code class=Fn>xdr_pmap</code>(<var class=Fa>XDR *xdrs</var>, <var class=Fa>struct pmap *regs</var>)</dt><dd><p class=Pp>Used for describing arguments to various <a class=Xr href=rpcbind.8.html>rpcbind(8)</a> procedures, externally. This routine is useful for users who wish to generate these arguments without using the <code class=Fn>pmap_*</code>() interface.</p><p class=Pp></p></dd><dt><var class=Ft>bool_t</var><code class=Fn>xdr_pmaplist</code>(<var class=Fa>XDR *xdrs</var>, <var class=Fa>struct pmaplist **rp</var>)</dt><dd><p class=Pp>Used for describing a list of port mappings, externally. This routine is useful for users who wish to generate these arguments without using the <code class=Fn>pmap_*</code>() interface.</p><p class=Pp></p></dd><dt><var class=Ft>bool_t</var><code class=Fn>xdr_rejected_reply</code>(<var class=Fa>XDR *xdrs</var>, <var class=Fa>struct rejected_reply *rr</var>)</dt><dd><p class=Pp>Used for describing RPC reply messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.</p><p class=Pp></p></dd><dt><var class=Ft>bool_t</var><code class=Fn>xdr_replymsg</code>(<var class=Fa>XDR *xdrs</var>, <var class=Fa>struct rpc_msg *rmsg</var>)</dt><dd><p class=Pp>Used for describing RPC reply messages. This routine is useful for users who wish to generate RPC style messages without using the RPC package.</p><p class=Pp></p></dd><dt><var class=Ft>void</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>xprt_register</code>(<var class=Fa>SVCXPRT *xprt</var>)</dt><dd><p class=Pp>After RPC service transport handles are created, they should register themselves with the RPC service package. This routine modifies the global variable <var class=Va>svc_fds</var>. Service implementors usually do not need this routine.</p><p class=Pp></p></dd><dt><var class=Ft>void</var></dt><dd style="width: auto;"> </dd><dt><code class=Fn>xprt_unregister</code>(<var class=Fa>SVCXPRT *xprt</var>)</dt><dd><p class=Pp>Before an RPC service transport handle is destroyed, it should unregister itself with the RPC service package. This routine modifies the global variable <var class=Va>svc_fds</var>. Service implementors usually do not need this routine.</p></dd></dl></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=rpc_secure.3.html>rpc_secure(3)</a>, <a class=Xr href=xdr.3.html>xdr(3)</a><p class=Pp><cite class=Rs><span class=RsT>Remote Procedure Calls: Protocol Specification</span>.</cite></p><p class=Pp><cite class=Rs><span class=RsT>Remote Procedure Call Programming Guide</span>.</cite></p><p class=Pp><cite class=Rs><span class=RsT>rpcgen Programming Guide</span>.</cite></p><p class=Pp><cite class=Rs><span class=RsT>RPC: Remote Procedure Call Protocol Specification</span>, <span class=RsQ>Sun Microsystems, Inc., USC-ISI</span>, <span class=RsO>RFC1050</span>.</cite></p></section></div><table class=foot><tr><td class=foot-date>February 16, 1988</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>