<!DOCTYPE html>
<html><head><meta charset=utf-8><title>libusb_get_port_number(3)</title><keywords content=man,libusb_get_port_number></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>libusb_get_port_number(3)</h1><table class=head><tr><td class=head-ltitle>LIBUSB(3)</td><td class=head-vol>FreeBSD Library Functions Manual</td><td class=head-rtitle>LIBUSB(3)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>libusb</code> — <div class=Nd>USB access library</div></section><section class=Sh><h2 class=Sh id=LIBRARY><a class=permalink href=#LIBRARY>LIBRARY</a></h2> USB access library (libusb, -lusb) </section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/libusb.h.html>libusb.h</a>&gt;</code></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> The <code class=Nm>libusb</code> library contains interfaces for directly managing a usb device. The current implementation supports v1.0 of the libusb API. </section><section class=Sh><h2 class=Sh id=LIBRARY_INITIALISATION_AND_DEINITIALISATION><a class=permalink href=#LIBRARY_INITIALISATION_AND_DEINITIALISATION>LIBRARY INITIALISATION AND DEINITIALISATION</a></h2><var class=Ft>const struct libusb_version *</var><code class=Fn>libusb_get_version</code>(<var class=Fa>void</var>) This function returns version information about LibUSB. <p class=Pp><var class=Ft>int</var><code class=Fn>libusb_init</code>(<var class=Fa>libusb_context **ctx</var>) This function initialises libusb. It must be called at the beginning of the program, before other libusb routines are used. This function returns 0 on success or LIBUSB_ERROR on failure.</p><p class=Pp><var class=Ft>void</var><code class=Fn>libusb_exit</code>(<var class=Fa>libusb_context *ctx</var>) Deinitialise libusb. Must be called at the end of the application. Other libusb routines may not be called after this function.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_has_capability</code>(<var class=Fa>uint32_t capability</var>) This function checks the runtime capabilities of <code class=Nm>libusb</code>. This function will return non-zero if the given <var class=Fa>capability</var> is supported, 0 if it is not supported. The valid values for <var class=Fa>capability</var> are:</p><div class=Bd-indent><dl class=Bl-tag><dt><var class=Va>LIBUSB_CAP_HAS_CAPABILITY</var></dt><dd><code class=Nm>libusb</code> supports <code class=Fn>libusb_has_capability</code>().</dd><dt><var class=Va>LIBUSB_CAP_HAS_HOTPLUG</var></dt><dd><code class=Nm>libusb</code> supports hotplug notifications.</dd><dt><var class=Va>LIBUSB_CAP_HAS_HID_ACCESS</var></dt><dd><code class=Nm>libusb</code> can access HID devices without requiring user intervention.</dd><dt><var class=Va>LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER</var></dt><dd><code class=Nm>libusb</code> supports detaching of the default USB driver with <code class=Fn>libusb_detach_kernel_driver</code>().</dd></dl></div><p class=Pp><var class=Ft>const char *</var><code class=Fn>libusb_strerror</code>(<var class=Fa>int code</var>) Get the ASCII representation of the error given by the <var class=Fa>code</var> argument. This function does not return NULL.</p><p class=Pp><var class=Ft>const char *</var><code class=Fn>libusb_error_name</code>(<var class=Fa>int code</var>) Get the ASCII representation of the error enum given by the <var class=Fa>code</var> argument. This function does not return NULL.</p><p class=Pp><var class=Ft>void</var><code class=Fn>libusb_set_debug</code>(<var class=Fa>libusb_context *ctx</var>, <var class=Fa>int level</var>) Set the debug level to <var class=Fa>level</var>.</p><p class=Pp><var class=Ft>ssize_t</var><code class=Fn>libusb_get_device_list</code>(<var class=Fa>libusb_context *ctx</var>, <var class=Fa>libusb_device ***list</var>) Populate <var class=Fa>list</var> with the list of usb devices available, adding a reference to each device in the list. All the list entries created by this function must have their reference counter decremented when you are done with them, and the list itself must be freed. This function returns the number of devices in the list or a LIBUSB_ERROR code.</p><p class=Pp><var class=Ft>void</var><code class=Fn>libusb_free_device_list</code>(<var class=Fa>libusb_device **list</var>, <var class=Fa>int unref_devices</var>) Free the list of devices discovered by libusb_get_device_list. If <var class=Fa>unref_device</var> is set to 1 all devices in the list have their reference counter decremented once.</p><p class=Pp><var class=Ft>uint8_t</var><code class=Fn>libusb_get_bus_number</code>(<var class=Fa>libusb_device *dev</var>) Returns the number of the bus contained by the device <var class=Fa>dev</var>.</p><p class=Pp><var class=Ft>uint8_t</var><code class=Fn>libusb_get_port_number</code>(<var class=Fa>libusb_device *dev</var>) Returns the port number which the device given by <var class=Fa>dev</var> is attached to.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_get_port_numbers</code>(<var class=Fa>libusb_device *dev</var>, <var class=Fa>uint8_t *buf</var>, <var class=Fa>uint8_t bufsize</var>) Stores, in the buffer <var class=Fa>buf</var> of size <var class=Fa>bufsize</var>, the list of all port numbers from root for the device <var class=Fa>dev</var>.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_get_port_path</code>(<var class=Fa>libusb_context *ctx</var>, <var class=Fa>libusb_device *dev</var>, <var class=Fa>uint8_t *buf</var>, <var class=Fa>uint8_t bufsize</var>) Deprecated function equivalent to libusb_get_port_numbers.</p><p class=Pp><var class=Ft>uint8_t</var><code class=Fn>libusb_get_device_address</code>(<var class=Fa>libusb_device *dev</var>) Returns the device_address contained by the device <var class=Fa>dev</var>.</p><p class=Pp><var class=Ft>enum libusb_speed</var><code class=Fn>libusb_get_device_speed</code>(<var class=Fa>libusb_device *dev</var>) Returns the wire speed at which the device is connected. See the LIBUSB_SPEED_XXX enums for more information. LIBUSB_SPEED_UNKNOWN is returned in case of unknown wire speed.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_get_max_packet_size</code>(<var class=Fa>libusb_device *dev</var>, <var class=Fa>unsigned char endpoint</var>) Returns the wMaxPacketSize value on success, LIBUSB_ERROR_NOT_FOUND if the endpoint does not exist and LIBUSB_ERROR_OTHERS on other failure.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_get_max_iso_packet_size</code>(<var class=Fa>libusb_device *dev</var>, <var class=Fa>unsigned char endpoint</var>) Returns the packet size multiplied by the packet multiplier on success, LIBUSB_ERROR_NOT_FOUND if the endpoint does not exist and LIBUSB_ERROR_OTHERS on other failure.</p><p class=Pp><var class=Ft>libusb_device *</var><code class=Fn>libusb_ref_device</code>(<var class=Fa>libusb_device *dev</var>) Increment the reference counter of the device <var class=Fa>dev</var>.</p><p class=Pp><var class=Ft>void</var><code class=Fn>libusb_unref_device</code>(<var class=Fa>libusb_device *dev</var>) Decrement the reference counter of the device <var class=Fa>dev</var>.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_open</code>(<var class=Fa>libusb_device *dev</var>, <var class=Fa>libusb_device_handle **devh</var>) Open a device and obtain a device_handle. Returns 0 on success, LIBUSB_ERROR_NO_MEM on memory allocation problems, LIBUSB_ERROR_ACCESS on permissions problems, LIBUSB_ERROR_NO_DEVICE if the device has been disconnected and a LIBUSB_ERROR code on other errors.</p><p class=Pp><var class=Ft>libusb_device_handle *</var><code class=Fn>libusb_open_device_with_vid_pid</code>(<var class=Fa>libusb_context *ctx</var>, <var class=Fa>uint16_t vid</var>, <var class=Fa>uint16_t pid</var>) A convenience function to open a device by vendor and product IDs <var class=Fa>vid</var> and <var class=Fa>pid</var>. Returns NULL on error.</p><p class=Pp><var class=Ft>void</var><code class=Fn>libusb_close</code>(<var class=Fa>libusb_device_handle *devh</var>) Close a device handle.</p><p class=Pp><var class=Ft>libusb_device *</var><code class=Fn>libusb_get_device</code>(<var class=Fa>libusb_device_handle *devh</var>) Get the device contained by devh. Returns NULL on error.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_get_configuration</code>(<var class=Fa>libusb_device_handle *devh</var>, <var class=Fa>int *config</var>) Returns the value of the current configuration. Returns 0 on success, LIBUSB_ERROR_NO_DEVICE if the device has been disconnected and a LIBUSB_ERROR code on error.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_set_configuration</code>(<var class=Fa>libusb_device_handle *devh</var>, <var class=Fa>int config</var>) Set the active configuration to <var class=Fa>config</var> for the device contained by <var class=Fa>devh</var>. This function returns 0 on success, LIBUSB_ERROR_NOT_FOUND if the requested configuration does not exist, LIBUSB_ERROR_BUSY if the interfaces are currently claimed, LIBUSB_ERROR_NO_DEVICE if the device has been disconnected and a LIBUSB_ERROR code on failure.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_claim_interface</code>(<var class=Fa>libusb_device_handle *devh</var>, <var class=Fa>int interface_number</var>) Claim an interface in a given libusb_handle <var class=Fa>devh</var>. This is a non-blocking function. It returns 0 on success, LIBUSB_ERROR_NOT_FOUND if the requested interface does not exist, LIBUSB_ERROR_BUSY if a program or driver has claimed the interface, LIBUSB_ERROR_NO_DEVICE if the device has been disconnected and a LIBUSB_ERROR code on failure.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_release_interface</code>(<var class=Fa>libusb_device_handle *devh</var>, <var class=Fa>int interface_number</var>) This function releases an interface. All the claimed interfaces on a device must be released before closing the device. Returns 0 on success, LIBUSB_ERROR_NOT_FOUND if the interface was not claimed, LIBUSB_ERROR_NO_DEVICE if the device has been disconnected and LIBUSB_ERROR on failure.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_set_interface_alt_setting</code>(<var class=Fa>libusb_device_handle *dev</var>, <var class=Fa>int interface_number</var>, <var class=Fa>int alternate_setting</var>) Activate an alternate setting for an interface. Returns 0 on success, LIBUSB_ERROR_NOT_FOUND if the interface was not claimed or the requested setting does not exist, LIBUSB_ERROR_NO_DEVICE if the device has been disconnected and a LIBUSB_ERROR code on failure.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_clear_halt</code>(<var class=Fa>libusb_device_handle *devh</var>, <var class=Fa>unsigned char endpoint</var>) Clear an halt/stall for a endpoint. Returns 0 on success, LIBUSB_ERROR_NOT_FOUND if the endpoint does not exist, LIBUSB_ERROR_NO_DEVICE if the device has been disconnected and a LIBUSB_ERROR code on failure.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_reset_device</code>(<var class=Fa>libusb_device_handle *devh</var>) Perform an USB port reset for an usb device. Returns 0 on success, LIBUSB_ERROR_NOT_FOUND if re-enumeration is required or if the device has been disconnected and a LIBUSB_ERROR code on failure.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_check_connected</code>(<var class=Fa>libusb_device_handle *devh</var>) Test if the USB device is still connected. Returns 0 on success, LIBUSB_ERROR_NO_DEVICE if it has been disconnected and a LIBUSB_ERROR code on failure.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_kernel_driver_active</code>(<var class=Fa>libusb_device_handle *devh</var>, <var class=Fa>int interface</var>) Determine if a driver is active on a interface. Returns 0 if no kernel driver is active and 1 if a kernel driver is active, LIBUSB_ERROR_NO_DEVICE if the device has been disconnected and a LIBUSB_ERROR code on failure.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_get_driver</code>(<var class=Fa>libusb_device_handle *devh</var>, <var class=Fa>int interface</var>, <var class=Fa>char *name</var>, <var class=Fa>int namelen</var>) or <var class=Ft>int</var><code class=Fn>libusb_get_driver_np</code>(<var class=Fa>libusb_device_handle *devh</var>, <var class=Fa>int interface</var>, <var class=Fa>char *name</var>, <var class=Fa>int namelen</var>) Copy the name of the driver attached to the given <var class=Fa>device</var> and <var class=Fa>interface</var> into the buffer <var class=Fa>name</var> of length <var class=Fa>namelen</var>. Returns 0 on success, LIBUSB_ERROR_NOT_FOUND if no kernel driver is attached to the given interface and LIBUSB_ERROR_INVALID_PARAM if the interface does not exist. This function is non-portable. The buffer pointed to by <var class=Fa>name</var> is only zero terminated on success.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_detach_kernel_driver</code>(<var class=Fa>libusb_device_handle *devh</var>, <var class=Fa>int interface</var>) or <var class=Ft>int</var><code class=Fn>libusb_detach_kernel_driver_np</code>(<var class=Fa>libusb_device_handle *devh</var>, <var class=Fa>int interface</var>) Detach a kernel driver from an interface. This is needed to claim an interface already claimed by a kernel driver. Returns 0 on success, LIBUSB_ERROR_NOT_FOUND if no kernel driver was active, LIBUSB_ERROR_INVALID_PARAM if the interface does not exist, LIBUSB_ERROR_NO_DEVICE if the device has been disconnected and a LIBUSB_ERROR code on failure. This function is non-portable.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_attach_kernel_driver</code>(<var class=Fa>libusb_device_handle *devh</var>, <var class=Fa>int interface</var>) Re-attach an interface kernel driver that was previously detached. Returns 0 on success, LIBUSB_ERROR_INVALID_PARAM if the interface does not exist, LIBUSB_ERROR_NO_DEVICE if the device has been disconnected, LIBUSB_ERROR_BUSY if the driver cannot be attached because the interface is claimed by a program or driver and a LIBUSB_ERROR code on failure.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_set_auto_detach_kernel_driver</code>(<var class=Fa>libusb_device_handle *devh</var>, <var class=Fa>int enable</var>) This function enables automatic kernel interface driver detach when an interface is claimed. When the interface is restored the kernel driver is allowed to be re-attached. If the <var class=Fa>enable</var> argument is non-zero the feature is enabled. Else disabled. Returns 0 on success and a LIBUSB_ERROR code on failure.</p></section><section class=Sh><h2 class=Sh id=USB_DESCRIPTORS><a class=permalink href=#USB_DESCRIPTORS>USB DESCRIPTORS</a></h2><var class=Ft>int</var><code class=Fn>libusb_get_device_descriptor</code>(<var class=Fa>libusb_device *dev</var>, <var class=Fa>libusb_device_descriptor *desc</var>) Get the USB device descriptor for the device <var class=Fa>dev</var>. This is a non-blocking function. Returns 0 on success and a LIBUSB_ERROR code on failure. <p class=Pp><var class=Ft>int</var><code class=Fn>libusb_get_active_config_descriptor</code>(<var class=Fa>libusb_device *dev</var>, <var class=Fa>struct libusb_config_descriptor **config</var>) Get the USB configuration descriptor for the active configuration. Returns 0 on success, LIBUSB_ERROR_NOT_FOUND if the device is in an unconfigured state and a LIBUSB_ERROR code on error.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_get_config_descriptor</code>(<var class=Fa>libusb_device *dev</var>, <var class=Fa>uint8_t config_index</var>, <var class=Fa>libusb_config_descriptor **config</var>) Get a USB configuration descriptor based on its index <var class=Fa>idx</var>. Returns 0 on success, LIBUSB_ERROR_NOT_FOUND if the configuration does not exist and a LIBUSB_ERROR code on error.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_get_config_descriptor_by_value</code>(<var class=Fa>libusb_device *dev</var>, <var class=Fa>uint8 bConfigurationValue</var>, <var class=Fa>libusb_config_descriptor **config</var>) Get a USB configuration descriptor with a specific bConfigurationValue. This is a non-blocking function which does not send a request through the device. Returns 0 on success, LIBUSB_ERROR_NOT_FOUND if the configuration does not exist and a LIBUSB_ERROR code on failure.</p><p class=Pp><var class=Ft>void</var><code class=Fn>libusb_free_config_descriptor</code>(<var class=Fa>libusb_config_descriptor *config</var>) Free a configuration descriptor.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_get_string_descriptor</code>(<var class=Fa>libusb_device_handle *devh</var>, <var class=Fa>uint8_t desc_idx</var>, <var class=Fa>uint16_t langid</var>, <var class=Fa>unsigned char *data</var>, <var class=Fa>int length</var>) Retrieve a string descriptor in raw format. Returns the number of bytes actually transferred on success or a negative LIBUSB_ERROR code on failure.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_get_string_descriptor_ascii</code>(<var class=Fa>libusb_device_handle *devh</var>, <var class=Fa>uint8_t desc_idx</var>, <var class=Fa>unsigned char *data</var>, <var class=Fa>int length</var>) Retrieve a string descriptor in C style ASCII. Returns the positive number of bytes in the resulting ASCII string on success and a LIBUSB_ERROR code on failure.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_parse_ss_endpoint_comp</code>(<var class=Fa>const void *buf</var>, <var class=Fa>int len</var>, <var class=Fa>libusb_ss_endpoint_companion_descriptor **ep_comp</var>) This function parses the USB 3.0 endpoint companion descriptor in host endian format pointed to by <var class=Fa>buf</var> and having a length of <var class=Fa>len</var>. Typically these arguments are the extra and extra_length fields of the endpoint descriptor. On success the pointer to resulting descriptor is stored at the location given by <var class=Fa>ep_comp</var>. Returns zero on success and a LIBUSB_ERROR code on failure. On success the parsed USB 3.0 endpoint companion descriptor must be freed using the libusb_free_ss_endpoint_comp function.</p><p class=Pp><var class=Ft>void</var><code class=Fn>libusb_free_ss_endpoint_comp</code>(<var class=Fa>libusb_ss_endpoint_companion_descriptor *ep_comp</var>) This function is NULL safe and frees a parsed USB 3.0 endpoint companion descriptor given by <var class=Fa>ep_comp</var>.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_get_ss_endpoint_companion_descriptor</code>(<var class=Fa>struct libusb_context *ctx</var>, <var class=Fa>const struct libusb_endpoint_descriptor *endpoint</var>, <var class=Fa>struct libusb_ss_endpoint_companion_descriptor **ep_comp</var>) This function finds and parses the USB 3.0 endpoint companion descriptor given by <var class=Fa>endpoint</var>. Returns zero on success and a LIBUSB_ERROR code on failure. On success the parsed USB 3.0 endpoint companion descriptor must be freed using the libusb_free_ss_endpoint_companion_descriptor function.</p><p class=Pp><var class=Ft>void</var><code class=Fn>libusb_free_ss_endpoint_companion_descriptor</code>(<var class=Fa>struct libusb_ss_endpoint_companion_descriptor *ep_comp</var>) This function is NULL safe and frees a parsed USB 3.0 endpoint companion descriptor given by <var class=Fa>ep_comp</var>.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_get_bos_descriptor</code>(<var class=Fa>libusb_device_handle *handle</var>, <var class=Fa>struct libusb_bos_descriptor **bos</var>) This function queries the USB device given by <var class=Fa>handle</var> and stores a pointer to a parsed BOS descriptor into <var class=Fa>bos</var>. Returns zero on success and a LIBUSB_ERROR code on failure. On success the parsed BOS descriptor must be freed using the libusb_free_bos_descriptor function.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_parse_bos_descriptor</code>(<var class=Fa>const void *buf</var>, <var class=Fa>int len</var>, <var class=Fa>libusb_bos_descriptor **bos</var>) This function parses a Binary Object Store, BOS, descriptor into host endian format pointed to by <var class=Fa>buf</var> and having a length of <var class=Fa>len</var>. On success the pointer to resulting descriptor is stored at the location given by <var class=Fa>bos</var>. Returns zero on success and a LIBUSB_ERROR code on failure. On success the parsed BOS descriptor must be freed using the libusb_free_bos_descriptor function.</p><p class=Pp><var class=Ft>void</var><code class=Fn>libusb_free_bos_descriptor</code>(<var class=Fa>libusb_bos_descriptor *bos</var>) This function is NULL safe and frees a parsed BOS descriptor given by <var class=Fa>bos</var>.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_get_usb_2_0_extension_descriptor</code>(<var class=Fa>struct libusb_context *ctx</var>, <var class=Fa>struct libusb_bos_dev_capability_descriptor *dev_cap</var>, <var class=Fa>struct libusb_usb_2_0_extension_descriptor **usb_2_0_extension</var>) This function parses the USB 2.0 extension descriptor from the descriptor given by <var class=Fa>dev_cap</var> and stores a pointer to the parsed descriptor into <var class=Fa>usb_2_0_extension</var>. Returns zero on success and a LIBUSB_ERROR code on failure. On success the parsed USB 2.0 extension descriptor must be freed using the libusb_free_usb_2_0_extension_descriptor function.</p><p class=Pp><var class=Ft>void</var><code class=Fn>libusb_free_usb_2_0_extension_descriptor</code>(<var class=Fa>struct libusb_usb_2_0_extension_descriptor *usb_2_0_extension</var>) This function is NULL safe and frees a parsed USB 2.0 extension descriptor given by <var class=Fa>usb_2_0_extension</var>.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_get_ss_usb_device_capability_descriptor</code>(<var class=Fa>struct libusb_context *ctx</var>, <var class=Fa>struct libusb_bos_dev_capability_descriptor *dev_cap</var>, <var class=Fa>struct libusb_ss_usb_device_capability_descriptor **ss_usb_device_capability</var>) This function parses the SuperSpeed device capability descriptor from the descriptor given by <var class=Fa>dev_cap</var> and stores a pointer to the parsed descriptor into <var class=Fa>ss_usb_device_capability</var>. Returns zero on success and a LIBUSB_ERROR code on failure. On success the parsed SuperSpeed device capability descriptor must be freed using the libusb_free_ss_usb_device_capability_descriptor function.</p><p class=Pp><var class=Ft>void</var><code class=Fn>libusb_free_ss_usb_device_capability_descriptor</code>(<var class=Fa>struct libusb_ss_usb_device_capability_descriptor *ss_usb_device_capability</var>) This function is NULL safe and frees a parsed SuperSpeed device capability descriptor given by <var class=Fa>ss_usb_device_capability</var>.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_get_container_id_descriptor</code>(<var class=Fa>struct libusb_context *ctx</var>, <var class=Fa>struct libusb_bos_dev_capability_descriptor *dev_cap</var>, <var class=Fa>struct libusb_container_id_descriptor **container_id</var>) This function parses the container ID descriptor from the descriptor given by <var class=Fa>dev_cap</var> and stores a pointer to the parsed descriptor into <var class=Fa>container_id</var>. Returns zero on success and a LIBUSB_ERROR code on failure. On success the parsed container ID descriptor must be freed using the libusb_free_container_id_descriptor function.</p><p class=Pp><var class=Ft>void</var><code class=Fn>libusb_free_container_id_descriptor</code>(<var class=Fa>struct libusb_container_id_descriptor *container_id</var>) This function is NULL safe and frees a parsed container ID descriptor given by <var class=Fa>container_id</var>.</p></section><section class=Sh><h2 class=Sh id=USB_ASYNCHRONOUS_I/O><a class=permalink href=#USB_ASYNCHRONOUS_I/O>USB ASYNCHRONOUS I/O</a></h2><var class=Ft>struct libusb_transfer *</var><code class=Fn>libusb_alloc_transfer</code>(<var class=Fa>int iso_packets</var>) Allocate a transfer with the number of isochronous packet descriptors specified by <var class=Fa>iso_packets</var>. Returns NULL on error. <p class=Pp><var class=Ft>void</var><code class=Fn>libusb_free_transfer</code>(<var class=Fa>struct libusb_transfer *tr</var>) Free a transfer.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_submit_transfer</code>(<var class=Fa>struct libusb_transfer *tr</var>) This function will submit a transfer and returns immediately. Returns 0 on success, LIBUSB_ERROR_NO_DEVICE if the device has been disconnected and a LIBUSB_ERROR code on other failure.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_cancel_transfer</code>(<var class=Fa>struct libusb_transfer *tr</var>) This function asynchronously cancels a transfer. Returns 0 on success and a LIBUSB_ERROR code on failure.</p></section><section class=Sh><h2 class=Sh id=USB_SYNCHRONOUS_I/O><a class=permalink href=#USB_SYNCHRONOUS_I/O>USB SYNCHRONOUS I/O</a></h2><var class=Ft>int</var><code class=Fn>libusb_control_transfer</code>(<var class=Fa>libusb_device_handle *devh</var>, <var class=Fa>uint8_t bmRequestType</var>, <var class=Fa>uint8_t bRequest</var>, <var class=Fa>uint16_t wValue</var>, <var class=Fa>uint16_t wIndex</var>, <var class=Fa>unsigned char *data</var>, <var class=Fa>uint16_t wLength</var>, <var class=Fa>unsigned int timeout</var>) Perform a USB control transfer. Returns the actual number of bytes transferred on success, in the range from and including zero up to and including <var class=Fa>wLength</var>. On error a LIBUSB_ERROR code is returned, for example LIBUSB_ERROR_TIMEOUT if the transfer timed out, LIBUSB_ERROR_PIPE if the control request was not supported, LIBUSB_ERROR_NO_DEVICE if the device has been disconnected and another LIBUSB_ERROR code on other failures. The LIBUSB_ERROR codes are all negative. <p class=Pp><var class=Ft>int</var><code class=Fn>libusb_bulk_transfer</code>(<var class=Fa>struct libusb_device_handle *devh</var>, <var class=Fa>unsigned char endpoint</var>, <var class=Fa>unsigned char *data</var>, <var class=Fa>int length</var>, <var class=Fa>int *transferred</var>, <var class=Fa>unsigned int timeout</var>) Perform an USB bulk transfer. A timeout value of zero means no timeout. The timeout value is given in milliseconds. Returns 0 on success, LIBUSB_ERROR_TIMEOUT if the transfer timed out, LIBUSB_ERROR_PIPE if the control request was not supported, LIBUSB_ERROR_OVERFLOW if the device offered more data, LIBUSB_ERROR_NO_DEVICE if the device has been disconnected and a LIBUSB_ERROR code on other failure.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_interrupt_transfer</code>(<var class=Fa>struct libusb_device_handle *devh</var>, <var class=Fa>unsigned char endpoint</var>, <var class=Fa>unsigned char *data</var>, <var class=Fa>int length</var>, <var class=Fa>int *transferred</var>, <var class=Fa>unsigned int timeout</var>) Perform an USB Interrupt transfer. A timeout value of zero means no timeout. The timeout value is given in milliseconds. Returns 0 on success, LIBUSB_ERROR_TIMEOUT if the transfer timed out, LIBUSB_ERROR_PIPE if the control request was not supported, LIBUSB_ERROR_OVERFLOW if the device offered more data, LIBUSB_ERROR_NO_DEVICE if the device has been disconnected and a LIBUSB_ERROR code on other failure.</p></section><section class=Sh><h2 class=Sh id=USB_STREAMS_SUPPORT><a class=permalink href=#USB_STREAMS_SUPPORT>USB STREAMS SUPPORT</a></h2><var class=Ft>int</var><code class=Fn>libusb_alloc_streams</code>(<var class=Fa>libusb_device_handle *dev</var>, <var class=Fa>uint32_t num_streams</var>, <var class=Fa>unsigned char *endpoints</var>, <var class=Fa>int num_endpoints</var>) This function verifies that the given number of streams using the given number of endpoints is allowed and allocates the resources needed to use so-called USB streams. Currently only a single stream per endpoint is supported to simplify the internals of LibUSB. This function returns 0 on success or a LIBUSB_ERROR code on failure. <p class=Pp><var class=Ft>int</var><code class=Fn>libusb_free_streams</code>(<var class=Fa>libusb_device_handle *dev</var>, <var class=Fa>unsigned char *endpoints</var>, <var class=Fa>int num_endpoints</var>) This function release resources needed for streams usage. Returns 0 on success or a LIBUSB_ERROR code on failure.</p><p class=Pp><var class=Ft>void</var><code class=Fn>libusb_transfer_set_stream_id</code>(<var class=Fa>struct libusb_transfer *transfer</var>, <var class=Fa>uint32_t stream_id</var>) This function sets the stream ID for the given USB transfer.</p><p class=Pp><var class=Ft>uint32_t</var><code class=Fn>libusb_transfer_get_stream_id</code>(<var class=Fa>struct libusb_transfer *transfer</var>) This function returns the stream ID for the given USB transfer. If no stream ID is used a value of zero is returned.</p></section><section class=Sh><h2 class=Sh id=USB_EVENTS><a class=permalink href=#USB_EVENTS>USB EVENTS</a></h2><var class=Ft>int</var><code class=Fn>libusb_try_lock_events</code>(<var class=Fa>libusb_context *ctx</var>) Try to acquire the event handling lock. Returns 0 if the lock was obtained and 1 if not. <p class=Pp><var class=Ft>void</var><code class=Fn>libusb_lock_events</code>(<var class=Fa>libusb_context *ctx</var>) Acquire the event handling lock. This function is blocking.</p><p class=Pp><var class=Ft>void</var><code class=Fn>libusb_unlock_events</code>(<var class=Fa>libusb_context *ctx</var>) Release the event handling lock. This will wake up any thread blocked on <code class=Fn>libusb_wait_for_event</code>().</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_event_handling_ok</code>(<var class=Fa>libusb_context *ctx</var>) Determine if it still OK for this thread to be doing event handling. Returns 1 if event handling can start or continue. Returns 0 if this thread must give up the events lock.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_event_handler_active</code>(<var class=Fa>libusb_context *ctx</var>) Determine if an active thread is handling events. Returns 1 if there is a thread handling events and 0 if there are no threads currently handling events.</p><p class=Pp><var class=Ft>void</var><code class=Fn>libusb_lock_event_waiters</code>(<var class=Fa>libusb_context *ctx</var>) Acquire the event_waiters lock. This lock is designed to be obtained in the situation where you want to be aware when events are completed, but some other thread is event handling so calling <code class=Fn>libusb_handle_events</code>() is not allowed.</p><p class=Pp><var class=Ft>void</var><code class=Fn>libusb_unlock_event_waiters</code>(<var class=Fa>libusb_context *ctx</var>) Release the event_waiters lock.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_wait_for_event</code>(<var class=Fa>libusb_context *ctx</var>, <var class=Fa>struct timeval *tv</var>) Wait for another thread to signal completion of an event. Must be called with the event waiters lock held, see <code class=Fn>libusb_lock_event_waiters</code>(). This will block until the timeout expires or a transfer completes or a thread releases the event handling lock through <code class=Fn>libusb_unlock_events</code>(). Returns 0 after a transfer completes or another thread stops event handling, and 1 if the timeout expired.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_handle_events_timeout_completed</code>(<var class=Fa>libusb_context *ctx</var>, <var class=Fa>struct timeval *tv</var>, <var class=Fa>int *completed</var>) Handle any pending events by checking if timeouts have expired and by checking the set of file descriptors for activity. If the <var class=Fa>completed</var> argument is not equal to NULL, this function will loop until a transfer completion callback sets the variable pointed to by the <var class=Fa>completed</var> argument to non-zero. If the <var class=Fa>tv</var> argument is not equal to NULL, this function will return LIBUSB_ERROR_TIMEOUT after the given timeout. Returns 0 on success, or a LIBUSB_ERROR code on failure or timeout.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_handle_events_completed</code>(<var class=Fa>libusb_context *ctx</var>, <var class=Fa>int *completed</var>) Handle any pending events by checking the set of file descriptors for activity. If the <var class=Fa>completed</var> argument is not equal to NULL, this function will loop until a transfer completion callback sets the variable pointed to by the <var class=Fa>completed</var> argument to non-zero. Returns 0 on success, or a LIBUSB_ERROR code on failure.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_handle_events_timeout</code>(<var class=Fa>libusb_context *ctx</var>, <var class=Fa>struct timeval *tv</var>) Handle any pending events by checking if timeouts have expired and by checking the set of file descriptors for activity. Returns 0 on success, or a LIBUSB_ERROR code on failure or timeout.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_handle_events</code>(<var class=Fa>libusb_context *ctx</var>) Handle any pending events in blocking mode with a sensible timeout. Returns 0 on success and a LIBUSB_ERROR code on failure.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_handle_events_locked</code>(<var class=Fa>libusb_context *ctx</var>, <var class=Fa>struct timeval *tv</var>) Handle any pending events by polling file descriptors, without checking if another thread is already doing so. Must be called with the event lock held.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_get_next_timeout</code>(<var class=Fa>libusb_context *ctx</var>, <var class=Fa>struct timeval *tv</var>) Determine the next internal timeout that libusb needs to handle. Returns 0 if there are no pending timeouts, 1 if a timeout was returned, or a LIBUSB_ERROR code on failure or timeout.</p><p class=Pp><var class=Ft>void</var><code class=Fn>libusb_set_pollfd_notifiers</code>(<var class=Fa>libusb_context *ctx</var>, <var class=Fa>libusb_pollfd_added_cb added_cb</var>, <var class=Fa>libusb_pollfd_removed_cb remove_cb</var>, <var class=Fa>void *user_data</var>) Register notification functions for file descriptor additions/removals. These functions will be invoked for every new or removed file descriptor that libusb uses as an event source.</p><p class=Pp><var class=Ft>const struct libusb_pollfd **</var><code class=Fn>libusb_get_pollfds</code>(<var class=Fa>libusb_context *ctx</var>) Retrieve a list of file descriptors that should be polled by your main loop as libusb event sources. Returns a NULL-terminated list on success or NULL on failure.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_hotplug_register_callback</code>(<var class=Fa>libusb_context *ctx</var>, <var class=Fa>libusb_hotplug_event events</var>, <var class=Fa>libusb_hotplug_flag flags</var>, <var class=Fa>int vendor_id</var>, <var class=Fa>int product_id</var>, <var class=Fa>int dev_class</var>, <var class=Fa>libusb_hotplug_callback_fn cb_fn</var>, <var class=Fa>void *user_data</var>, <var class=Fa>libusb_hotplug_callback_handle *handle</var>) This function registers a hotplug filter. The <var class=Fa>events</var> argument select which events makes the hotplug filter trigger. Available event values are LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED and LIBUSB_HOTPLUG_EVENT_DEVICE_LEFT. One or more events must be specified. The <var class=Fa>vendor_id</var>, <var class=Fa>product_id</var> and <var class=Fa>dev_class</var> arguments can be set to LIBUSB_HOTPLUG_MATCH_ANY to match any value in the USB device descriptor. Else the specified value is used for matching. If the <var class=Fa>flags</var> argument is set to LIBUSB_HOTPLUG_ENUMERATE, all currently attached and matching USB devices will be passed to the hotplug filter, given by the <var class=Fa>cb_fn</var> argument. Else the <var class=Fa>flags</var> argument should be set to LIBUSB_HOTPLUG_NO_FLAGS. This function returns 0 upon success or a LIBUSB_ERROR code on failure.</p><p class=Pp><var class=Ft>int</var><code class=Fn>libusb_hotplug_callback_fn</code>(<var class=Fa>libusb_context *ctx</var>, <var class=Fa>libusb_device *device</var>, <var class=Fa>libusb_hotplug_event event</var>, <var class=Fa>void *user_data</var>) The hotplug filter function. If this function returns non-zero, the filter is removed. Else the filter is kept and can receive more events. The <var class=Fa>user_data</var> argument is the same as given when the filter was registered. The <var class=Fa>event</var> argument can be either of LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED or LIBUSB_HOTPLUG_EVENT_DEVICE_LEFT.</p><p class=Pp><var class=Ft>void</var><code class=Fn>libusb_hotplug_deregister_callback</code>(<var class=Fa>libusb_context *ctx</var>, <var class=Fa>libusb_hotplug_callback_handle handle</var>) This function unregisters a hotplug filter.</p></section><section class=Sh><h2 class=Sh id=LIBUSB_VERSION_0.1_COMPATIBILITY><a class=permalink href=#LIBUSB_VERSION_0.1_COMPATIBILITY>LIBUSB VERSION 0.1 COMPATIBILITY</a></h2> The library is also compliant with LibUSB version 0.1.12. <p class=Pp><code class=Fn>usb_open</code>() <code class=Fn>usb_close</code>() <code class=Fn>usb_get_string</code>() <code class=Fn>usb_get_string_simple</code>() <code class=Fn>usb_get_descriptor_by_endpoint</code>() <code class=Fn>usb_get_descriptor</code>() <code class=Fn>usb_parse_descriptor</code>() <code class=Fn>usb_parse_configuration</code>() <code class=Fn>usb_destroy_configuration</code>() <code class=Fn>usb_fetch_and_parse_descriptors</code>() <code class=Fn>usb_bulk_write</code>() <code class=Fn>usb_bulk_read</code>() <code class=Fn>usb_interrupt_write</code>() <code class=Fn>usb_interrupt_read</code>() <code class=Fn>usb_control_msg</code>() <code class=Fn>usb_set_configuration</code>() <code class=Fn>usb_claim_interface</code>() <code class=Fn>usb_release_interface</code>() <code class=Fn>usb_set_altinterface</code>() <code class=Fn>usb_resetep</code>() <code class=Fn>usb_clear_halt</code>() <code class=Fn>usb_reset</code>() <code class=Fn>usb_strerror</code>() <code class=Fn>usb_init</code>() <code class=Fn>usb_set_debug</code>() <code class=Fn>usb_find_busses</code>() <code class=Fn>usb_find_devices</code>() <code class=Fn>usb_device</code>() <code class=Fn>usb_get_busses</code>() <code class=Fn>usb_check_connected</code>() <code class=Fn>usb_get_driver_np</code>() <code class=Fn>usb_detach_kernel_driver_np</code>()</p></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=libusb20.3.html>libusb20(3)</a>, <a class=Xr href=usb.4.html>usb(4)</a>, <a class=Xr href=usbconfig.8.html>usbconfig(8)</a>, <a class=Xr href=usbdump.8.html>usbdump(8)</a><p class=Pp><a href=https://libusb.info/ class=Lk>https://libusb.info/</a></p></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2><code class=Nm>libusb</code> support first appeared in <span class=Ux>FreeBSD 8.0</span>. </section></div><table class=foot><tr><td class=foot-date>June 9, 2020</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>