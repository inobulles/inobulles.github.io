<!DOCTYPE html>
<html><head><meta charset=utf-8><title>atomic_swap(9)</title><keywords content=man,atomic_swap></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>atomic_swap(9)</h1><table class=head><tr><td class=head-ltitle>ATOMIC(9)</td><td class=head-vol>FreeBSD Kernel Developer's Manual</td><td class=head-rtitle>ATOMIC(9)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>atomic_add</code>, <code class=Nm>atomic_clear</code>, <code class=Nm>atomic_cmpset</code>, <code class=Nm>atomic_fcmpset</code>, <code class=Nm>atomic_fetchadd</code>, <code class=Nm>atomic_load</code>, <code class=Nm>atomic_readandclear</code>, <code class=Nm>atomic_set</code>, <code class=Nm>atomic_subtract</code>, <code class=Nm>atomic_store</code>, <code class=Nm>atomic_thread_fence</code> — <div class=Nd>atomic operations</div></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/sys/types.h.html>sys/types.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/machine/atomic.h.html>machine/atomic.h</a>&gt;</code><p class=Pp><var class=Ft>void</var><br><code class=Fn>atomic_add_[acq_|rel_]&lt;type&gt;</code>(<var class=Fa style="white-space: nowrap;">volatile &lt;type&gt; *p</var>, <var class=Fa style="white-space: nowrap;">&lt;type&gt; v</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>atomic_clear_[acq_|rel_]&lt;type&gt;</code>(<var class=Fa style="white-space: nowrap;">volatile &lt;type&gt; *p</var>, <var class=Fa style="white-space: nowrap;">&lt;type&gt; v</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>atomic_cmpset_[acq_|rel_]&lt;type&gt;</code>(<var class=Fa>volatile &lt;type&gt; *dst</var>, <var class=Fa>&lt;type&gt; old</var>, <var class=Fa>&lt;type&gt; new</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>atomic_fcmpset_[acq_|rel_]&lt;type&gt;</code>(<var class=Fa>volatile &lt;type&gt; *dst</var>, <var class=Fa>&lt;type&gt; *old</var>, <var class=Fa>&lt;type&gt; new</var>);</p><p class=Pp><var class=Ft>&lt;type&gt;</var><br><code class=Fn>atomic_fetchadd_&lt;type&gt;</code>(<var class=Fa style="white-space: nowrap;">volatile &lt;type&gt; *p</var>, <var class=Fa style="white-space: nowrap;">&lt;type&gt; v</var>);</p><p class=Pp><var class=Ft>&lt;type&gt;</var><br><code class=Fn>atomic_load_[acq_]&lt;type&gt;</code>(<var class=Fa style="white-space: nowrap;">volatile &lt;type&gt; *p</var>);</p><p class=Pp><var class=Ft>&lt;type&gt;</var><br><code class=Fn>atomic_readandclear_&lt;type&gt;</code>(<var class=Fa style="white-space: nowrap;">volatile &lt;type&gt; *p</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>atomic_set_[acq_|rel_]&lt;type&gt;</code>(<var class=Fa style="white-space: nowrap;">volatile &lt;type&gt; *p</var>, <var class=Fa style="white-space: nowrap;">&lt;type&gt; v</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>atomic_subtract_[acq_|rel_]&lt;type&gt;</code>(<var class=Fa style="white-space: nowrap;">volatile &lt;type&gt; *p</var>, <var class=Fa style="white-space: nowrap;">&lt;type&gt; v</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>atomic_store_[rel_]&lt;type&gt;</code>(<var class=Fa style="white-space: nowrap;">volatile &lt;type&gt; *p</var>, <var class=Fa style="white-space: nowrap;">&lt;type&gt; v</var>);</p><p class=Pp><var class=Ft>&lt;type&gt;</var><br><code class=Fn>atomic_swap_&lt;type&gt;</code>(<var class=Fa style="white-space: nowrap;">volatile &lt;type&gt; *p</var>, <var class=Fa style="white-space: nowrap;">&lt;type&gt; v</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>atomic_testandclear_&lt;type&gt;</code>(<var class=Fa style="white-space: nowrap;">volatile &lt;type&gt; *p</var>, <var class=Fa style="white-space: nowrap;">u_int v</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>atomic_testandset_&lt;type&gt;</code>(<var class=Fa style="white-space: nowrap;">volatile &lt;type&gt; *p</var>, <var class=Fa style="white-space: nowrap;">u_int v</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>atomic_thread_fence_[acq|acq_rel|rel|seq_cst]</code>(<var class=Fa style="white-space: nowrap;">void</var>);</p></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> Atomic operations are commonly used to implement reference counts and as building blocks for synchronization primitives, such as mutexes. <p class=Pp>All of these operations are performed <i class=Em>atomically</i> across multiple threads and in the presence of interrupts, meaning that they are performed in an indivisible manner from the perspective of concurrently running threads and interrupt handlers.</p><p class=Pp>On all architectures supported by <span class=Ux>FreeBSD</span>, ordinary loads and stores of integers in cache-coherent memory are inherently atomic if the integer is naturally aligned and its size does not exceed the processor's word size. However, such loads and stores may be elided from the program by the compiler, whereas atomic operations are always performed.</p><p class=Pp>When atomic operations are performed on cache-coherent memory, all operations on the same location are totally ordered.</p><p class=Pp>When an atomic load is performed on a location in cache-coherent memory, it reads the entire value that was defined by the last atomic store to each byte of the location. An atomic load will never return a value out of thin air. When an atomic store is performed on a location, no other thread or interrupt handler will observe a <i class=Em>torn write</i>, or partial modification of the location.</p><p class=Pp>Except as noted below, the semantics of these operations are almost identical to the semantics of similarly named C11 atomic operations.</p><section class=Ss><h2 class=Ss id=Types><a class=permalink href=#Types>Types</a></h2> Most atomic operations act upon a specific <var class=Fa>type</var>. That type is indicated in the function name. In contrast to C11 atomic operations, <span class=Ux>FreeBSD</span>'s atomic operations are performed on ordinary integer types. The available types are: <p class=Pp></p><div class=Bd-indent><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#int><code class=Li id=int>int</code></a></dt><dd>unsigned integer</dd><dt><a class=permalink href=#long><code class=Li id=long>long</code></a></dt><dd>unsigned long integer</dd><dt><a class=permalink href=#ptr><code class=Li id=ptr>ptr</code></a></dt><dd>unsigned integer the size of a pointer</dd><dt><a class=permalink href=#32><code class=Li id=32>32</code></a></dt><dd>unsigned 32-bit integer</dd><dt><a class=permalink href=#64><code class=Li id=64>64</code></a></dt><dd>unsigned 64-bit integer</dd></dl></div><p class=Pp>For example, the function to atomically add two integers is called <code class=Fn>atomic_add_int</code>().</p><p class=Pp>Certain architectures also provide operations for types smaller than “<code class=Li>int</code>”.</p><p class=Pp></p><div class=Bd-indent><dl class="Bl-tag Bl-compact"><dt><a class=permalink href=#char><code class=Li id=char>char</code></a></dt><dd>unsigned character</dd><dt><a class=permalink href=#short><code class=Li id=short>short</code></a></dt><dd>unsigned short integer</dd><dt><a class=permalink href=#8><code class=Li id=8>8</code></a></dt><dd>unsigned 8-bit integer</dd><dt><a class=permalink href=#16><code class=Li id=16>16</code></a></dt><dd>unsigned 16-bit integer</dd></dl></div><p class=Pp>These types must not be used in machine-independent code.</p></section><section class=Ss><h2 class=Ss id=Acquire_and_Release_Operations><a class=permalink href=#Acquire_and_Release_Operations>Acquire and Release Operations</a></h2> By default, a thread's accesses to different memory locations might not be performed in <i class=Em>program order</i>, that is, the order in which the accesses appear in the source code. To optimize the program's execution, both the compiler and processor might reorder the thread's accesses. However, both ensure that their reordering of the accesses is not visible to the thread. Otherwise, the traditional memory model that is expected by single-threaded programs would be violated. Nonetheless, other threads in a multithreaded program, such as the <span class=Ux>FreeBSD</span> kernel, might observe the reordering. Moreover, in some cases, such as the implementation of synchronization between threads, arbitrary reordering might result in the incorrect execution of the program. To constrain the reordering that both the compiler and processor might perform on a thread's accesses, a programmer can use atomic operations with <i class=Em>acquire</i> and <i class=Em>release</i> semantics. <p class=Pp>Atomic operations on memory have up to three variants. The first, or <i class=Em>relaxed</i> variant, performs the operation without imposing any ordering constraints on accesses to other memory locations. This variant is the default. The second variant has acquire semantics, and the third variant has release semantics.</p><p class=Pp>When an atomic operation has acquire semantics, the operation must have completed before any subsequent load or store (by program order) is performed. Conversely, acquire semantics do not require that prior loads or stores have completed before the atomic operation is performed. An atomic operation can only have acquire semantics if it performs a load from memory. To denote acquire semantics, the suffix “<code class=Li>_acq</code>” is inserted into the function name immediately prior to the “<code class=Li>_</code>⟨<var class=Fa>type</var>⟩” suffix. For example, to subtract two integers ensuring that the subtraction is completed before any subsequent loads and stores are performed, use <code class=Fn>atomic_subtract_acq_int</code>().</p><p class=Pp>When an atomic operation has release semantics, all prior loads or stores (by program order) must have completed before the operation is performed. Conversely, release semantics do not require that the atomic operation must have completed before any subsequent load or store is performed. An atomic operation can only have release semantics if it performs a store to memory. To denote release semantics, the suffix “<code class=Li>_rel</code>” is inserted into the function name immediately prior to the “<code class=Li>_</code>⟨<var class=Fa>type</var>⟩” suffix. For example, to add two long integers ensuring that all prior loads and stores are completed before the addition is performed, use <code class=Fn>atomic_add_rel_long</code>().</p><p class=Pp>When a release operation by one thread <i class=Em>synchronizes with</i> an acquire operation by another thread, usually meaning that the acquire operation reads the value written by the release operation, then the effects of all prior stores by the releasing thread must become visible to subsequent loads by the acquiring thread. Moreover, the effects of all stores (by other threads) that were visible to the releasing thread must also become visible to the acquiring thread. These rules only apply to the synchronizing threads. Other threads might observe these stores in a different order.</p><p class=Pp>In effect, atomic operations with acquire and release semantics establish one-way barriers to reordering that enable the implementations of synchronization primitives to express their ordering requirements without also imposing unnecessary ordering. For example, for a critical section guarded by a mutex, an acquire operation when the mutex is locked and a release operation when the mutex is unlocked will prevent any loads or stores from moving outside of the critical section. However, they will not prevent the compiler or processor from moving loads or stores into the critical section, which does not violate the semantics of a mutex.</p></section><section class=Ss><h2 class=Ss id=Thread_Fence_Operations><a class=permalink href=#Thread_Fence_Operations>Thread Fence Operations</a></h2> Alternatively, a programmer can use atomic thread fence operations to constrain the reordering of accesses. In contrast to other atomic operations, fences do not, themselves, access memory. <p class=Pp>When a fence has acquire semantics, all prior loads (by program order) must have completed before any subsequent load or store is performed. Thus, an acquire fence is a two-way barrier for load operations. To denote acquire semantics, the suffix “<code class=Li>_acq</code>” is appended to the function name, for example, <code class=Fn>atomic_thread_fence_acq</code>().</p><p class=Pp>When a fence has release semantics, all prior loads or stores (by program order) must have completed before any subsequent store operation is performed. Thus, a release fence is a two-way barrier for store operations. To denote release semantics, the suffix “<code class=Li>_rel</code>” is appended to the function name, for example, <code class=Fn>atomic_thread_fence_rel</code>().</p><p class=Pp>Although <code class=Fn>atomic_thread_fence_acq_rel</code>() implements both acquire and release semantics, it is not a full barrier. For example, a store prior to the fence (in program order) may be completed after a load subsequent to the fence. In contrast, <code class=Fn>atomic_thread_fence_seq_cst</code>() implements a full barrier. Neither loads nor stores may cross this barrier in either direction.</p><p class=Pp>In C11, a release fence by one thread synchronizes with an acquire fence by another thread when an atomic load that is prior to the acquire fence (by program order) reads the value written by an atomic store that is subsequent to the release fence. In constrast, in FreeBSD, because of the atomicity of ordinary, naturally aligned loads and stores, fences can also be synchronized by ordinary loads and stores. This simplifies the implementation and use of some synchronization primitives in <span class=Ux>FreeBSD</span>.</p><p class=Pp>Since neither a compiler nor a processor can foresee which (atomic) load will read the value written by an (atomic) store, the ordering constraints imposed by fences must be more restrictive than acquire loads and release stores. Essentially, this is why fences are two-way barriers.</p><p class=Pp>Although fences impose more restrictive ordering than acquire loads and release stores, by separating access from ordering, they can sometimes facilitate more efficient implementations of synchronization primitives. For example, they can be used to avoid executing a memory barrier until a memory access shows that some condition is satisfied.</p></section><section class=Ss><h2 class=Ss id=Multiple_Processors><a class=permalink href=#Multiple_Processors>Multiple Processors</a></h2> In multiprocessor systems, the atomicity of the atomic operations on memory depends on support for cache coherence in the underlying architecture. In general, cache coherence on the default memory type, <code class=Dv>VM_MEMATTR_DEFAULT</code>, is guaranteed by all architectures that are supported by <span class=Ux>FreeBSD</span>. For example, cache coherence is guaranteed on write-back memory by the amd64 and i386 architectures. However, on some architectures, cache coherence might not be enabled on all memory types. To determine if cache coherence is enabled for a non-default memory type, consult the architecture's documentation. </section><section class=Ss><h2 class=Ss id=Semantics><a class=permalink href=#Semantics>Semantics</a></h2> This section describes the semantics of each operation using a C like notation. <dl class=Bl-hang><dt><code class=Fn>atomic_add</code>(<var class=Fa>p</var>, <var class=Fa>v</var>)</dt><dd><div class=Bd><pre>
*p += v;
    </pre></div></dd><dt><code class=Fn>atomic_clear</code>(<var class=Fa>p</var>, <var class=Fa>v</var>)</dt><dd><div class=Bd><pre>
*p &amp;= ~v;
    </pre></div></dd><dt><code class=Fn>atomic_cmpset</code>(<var class=Fa>dst</var>, <var class=Fa>old</var>, <var class=Fa>new</var>)</dt><dd><div class=Bd><pre>
if (*dst == old) {
	*dst = new;
	return (1);
} else
	return (0);
    </pre></div></dd></dl><p class=Pp>Some architectures do not implement the <code class=Fn>atomic_cmpset</code>() functions for the types “<code class=Li>char</code>”, “<code class=Li>short</code>”, “<code class=Li>8</code>”, and “<code class=Li>16</code>”.</p><dl class=Bl-hang><dt><code class=Fn>atomic_fcmpset</code>(<var class=Fa>dst</var>, <var class=Fa>*old</var>, <var class=Fa>new</var>)</dt><dd></dd></dl><p class=Pp>On architectures implementing <i class=Em>Compare And Swap</i> operation in hardware, the functionality can be described as</p><div class="Bd Bd-indent"><pre>
if (*dst == *old) {
	*dst = new;
	return (1);
} else {
	*old = *dst;
	return (0);
}
</pre></div> On architectures which provide <i class=Em>Load Linked/Store Conditional</i> primitive, the write to <code class=Dv>*dst</code> might also fail for several reasons, most important of which is a parallel write to <code class=Dv>*dst</code> cache line by other CPU. In this case <code class=Fn>atomic_fcmpset</code>() function also returns <code class=Dv>false</code>, despite <div class="Bd Bd-indent"><code class=Li>*old == *dst.</code></div><p class=Pp>Some architectures do not implement the <code class=Fn>atomic_fcmpset</code>() functions for the types “<code class=Li>char</code>”, “<code class=Li>short</code>”, “<code class=Li>8</code>”, and “<code class=Li>16</code>”.</p><dl class=Bl-hang><dt><code class=Fn>atomic_fetchadd</code>(<var class=Fa>p</var>, <var class=Fa>v</var>)</dt><dd><div class=Bd><pre>
tmp = *p;
*p += v;
return (tmp);
    </pre></div></dd></dl><p class=Pp>The <code class=Fn>atomic_fetchadd</code>() functions are only implemented for the types “<code class=Li>int</code>”, “<code class=Li>long</code>” and “<code class=Li>32</code>” and do not have any variants with memory barriers at this time.</p><dl class=Bl-hang><dt><code class=Fn>atomic_load</code>(<var class=Fa>p</var>)</dt><dd><div class=Bd><pre>
return (*p);
    </pre></div></dd><dt><code class=Fn>atomic_readandclear</code>(<var class=Fa>p</var>)</dt><dd><div class=Bd><pre>
tmp = *p;
*p = 0;
return (tmp);
    </pre></div></dd></dl><p class=Pp>The <code class=Fn>atomic_readandclear</code>() functions are not implemented for the types “<code class=Li>char</code>”, “<code class=Li>short</code>”, “<code class=Li>ptr</code>”, “<code class=Li>8</code>”, and “<code class=Li>16</code>” and do not have any variants with memory barriers at this time.</p><dl class=Bl-hang><dt><code class=Fn>atomic_set</code>(<var class=Fa>p</var>, <var class=Fa>v</var>)</dt><dd><div class=Bd><pre>
*p |= v;
    </pre></div></dd><dt><code class=Fn>atomic_subtract</code>(<var class=Fa>p</var>, <var class=Fa>v</var>)</dt><dd><div class=Bd><pre>
*p -= v;
    </pre></div></dd><dt><code class=Fn>atomic_store</code>(<var class=Fa>p</var>, <var class=Fa>v</var>)</dt><dd><div class=Bd><pre>
*p = v;
    </pre></div></dd><dt><code class=Fn>atomic_swap</code>(<var class=Fa>p</var>, <var class=Fa>v</var>)</dt><dd><div class=Bd><pre>
tmp = *p;
*p = v;
return (tmp);
    </pre></div></dd></dl><p class=Pp>The <code class=Fn>atomic_swap</code>() functions are not implemented for the types “<code class=Li>char</code>”, “<code class=Li>short</code>”, “<code class=Li>ptr</code>”, “<code class=Li>8</code>”, and “<code class=Li>16</code>” and do not have any variants with memory barriers at this time.</p><dl class=Bl-hang><dt><code class=Fn>atomic_testandclear</code>(<var class=Fa>p</var>, <var class=Fa>v</var>)</dt><dd><div class=Bd><pre>
bit = 1 &lt;&lt; (v % (sizeof(*p) * NBBY));
tmp = (*p &amp; bit) != 0;
*p &amp;= ~bit;
return (tmp);
    </pre></div></dd></dl><dl class=Bl-hang><dt><code class=Fn>atomic_testandset</code>(<var class=Fa>p</var>, <var class=Fa>v</var>)</dt><dd><div class=Bd><pre>
bit = 1 &lt;&lt; (v % (sizeof(*p) * NBBY));
tmp = (*p &amp; bit) != 0;
*p |= bit;
return (tmp);
    </pre></div></dd></dl><p class=Pp>The <code class=Fn>atomic_testandset</code>() and <code class=Fn>atomic_testandclear</code>() functions are only implemented for the types “<code class=Li>int</code>”, “<code class=Li>long</code>” and “<code class=Li>32</code>” and do not have any variants with memory barriers at this time.</p><p class=Pp>The type “<code class=Li>64</code>” is currently not implemented for some of the atomic operations on the arm, i386, and powerpc architectures.</p></section></section><section class=Sh><h2 class=Sh id=RETURN_VALUES><a class=permalink href=#RETURN_VALUES>RETURN VALUES</a></h2> The <code class=Fn>atomic_cmpset</code>() function returns the result of the compare operation. The <code class=Fn>atomic_fcmpset</code>() function returns <code class=Dv>true</code> if the operation succeeded. Otherwise it returns <code class=Dv>false</code> and sets <var class=Va>*old</var> to the found value. The <code class=Fn>atomic_fetchadd</code>(), <code class=Fn>atomic_load</code>(), <code class=Fn>atomic_readandclear</code>(), and <code class=Fn>atomic_swap</code>() functions return the value at the specified address. The <code class=Fn>atomic_testandset</code>() and <code class=Fn>atomic_testandclear</code>() function returns the result of the test operation. </section><section class=Sh><h2 class=Sh id=EXAMPLES><a class=permalink href=#EXAMPLES>EXAMPLES</a></h2> This example uses the <code class=Fn>atomic_cmpset_acq_ptr</code>() and <code class=Fn>atomic_set_ptr</code>() functions to obtain a sleep mutex and handle recursion. Since the <var class=Va>mtx_lock</var> member of a <var class=Vt>struct mtx</var> is a pointer, the “<code class=Li>ptr</code>” type is used. <div class="Bd Pp"><pre>
/* Try to obtain mtx_lock once. */
#define _obtain_lock(mp, tid)						\
	atomic_cmpset_acq_ptr(&amp;(mp)-&gt;mtx_lock, MTX_UNOWNED, (tid))

/* Get a sleep lock, deal with recursion inline. */
#define _get_sleep_lock(mp, tid, opts, file, line) do {			\
	uintptr_t _tid = (uintptr_t)(tid);				\
									\
	if (!_obtain_lock(mp, tid)) {					\
		if (((mp)-&gt;mtx_lock &amp; MTX_FLAGMASK) != _tid)		\
			_mtx_lock_sleep((mp), _tid, (opts), (file), (line));\
		else {							\
			atomic_set_ptr(&amp;(mp)-&gt;mtx_lock, MTX_RECURSE);	\
			(mp)-&gt;mtx_recurse++;				\
		}							\
	}								\
} while (0)
</pre></div></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> The <code class=Fn>atomic_add</code>(), <code class=Fn>atomic_clear</code>(), <code class=Fn>atomic_set</code>(), and <code class=Fn>atomic_subtract</code>() operations were introduced in <span class=Ux>FreeBSD 3.0</span>. Initially, these operations were defined on the types “<code class=Li>char</code>”, “<code class=Li>short</code>”, “<code class=Li>int</code>”, and “<code class=Li>long</code>”. <p class=Pp>The <code class=Fn>atomic_cmpset</code>(), <code class=Fn>atomic_load_acq</code>(), <code class=Fn>atomic_readandclear</code>(), and <code class=Fn>atomic_store_rel</code>() operations were added in <span class=Ux>FreeBSD 5.0</span>. Simultaneously, the acquire and release variants were introduced, and support was added for operation on the types “<code class=Li>8</code>”, “<code class=Li>16</code>”, “<code class=Li>32</code>”, “<code class=Li>64</code>”, and “<code class=Li>ptr</code>”.</p><p class=Pp>The <code class=Fn>atomic_fetchadd</code>() operation was added in <span class=Ux>FreeBSD 6.0</span>.</p><p class=Pp>The <code class=Fn>atomic_swap</code>() and <code class=Fn>atomic_testandset</code>() operations were added in <span class=Ux>FreeBSD 10.0</span>.</p><p class=Pp>The <code class=Fn>atomic_testandclear</code>() and <code class=Fn>atomic_thread_fence</code>() operations were added in <span class=Ux>FreeBSD 11.0</span>.</p><p class=Pp>The relaxed variants of <code class=Fn>atomic_load</code>() and <code class=Fn>atomic_store</code>() were added in <span class=Ux>FreeBSD 12.0</span>.</p></section></div><table class=foot><tr><td class=foot-date>August 18, 2019</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>