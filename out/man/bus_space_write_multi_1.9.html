<!DOCTYPE html>
<html><head><meta charset=utf-8><title>bus_space_write_multi_1(9)</title><keywords content=man,bus_space_write_multi_1></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>bus_space_write_multi_1(9)</h1><table class=head><tr><td class=head-ltitle>BUS_SPACE(9)</td><td class=head-vol>FreeBSD Kernel Developer's Manual</td><td class=head-rtitle>BUS_SPACE(9)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>bus_space</code>, <code class=Nm>bus_space_barrier</code>, <code class=Nm>bus_space_copy_region_1</code>, <code class=Nm>bus_space_copy_region_2</code>, <code class=Nm>bus_space_copy_region_4</code>, <code class=Nm>bus_space_copy_region_8</code>, <code class=Nm>bus_space_copy_region_stream_1</code>, <code class=Nm>bus_space_copy_region_stream_2</code>, <code class=Nm>bus_space_copy_region_stream_4</code>, <code class=Nm>bus_space_copy_region_stream_8</code>, <code class=Nm>bus_space_free</code>, <code class=Nm>bus_space_map</code>, <code class=Nm>bus_space_read_1</code>, <code class=Nm>bus_space_read_2</code>, <code class=Nm>bus_space_read_4</code>, <code class=Nm>bus_space_read_8</code>, <code class=Nm>bus_space_read_multi_1</code>, <code class=Nm>bus_space_read_multi_2</code>, <code class=Nm>bus_space_read_multi_4</code>, <code class=Nm>bus_space_read_multi_8</code>, <code class=Nm>bus_space_read_multi_stream_1</code>, <code class=Nm>bus_space_read_multi_stream_2</code>, <code class=Nm>bus_space_read_multi_stream_4</code>, <code class=Nm>bus_space_read_multi_stream_8</code>, <code class=Nm>bus_space_read_region_1</code>, <code class=Nm>bus_space_read_region_2</code>, <code class=Nm>bus_space_read_region_4</code>, <code class=Nm>bus_space_read_region_8</code>, <code class=Nm>bus_space_read_region_stream_1</code>, <code class=Nm>bus_space_read_region_stream_2</code>, <code class=Nm>bus_space_read_region_stream_4</code>, <code class=Nm>bus_space_read_region_stream_8</code>, <code class=Nm>bus_space_read_stream_1</code>, <code class=Nm>bus_space_read_stream_2</code>, <code class=Nm>bus_space_read_stream_4</code>, <code class=Nm>bus_space_read_stream_8</code>, <code class=Nm>bus_space_set_multi_1</code>, <code class=Nm>bus_space_set_multi_2</code>, <code class=Nm>bus_space_set_multi_4</code>, <code class=Nm>bus_space_set_multi_8</code>, <code class=Nm>bus_space_set_multi_stream_1</code>, <code class=Nm>bus_space_set_multi_stream_2</code>, <code class=Nm>bus_space_set_multi_stream_4</code>, <code class=Nm>bus_space_set_multi_stream_8</code>, <code class=Nm>bus_space_set_region_1</code>, <code class=Nm>bus_space_set_region_2</code>, <code class=Nm>bus_space_set_region_4</code>, <code class=Nm>bus_space_set_region_8</code>, <code class=Nm>bus_space_set_region_stream_1</code>, <code class=Nm>bus_space_set_region_stream_2</code>, <code class=Nm>bus_space_set_region_stream_4</code>, <code class=Nm>bus_space_set_region_stream_8</code>, <code class=Nm>bus_space_subregion</code>, <code class=Nm>bus_space_unmap</code>, <code class=Nm>bus_space_write_1</code>, <code class=Nm>bus_space_write_2</code>, <code class=Nm>bus_space_write_4</code>, <code class=Nm>bus_space_write_8</code>, <code class=Nm>bus_space_write_multi_1</code>, <code class=Nm>bus_space_write_multi_2</code>, <code class=Nm>bus_space_write_multi_4</code>, <code class=Nm>bus_space_write_multi_8</code>, <code class=Nm>bus_space_write_multi_stream_1</code>, <code class=Nm>bus_space_write_multi_stream_2</code>, <code class=Nm>bus_space_write_multi_stream_4</code>, <code class=Nm>bus_space_write_multi_stream_8</code>, <code class=Nm>bus_space_write_region_1</code>, <code class=Nm>bus_space_write_region_2</code>, <code class=Nm>bus_space_write_region_4</code>, <code class=Nm>bus_space_write_region_8</code>, <code class=Nm>bus_space_write_region_stream_1</code>, <code class=Nm>bus_space_write_region_stream_2</code>, <code class=Nm>bus_space_write_region_stream_4</code>, <code class=Nm>bus_space_write_region_stream_8</code>, <code class=Nm>bus_space_write_stream_1</code>, <code class=Nm>bus_space_write_stream_2</code>, <code class=Nm>bus_space_write_stream_4</code>, <code class=Nm>bus_space_write_stream_8</code> — <div class=Nd>bus space manipulation functions</div></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/machine/bus.h.html>machine/bus.h</a>&gt;</code><p class=Pp><var class=Ft>int</var><br><code class=Fn>bus_space_map</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_addr_t address</var>, <var class=Fa>bus_size_t size</var>, <var class=Fa>int flags</var>, <var class=Fa>bus_space_handle_t *handlep</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_unmap</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t size</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bus_space_subregion</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>bus_size_t size</var>, <var class=Fa>bus_space_handle_t *nhandlep</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>bus_space_alloc</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_addr_t reg_start</var>, <var class=Fa>bus_addr_t reg_end</var>, <var class=Fa>bus_size_t size</var>, <var class=Fa>bus_size_t alignment</var>, <var class=Fa>bus_size_t boundary</var>, <var class=Fa>int flags</var>, <var class=Fa>bus_addr_t *addrp</var>, <var class=Fa>bus_space_handle_t *handlep</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_free</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t size</var>);</p><p class=Pp><var class=Ft>uint8_t</var><br><code class=Fn>bus_space_read_1</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>);</p><p class=Pp><var class=Ft>uint16_t</var><br><code class=Fn>bus_space_read_2</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>);</p><p class=Pp><var class=Ft>uint32_t</var><br><code class=Fn>bus_space_read_4</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>bus_space_read_8</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>);</p><p class=Pp><var class=Ft>uint8_t</var><br><code class=Fn>bus_space_read_stream_1</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>);</p><p class=Pp><var class=Ft>uint16_t</var><br><code class=Fn>bus_space_read_stream_2</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>);</p><p class=Pp><var class=Ft>uint32_t</var><br><code class=Fn>bus_space_read_stream_4</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>);</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>bus_space_read_stream_8</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_write_1</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint8_t value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_write_2</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint16_t value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_write_4</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint32_t value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_write_8</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint64_t value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_write_stream_1</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint8_t value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_write_stream_2</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint16_t value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_write_stream_4</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint32_t value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_write_stream_8</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint64_t value</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_barrier</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>bus_size_t length</var>, <var class=Fa>int flags</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_read_region_1</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint8_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_read_region_2</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint16_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_read_region_4</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint32_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_read_region_8</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint64_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_read_region_stream_1</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint8_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_read_region_stream_2</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint16_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_read_region_stream_4</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint32_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_read_region_stream_8</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint64_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_write_region_1</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint8_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_write_region_2</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint16_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_write_region_4</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint32_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_write_region_8</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint64_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_write_region_stream_1</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint8_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_write_region_stream_2</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint16_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_write_region_stream_4</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint32_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_write_region_stream_8</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint64_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_copy_region_1</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t srchandle</var>, <var class=Fa>bus_size_t srcoffset</var>, <var class=Fa>bus_space_handle_t dsthandle</var>, <var class=Fa>bus_size_t dstoffset</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_copy_region_2</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t srchandle</var>, <var class=Fa>bus_size_t srcoffset</var>, <var class=Fa>bus_space_handle_t dsthandle</var>, <var class=Fa>bus_size_t dstoffset</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_copy_region_4</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t srchandle</var>, <var class=Fa>bus_size_t srcoffset</var>, <var class=Fa>bus_space_handle_t dsthandle</var>, <var class=Fa>bus_size_t dstoffset</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_copy_region_8</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t srchandle</var>, <var class=Fa>bus_size_t srcoffset</var>, <var class=Fa>bus_space_handle_t dsthandle</var>, <var class=Fa>bus_size_t dstoffset</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_copy_region_stream_1</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t srchandle</var>, <var class=Fa>bus_size_t srcoffset</var>, <var class=Fa>bus_space_handle_t dsthandle</var>, <var class=Fa>bus_size_t dstoffset</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_copy_region_stream_2</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t srchandle</var>, <var class=Fa>bus_size_t srcoffset</var>, <var class=Fa>bus_space_handle_t dsthandle</var>, <var class=Fa>bus_size_t dstoffset</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_copy_region_stream_4</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t srchandle</var>, <var class=Fa>bus_size_t srcoffset</var>, <var class=Fa>bus_space_handle_t dsthandle</var>, <var class=Fa>bus_size_t dstoffset</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_copy_region_stream_8</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t srchandle</var>, <var class=Fa>bus_size_t srcoffset</var>, <var class=Fa>bus_space_handle_t dsthandle</var>, <var class=Fa>bus_size_t dstoffset</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_set_region_1</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint8_t value</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_set_region_2</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint16_t value</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_set_region_4</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint32_t value</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_set_region_8</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint64_t value</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_set_region_stream_1</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint8_t value</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_set_region_stream_2</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint16_t value</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_set_region_stream_4</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint32_t value</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_set_region_stream_8</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint64_t value</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_read_multi_1</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint8_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_read_multi_2</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint16_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_read_multi_4</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint32_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_read_multi_8</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint64_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_read_multi_stream_1</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint8_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_read_multi_stream_2</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint16_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_read_multi_stream_4</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint32_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_read_multi_stream_8</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint64_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_write_multi_1</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint8_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_write_multi_2</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint16_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_write_multi_4</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint32_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_write_multi_8</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint64_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_write_multi_stream_1</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint8_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_write_multi_stream_2</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint16_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_write_multi_stream_4</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint32_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_write_multi_stream_8</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint64_t *datap</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_set_multi_1</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint8_t value</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_set_multi_2</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint16_t value</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_set_multi_4</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint32_t value</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_set_multi_8</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint64_t value</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_set_multi_stream_1</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint8_t value</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_set_multi_stream_2</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint16_t value</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_set_multi_stream_4</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint32_t value</var>, <var class=Fa>bus_size_t count</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bus_space_set_multi_stream_8</code>(<var class=Fa>bus_space_tag_t space</var>, <var class=Fa>bus_space_handle_t handle</var>, <var class=Fa>bus_size_t offset</var>, <var class=Fa>uint64_t value</var>, <var class=Fa>bus_size_t count</var>);</p></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> The <code class=Nm>bus_space</code> functions exist to allow device drivers machine-independent access to bus memory and register areas. All of the functions and types described in this document can be used by including the <code class=In>&lt;<a class=In href=../src/machine/bus.h.html>machine/bus.h</a>&gt;</code> header file. <p class=Pp>Many common devices are used on multiple architectures, but are accessed differently on each because of architectural constraints. For instance, a device which is mapped in one system's I/O space may be mapped in memory space on a second system. On a third system, architectural limitations might change the way registers need to be accessed (e.g. creating a non-linear register space). In some cases, a single driver may need to access the same type of device in multiple ways in a single system or architecture. The goal of the <code class=Nm>bus_space</code> functions is to allow a single driver source file to manipulate a set of devices on different system architectures, and to allow a single driver object file to manipulate a set of devices on multiple bus types on a single architecture.</p><p class=Pp>Not all buses have to implement all functions described in this document, though that is encouraged if the operations are logically supported by the bus. Unimplemented functions should cause compile-time errors if possible.</p><p class=Pp>All of the interface definitions described in this document are shown as function prototypes and discussed as if they were required to be functions. Implementations are encouraged to implement prototyped (type-checked) versions of these interfaces, but may implement them as macros if appropriate. Machine-dependent types, variables, and functions should be marked clearly in <code class=In>&lt;<a class=In href=../src/machine/bus.h.html>machine/bus.h</a>&gt;</code> to avoid confusion with the machine-independent types and functions, and, if possible, should be given names which make the machine-dependence clear.</p></section><section class=Sh><h2 class=Sh id=CONCEPTS_AND_GUIDELINES><a class=permalink href=#CONCEPTS_AND_GUIDELINES>CONCEPTS AND GUIDELINES</a></h2> Bus spaces are described by bus space tags, which can be created only by machine-dependent code. A given machine may have several different types of bus space (e.g. memory space and I/O space), and thus may provide multiple different bus space tags. Individual buses or devices on a machine may use more than one bus space tag. For instance, ISA devices are given an ISA memory space tag and an ISA I/O space tag. Architectures may have several different tags which represent the same type of space, for instance because of multiple different host bus interface chipsets. <p class=Pp>A range in bus space is described by a bus address and a bus size. The bus address describes the start of the range in bus space. The bus size describes the size of the range in bytes. Buses which are not byte addressable may require use of bus space ranges with appropriately aligned addresses and properly rounded sizes.</p><p class=Pp>Access to regions of bus space is facilitated by use of bus space handles, which are usually created by mapping a specific range of a bus space. Handles may also be created by allocating and mapping a range of bus space, the actual location of which is picked by the implementation within bounds specified by the caller of the allocation function.</p><p class=Pp>All of the bus space access functions require one bus space tag argument, at least one handle argument, and at least one offset argument (a bus size). The bus space tag specifies the space, each handle specifies a region in the space, and each offset specifies the offset into the region of the actual location(s) to be accessed. Offsets are given in bytes, though buses may impose alignment constraints. The offset used to access data relative to a given handle must be such that all of the data being accessed is in the mapped region that the handle describes. Trying to access data outside that region is an error.</p><p class=Pp>Because some architectures' memory systems use buffering to improve memory and device access performance, there is a mechanism which can be used to create “barriers” in the bus space read and write stream. There are three types of barriers: read, write, and read/write. All reads started to the region before a read barrier must complete before any reads after the read barrier are started. (The analogous requirement is true for write barriers.) Read/write barriers force all reads and writes started before the barrier to complete before any reads or writes after the barrier are started. Correctly-written drivers will include all appropriate barriers, and assume only the read/write ordering imposed by the barrier operations.</p><p class=Pp>People trying to write portable drivers with the <code class=Nm>bus_space</code> functions should try to make minimal assumptions about what the system allows. In particular, they should expect that the system requires bus space addresses being accessed to be naturally aligned (i.e., base address of handle added to offset is a multiple of the access size), and that the system does alignment checking on pointers (i.e., pointer to objects being read and written must point to properly-aligned data).</p><p class=Pp>The descriptions of the <code class=Nm>bus_space</code> functions given below all assume that they are called with proper arguments. If called with invalid arguments or arguments that are out of range (e.g. trying to access data outside of the region mapped when a given handle was created), undefined behaviour results. In that case, they may cause the system to halt, either intentionally (via panic) or unintentionally (by causing a fatal trap of by some other means) or may cause improper operation which is not immediately fatal. Functions which return <var class=Ft>void</var> or which return data read from bus space (i.e., functions which do not obviously return an error code) do not fail. They could only fail if given invalid arguments, and in that case their behaviour is undefined. Functions which take a count of bytes have undefined results if the specified <var class=Fa>count</var> is zero.</p></section><section class=Sh><h2 class=Sh id=TYPES><a class=permalink href=#TYPES>TYPES</a></h2> Several types are defined in <code class=In>&lt;<a class=In href=../src/machine/bus.h.html>machine/bus.h</a>&gt;</code> to facilitate use of the <code class=Nm>bus_space</code> functions by drivers. <section class=Ss><h2 class=Ss><var class=Vt>bus_addr_t</var></h2> The <var class=Vt>bus_addr_t</var> type is used to describe bus addresses. It must be an unsigned integral type capable of holding the largest bus address usable by the architecture. This type is primarily used when mapping and unmapping bus space. </section><section class=Ss><h2 class=Ss><var class=Vt>bus_size_t</var></h2> The <var class=Vt>bus_size_t</var> type is used to describe sizes of ranges in bus space. It must be an unsigned integral type capable of holding the size of the largest bus address range usable on the architecture. This type is used by virtually all of the <code class=Nm>bus_space</code> functions, describing sizes when mapping regions and offsets into regions when performing space access operations. </section><section class=Ss><h2 class=Ss><var class=Vt>bus_space_tag_t</var></h2> The <var class=Vt>bus_space_tag_t</var> type is used to describe a particular bus space on a machine. Its contents are machine-dependent and should be considered opaque by machine-independent code. This type is used by all <code class=Nm>bus_space</code> functions to name the space on which they are operating. </section><section class=Ss><h2 class=Ss><var class=Vt>bus_space_handle_t</var></h2> The <var class=Vt>bus_space_handle_t</var> type is used to describe a mapping of a range of bus space. Its contents are machine-dependent and should be considered opaque by machine-independent code. This type is used when performing bus space access operations. </section></section><section class=Sh><h2 class=Sh id=MAPPING_AND_UNMAPPING_BUS_SPACE><a class=permalink href=#MAPPING_AND_UNMAPPING_BUS_SPACE>MAPPING AND UNMAPPING BUS SPACE</a></h2> This section is specific to the <span class=Ux>NetBSD</span> version of these functions and may or may not apply to the <span class=Ux>FreeBSD</span> version. <p class=Pp>Bus space must be mapped before it can be used, and should be unmapped when it is no longer needed. The <code class=Fn>bus_space_map</code>() and <code class=Fn>bus_space_unmap</code>() functions provide these capabilities.</p><p class=Pp>Some drivers need to be able to pass a subregion of already-mapped bus space to another driver or module within a driver. The <code class=Fn>bus_space_subregion</code>() function allows such subregions to be created.</p><section class=Ss><h2 class=Ss><code class=Fn>bus_space_map</code>(<var class=Fa>space</var>, <var class=Fa>address</var>, <var class=Fa>size</var>, <var class=Fa>flags</var>, <var class=Fa>handlep</var>)</h2> The <code class=Fn>bus_space_map</code>() function maps the region of bus space named by the <var class=Fa>space</var>, <var class=Fa>address</var>, and <var class=Fa>size</var> arguments. If successful, it returns zero and fills in the bus space handle pointed to by <var class=Fa>handlep</var> with the handle that can be used to access the mapped region. If unsuccessful, it will return non-zero and leave the bus space handle pointed to by <var class=Fa>handlep</var> in an undefined state. <p class=Pp>The <var class=Fa>flags</var> argument controls how the space is to be mapped. Supported flags include:</p><dl class=Bl-tag><dt><a class=permalink href=#BUS_SPACE_MAP_CACHEABLE><code class=Dv id=BUS_SPACE_MAP_CACHEABLE>BUS_SPACE_MAP_CACHEABLE</code></a></dt><dd>Try to map the space so that accesses can be cached and/or prefetched by the system. If this flag is not specified, the implementation should map the space so that it will not be cached or prefetched. <p class=Pp>This flag must have a value of 1 on all implementations for backward compatibility.</p></dd><dt><a class=permalink href=#BUS_SPACE_MAP_LINEAR><code class=Dv id=BUS_SPACE_MAP_LINEAR>BUS_SPACE_MAP_LINEAR</code></a></dt><dd>Try to map the space so that its contents can be accessed linearly via normal memory access methods (e.g. pointer dereferencing and structure accesses). This is useful when software wants to do direct access to a memory device, e.g. a frame buffer. If this flag is specified and linear mapping is not possible, the <code class=Fn>bus_space_map</code>() call should fail. If this flag is not specified, the system may map the space in whatever way is most convenient.</dd></dl><p class=Pp>Not all combinations of flags make sense or are supported with all spaces. For instance, <code class=Dv>BUS_SPACE_MAP_CACHEABLE</code> may be meaningless when used on many systems' I/O port spaces, and on some systems <code class=Dv>BUS_SPACE_MAP_LINEAR</code> without <code class=Dv>BUS_SPACE_MAP_CACHEABLE</code> may never work. When the system hardware or firmware provides hints as to how spaces should be mapped (e.g. the PCI memory mapping registers' “prefetchable” bit), those hints should be followed for maximum compatibility. On some systems, requesting a mapping that cannot be satisfied (e.g. requesting a non-cacheable mapping when the system can only provide a cacheable one) will cause the request to fail.</p><p class=Pp>Some implementations may keep track of use of bus space for some or all bus spaces and refuse to allow duplicate allocations. This is encouraged for bus spaces which have no notion of slot-specific space addressing, such as ISA, and for spaces which coexist with those spaces (e.g. PCI memory and I/O spaces co-existing with ISA memory and I/O spaces).</p><p class=Pp>Mapped regions may contain areas for which there is no device on the bus. If space in those areas is accessed, the results are bus-dependent.</p></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_unmap</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>size</var>)</h2> The <code class=Fn>bus_space_unmap</code>() function unmaps a region of bus space mapped with <code class=Fn>bus_space_map</code>(). When unmapping a region, the <var class=Fa>size</var> specified should be the same as the size given to <code class=Fn>bus_space_map</code>() when mapping that region. <p class=Pp>After <code class=Fn>bus_space_unmap</code>() is called on a handle, that handle is no longer valid. (If copies were made of the handle they are no longer valid, either.)</p><p class=Pp>This function will never fail. If it would fail (e.g. because of an argument error), that indicates a software bug which should cause a panic. In that case, <code class=Fn>bus_space_unmap</code>() will never return.</p></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_subregion</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>size</var>, <var class=Fa>nhandlep</var>)</h2> The <code class=Fn>bus_space_subregion</code>() function is a convenience function which makes a new handle to some subregion of an already-mapped region of bus space. The subregion described by the new handle starts at byte offset <var class=Fa>offset</var> into the region described by <var class=Fa>handle</var>, with the size give by <var class=Fa>size</var>, and must be wholly contained within the original region. <p class=Pp>If successful, <code class=Fn>bus_space_subregion</code>() returns zero and fills in the bus space handle pointed to by <var class=Fa>nhandlep</var>. If unsuccessful, it returns non-zero and leaves the bus space handle pointed to by <var class=Fa>nhandlep</var> in an undefined state. In either case, the handle described by <var class=Fa>handle</var> remains valid and is unmodified.</p><p class=Pp>When done with a handle created by <code class=Fn>bus_space_subregion</code>(), the handle should be thrown away. Under no circumstances should <code class=Fn>bus_space_unmap</code>() be used on the handle. Doing so may confuse any resource management being done on the space, and will result in undefined behaviour. When <code class=Fn>bus_space_unmap</code>() or <code class=Fn>bus_space_free</code>() is called on a handle, all subregions of that handle become invalid.</p></section></section><section class=Sh><h2 class=Sh id=ALLOCATING_AND_FREEING_BUS_SPACE><a class=permalink href=#ALLOCATING_AND_FREEING_BUS_SPACE>ALLOCATING AND FREEING BUS SPACE</a></h2> This section is specific to the <span class=Ux>NetBSD</span> version of these functions and may or may not apply to the <span class=Ux>FreeBSD</span> version. <p class=Pp>Some devices require or allow bus space to be allocated by the operating system for device use. When the devices no longer need the space, the operating system should free it for use by other devices. The <code class=Fn>bus_space_alloc</code>() and <code class=Fn>bus_space_free</code>() functions provide these capabilities.</p><section class=Ss><h2 class=Ss><code class=Fn>bus_space_alloc</code>(<var class=Fa>space</var>, <var class=Fa>reg_start</var>, <var class=Fa>reg_end</var>, <var class=Fa>size</var>, <var class=Fa>alignment</var>, <var class=Fa>boundary</var>, <var class=Fa>flags</var>, <var class=Fa>addrp</var>, <var class=Fa>handlep</var>)</h2> The <code class=Fn>bus_space_alloc</code>() function allocates and maps a region of bus space with the size given by <var class=Fa>size</var>, corresponding to the given constraints. If successful, it returns zero, fills in the bus address pointed to by <var class=Fa>addrp</var> with the bus space address of the allocated region, and fills in the bus space handle pointed to by <var class=Fa>handlep</var> with the handle that can be used to access that region. If unsuccessful, it returns non-zero and leaves the bus address pointed to by <var class=Fa>addrp</var> and the bus space handle pointed to by <var class=Fa>handlep</var> in an undefined state. <p class=Pp>Constraints on the allocation are given by the <var class=Fa>reg_start</var>, <var class=Fa>reg_end</var>, <var class=Fa>alignment</var>, and <var class=Fa>boundary</var> parameters. The allocated region will start at or after <var class=Fa>reg_start</var> and end before or at <var class=Fa>reg_end</var>. The <var class=Fa>alignment</var> constraint must be a power of two, and the allocated region will start at an address that is an even multiple of that power of two. The <var class=Fa>boundary</var> constraint, if non-zero, ensures that the region is allocated so that <var class=Fa>first address in region</var> / <var class=Fa>boundary</var> has the same value as <var class=Fa>last address in region</var> / <var class=Fa>boundary</var>. If the constraints cannot be met, <code class=Fn>bus_space_alloc</code>() will fail. It is an error to specify a set of constraints that can never be met (for example, <var class=Fa>size</var> greater than <var class=Fa>boundary</var>).</p><p class=Pp>The <var class=Fa>flags</var> parameter is the same as the like-named parameter to <code class=Fn>bus_space_map</code>(), the same flag values should be used, and they have the same meanings.</p><p class=Pp>Handles created by <code class=Fn>bus_space_alloc</code>() should only be freed with <code class=Fn>bus_space_free</code>(). Trying to use <code class=Fn>bus_space_unmap</code>() on them causes undefined behaviour. The <code class=Fn>bus_space_subregion</code>() function can be used on handles created by <code class=Fn>bus_space_alloc</code>().</p></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_free</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>size</var>)</h2> The <code class=Fn>bus_space_free</code>() function unmaps and frees a region of bus space mapped and allocated with <code class=Fn>bus_space_alloc</code>(). When unmapping a region, the <var class=Fa>size</var> specified should be the same as the size given to <code class=Fn>bus_space_alloc</code>() when allocating the region. <p class=Pp>After <code class=Fn>bus_space_free</code>() is called on a handle, that handle is no longer valid. (If copies were made of the handle, they are no longer valid, either.)</p><p class=Pp>This function will never fail. If it would fail (e.g. because of an argument error), that indicates a software bug which should cause a panic. In that case, <code class=Fn>bus_space_free</code>() will never return.</p></section></section><section class=Sh><h2 class=Sh id=READING_AND_WRITING_SINGLE_DATA_ITEMS><a class=permalink href=#READING_AND_WRITING_SINGLE_DATA_ITEMS>READING AND WRITING SINGLE DATA ITEMS</a></h2> The simplest way to access bus space is to read or write a single data item. The <code class=Fn>bus_space_read_N</code>() and <code class=Fn>bus_space_write_N</code>() families of functions provide the ability to read and write 1, 2, 4, and 8 byte data items on buses which support those access sizes. <section class=Ss><h2 class=Ss><code class=Fn>bus_space_read_1</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_read_2</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_read_4</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_read_8</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>)</h2> The <code class=Fn>bus_space_read_N</code>() family of functions reads a 1, 2, 4, or 8 byte data item from the offset specified by <var class=Fa>offset</var> into the region specified by <var class=Fa>handle</var> of the bus space specified by <var class=Fa>space</var>. The location being read must lie within the bus space region specified by <var class=Fa>handle</var>. <p class=Pp>For portability, the starting address of the region specified by <var class=Fa>handle</var> plus the offset should be a multiple of the size of data item being read. On some systems, not obeying this requirement may cause incorrect data to be read, on others it may cause a system crash.</p><p class=Pp>Read operations done by the <code class=Fn>bus_space_read_N</code>() functions may be executed out of order with respect to other pending read and write operations unless order is enforced by use of the <code class=Fn>bus_space_barrier</code>() function.</p><p class=Pp>These functions will never fail. If they would fail (e.g. because of an argument error), that indicates a software bug which should cause a panic. In that case, they will never return.</p></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_write_1</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>value</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_write_2</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>value</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_write_4</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>value</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_write_8</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>value</var>)</h2> The <code class=Fn>bus_space_write_N</code>() family of functions writes a 1, 2, 4, or 8 byte data item to the offset specified by <var class=Fa>offset</var> into the region specified by <var class=Fa>handle</var> of the bus space specified by <var class=Fa>space</var>. The location being written must lie within the bus space region specified by <var class=Fa>handle</var>. <p class=Pp>For portability, the starting address of the region specified by <var class=Fa>handle</var> plus the offset should be a multiple of the size of data item being written. On some systems, not obeying this requirement may cause incorrect data to be written, on others it may cause a system crash.</p><p class=Pp>Write operations done by the <code class=Fn>bus_space_write_N</code>() functions may be executed out of order with respect to other pending read and write operations unless order is enforced by use of the <code class=Fn>bus_space_barrier</code>() function.</p><p class=Pp>These functions will never fail. If they would fail (e.g. because of an argument error), that indicates a software bug which should cause a panic. In that case, they will never return.</p></section></section><section class=Sh><h2 class=Sh id=BARRIERS><a class=permalink href=#BARRIERS>BARRIERS</a></h2> In order to allow high-performance buffering implementations to avoid bus activity on every operation, read and write ordering should be specified explicitly by drivers when necessary. The <code class=Fn>bus_space_barrier</code>() function provides that ability. <section class=Ss><h2 class=Ss><code class=Fn>bus_space_barrier</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>length</var>, <var class=Fa>flags</var>)</h2> The <code class=Fn>bus_space_barrier</code>() function enforces ordering of bus space read and write operations for the specified subregion (described by the <var class=Fa>offset</var> and <var class=Fa>length</var> parameters) of the region named by <var class=Fa>handle</var> in the space named by <var class=Fa>space</var>. <p class=Pp>The <var class=Fa>flags</var> argument controls what types of operations are to be ordered. Supported flags are:</p><dl class=Bl-tag><dt><a class=permalink href=#BUS_SPACE_BARRIER_READ><code class=Dv id=BUS_SPACE_BARRIER_READ>BUS_SPACE_BARRIER_READ</code></a></dt><dd>Synchronize read operations.</dd><dt><a class=permalink href=#BUS_SPACE_BARRIER_WRITE><code class=Dv id=BUS_SPACE_BARRIER_WRITE>BUS_SPACE_BARRIER_WRITE</code></a></dt><dd>Synchronize write operations.</dd></dl><p class=Pp>Those flags can be combined (or-ed together) to enforce ordering on both read and write operations.</p><p class=Pp>All of the specified type(s) of operation which are done to the region before the barrier operation are guaranteed to complete before any of the specified type(s) of operation done after the barrier.</p><p class=Pp>Example: Consider a hypothetical device with two single-byte ports, one write-only input port (at offset 0) and a read-only output port (at offset 1). Operation of the device is as follows: data bytes are written to the input port, and are placed by the device on a stack, the top of which is read by reading from the output port. The sequence to correctly write two data bytes to the device then read those two data bytes back would be:</p><div class="Bd Pp"><pre>
/*
 * t and h are the tag and handle for the mapped device's
 * space.
 */
bus_space_write_1(t, h, 0, data0);
bus_space_barrier(t, h, 0, 1, BUS_SPACE_BARRIER_WRITE);  /* 1 */
bus_space_write_1(t, h, 0, data1);
bus_space_barrier(t, h, 0, 2,
    BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE);     /* 2 */
ndata1 = bus_space_read_1(t, h, 1);
bus_space_barrier(t, h, 1, 1, BUS_SPACE_BARRIER_READ);   /* 3 */
ndata0 = bus_space_read_1(t, h, 1);
/* data0 == ndata0, data1 == ndata1 */
</pre></div><p class=Pp>The first barrier makes sure that the first write finishes before the second write is issued, so that two writes to the input port are done in order and are not collapsed into a single write. This ensures that the data bytes are written to the device correctly and in order.</p><p class=Pp>The second barrier makes sure that the writes to the output port finish before any of the reads to the input port are issued, thereby making sure that all of the writes are finished before data is read. This ensures that the first byte read from the device really is the last one that was written.</p><p class=Pp>The third barrier makes sure that the first read finishes before the second read is issued, ensuring that data is read correctly and in order.</p><p class=Pp>The barriers in the example above are specified to cover the absolute minimum number of bus space locations. It is correct (and often easier) to make barrier operations cover the device's whole range of bus space, that is, to specify an offset of zero and the size of the whole region.</p></section></section><section class=Sh><h2 class=Sh id=REGION_OPERATIONS><a class=permalink href=#REGION_OPERATIONS>REGION OPERATIONS</a></h2> Some devices use buffers which are mapped as regions in bus space. Often, drivers want to copy the contents of those buffers to or from memory, e.g. into mbufs which can be passed to higher levels of the system or from mbufs to be output to a network. In order to allow drivers to do this as efficiently as possible, the <code class=Fn>bus_space_read_region_N</code>() and <code class=Fn>bus_space_write_region_N</code>() families of functions are provided. <p class=Pp>Drivers occasionally need to copy one region of a bus space to another, or to set all locations in a region of bus space to contain a single value. The <code class=Fn>bus_space_copy_region_N</code>() family of functions and the <code class=Fn>bus_space_set_region_N</code>() family of functions allow drivers to perform these operations.</p><section class=Ss><h2 class=Ss><code class=Fn>bus_space_read_region_1</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>datap</var>, <var class=Fa>count</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_read_region_2</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>datap</var>, <var class=Fa>count</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_read_region_4</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>datap</var>, <var class=Fa>count</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_read_region_8</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>datap</var>, <var class=Fa>count</var>)</h2> The <code class=Fn>bus_space_read_region_N</code>() family of functions reads <var class=Fa>count</var> 1, 2, 4, or 8 byte data items from bus space starting at byte offset <var class=Fa>offset</var> in the region specified by <var class=Fa>handle</var> of the bus space specified by <var class=Fa>space</var> and writes them into the array specified by <var class=Fa>datap</var>. Each successive data item is read from an offset 1, 2, 4, or 8 bytes after the previous data item (depending on which function is used). All locations being read must lie within the bus space region specified by <var class=Fa>handle</var>. <p class=Pp>For portability, the starting address of the region specified by <var class=Fa>handle</var> plus the offset should be a multiple of the size of data items being read and the data array pointer should be properly aligned. On some systems, not obeying these requirements may cause incorrect data to be read, on others it may cause a system crash.</p><p class=Pp>Read operations done by the <code class=Fn>bus_space_read_region_N</code>() functions may be executed in any order. They may also be executed out of order with respect to other pending read and write operations unless order is enforced by use of the <code class=Fn>bus_space_barrier</code>() function. There is no way to insert barriers between reads of individual bus space locations executed by the <code class=Fn>bus_space_read_region_N</code>() functions.</p><p class=Pp>These functions will never fail. If they would fail (e.g. because of an argument error), that indicates a software bug which should cause a panic. In that case, they will never return.</p></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_write_region_1</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>datap</var>, <var class=Fa>count</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_write_region_2</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>datap</var>, <var class=Fa>count</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_write_region_4</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>datap</var>, <var class=Fa>count</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_write_region_8</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>datap</var>, <var class=Fa>count</var>)</h2> The <code class=Fn>bus_space_write_region_N</code>() family of functions reads <var class=Fa>count</var> 1, 2, 4, or 8 byte data items from the array specified by <var class=Fa>datap</var> and writes them to bus space starting at byte offset <var class=Fa>offset</var> in the region specified by <var class=Fa>handle</var> of the bus space specified by <var class=Fa>space</var>. Each successive data item is written to an offset 1, 2, 4, or 8 bytes after the previous data item (depending on which function is used). All locations being written must lie within the bus space region specified by <var class=Fa>handle</var>. <p class=Pp>For portability, the starting address of the region specified by <var class=Fa>handle</var> plus the offset should be a multiple of the size of data items being written and the data array pointer should be properly aligned. On some systems, not obeying these requirements may cause incorrect data to be written, on others it may cause a system crash.</p><p class=Pp>Write operations done by the <code class=Fn>bus_space_write_region_N</code>() functions may be executed in any order. They may also be executed out of order with respect to other pending read and write operations unless order is enforced by use of the <code class=Fn>bus_space_barrier</code>() function. There is no way to insert barriers between writes of individual bus space locations executed by the <code class=Fn>bus_space_write_region_N</code>() functions.</p><p class=Pp>These functions will never fail. If they would fail (e.g. because of an argument error), that indicates a software bug which should cause a panic. In that case, they will never return.</p></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_copy_region_1</code>(<var class=Fa>space</var>, <var class=Fa>srchandle</var>, <var class=Fa>srcoffset</var>, <var class=Fa>dsthandle</var>, <var class=Fa>dstoffset</var>, <var class=Fa>count</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_copy_region_2</code>(<var class=Fa>space</var>, <var class=Fa>srchandle</var>, <var class=Fa>srcoffset</var>, <var class=Fa>dsthandle</var>, <var class=Fa>dstoffset</var>, <var class=Fa>count</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_copy_region_4</code>(<var class=Fa>space</var>, <var class=Fa>srchandle</var>, <var class=Fa>srcoffset</var>, <var class=Fa>dsthandle</var>, <var class=Fa>dstoffset</var>, <var class=Fa>count</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_copy_region_8</code>(<var class=Fa>space</var>, <var class=Fa>srchandle</var>, <var class=Fa>srcoffset</var>, <var class=Fa>dsthandle</var>, <var class=Fa>dstoffset</var>, <var class=Fa>count</var>)</h2> The <code class=Fn>bus_space_copy_region_N</code>() family of functions copies <var class=Fa>count</var> 1, 2, 4, or 8 byte data items in bus space from the area starting at byte offset <var class=Fa>srcoffset</var> in the region specified by <var class=Fa>srchandle</var> of the bus space specified by <var class=Fa>space</var> to the area starting at byte offset <var class=Fa>dstoffset</var> in the region specified by <var class=Fa>dsthandle</var> in the same bus space. Each successive data item read or written has an offset 1, 2, 4, or 8 bytes after the previous data item (depending on which function is used). All locations being read and written must lie within the bus space region specified by their respective handles. <p class=Pp>For portability, the starting addresses of the regions specified by the each handle plus its respective offset should be a multiple of the size of data items being copied. On some systems, not obeying this requirement may cause incorrect data to be copied, on others it may cause a system crash.</p><p class=Pp>Read and write operations done by the <code class=Fn>bus_space_copy_region_N</code>() functions may be executed in any order. They may also be executed out of order with respect to other pending read and write operations unless order is enforced by use of the <code class=Fn>bus_space_barrier</code>() function. There is no way to insert barriers between reads or writes of individual bus space locations executed by the <code class=Fn>bus_space_copy_region_N</code>() functions.</p><p class=Pp>Overlapping copies between different subregions of a single region of bus space are handled correctly by the <code class=Fn>bus_space_copy_region_N</code>() functions.</p><p class=Pp>These functions will never fail. If they would fail (e.g. because of an argument error), that indicates a software bug which should cause a panic. In that case, they will never return.</p></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_set_region_1</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>value</var>, <var class=Fa>count</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_set_region_2</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>value</var>, <var class=Fa>count</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_set_region_4</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>value</var>, <var class=Fa>count</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_set_region_8</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>value</var>, <var class=Fa>count</var>)</h2> The <code class=Fn>bus_space_set_region_N</code>() family of functions writes the given <var class=Fa>value</var> to <var class=Fa>count</var> 1, 2, 4, or 8 byte data items in bus space starting at byte offset <var class=Fa>offset</var> in the region specified by <var class=Fa>handle</var> of the bus space specified by <var class=Fa>space</var>. Each successive data item has an offset 1, 2, 4, or 8 bytes after the previous data item (depending on which function is used). All locations being written must lie within the bus space region specified by <var class=Fa>handle</var>. <p class=Pp>For portability, the starting address of the region specified by <var class=Fa>handle</var> plus the offset should be a multiple of the size of data items being written. On some systems, not obeying this requirement may cause incorrect data to be written, on others it may cause a system crash.</p><p class=Pp>Write operations done by the <code class=Fn>bus_space_set_region_N</code>() functions may be executed in any order. They may also be executed out of order with respect to other pending read and write operations unless order is enforced by use of the <code class=Fn>bus_space_barrier</code>() function. There is no way to insert barriers between writes of individual bus space locations executed by the <code class=Fn>bus_space_set_region_N</code>() functions.</p><p class=Pp>These functions will never fail. If they would fail (e.g. because of an argument error), that indicates a software bug which should cause a panic. In that case, they will never return.</p></section></section><section class=Sh><h2 class=Sh id=READING_AND_WRITING_A_SINGLE_LOCATION_MULTIPLE_TIMES><a class=permalink href=#READING_AND_WRITING_A_SINGLE_LOCATION_MULTIPLE_TIMES>READING AND WRITING A SINGLE LOCATION MULTIPLE TIMES</a></h2> Some devices implement single locations in bus space which are to be read or written multiple times to communicate data, e.g. some ethernet devices' packet buffer FIFOs. In order to allow drivers to manipulate these types of devices as efficiently as possible, the <code class=Fn>bus_space_read_multi_N</code>(), <code class=Fn>bus_space_set_multi_N</code>(), and <code class=Fn>bus_space_write_multi_N</code>() families of functions are provided. <section class=Ss><h2 class=Ss><code class=Fn>bus_space_read_multi_1</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>datap</var>, <var class=Fa>count</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_read_multi_2</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>datap</var>, <var class=Fa>count</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_read_multi_4</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>datap</var>, <var class=Fa>count</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_read_multi_8</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>datap</var>, <var class=Fa>count</var>)</h2> The <code class=Fn>bus_space_read_multi_N</code>() family of functions reads <var class=Fa>count</var> 1, 2, 4, or 8 byte data items from bus space at byte offset <var class=Fa>offset</var> in the region specified by <var class=Fa>handle</var> of the bus space specified by <var class=Fa>space</var> and writes them into the array specified by <var class=Fa>datap</var>. Each successive data item is read from the same location in bus space. The location being read must lie within the bus space region specified by <var class=Fa>handle</var>. <p class=Pp>For portability, the starting address of the region specified by <var class=Fa>handle</var> plus the offset should be a multiple of the size of data items being read and the data array pointer should be properly aligned. On some systems, not obeying these requirements may cause incorrect data to be read, on others it may cause a system crash.</p><p class=Pp>Read operations done by the <code class=Fn>bus_space_read_multi_N</code>() functions may be executed out of order with respect to other pending read and write operations unless order is enforced by use of the <code class=Fn>bus_space_barrier</code>() function. Because the <code class=Fn>bus_space_read_multi_N</code>() functions read the same bus space location multiple times, they place an implicit read barrier between each successive read of that bus space location.</p><p class=Pp>These functions will never fail. If they would fail (e.g. because of an argument error), that indicates a software bug which should cause a panic. In that case, they will never return.</p></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_write_multi_1</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>datap</var>, <var class=Fa>count</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_write_multi_2</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>datap</var>, <var class=Fa>count</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_write_multi_4</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>datap</var>, <var class=Fa>count</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_write_multi_8</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>datap</var>, <var class=Fa>count</var>)</h2> The <code class=Fn>bus_space_write_multi_N</code>() family of functions reads <var class=Fa>count</var> 1, 2, 4, or 8 byte data items from the array specified by <var class=Fa>datap</var> and writes them into bus space at byte offset <var class=Fa>offset</var> in the region specified by <var class=Fa>handle</var> of the bus space specified by <var class=Fa>space</var>. Each successive data item is written to the same location in bus space. The location being written must lie within the bus space region specified by <var class=Fa>handle</var>. <p class=Pp>For portability, the starting address of the region specified by <var class=Fa>handle</var> plus the offset should be a multiple of the size of data items being written and the data array pointer should be properly aligned. On some systems, not obeying these requirements may cause incorrect data to be written, on others it may cause a system crash.</p><p class=Pp>Write operations done by the <code class=Fn>bus_space_write_multi_N</code>() functions may be executed out of order with respect to other pending read and write operations unless order is enforced by use of the <code class=Fn>bus_space_barrier</code>() function. Because the <code class=Fn>bus_space_write_multi_N</code>() functions write the same bus space location multiple times, they place an implicit write barrier between each successive write of that bus space location.</p><p class=Pp>These functions will never fail. If they would fail (e.g. because of an argument error), that indicates a software bug which should cause a panic. In that case, they will never return.</p></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_set_multi_1</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>value</var>, <var class=Fa>count</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_set_multi_2</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>value</var>, <var class=Fa>count</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_set_multi_4</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>value</var>, <var class=Fa>count</var>)</h2></section><section class=Ss><h2 class=Ss><code class=Fn>bus_space_set_multi_8</code>(<var class=Fa>space</var>, <var class=Fa>handle</var>, <var class=Fa>offset</var>, <var class=Fa>value</var>, <var class=Fa>count</var>)</h2> The <code class=Fn>bus_space_set_multi_N</code>() writes <var class=Fa>value</var> into bus space at byte offset <var class=Fa>offset</var> in the region specified by <var class=Fa>handle</var> of the bus space specified by <var class=Fa>space</var>, <var class=Fa>count</var> times. The location being written must lie within the bus space region specified by <var class=Fa>handle</var>. <p class=Pp>For portability, the starting address of the region specified by <var class=Fa>handle</var> plus the offset should be a multiple of the size of data items being written and the data array pointer should be properly aligned. On some systems, not obeying these requirements may cause incorrect data to be written, on others it may cause a system crash.</p><p class=Pp>Write operations done by the <code class=Fn>bus_space_set_multi_N</code>() functions may be executed out of order with respect to other pending read and write operations unless order is enforced by use of the <code class=Fn>bus_space_barrier</code>() function. Because the <code class=Fn>bus_space_set_multi_N</code>() functions write the same bus space location multiple times, they place an implicit write barrier between each successive write of that bus space location.</p><p class=Pp>These functions will never fail. If they would fail (e.g. because of an argument error), that indicates a software bug which should cause a panic. In that case, they will never return.</p></section></section><section class=Sh><h2 class=Sh id=STREAM_FUNCTIONS><a class=permalink href=#STREAM_FUNCTIONS>STREAM FUNCTIONS</a></h2> Most of the <code class=Nm>bus_space</code> functions imply a host byte-order and a bus byte-order and take care of any translation for the caller. In some cases, however, hardware may map a FIFO or some other memory region for which the caller may want to use multi-word, yet untranslated access. Access to these types of memory regions should be with the <code class=Fn>bus_space_*_stream_N</code>() functions. <p class=Pp></p><dl class="Bl-tag Bl-compact"><dt><code class=Fn>bus_space_read_stream_1</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_read_stream_2</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_read_stream_4</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_read_stream_8</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_read_multi_stream_1</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_read_multi_stream_2</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_read_multi_stream_4</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_read_multi_stream_8</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_read_region_stream_1</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_read_region_stream_2</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_read_region_stream_4</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_read_region_stream_8</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_write_stream_1</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_write_stream_2</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_write_stream_4</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_write_stream_8</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_write_multi_stream_1</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_write_multi_stream_2</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_write_multi_stream_4</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_write_multi_stream_8</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_write_region_stream_1</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_write_region_stream_2</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_write_region_stream_4</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_write_region_stream_8</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_copy_region_stream_1</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_copy_region_stream_2</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_copy_region_stream_4</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_copy_region_stream_8</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_set_multi_stream_1</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_set_multi_stream_2</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_set_multi_stream_4</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_set_multi_stream_8</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_set_region_stream_1</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_set_region_stream_2</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_set_region_stream_4</code>()</dt><dd style="width: auto;"> </dd><dt><code class=Fn>bus_space_set_region_stream_8</code>()</dt><dd style="width: auto;"> </dd></dl><p class=Pp>These functions are defined just as their non-stream counterparts, except that they provide no byte-order translation.</p></section><section class=Sh><h2 class=Sh id=COMPATIBILITY><a class=permalink href=#COMPATIBILITY>COMPATIBILITY</a></h2> The current <span class=Ux>NetBSD</span> version of the <code class=Nm>bus_space</code> interface specification differs slightly from the original specification that came into wide use and <span class=Ux>FreeBSD</span> adopted. A few of the function names and arguments have changed for consistency and increased functionality. </section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=bus_dma.9.html>bus_dma(9)</a></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> The <code class=Nm>bus_space</code> functions were introduced in a different form (memory and I/O spaces were accessed via different sets of functions) in <span class=Ux>NetBSD 1.2</span>. The functions were merged to work on generic “spaces” early in the <span class=Ux>NetBSD 1.3</span> development cycle, and many drivers were converted to use them. This document was written later during the <span class=Ux>NetBSD 1.3</span> development cycle, and the specification was updated to fix some consistency problems and to add some missing functionality. <p class=Pp>The manual page was then adapted to the version of the interface that <span class=Ux>FreeBSD</span> imported for the CAM SCSI drivers, plus subsequent evolution. The <span class=Ux>FreeBSD</span><code class=Nm>bus_space</code> version was imported in <span class=Ux>FreeBSD 3.0</span>.</p></section><section class=Sh><h2 class=Sh id=AUTHORS><a class=permalink href=#AUTHORS>AUTHORS</a></h2> The <code class=Nm>bus_space</code> interfaces were designed and implemented by the <span class=Ux>NetBSD</span> developer community. Primary contributors and implementors were <span class=An>Chris Demetriou</span>, <span class=An>Jason Thorpe</span>, and <span class=An>Charles Hannum</span>, but the rest of the <span class=Ux>NetBSD</span> developers and the user community played a significant role in development. <p class=Pp><span class=An>Justin Gibbs</span> ported these interfaces to <span class=Ux>FreeBSD</span>.</p><p class=Pp><span class=An>Chris Demetriou</span> wrote this manual page.</p><p class=Pp><span class=An>Warner Losh</span> modified it for the <span class=Ux>FreeBSD</span> implementation.</p></section><section class=Sh><h2 class=Sh id=BUGS><a class=permalink href=#BUGS>BUGS</a></h2> This manual may not completely and accurately document the interface, and many parts of the interface are unspecified. </section></div><table class=foot><tr><td class=foot-date>January 15, 2017</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>