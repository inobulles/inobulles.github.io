<!DOCTYPE html>
<html><head><meta charset=utf-8><title>TAILQ_EMPTY(3)</title><keywords content=man,TAILQ_EMPTY></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>TAILQ_EMPTY(3)</h1><table class=head><tr><td class=head-ltitle>QUEUE(3)</td><td class=head-vol>FreeBSD Library Functions Manual</td><td class=head-rtitle>QUEUE(3)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>SLIST_CLASS_ENTRY</code>, <code class=Nm>SLIST_CLASS_HEAD</code>, <code class=Nm>SLIST_CONCAT</code>, <code class=Nm>SLIST_EMPTY</code>, <code class=Nm>SLIST_ENTRY</code>, <code class=Nm>SLIST_FIRST</code>, <code class=Nm>SLIST_FOREACH</code>, <code class=Nm>SLIST_FOREACH_FROM</code>, <code class=Nm>SLIST_FOREACH_FROM_SAFE</code>, <code class=Nm>SLIST_FOREACH_SAFE</code>, <code class=Nm>SLIST_HEAD</code>, <code class=Nm>SLIST_HEAD_INITIALIZER</code>, <code class=Nm>SLIST_INIT</code>, <code class=Nm>SLIST_INSERT_AFTER</code>, <code class=Nm>SLIST_INSERT_HEAD</code>, <code class=Nm>SLIST_NEXT</code>, <code class=Nm>SLIST_REMOVE</code>, <code class=Nm>SLIST_REMOVE_AFTER</code>, <code class=Nm>SLIST_REMOVE_HEAD</code>, <code class=Nm>SLIST_SWAP</code>, <code class=Nm>STAILQ_CLASS_ENTRY</code>, <code class=Nm>STAILQ_CLASS_HEAD</code>, <code class=Nm>STAILQ_CONCAT</code>, <code class=Nm>STAILQ_EMPTY</code>, <code class=Nm>STAILQ_ENTRY</code>, <code class=Nm>STAILQ_FIRST</code>, <code class=Nm>STAILQ_FOREACH</code>, <code class=Nm>STAILQ_FOREACH_FROM</code>, <code class=Nm>STAILQ_FOREACH_FROM_SAFE</code>, <code class=Nm>STAILQ_FOREACH_SAFE</code>, <code class=Nm>STAILQ_HEAD</code>, <code class=Nm>STAILQ_HEAD_INITIALIZER</code>, <code class=Nm>STAILQ_INIT</code>, <code class=Nm>STAILQ_INSERT_AFTER</code>, <code class=Nm>STAILQ_INSERT_HEAD</code>, <code class=Nm>STAILQ_INSERT_TAIL</code>, <code class=Nm>STAILQ_LAST</code>, <code class=Nm>STAILQ_NEXT</code>, <code class=Nm>STAILQ_REMOVE</code>, <code class=Nm>STAILQ_REMOVE_AFTER</code>, <code class=Nm>STAILQ_REMOVE_HEAD</code>, <code class=Nm>STAILQ_SWAP</code>, <code class=Nm>LIST_CLASS_ENTRY</code>, <code class=Nm>LIST_CLASS_HEAD</code>, <code class=Nm>LIST_CONCAT</code>, <code class=Nm>LIST_EMPTY</code>, <code class=Nm>LIST_ENTRY</code>, <code class=Nm>LIST_FIRST</code>, <code class=Nm>LIST_FOREACH</code>, <code class=Nm>LIST_FOREACH_FROM</code>, <code class=Nm>LIST_FOREACH_FROM_SAFE</code>, <code class=Nm>LIST_FOREACH_SAFE</code>, <code class=Nm>LIST_HEAD</code>, <code class=Nm>LIST_HEAD_INITIALIZER</code>, <code class=Nm>LIST_INIT</code>, <code class=Nm>LIST_INSERT_AFTER</code>, <code class=Nm>LIST_INSERT_BEFORE</code>, <code class=Nm>LIST_INSERT_HEAD</code>, <code class=Nm>LIST_NEXT</code>, <code class=Nm>LIST_PREV</code>, <code class=Nm>LIST_REMOVE</code>, <code class=Nm>LIST_SWAP</code>, <code class=Nm>TAILQ_CLASS_ENTRY</code>, <code class=Nm>TAILQ_CLASS_HEAD</code>, <code class=Nm>TAILQ_CONCAT</code>, <code class=Nm>TAILQ_EMPTY</code>, <code class=Nm>TAILQ_ENTRY</code>, <code class=Nm>TAILQ_FIRST</code>, <code class=Nm>TAILQ_FOREACH</code>, <code class=Nm>TAILQ_FOREACH_FROM</code>, <code class=Nm>TAILQ_FOREACH_FROM_SAFE</code>, <code class=Nm>TAILQ_FOREACH_REVERSE</code>, <code class=Nm>TAILQ_FOREACH_REVERSE_FROM</code>, <code class=Nm>TAILQ_FOREACH_REVERSE_FROM_SAFE</code>, <code class=Nm>TAILQ_FOREACH_REVERSE_SAFE</code>, <code class=Nm>TAILQ_FOREACH_SAFE</code>, <code class=Nm>TAILQ_HEAD</code>, <code class=Nm>TAILQ_HEAD_INITIALIZER</code>, <code class=Nm>TAILQ_INIT</code>, <code class=Nm>TAILQ_INSERT_AFTER</code>, <code class=Nm>TAILQ_INSERT_BEFORE</code>, <code class=Nm>TAILQ_INSERT_HEAD</code>, <code class=Nm>TAILQ_INSERT_TAIL</code>, <code class=Nm>TAILQ_LAST</code>, <code class=Nm>TAILQ_NEXT</code>, <code class=Nm>TAILQ_PREV</code>, <code class=Nm>TAILQ_REMOVE</code>, <code class=Nm>TAILQ_SWAP</code> — <div class=Nd>implementations of singly-linked lists, singly-linked tail queues, lists and tail queues</div></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/sys/queue.h.html>sys/queue.h</a>&gt;</code><p class=Pp><code class=Fn>SLIST_CLASS_ENTRY</code>(<var class=Fa style="white-space: nowrap;">CLASSTYPE</var>);</p><p class=Pp><code class=Fn>SLIST_CLASS_HEAD</code>(<var class=Fa style="white-space: nowrap;">HEADNAME</var>, <var class=Fa style="white-space: nowrap;">CLASSTYPE</var>);</p><p class=Pp><code class=Fn>SLIST_CONCAT</code>(<var class=Fa style="white-space: nowrap;">SLIST_HEAD *head1</var>, <var class=Fa style="white-space: nowrap;">SLIST_HEAD *head2</var>, <var class=Fa style="white-space: nowrap;">TYPE</var>, <var class=Fa style="white-space: nowrap;">SLIST_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>SLIST_EMPTY</code>(<var class=Fa style="white-space: nowrap;">SLIST_HEAD *head</var>);</p><p class=Pp><code class=Fn>SLIST_ENTRY</code>(<var class=Fa style="white-space: nowrap;">TYPE</var>);</p><p class=Pp><code class=Fn>SLIST_FIRST</code>(<var class=Fa style="white-space: nowrap;">SLIST_HEAD *head</var>);</p><p class=Pp><code class=Fn>SLIST_FOREACH</code>(<var class=Fa style="white-space: nowrap;">TYPE *var</var>, <var class=Fa style="white-space: nowrap;">SLIST_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">SLIST_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>SLIST_FOREACH_FROM</code>(<var class=Fa style="white-space: nowrap;">TYPE *var</var>, <var class=Fa style="white-space: nowrap;">SLIST_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">SLIST_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>SLIST_FOREACH_FROM_SAFE</code>(<var class=Fa style="white-space: nowrap;">TYPE *var</var>, <var class=Fa style="white-space: nowrap;">SLIST_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">SLIST_ENTRY NAME</var>, <var class=Fa style="white-space: nowrap;">TYPE *temp_var</var>);</p><p class=Pp><code class=Fn>SLIST_FOREACH_SAFE</code>(<var class=Fa style="white-space: nowrap;">TYPE *var</var>, <var class=Fa style="white-space: nowrap;">SLIST_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">SLIST_ENTRY NAME</var>, <var class=Fa style="white-space: nowrap;">TYPE *temp_var</var>);</p><p class=Pp><code class=Fn>SLIST_HEAD</code>(<var class=Fa style="white-space: nowrap;">HEADNAME</var>, <var class=Fa style="white-space: nowrap;">TYPE</var>);</p><p class=Pp><code class=Fn>SLIST_HEAD_INITIALIZER</code>(<var class=Fa style="white-space: nowrap;">SLIST_HEAD head</var>);</p><p class=Pp><code class=Fn>SLIST_INIT</code>(<var class=Fa style="white-space: nowrap;">SLIST_HEAD *head</var>);</p><p class=Pp><code class=Fn>SLIST_INSERT_AFTER</code>(<var class=Fa style="white-space: nowrap;">TYPE *listelm</var>, <var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">SLIST_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>SLIST_INSERT_HEAD</code>(<var class=Fa style="white-space: nowrap;">SLIST_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">SLIST_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>SLIST_NEXT</code>(<var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">SLIST_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>SLIST_REMOVE</code>(<var class=Fa style="white-space: nowrap;">SLIST_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">TYPE</var>, <var class=Fa style="white-space: nowrap;">SLIST_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>SLIST_REMOVE_AFTER</code>(<var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">SLIST_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>SLIST_REMOVE_HEAD</code>(<var class=Fa style="white-space: nowrap;">SLIST_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">SLIST_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>SLIST_SWAP</code>(<var class=Fa style="white-space: nowrap;">SLIST_HEAD *head1</var>, <var class=Fa style="white-space: nowrap;">SLIST_HEAD *head2</var>, <var class=Fa style="white-space: nowrap;">TYPE</var>);</p><p class=Pp><code class=Fn>STAILQ_CLASS_ENTRY</code>(<var class=Fa style="white-space: nowrap;">CLASSTYPE</var>);</p><p class=Pp><code class=Fn>STAILQ_CLASS_HEAD</code>(<var class=Fa style="white-space: nowrap;">HEADNAME</var>, <var class=Fa style="white-space: nowrap;">CLASSTYPE</var>);</p><p class=Pp><code class=Fn>STAILQ_CONCAT</code>(<var class=Fa style="white-space: nowrap;">STAILQ_HEAD *head1</var>, <var class=Fa style="white-space: nowrap;">STAILQ_HEAD *head2</var>);</p><p class=Pp><code class=Fn>STAILQ_EMPTY</code>(<var class=Fa style="white-space: nowrap;">STAILQ_HEAD *head</var>);</p><p class=Pp><code class=Fn>STAILQ_ENTRY</code>(<var class=Fa style="white-space: nowrap;">TYPE</var>);</p><p class=Pp><code class=Fn>STAILQ_FIRST</code>(<var class=Fa style="white-space: nowrap;">STAILQ_HEAD *head</var>);</p><p class=Pp><code class=Fn>STAILQ_FOREACH</code>(<var class=Fa style="white-space: nowrap;">TYPE *var</var>, <var class=Fa style="white-space: nowrap;">STAILQ_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">STAILQ_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>STAILQ_FOREACH_FROM</code>(<var class=Fa style="white-space: nowrap;">TYPE *var</var>, <var class=Fa style="white-space: nowrap;">STAILQ_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">STAILQ_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>STAILQ_FOREACH_FROM_SAFE</code>(<var class=Fa style="white-space: nowrap;">TYPE *var</var>, <var class=Fa style="white-space: nowrap;">STAILQ_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">STAILQ_ENTRY NAME</var>, <var class=Fa style="white-space: nowrap;">TYPE *temp_var</var>);</p><p class=Pp><code class=Fn>STAILQ_FOREACH_SAFE</code>(<var class=Fa style="white-space: nowrap;">TYPE *var</var>, <var class=Fa style="white-space: nowrap;">STAILQ_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">STAILQ_ENTRY NAME</var>, <var class=Fa style="white-space: nowrap;">TYPE *temp_var</var>);</p><p class=Pp><code class=Fn>STAILQ_HEAD</code>(<var class=Fa style="white-space: nowrap;">HEADNAME</var>, <var class=Fa style="white-space: nowrap;">TYPE</var>);</p><p class=Pp><code class=Fn>STAILQ_HEAD_INITIALIZER</code>(<var class=Fa style="white-space: nowrap;">STAILQ_HEAD head</var>);</p><p class=Pp><code class=Fn>STAILQ_INIT</code>(<var class=Fa style="white-space: nowrap;">STAILQ_HEAD *head</var>);</p><p class=Pp><code class=Fn>STAILQ_INSERT_AFTER</code>(<var class=Fa style="white-space: nowrap;">STAILQ_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">TYPE *listelm</var>, <var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">STAILQ_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>STAILQ_INSERT_HEAD</code>(<var class=Fa style="white-space: nowrap;">STAILQ_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">STAILQ_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>STAILQ_INSERT_TAIL</code>(<var class=Fa style="white-space: nowrap;">STAILQ_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">STAILQ_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>STAILQ_LAST</code>(<var class=Fa style="white-space: nowrap;">STAILQ_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">STAILQ_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>STAILQ_NEXT</code>(<var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">STAILQ_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>STAILQ_REMOVE</code>(<var class=Fa style="white-space: nowrap;">STAILQ_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">TYPE</var>, <var class=Fa style="white-space: nowrap;">STAILQ_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>STAILQ_REMOVE_AFTER</code>(<var class=Fa style="white-space: nowrap;">STAILQ_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">STAILQ_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>STAILQ_REMOVE_HEAD</code>(<var class=Fa style="white-space: nowrap;">STAILQ_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">STAILQ_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>STAILQ_SWAP</code>(<var class=Fa style="white-space: nowrap;">STAILQ_HEAD *head1</var>, <var class=Fa style="white-space: nowrap;">STAILQ_HEAD *head2</var>, <var class=Fa style="white-space: nowrap;">TYPE</var>);</p><p class=Pp><code class=Fn>LIST_CLASS_ENTRY</code>(<var class=Fa style="white-space: nowrap;">CLASSTYPE</var>);</p><p class=Pp><code class=Fn>LIST_CLASS_HEAD</code>(<var class=Fa style="white-space: nowrap;">HEADNAME</var>, <var class=Fa style="white-space: nowrap;">CLASSTYPE</var>);</p><p class=Pp><code class=Fn>LIST_CONCAT</code>(<var class=Fa style="white-space: nowrap;">LIST_HEAD *head1</var>, <var class=Fa style="white-space: nowrap;">LIST_HEAD *head2</var>, <var class=Fa style="white-space: nowrap;">TYPE</var>, <var class=Fa style="white-space: nowrap;">LIST_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>LIST_EMPTY</code>(<var class=Fa style="white-space: nowrap;">LIST_HEAD *head</var>);</p><p class=Pp><code class=Fn>LIST_ENTRY</code>(<var class=Fa style="white-space: nowrap;">TYPE</var>);</p><p class=Pp><code class=Fn>LIST_FIRST</code>(<var class=Fa style="white-space: nowrap;">LIST_HEAD *head</var>);</p><p class=Pp><code class=Fn>LIST_FOREACH</code>(<var class=Fa style="white-space: nowrap;">TYPE *var</var>, <var class=Fa style="white-space: nowrap;">LIST_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">LIST_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>LIST_FOREACH_FROM</code>(<var class=Fa style="white-space: nowrap;">TYPE *var</var>, <var class=Fa style="white-space: nowrap;">LIST_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">LIST_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>LIST_FOREACH_FROM_SAFE</code>(<var class=Fa style="white-space: nowrap;">TYPE *var</var>, <var class=Fa style="white-space: nowrap;">LIST_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">LIST_ENTRY NAME</var>, <var class=Fa style="white-space: nowrap;">TYPE *temp_var</var>);</p><p class=Pp><code class=Fn>LIST_FOREACH_SAFE</code>(<var class=Fa style="white-space: nowrap;">TYPE *var</var>, <var class=Fa style="white-space: nowrap;">LIST_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">LIST_ENTRY NAME</var>, <var class=Fa style="white-space: nowrap;">TYPE *temp_var</var>);</p><p class=Pp><code class=Fn>LIST_HEAD</code>(<var class=Fa style="white-space: nowrap;">HEADNAME</var>, <var class=Fa style="white-space: nowrap;">TYPE</var>);</p><p class=Pp><code class=Fn>LIST_HEAD_INITIALIZER</code>(<var class=Fa style="white-space: nowrap;">LIST_HEAD head</var>);</p><p class=Pp><code class=Fn>LIST_INIT</code>(<var class=Fa style="white-space: nowrap;">LIST_HEAD *head</var>);</p><p class=Pp><code class=Fn>LIST_INSERT_AFTER</code>(<var class=Fa style="white-space: nowrap;">TYPE *listelm</var>, <var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">LIST_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>LIST_INSERT_BEFORE</code>(<var class=Fa style="white-space: nowrap;">TYPE *listelm</var>, <var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">LIST_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>LIST_INSERT_HEAD</code>(<var class=Fa style="white-space: nowrap;">LIST_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">LIST_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>LIST_NEXT</code>(<var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">LIST_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>LIST_PREV</code>(<var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">LIST_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">TYPE</var>, <var class=Fa style="white-space: nowrap;">LIST_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>LIST_REMOVE</code>(<var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">LIST_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>LIST_SWAP</code>(<var class=Fa style="white-space: nowrap;">LIST_HEAD *head1</var>, <var class=Fa style="white-space: nowrap;">LIST_HEAD *head2</var>, <var class=Fa style="white-space: nowrap;">TYPE</var>, <var class=Fa style="white-space: nowrap;">LIST_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>TAILQ_CLASS_ENTRY</code>(<var class=Fa style="white-space: nowrap;">CLASSTYPE</var>);</p><p class=Pp><code class=Fn>TAILQ_CLASS_HEAD</code>(<var class=Fa style="white-space: nowrap;">HEADNAME</var>, <var class=Fa style="white-space: nowrap;">CLASSTYPE</var>);</p><p class=Pp><code class=Fn>TAILQ_CONCAT</code>(<var class=Fa style="white-space: nowrap;">TAILQ_HEAD *head1</var>, <var class=Fa style="white-space: nowrap;">TAILQ_HEAD *head2</var>, <var class=Fa style="white-space: nowrap;">TAILQ_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>TAILQ_EMPTY</code>(<var class=Fa style="white-space: nowrap;">TAILQ_HEAD *head</var>);</p><p class=Pp><code class=Fn>TAILQ_ENTRY</code>(<var class=Fa style="white-space: nowrap;">TYPE</var>);</p><p class=Pp><code class=Fn>TAILQ_FIRST</code>(<var class=Fa style="white-space: nowrap;">TAILQ_HEAD *head</var>);</p><p class=Pp><code class=Fn>TAILQ_FOREACH</code>(<var class=Fa style="white-space: nowrap;">TYPE *var</var>, <var class=Fa style="white-space: nowrap;">TAILQ_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">TAILQ_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>TAILQ_FOREACH_FROM</code>(<var class=Fa style="white-space: nowrap;">TYPE *var</var>, <var class=Fa style="white-space: nowrap;">TAILQ_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">TAILQ_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>TAILQ_FOREACH_FROM_SAFE</code>(<var class=Fa style="white-space: nowrap;">TYPE *var</var>, <var class=Fa style="white-space: nowrap;">TAILQ_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">TAILQ_ENTRY NAME</var>, <var class=Fa style="white-space: nowrap;">TYPE *temp_var</var>);</p><p class=Pp><code class=Fn>TAILQ_FOREACH_REVERSE</code>(<var class=Fa style="white-space: nowrap;">TYPE *var</var>, <var class=Fa style="white-space: nowrap;">TAILQ_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">HEADNAME</var>, <var class=Fa style="white-space: nowrap;">TAILQ_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>TAILQ_FOREACH_REVERSE_FROM</code>(<var class=Fa style="white-space: nowrap;">TYPE *var</var>, <var class=Fa style="white-space: nowrap;">TAILQ_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">HEADNAME</var>, <var class=Fa style="white-space: nowrap;">TAILQ_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>TAILQ_FOREACH_REVERSE_FROM_SAFE</code>(<var class=Fa style="white-space: nowrap;">TYPE *var</var>, <var class=Fa style="white-space: nowrap;">TAILQ_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">HEADNAME</var>, <var class=Fa style="white-space: nowrap;">TAILQ_ENTRY NAME</var>, <var class=Fa style="white-space: nowrap;">TYPE *temp_var</var>);</p><p class=Pp><code class=Fn>TAILQ_FOREACH_REVERSE_SAFE</code>(<var class=Fa style="white-space: nowrap;">TYPE *var</var>, <var class=Fa style="white-space: nowrap;">TAILQ_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">HEADNAME</var>, <var class=Fa style="white-space: nowrap;">TAILQ_ENTRY NAME</var>, <var class=Fa style="white-space: nowrap;">TYPE *temp_var</var>);</p><p class=Pp><code class=Fn>TAILQ_FOREACH_SAFE</code>(<var class=Fa style="white-space: nowrap;">TYPE *var</var>, <var class=Fa style="white-space: nowrap;">TAILQ_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">TAILQ_ENTRY NAME</var>, <var class=Fa style="white-space: nowrap;">TYPE *temp_var</var>);</p><p class=Pp><code class=Fn>TAILQ_HEAD</code>(<var class=Fa style="white-space: nowrap;">HEADNAME</var>, <var class=Fa style="white-space: nowrap;">TYPE</var>);</p><p class=Pp><code class=Fn>TAILQ_HEAD_INITIALIZER</code>(<var class=Fa style="white-space: nowrap;">TAILQ_HEAD head</var>);</p><p class=Pp><code class=Fn>TAILQ_INIT</code>(<var class=Fa style="white-space: nowrap;">TAILQ_HEAD *head</var>);</p><p class=Pp><code class=Fn>TAILQ_INSERT_AFTER</code>(<var class=Fa style="white-space: nowrap;">TAILQ_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">TYPE *listelm</var>, <var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">TAILQ_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>TAILQ_INSERT_BEFORE</code>(<var class=Fa style="white-space: nowrap;">TYPE *listelm</var>, <var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">TAILQ_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>TAILQ_INSERT_HEAD</code>(<var class=Fa style="white-space: nowrap;">TAILQ_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">TAILQ_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>TAILQ_INSERT_TAIL</code>(<var class=Fa style="white-space: nowrap;">TAILQ_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">TAILQ_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>TAILQ_LAST</code>(<var class=Fa style="white-space: nowrap;">TAILQ_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">HEADNAME</var>);</p><p class=Pp><code class=Fn>TAILQ_NEXT</code>(<var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">TAILQ_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>TAILQ_PREV</code>(<var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">HEADNAME</var>, <var class=Fa style="white-space: nowrap;">TAILQ_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>TAILQ_REMOVE</code>(<var class=Fa style="white-space: nowrap;">TAILQ_HEAD *head</var>, <var class=Fa style="white-space: nowrap;">TYPE *elm</var>, <var class=Fa style="white-space: nowrap;">TAILQ_ENTRY NAME</var>);</p><p class=Pp><code class=Fn>TAILQ_SWAP</code>(<var class=Fa style="white-space: nowrap;">TAILQ_HEAD *head1</var>, <var class=Fa style="white-space: nowrap;">TAILQ_HEAD *head2</var>, <var class=Fa style="white-space: nowrap;">TYPE</var>, <var class=Fa style="white-space: nowrap;">TAILQ_ENTRY NAME</var>);</p></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> These macros define and operate on four types of data structures which can be used in both C and C++ source code: <ol class="Bl-enum Bd-indent Bl-compact"><li>Lists</li><li>Singly-linked lists</li><li>Singly-linked tail queues</li><li>Tail queues</li></ol> All four structures support the following functionality: <ol class="Bl-enum Bd-indent Bl-compact"><li>Insertion of a new entry at the head of the list.</li><li>Insertion of a new entry after any element in the list.</li><li>O(1) removal of an entry from the head of the list.</li><li>Forward traversal through the list.</li><li>Swapping the contents of two lists.</li></ol><p class=Pp>Singly-linked lists are the simplest of the four data structures and support only the above functionality. Singly-linked lists are ideal for applications with large datasets and few or no removals, or for implementing a LIFO queue. Singly-linked lists add the following functionality:</p><ol class="Bl-enum Bd-indent Bl-compact"><li>O(n) removal of any entry in the list.</li><li>O(n) concatenation of two lists.</li></ol><p class=Pp>Singly-linked tail queues add the following functionality:</p><ol class="Bl-enum Bd-indent Bl-compact"><li>Entries can be added at the end of a list.</li><li>O(n) removal of any entry in the list.</li><li>They may be concatenated.</li></ol> However: <ol class="Bl-enum Bd-indent Bl-compact"><li>All list insertions must specify the head of the list.</li><li>Each head entry requires two pointers rather than one.</li><li>Code size is about 15% greater and operations run about 20% slower than singly-linked lists.</li></ol><p class=Pp>Singly-linked tail queues are ideal for applications with large datasets and few or no removals, or for implementing a FIFO queue.</p><p class=Pp>All doubly linked types of data structures (lists and tail queues) additionally allow:</p><ol class="Bl-enum Bd-indent Bl-compact"><li>Insertion of a new entry before any element in the list.</li><li>O(1) removal of any entry in the list.</li></ol> However: <ol class="Bl-enum Bd-indent Bl-compact"><li>Each element requires two pointers rather than one.</li><li>Code size and execution time of operations (except for removal) is about twice that of the singly-linked data-structures.</li></ol><p class=Pp>Linked lists are the simplest of the doubly linked data structures. They add the following functionality over the above:</p><ol class="Bl-enum Bd-indent Bl-compact"><li>O(n) concatenation of two lists.</li><li>They may be traversed backwards.</li></ol> However: <ol class="Bl-enum Bd-indent Bl-compact"><li>To traverse backwards, an entry to begin the traversal and the list in which it is contained must be specified.</li></ol><p class=Pp>Tail queues add the following functionality:</p><ol class="Bl-enum Bd-indent Bl-compact"><li>Entries can be added at the end of a list.</li><li>They may be traversed backwards, from tail to head.</li><li>They may be concatenated.</li></ol> However: <ol class="Bl-enum Bd-indent Bl-compact"><li>All list insertions and removals must specify the head of the list.</li><li>Each head entry requires two pointers rather than one.</li><li>Code size is about 15% greater and operations run about 20% slower than singly-linked lists.</li></ol><p class=Pp>In the macro definitions, <var class=Fa>TYPE</var> is the name of a user defined structure. The structure must contain a field called <var class=Fa>NAME</var> which is of type <code class=Li>SLIST_ENTRY</code>, <code class=Li>STAILQ_ENTRY</code>, <code class=Li>LIST_ENTRY</code>, or <code class=Li>TAILQ_ENTRY</code>. In the macro definitions, <var class=Fa>CLASSTYPE</var> is the name of a user defined class. The class must contain a field called <var class=Fa>NAME</var> which is of type <code class=Li>SLIST_CLASS_ENTRY</code>, <code class=Li>STAILQ_CLASS_ENTRY</code>, <code class=Li>LIST_CLASS_ENTRY</code>, or <code class=Li>TAILQ_CLASS_ENTRY</code>. The argument <var class=Fa>HEADNAME</var> is the name of a user defined structure that must be declared using the macros <code class=Li>SLIST_HEAD</code>, <code class=Li>SLIST_CLASS_HEAD</code>, <code class=Li>STAILQ_HEAD</code>, <code class=Li>STAILQ_CLASS_HEAD</code>, <code class=Li>LIST_HEAD</code>, <code class=Li>LIST_CLASS_HEAD</code>, <code class=Li>TAILQ_HEAD</code>, or <code class=Li>TAILQ_CLASS_HEAD</code>. See the examples below for further explanation of how these macros are used.</p></section><section class=Sh><h2 class=Sh id=SINGLY_LINKED_LISTS><a class=permalink href=#SINGLY_LINKED_LISTS>SINGLY-LINKED LISTS</a></h2> A singly-linked list is headed by a structure defined by the <code class=Nm>SLIST_HEAD</code> macro. This structure contains a single pointer to the first element on the list. The elements are singly linked for minimum space and pointer manipulation overhead at the expense of O(n) removal for arbitrary elements. New elements can be added to the list after an existing element or at the head of the list. An <var class=Fa>SLIST_HEAD</var> structure is declared as follows: <div class="Bd Pp Bd-indent"><pre>
SLIST_HEAD(HEADNAME, TYPE) head;
</pre></div><p class=Pp>where <var class=Fa>HEADNAME</var> is the name of the structure to be defined, and <var class=Fa>TYPE</var> is the type of the elements to be linked into the list. A pointer to the head of the list can later be declared as:</p><div class="Bd Pp Bd-indent"><pre>
struct HEADNAME *headp;
</pre></div><p class=Pp>(The names <code class=Li>head</code> and <code class=Li>headp</code> are user selectable.)</p><p class=Pp>The macro <code class=Nm>SLIST_HEAD_INITIALIZER</code> evaluates to an initializer for the list <var class=Fa>head</var>.</p><p class=Pp>The macro <code class=Nm>SLIST_CONCAT</code> concatenates the list headed by <var class=Fa>head2</var> onto the end of the one headed by <var class=Fa>head1</var> removing all entries from the former. Use of this macro should be avoided as it traverses the entirety of the <var class=Fa>head1</var> list. A singly-linked tail queue should be used if this macro is needed in high-usage code paths or to operate on long lists.</p><p class=Pp>The macro <code class=Nm>SLIST_EMPTY</code> evaluates to true if there are no elements in the list.</p><p class=Pp>The macro <code class=Nm>SLIST_ENTRY</code> declares a structure that connects the elements in the list.</p><p class=Pp>The macro <code class=Nm>SLIST_FIRST</code> returns the first element in the list or NULL if the list is empty.</p><p class=Pp>The macro <code class=Nm>SLIST_FOREACH</code> traverses the list referenced by <var class=Fa>head</var> in the forward direction, assigning each element in turn to <var class=Fa>var</var>.</p><p class=Pp>The macro <code class=Nm>SLIST_FOREACH_FROM</code> behaves identically to <code class=Nm>SLIST_FOREACH</code> when <var class=Fa>var</var> is NULL, else it treats <var class=Fa>var</var> as a previously found SLIST element and begins the loop at <var class=Fa>var</var> instead of the first element in the SLIST referenced by <var class=Fa>head</var>.</p><p class=Pp>The macro <code class=Nm>SLIST_FOREACH_SAFE</code> traverses the list referenced by <var class=Fa>head</var> in the forward direction, assigning each element in turn to <var class=Fa>var</var>. However, unlike <code class=Fn>SLIST_FOREACH</code>() here it is permitted to both remove <var class=Fa>var</var> as well as free it from within the loop safely without interfering with the traversal.</p><p class=Pp>The macro <code class=Nm>SLIST_FOREACH_FROM_SAFE</code> behaves identically to <code class=Nm>SLIST_FOREACH_SAFE</code> when <var class=Fa>var</var> is NULL, else it treats <var class=Fa>var</var> as a previously found SLIST element and begins the loop at <var class=Fa>var</var> instead of the first element in the SLIST referenced by <var class=Fa>head</var>.</p><p class=Pp>The macro <code class=Nm>SLIST_INIT</code> initializes the list referenced by <var class=Fa>head</var>.</p><p class=Pp>The macro <code class=Nm>SLIST_INSERT_HEAD</code> inserts the new element <var class=Fa>elm</var> at the head of the list.</p><p class=Pp>The macro <code class=Nm>SLIST_INSERT_AFTER</code> inserts the new element <var class=Fa>elm</var> after the element <var class=Fa>listelm</var>.</p><p class=Pp>The macro <code class=Nm>SLIST_NEXT</code> returns the next element in the list.</p><p class=Pp>The macro <code class=Nm>SLIST_REMOVE_AFTER</code> removes the element after <var class=Fa>elm</var> from the list. Unlike <var class=Fa>SLIST_REMOVE</var>, this macro does not traverse the entire list.</p><p class=Pp>The macro <code class=Nm>SLIST_REMOVE_HEAD</code> removes the element <var class=Fa>elm</var> from the head of the list. For optimum efficiency, elements being removed from the head of the list should explicitly use this macro instead of the generic <var class=Fa>SLIST_REMOVE</var> macro.</p><p class=Pp>The macro <code class=Nm>SLIST_REMOVE</code> removes the element <var class=Fa>elm</var> from the list. Use of this macro should be avoided as it traverses the entire list. A doubly-linked list should be used if this macro is needed in high-usage code paths or to operate on long lists.</p><p class=Pp>The macro <code class=Nm>SLIST_SWAP</code> swaps the contents of <var class=Fa>head1</var> and <var class=Fa>head2</var>.</p></section><section class=Sh><h2 class=Sh id=SINGLY_LINKED_LIST_EXAMPLE><a class=permalink href=#SINGLY_LINKED_LIST_EXAMPLE>SINGLY-LINKED LIST EXAMPLE</a></h2><div class=Bd><pre>
SLIST_HEAD(slisthead, entry) head =
    SLIST_HEAD_INITIALIZER(head);
struct slisthead *headp;		/* Singly-linked List head. */
struct entry {
	...
	SLIST_ENTRY(entry) entries;	/* Singly-linked List. */
	...
} *n1, *n2, *n3, *np;

SLIST_INIT(&amp;head);			/* Initialize the list. */

n1 = malloc(sizeof(struct entry));	/* Insert at the head. */
SLIST_INSERT_HEAD(&amp;head, n1, entries);

n2 = malloc(sizeof(struct entry));	/* Insert after. */
SLIST_INSERT_AFTER(n1, n2, entries);

SLIST_REMOVE(&amp;head, n2, entry, entries);/* Deletion. */
free(n2);

n3 = SLIST_FIRST(&amp;head);
SLIST_REMOVE_HEAD(&amp;head, entries);	/* Deletion from the head. */
free(n3);
					/* Forward traversal. */
SLIST_FOREACH(np, &amp;head, entries)
	np-&gt; ...
					/* Safe forward traversal. */
SLIST_FOREACH_SAFE(np, &amp;head, entries, np_temp) {
	np-&gt;do_stuff();
	...
	SLIST_REMOVE(&amp;head, np, entry, entries);
	free(np);
}

while (!SLIST_EMPTY(&amp;head)) {		/* List Deletion. */
	n1 = SLIST_FIRST(&amp;head);
	SLIST_REMOVE_HEAD(&amp;head, entries);
	free(n1);
}
</pre></div></section><section class=Sh><h2 class=Sh id=SINGLY_LINKED_TAIL_QUEUES><a class=permalink href=#SINGLY_LINKED_TAIL_QUEUES>SINGLY-LINKED TAIL QUEUES</a></h2> A singly-linked tail queue is headed by a structure defined by the <code class=Nm>STAILQ_HEAD</code> macro. This structure contains a pair of pointers, one to the first element in the tail queue and the other to the last element in the tail queue. The elements are singly linked for minimum space and pointer manipulation overhead at the expense of O(n) removal for arbitrary elements. New elements can be added to the tail queue after an existing element, at the head of the tail queue, or at the end of the tail queue. A <var class=Fa>STAILQ_HEAD</var> structure is declared as follows: <div class="Bd Pp Bd-indent"><pre>
STAILQ_HEAD(HEADNAME, TYPE) head;
</pre></div><p class=Pp>where <code class=Li>HEADNAME</code> is the name of the structure to be defined, and <code class=Li>TYPE</code> is the type of the elements to be linked into the tail queue. A pointer to the head of the tail queue can later be declared as:</p><div class="Bd Pp Bd-indent"><pre>
struct HEADNAME *headp;
</pre></div><p class=Pp>(The names <code class=Li>head</code> and <code class=Li>headp</code> are user selectable.)</p><p class=Pp>The macro <code class=Nm>STAILQ_HEAD_INITIALIZER</code> evaluates to an initializer for the tail queue <var class=Fa>head</var>.</p><p class=Pp>The macro <code class=Nm>STAILQ_CONCAT</code> concatenates the tail queue headed by <var class=Fa>head2</var> onto the end of the one headed by <var class=Fa>head1</var> removing all entries from the former.</p><p class=Pp>The macro <code class=Nm>STAILQ_EMPTY</code> evaluates to true if there are no items on the tail queue.</p><p class=Pp>The macro <code class=Nm>STAILQ_ENTRY</code> declares a structure that connects the elements in the tail queue.</p><p class=Pp>The macro <code class=Nm>STAILQ_FIRST</code> returns the first item on the tail queue or NULL if the tail queue is empty.</p><p class=Pp>The macro <code class=Nm>STAILQ_FOREACH</code> traverses the tail queue referenced by <var class=Fa>head</var> in the forward direction, assigning each element in turn to <var class=Fa>var</var>.</p><p class=Pp>The macro <code class=Nm>STAILQ_FOREACH_FROM</code> behaves identically to <code class=Nm>STAILQ_FOREACH</code> when <var class=Fa>var</var> is NULL, else it treats <var class=Fa>var</var> as a previously found STAILQ element and begins the loop at <var class=Fa>var</var> instead of the first element in the STAILQ referenced by <var class=Fa>head</var>.</p><p class=Pp>The macro <code class=Nm>STAILQ_FOREACH_SAFE</code> traverses the tail queue referenced by <var class=Fa>head</var> in the forward direction, assigning each element in turn to <var class=Fa>var</var>. However, unlike <code class=Fn>STAILQ_FOREACH</code>() here it is permitted to both remove <var class=Fa>var</var> as well as free it from within the loop safely without interfering with the traversal.</p><p class=Pp>The macro <code class=Nm>STAILQ_FOREACH_FROM_SAFE</code> behaves identically to <code class=Nm>STAILQ_FOREACH_SAFE</code> when <var class=Fa>var</var> is NULL, else it treats <var class=Fa>var</var> as a previously found STAILQ element and begins the loop at <var class=Fa>var</var> instead of the first element in the STAILQ referenced by <var class=Fa>head</var>.</p><p class=Pp>The macro <code class=Nm>STAILQ_INIT</code> initializes the tail queue referenced by <var class=Fa>head</var>.</p><p class=Pp>The macro <code class=Nm>STAILQ_INSERT_HEAD</code> inserts the new element <var class=Fa>elm</var> at the head of the tail queue.</p><p class=Pp>The macro <code class=Nm>STAILQ_INSERT_TAIL</code> inserts the new element <var class=Fa>elm</var> at the end of the tail queue.</p><p class=Pp>The macro <code class=Nm>STAILQ_INSERT_AFTER</code> inserts the new element <var class=Fa>elm</var> after the element <var class=Fa>listelm</var>.</p><p class=Pp>The macro <code class=Nm>STAILQ_LAST</code> returns the last item on the tail queue. If the tail queue is empty the return value is <code class=Dv>NULL</code>.</p><p class=Pp>The macro <code class=Nm>STAILQ_NEXT</code> returns the next item on the tail queue, or NULL this item is the last.</p><p class=Pp>The macro <code class=Nm>STAILQ_REMOVE_AFTER</code> removes the element after <var class=Fa>elm</var> from the tail queue. Unlike <var class=Fa>STAILQ_REMOVE</var>, this macro does not traverse the entire tail queue.</p><p class=Pp>The macro <code class=Nm>STAILQ_REMOVE_HEAD</code> removes the element at the head of the tail queue. For optimum efficiency, elements being removed from the head of the tail queue should use this macro explicitly rather than the generic <var class=Fa>STAILQ_REMOVE</var> macro.</p><p class=Pp>The macro <code class=Nm>STAILQ_REMOVE</code> removes the element <var class=Fa>elm</var> from the tail queue. Use of this macro should be avoided as it traverses the entire list. A doubly-linked tail queue should be used if this macro is needed in high-usage code paths or to operate on long tail queues.</p><p class=Pp>The macro <code class=Nm>STAILQ_SWAP</code> swaps the contents of <var class=Fa>head1</var> and <var class=Fa>head2</var>.</p></section><section class=Sh><h2 class=Sh id=SINGLY_LINKED_TAIL_QUEUE_EXAMPLE><a class=permalink href=#SINGLY_LINKED_TAIL_QUEUE_EXAMPLE>SINGLY-LINKED TAIL QUEUE EXAMPLE</a></h2><div class=Bd><pre>
STAILQ_HEAD(stailhead, entry) head =
    STAILQ_HEAD_INITIALIZER(head);
struct stailhead *headp;		/* Singly-linked tail queue head. */
struct entry {
	...
	STAILQ_ENTRY(entry) entries;	/* Tail queue. */
	...
} *n1, *n2, *n3, *np;

STAILQ_INIT(&amp;head);			/* Initialize the queue. */

n1 = malloc(sizeof(struct entry));	/* Insert at the head. */
STAILQ_INSERT_HEAD(&amp;head, n1, entries);

n1 = malloc(sizeof(struct entry));	/* Insert at the tail. */
STAILQ_INSERT_TAIL(&amp;head, n1, entries);

n2 = malloc(sizeof(struct entry));	/* Insert after. */
STAILQ_INSERT_AFTER(&amp;head, n1, n2, entries);
					/* Deletion. */
STAILQ_REMOVE(&amp;head, n2, entry, entries);
free(n2);
					/* Deletion from the head. */
n3 = STAILQ_FIRST(&amp;head);
STAILQ_REMOVE_HEAD(&amp;head, entries);
free(n3);
					/* Forward traversal. */
STAILQ_FOREACH(np, &amp;head, entries)
	np-&gt; ...
					/* Safe forward traversal. */
STAILQ_FOREACH_SAFE(np, &amp;head, entries, np_temp) {
	np-&gt;do_stuff();
	...
	STAILQ_REMOVE(&amp;head, np, entry, entries);
	free(np);
}
					/* TailQ Deletion. */
while (!STAILQ_EMPTY(&amp;head)) {
	n1 = STAILQ_FIRST(&amp;head);
	STAILQ_REMOVE_HEAD(&amp;head, entries);
	free(n1);
}
					/* Faster TailQ Deletion. */
n1 = STAILQ_FIRST(&amp;head);
while (n1 != NULL) {
	n2 = STAILQ_NEXT(n1, entries);
	free(n1);
	n1 = n2;
}
STAILQ_INIT(&amp;head);
</pre></div></section><section class=Sh><h2 class=Sh id=LISTS><a class=permalink href=#LISTS>LISTS</a></h2> A list is headed by a structure defined by the <code class=Nm>LIST_HEAD</code> macro. This structure contains a single pointer to the first element on the list. The elements are doubly linked so that an arbitrary element can be removed without traversing the list. New elements can be added to the list after an existing element, before an existing element, or at the head of the list. A <var class=Fa>LIST_HEAD</var> structure is declared as follows: <div class="Bd Pp Bd-indent"><pre>
LIST_HEAD(HEADNAME, TYPE) head;
</pre></div><p class=Pp>where <var class=Fa>HEADNAME</var> is the name of the structure to be defined, and <var class=Fa>TYPE</var> is the type of the elements to be linked into the list. A pointer to the head of the list can later be declared as:</p><div class="Bd Pp Bd-indent"><pre>
struct HEADNAME *headp;
</pre></div><p class=Pp>(The names <code class=Li>head</code> and <code class=Li>headp</code> are user selectable.)</p><p class=Pp>The macro <code class=Nm>LIST_HEAD_INITIALIZER</code> evaluates to an initializer for the list <var class=Fa>head</var>.</p><p class=Pp>The macro <code class=Nm>LIST_CONCAT</code> concatenates the list headed by <var class=Fa>head2</var> onto the end of the one headed by <var class=Fa>head1</var> removing all entries from the former. Use of this macro should be avoided as it traverses the entirety of the <var class=Fa>head1</var> list. A tail queue should be used if this macro is needed in high-usage code paths or to operate on long lists.</p><p class=Pp>The macro <code class=Nm>LIST_EMPTY</code> evaluates to true if there are no elements in the list.</p><p class=Pp>The macro <code class=Nm>LIST_ENTRY</code> declares a structure that connects the elements in the list.</p><p class=Pp>The macro <code class=Nm>LIST_FIRST</code> returns the first element in the list or NULL if the list is empty.</p><p class=Pp>The macro <code class=Nm>LIST_FOREACH</code> traverses the list referenced by <var class=Fa>head</var> in the forward direction, assigning each element in turn to <var class=Fa>var</var>.</p><p class=Pp>The macro <code class=Nm>LIST_FOREACH_FROM</code> behaves identically to <code class=Nm>LIST_FOREACH</code> when <var class=Fa>var</var> is NULL, else it treats <var class=Fa>var</var> as a previously found LIST element and begins the loop at <var class=Fa>var</var> instead of the first element in the LIST referenced by <var class=Fa>head</var>.</p><p class=Pp>The macro <code class=Nm>LIST_FOREACH_SAFE</code> traverses the list referenced by <var class=Fa>head</var> in the forward direction, assigning each element in turn to <var class=Fa>var</var>. However, unlike <code class=Fn>LIST_FOREACH</code>() here it is permitted to both remove <var class=Fa>var</var> as well as free it from within the loop safely without interfering with the traversal.</p><p class=Pp>The macro <code class=Nm>LIST_FOREACH_FROM_SAFE</code> behaves identically to <code class=Nm>LIST_FOREACH_SAFE</code> when <var class=Fa>var</var> is NULL, else it treats <var class=Fa>var</var> as a previously found LIST element and begins the loop at <var class=Fa>var</var> instead of the first element in the LIST referenced by <var class=Fa>head</var>.</p><p class=Pp>The macro <code class=Nm>LIST_INIT</code> initializes the list referenced by <var class=Fa>head</var>.</p><p class=Pp>The macro <code class=Nm>LIST_INSERT_HEAD</code> inserts the new element <var class=Fa>elm</var> at the head of the list.</p><p class=Pp>The macro <code class=Nm>LIST_INSERT_AFTER</code> inserts the new element <var class=Fa>elm</var> after the element <var class=Fa>listelm</var>.</p><p class=Pp>The macro <code class=Nm>LIST_INSERT_BEFORE</code> inserts the new element <var class=Fa>elm</var> before the element <var class=Fa>listelm</var>.</p><p class=Pp>The macro <code class=Nm>LIST_NEXT</code> returns the next element in the list, or NULL if this is the last.</p><p class=Pp>The macro <code class=Nm>LIST_PREV</code> returns the previous element in the list, or NULL if this is the first. List <var class=Fa>head</var> must contain element <var class=Fa>elm</var>.</p><p class=Pp>The macro <code class=Nm>LIST_REMOVE</code> removes the element <var class=Fa>elm</var> from the list.</p><p class=Pp>The macro <code class=Nm>LIST_SWAP</code> swaps the contents of <var class=Fa>head1</var> and <var class=Fa>head2</var>.</p></section><section class=Sh><h2 class=Sh id=LIST_EXAMPLE><a class=permalink href=#LIST_EXAMPLE>LIST EXAMPLE</a></h2><div class=Bd><pre>
LIST_HEAD(listhead, entry) head =
    LIST_HEAD_INITIALIZER(head);
struct listhead *headp;			/* List head. */
struct entry {
	...
	LIST_ENTRY(entry) entries;	/* List. */
	...
} *n1, *n2, *n3, *np, *np_temp;

LIST_INIT(&amp;head);			/* Initialize the list. */

n1 = malloc(sizeof(struct entry));	/* Insert at the head. */
LIST_INSERT_HEAD(&amp;head, n1, entries);

n2 = malloc(sizeof(struct entry));	/* Insert after. */
LIST_INSERT_AFTER(n1, n2, entries);

n3 = malloc(sizeof(struct entry));	/* Insert before. */
LIST_INSERT_BEFORE(n2, n3, entries);

LIST_REMOVE(n2, entries);		/* Deletion. */
free(n2);
					/* Forward traversal. */
LIST_FOREACH(np, &amp;head, entries)
	np-&gt; ...

					/* Safe forward traversal. */
LIST_FOREACH_SAFE(np, &amp;head, entries, np_temp) {
	np-&gt;do_stuff();
	...
	LIST_REMOVE(np, entries);
	free(np);
}

while (!LIST_EMPTY(&amp;head)) {		/* List Deletion. */
	n1 = LIST_FIRST(&amp;head);
	LIST_REMOVE(n1, entries);
	free(n1);
}

n1 = LIST_FIRST(&amp;head);			/* Faster List Deletion. */
while (n1 != NULL) {
	n2 = LIST_NEXT(n1, entries);
	free(n1);
	n1 = n2;
}
LIST_INIT(&amp;head);
</pre></div></section><section class=Sh><h2 class=Sh id=TAIL_QUEUES><a class=permalink href=#TAIL_QUEUES>TAIL QUEUES</a></h2> A tail queue is headed by a structure defined by the <code class=Nm>TAILQ_HEAD</code> macro. This structure contains a pair of pointers, one to the first element in the tail queue and the other to the last element in the tail queue. The elements are doubly linked so that an arbitrary element can be removed without traversing the tail queue. New elements can be added to the tail queue after an existing element, before an existing element, at the head of the tail queue, or at the end of the tail queue. A <var class=Fa>TAILQ_HEAD</var> structure is declared as follows: <div class="Bd Pp Bd-indent"><pre>
TAILQ_HEAD(HEADNAME, TYPE) head;
</pre></div><p class=Pp>where <code class=Li>HEADNAME</code> is the name of the structure to be defined, and <code class=Li>TYPE</code> is the type of the elements to be linked into the tail queue. A pointer to the head of the tail queue can later be declared as:</p><div class="Bd Pp Bd-indent"><pre>
struct HEADNAME *headp;
</pre></div><p class=Pp>(The names <code class=Li>head</code> and <code class=Li>headp</code> are user selectable.)</p><p class=Pp>The macro <code class=Nm>TAILQ_HEAD_INITIALIZER</code> evaluates to an initializer for the tail queue <var class=Fa>head</var>.</p><p class=Pp>The macro <code class=Nm>TAILQ_CONCAT</code> concatenates the tail queue headed by <var class=Fa>head2</var> onto the end of the one headed by <var class=Fa>head1</var> removing all entries from the former.</p><p class=Pp>The macro <code class=Nm>TAILQ_EMPTY</code> evaluates to true if there are no items on the tail queue.</p><p class=Pp>The macro <code class=Nm>TAILQ_ENTRY</code> declares a structure that connects the elements in the tail queue.</p><p class=Pp>The macro <code class=Nm>TAILQ_FIRST</code> returns the first item on the tail queue or NULL if the tail queue is empty.</p><p class=Pp>The macro <code class=Nm>TAILQ_FOREACH</code> traverses the tail queue referenced by <var class=Fa>head</var> in the forward direction, assigning each element in turn to <var class=Fa>var</var>. <var class=Fa>var</var> is set to <code class=Dv>NULL</code> if the loop completes normally, or if there were no elements.</p><p class=Pp>The macro <code class=Nm>TAILQ_FOREACH_FROM</code> behaves identically to <code class=Nm>TAILQ_FOREACH</code> when <var class=Fa>var</var> is NULL, else it treats <var class=Fa>var</var> as a previously found TAILQ element and begins the loop at <var class=Fa>var</var> instead of the first element in the TAILQ referenced by <var class=Fa>head</var>.</p><p class=Pp>The macro <code class=Nm>TAILQ_FOREACH_REVERSE</code> traverses the tail queue referenced by <var class=Fa>head</var> in the reverse direction, assigning each element in turn to <var class=Fa>var</var>.</p><p class=Pp>The macro <code class=Nm>TAILQ_FOREACH_REVERSE_FROM</code> behaves identically to <code class=Nm>TAILQ_FOREACH_REVERSE</code> when <var class=Fa>var</var> is NULL, else it treats <var class=Fa>var</var> as a previously found TAILQ element and begins the reverse loop at <var class=Fa>var</var> instead of the last element in the TAILQ referenced by <var class=Fa>head</var>.</p><p class=Pp>The macros <code class=Nm>TAILQ_FOREACH_SAFE</code> and <code class=Nm>TAILQ_FOREACH_REVERSE_SAFE</code> traverse the list referenced by <var class=Fa>head</var> in the forward or reverse direction respectively, assigning each element in turn to <var class=Fa>var</var>. However, unlike their unsafe counterparts, <code class=Nm>TAILQ_FOREACH</code> and <code class=Nm>TAILQ_FOREACH_REVERSE</code> permit to both remove <var class=Fa>var</var> as well as free it from within the loop safely without interfering with the traversal.</p><p class=Pp>The macro <code class=Nm>TAILQ_FOREACH_FROM_SAFE</code> behaves identically to <code class=Nm>TAILQ_FOREACH_SAFE</code> when <var class=Fa>var</var> is NULL, else it treats <var class=Fa>var</var> as a previously found TAILQ element and begins the loop at <var class=Fa>var</var> instead of the first element in the TAILQ referenced by <var class=Fa>head</var>.</p><p class=Pp>The macro <code class=Nm>TAILQ_FOREACH_REVERSE_FROM_SAFE</code> behaves identically to <code class=Nm>TAILQ_FOREACH_REVERSE_SAFE</code> when <var class=Fa>var</var> is NULL, else it treats <var class=Fa>var</var> as a previously found TAILQ element and begins the reverse loop at <var class=Fa>var</var> instead of the last element in the TAILQ referenced by <var class=Fa>head</var>.</p><p class=Pp>The macro <code class=Nm>TAILQ_INIT</code> initializes the tail queue referenced by <var class=Fa>head</var>.</p><p class=Pp>The macro <code class=Nm>TAILQ_INSERT_HEAD</code> inserts the new element <var class=Fa>elm</var> at the head of the tail queue.</p><p class=Pp>The macro <code class=Nm>TAILQ_INSERT_TAIL</code> inserts the new element <var class=Fa>elm</var> at the end of the tail queue.</p><p class=Pp>The macro <code class=Nm>TAILQ_INSERT_AFTER</code> inserts the new element <var class=Fa>elm</var> after the element <var class=Fa>listelm</var>.</p><p class=Pp>The macro <code class=Nm>TAILQ_INSERT_BEFORE</code> inserts the new element <var class=Fa>elm</var> before the element <var class=Fa>listelm</var>.</p><p class=Pp>The macro <code class=Nm>TAILQ_LAST</code> returns the last item on the tail queue. If the tail queue is empty the return value is <code class=Dv>NULL</code>.</p><p class=Pp>The macro <code class=Nm>TAILQ_NEXT</code> returns the next item on the tail queue, or NULL if this item is the last.</p><p class=Pp>The macro <code class=Nm>TAILQ_PREV</code> returns the previous item on the tail queue, or NULL if this item is the first.</p><p class=Pp>The macro <code class=Nm>TAILQ_REMOVE</code> removes the element <var class=Fa>elm</var> from the tail queue.</p><p class=Pp>The macro <code class=Nm>TAILQ_SWAP</code> swaps the contents of <var class=Fa>head1</var> and <var class=Fa>head2</var>.</p></section><section class=Sh><h2 class=Sh id=TAIL_QUEUE_EXAMPLE><a class=permalink href=#TAIL_QUEUE_EXAMPLE>TAIL QUEUE EXAMPLE</a></h2><div class=Bd><pre>
TAILQ_HEAD(tailhead, entry) head =
    TAILQ_HEAD_INITIALIZER(head);
struct tailhead *headp;			/* Tail queue head. */
struct entry {
	...
	TAILQ_ENTRY(entry) entries;	/* Tail queue. */
	...
} *n1, *n2, *n3, *np;

TAILQ_INIT(&amp;head);			/* Initialize the queue. */

n1 = malloc(sizeof(struct entry));	/* Insert at the head. */
TAILQ_INSERT_HEAD(&amp;head, n1, entries);

n1 = malloc(sizeof(struct entry));	/* Insert at the tail. */
TAILQ_INSERT_TAIL(&amp;head, n1, entries);

n2 = malloc(sizeof(struct entry));	/* Insert after. */
TAILQ_INSERT_AFTER(&amp;head, n1, n2, entries);

n3 = malloc(sizeof(struct entry));	/* Insert before. */
TAILQ_INSERT_BEFORE(n2, n3, entries);

TAILQ_REMOVE(&amp;head, n2, entries);	/* Deletion. */
free(n2);
					/* Forward traversal. */
TAILQ_FOREACH(np, &amp;head, entries)
	np-&gt; ...
					/* Safe forward traversal. */
TAILQ_FOREACH_SAFE(np, &amp;head, entries, np_temp) {
	np-&gt;do_stuff();
	...
	TAILQ_REMOVE(&amp;head, np, entries);
	free(np);
}
					/* Reverse traversal. */
TAILQ_FOREACH_REVERSE(np, &amp;head, tailhead, entries)
	np-&gt; ...
					/* TailQ Deletion. */
while (!TAILQ_EMPTY(&amp;head)) {
	n1 = TAILQ_FIRST(&amp;head);
	TAILQ_REMOVE(&amp;head, n1, entries);
	free(n1);
}
					/* Faster TailQ Deletion. */
n1 = TAILQ_FIRST(&amp;head);
while (n1 != NULL) {
	n2 = TAILQ_NEXT(n1, entries);
	free(n1);
	n1 = n2;
}
TAILQ_INIT(&amp;head);
</pre></div></section><section class=Sh><h2 class=Sh id=DIAGNOSTICS><a class=permalink href=#DIAGNOSTICS>DIAGNOSTICS</a></h2> When debugging <code class=Nm>queue(3)</code>, it can be useful to trace queue changes. To enable tracing, define the macro <var class=Va>QUEUE_MACRO_DEBUG_TRACE</var> at compile time. <p class=Pp>It can also be useful to trash pointers that have been unlinked from a queue, to detect use after removal. To enable pointer trashing, define the macro <var class=Va>QUEUE_MACRO_DEBUG_TRASH</var> at compile time. The macro <code class=Fn>QMD_IS_TRASHED</code>(<var class=Fa>void *ptr</var>) returns true if <var class=Fa>ptr</var> has been trashed by the <var class=Va>QUEUE_MACRO_DEBUG_TRASH</var> option.</p><p class=Pp>In the kernel (with <var class=Va>INVARIANTS</var> enabled), the <code class=Fn>SLIST_REMOVE_PREVPTR</code>() macro is available to aid debugging:</p><dl class="Bl-hang Bd-indent"><dt><code class=Fn>SLIST_REMOVE_PREVPTR</code>(<var class=Fa>TYPE **prev</var>, <var class=Fa>TYPE *elm</var>, <var class=Fa>SLIST_ENTRY NAME</var>)</dt><dd><p class=Pp>Removes <var class=Fa>elm</var>, which must directly follow the element whose <var class=Va>&amp;SLIST_NEXT()</var> is <var class=Fa>prev</var>, from the SLIST. This macro validates that <var class=Fa>elm</var> follows <var class=Fa>prev</var> in <var class=Va>INVARIANTS</var> mode.</p></dd></dl></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=tree.3.html>tree(3)</a></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> The <code class=Nm>queue</code> functions first appeared in <span class=Ux>4.4BSD</span>. </section></div><table class=foot><tr><td class=foot-date>September 8, 2016</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>