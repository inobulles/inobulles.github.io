<!DOCTYPE html>
<html><head><meta charset=utf-8><title>libalias(3)</title><keywords content=man,libalias></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>libalias(3)</h1><table class=head><tr><td class=head-ltitle>LIBALIAS(3)</td><td class=head-vol>FreeBSD Library Functions Manual</td><td class=head-rtitle>LIBALIAS(3)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>libalias</code> — <div class=Nd>packet aliasing library for masquerading and network address translation</div></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/sys/types.h.html>sys/types.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/netinet/in.h.html>netinet/in.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/alias.h.html>alias.h</a>&gt;</code><p class=Pp>Function prototypes are given in the main body of the text.</p></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> The <code class=Nm>libalias</code> library is a collection of functions for aliasing and de-aliasing of IP packets, intended for masquerading and network address translation (NAT). </section><section class=Sh><h2 class=Sh id=INTRODUCTION><a class=permalink href=#INTRODUCTION>INTRODUCTION</a></h2> This library is a moderately portable set of functions designed to assist in the process of IP masquerading and network address translation. Outgoing packets from a local network with unregistered IP addresses can be aliased to appear as if they came from an accessible IP address. Incoming packets are then de-aliased so that they are sent to the correct machine on the local network. <p class=Pp>A certain amount of flexibility is built into the packet aliasing engine. In the simplest mode of operation, a many-to-one address mapping takes place between the local network and the packet aliasing host. This is known as IP masquerading. In addition, one-to-one mappings between local and public addresses can also be implemented, which is known as static NAT. In between these extremes, different groups of private addresses can be linked to different public addresses, comprising several distinct many-to-one mappings. Also, a given public address and port can be statically redirected to a private address/port.</p></section><section class=Sh><h2 class=Sh id=INITIALIZATION_AND_CONTROL><a class=permalink href=#INITIALIZATION_AND_CONTROL>INITIALIZATION AND CONTROL</a></h2> One special function, <code class=Fn>LibAliasInit</code>(), must always be called before any packet handling may be performed, and the returned instance pointer must be passed to all the other functions. Normally, the <code class=Fn>LibAliasSetAddress</code>() function is called afterwards, to set the default aliasing address. In addition, the operating mode of the packet aliasing engine can be customized by calling <code class=Fn>LibAliasSetMode</code>(). <p class=Pp><var class=Ft>struct libalias *</var><code class=Fn>LibAliasInit</code>(<var class=Fa>struct libalias *</var>)</p><div class="Bd Pp Bd-indent">This function is used to initialize internal data structures. When called the first time, a <code class=Dv>NULL</code> pointer should be passed as an argument. The following mode bits are always set after calling <code class=Fn>LibAliasInit</code>(). See the description of <code class=Fn>LibAliasSetMode</code>() below for the meaning of these mode bits. <p class=Pp></p><ul class="Bl-item Bd-indent Bl-compact"><li><a class=permalink href=#PKT_ALIAS_SAME_PORTS><code class=Dv id=PKT_ALIAS_SAME_PORTS>PKT_ALIAS_SAME_PORTS</code></a></li><li><a class=permalink href=#PKT_ALIAS_USE_SOCKETS><code class=Dv id=PKT_ALIAS_USE_SOCKETS>PKT_ALIAS_USE_SOCKETS</code></a></li><li><a class=permalink href=#PKT_ALIAS_RESET_ON_ADDR_CHANGE><code class=Dv id=PKT_ALIAS_RESET_ON_ADDR_CHANGE>PKT_ALIAS_RESET_ON_ADDR_CHANGE</code></a></li></ul><p class=Pp>This function will always return the packet aliasing engine to the same initial state. The <code class=Fn>LibAliasSetAddress</code>() function is normally called afterwards, and any desired changes from the default mode bits listed above require a call to <code class=Fn>LibAliasSetMode</code>().</p><p class=Pp>It is mandatory that this function be called at the beginning of a program prior to any packet handling.</p></div><p class=Pp><var class=Ft>void</var><code class=Fn>LibAliasUninit</code>(<var class=Fa>struct libalias *</var>)</p><div class="Bd Pp Bd-indent">This function has no return value and is used to clear any resources attached to internal data structures. <p class=Pp>This function should be called when a program stops using the aliasing engine; amongst other things, it clears out any firewall holes. To provide backwards compatibility and extra security, it is added to the <a class=Xr href=atexit.3.html>atexit(3)</a> chain by <code class=Fn>LibAliasInit</code>().</p></div><p class=Pp><var class=Ft>void</var><code class=Fn>LibAliasSetAddress</code>(<var class=Fa>struct libalias *</var>, <var class=Fa>struct in_addr addr</var>)</p><div class="Bd Pp Bd-indent">This function sets the source address to which outgoing packets from the local area network are aliased. All outgoing packets are re-mapped to this address unless overridden by a static address mapping established by <code class=Fn>LibAliasRedirectAddr</code>(). If this function has not been called, and no static rules match, an outgoing packet retains its source address. <p class=Pp>If the <code class=Dv>PKT_ALIAS_RESET_ON_ADDR_CHANGE</code> mode bit is set (the default mode of operation), then the internal aliasing link tables will be reset any time the aliasing address changes. This is useful for interfaces such as <a class=Xr href=ppp.8.html>ppp(8)</a>, where the IP address may or may not change on successive dial-up attempts.</p><p class=Pp>If the <code class=Dv>PKT_ALIAS_RESET_ON_ADDR_CHANGE</code> mode bit is set to zero, this function can also be used to dynamically change the aliasing address on a packet-to-packet basis (it is a low overhead call).</p><p class=Pp>It is mandatory that this function be called prior to any packet handling.</p></div><p class=Pp><var class=Ft>unsigned int</var><code class=Fn>LibAliasSetMode</code>(<var class=Fa>struct libalias *</var>, <var class=Fa>unsigned int flags</var>, <var class=Fa>unsigned int mask</var>)</p><div class="Bd Pp Bd-indent">This function sets or clears mode bits according to the value of <var class=Fa>flags</var>. Only bits marked in <var class=Fa>mask</var> are affected. The following mode bits are defined in <code class=In>&lt;<a class=In href=../src/alias.h.html>alias.h</a>&gt;</code>: <dl class=Bl-tag><dt><a class=permalink href=#PKT_ALIAS_LOG><code class=Dv id=PKT_ALIAS_LOG>PKT_ALIAS_LOG</code></a></dt><dd>Enables logging into <span class=Pa>/var/log/alias.log</span>. Each time an aliasing link is created or deleted, the log file is appended to with the current number of ICMP, TCP and UDP links. Mainly useful for debugging when the log file is viewed continuously with <a class=Xr href=tail.1.html>tail(1)</a>.</dd><dt><a class=permalink href=#PKT_ALIAS_DENY_INCOMING><code class=Dv id=PKT_ALIAS_DENY_INCOMING>PKT_ALIAS_DENY_INCOMING</code></a></dt><dd>If this mode bit is set, all incoming packets associated with new TCP connections or new UDP transactions will be marked for being ignored (<code class=Fn>LibAliasIn</code>() returns <code class=Dv>PKT_ALIAS_IGNORED</code> code) by the calling program. Response packets to connections or transactions initiated from the packet aliasing host or local network will be unaffected. This mode bit is useful for implementing a one-way firewall.</dd><dt><a class=permalink href=#PKT_ALIAS_SAME_PORTS_2><code class=Dv id=PKT_ALIAS_SAME_PORTS_2>PKT_ALIAS_SAME_PORTS</code></a></dt><dd>If this mode bit is set, the packet-aliasing engine will attempt to leave the alias port numbers unchanged from the actual local port numbers. This can be done as long as the quintuple (proto, alias addr, alias port, remote addr, remote port) is unique. If a conflict exists, a new aliasing port number is chosen even if this mode bit is set.</dd><dt><a class=permalink href=#PKT_ALIAS_USE_SOCKETS_2><code class=Dv id=PKT_ALIAS_USE_SOCKETS_2>PKT_ALIAS_USE_SOCKETS</code></a></dt><dd>This bit should be set when the packet aliasing host originates network traffic as well as forwards it. When the packet aliasing host is waiting for a connection from an unknown host address or unknown port number (e.g. an FTP data connection), this mode bit specifies that a socket be allocated as a place holder to prevent port conflicts. Once a connection is established, usually within a minute or so, the socket is closed.</dd><dt><a class=permalink href=#PKT_ALIAS_UNREGISTERED_ONLY><code class=Dv id=PKT_ALIAS_UNREGISTERED_ONLY>PKT_ALIAS_UNREGISTERED_ONLY</code></a></dt><dd>If this mode bit is set, traffic on the local network which does not originate from unregistered address spaces will be ignored. Standard Class A, B and C unregistered addresses are: <p class=Pp>10.0.0.0 -&gt; 10.255.255.255 (Class A subnet) 172.16.0.0 -&gt; 172.31.255.255 (Class B subnets) 192.168.0.0 -&gt; 192.168.255.255 (Class C subnets)</p><p class=Pp>This option is useful in the case that the packet aliasing host has both registered and unregistered subnets on different interfaces. The registered subnet is fully accessible to the outside world, so traffic from it does not need to be passed through the packet aliasing engine.</p></dd><dt><a class=permalink href=#PKT_ALIAS_UNREGISTERED_CGN><code class=Dv id=PKT_ALIAS_UNREGISTERED_CGN>PKT_ALIAS_UNREGISTERED_CGN</code></a></dt><dd>Like PKT_ALIAS_UNREGISTERED_ONLY, but includes the RFC 6598 (Carrier Grade NAT) subnet as follows: <p class=Pp>100.64.0.0 -&gt; 100.127.255.255 (RFC 6598 subnet)</p></dd><dt><a class=permalink href=#PKT_ALIAS_RESET_ON_ADDR_CHANGE_2><code class=Dv id=PKT_ALIAS_RESET_ON_ADDR_CHANGE_2>PKT_ALIAS_RESET_ON_ADDR_CHANGE</code></a></dt><dd>When this mode bit is set and <code class=Fn>LibAliasSetAddress</code>() is called to change the aliasing address, the internal link table of the packet aliasing engine will be cleared. This operating mode is useful for <a class=Xr href=ppp.8.html>ppp(8)</a> links where the interface address can sometimes change or remain the same between dial-up attempts. If this mode bit is not set, the link table will never be reset in the event of an address change.</dd><dt><a class=permalink href=#PKT_ALIAS_PUNCH_FW><code class=Dv id=PKT_ALIAS_PUNCH_FW>PKT_ALIAS_PUNCH_FW</code></a></dt><dd>This option makes <code class=Nm>libalias</code> “punch holes” in an <a class=Xr href=ipfirewall.4.html>ipfirewall(4)</a> - based firewall for FTP/IRC DCC connections. The holes punched are bound by from/to IP address and port; it will not be possible to use a hole for another connection. A hole is removed when the connection that uses it dies. To cater to unexpected death of a program using <code class=Nm>libalias</code> (e.g. kill -9), changing the state of the flag will clear the entire firewall range allocated for holes. This clearing will also happen on the initial call to <code class=Fn>LibAliasSetFWBase</code>(), which must happen prior to setting this flag.</dd><dt><a class=permalink href=#PKT_ALIAS_REVERSE><code class=Dv id=PKT_ALIAS_REVERSE>PKT_ALIAS_REVERSE</code></a></dt><dd>This option makes <code class=Nm>libalias</code> reverse the way it handles incoming and outgoing packets, allowing it to be fed with data that passes through the internal interface rather than the external one.</dd><dt><a class=permalink href=#PKT_ALIAS_PROXY_ONLY><code class=Dv id=PKT_ALIAS_PROXY_ONLY>PKT_ALIAS_PROXY_ONLY</code></a></dt><dd>This option tells <code class=Nm>libalias</code> to obey transparent proxy rules only. Normal packet aliasing is not performed. See <code class=Fn>LibAliasProxyRule</code>() below for details.</dd><dt><a class=permalink href=#PKT_ALIAS_SKIP_GLOBAL><code class=Dv id=PKT_ALIAS_SKIP_GLOBAL>PKT_ALIAS_SKIP_GLOBAL</code></a></dt><dd>This option is used by <span class=Pa>ipfw_nat</span> only. Specifying it as a flag to <code class=Fn>LibAliasSetMode</code>() has no effect. See section <a class=Sx href=#NETWORK_ADDRESS_TRANSLATION>NETWORK ADDRESS TRANSLATION</a> in <a class=Xr href=ipfw.8.html>ipfw(8)</a> for more details.</dd></dl></div><p class=Pp><var class=Ft>void</var><code class=Fn>LibAliasSetFWBase</code>(<var class=Fa>struct libalias *</var>, <var class=Fa>unsigned int base</var>, <var class=Fa>unsigned int num</var>)</p><div class="Bd Pp Bd-indent">Set the firewall range allocated for punching firewall holes (with the <code class=Dv>PKT_ALIAS_PUNCH_FW</code> flag). The range is cleared for all rules on initialization.</div><p class=Pp><var class=Ft>void</var><code class=Fn>LibAliasSkinnyPort</code>(<var class=Fa>struct libalias *</var>, <var class=Fa>unsigned int port</var>)</p><div class="Bd Pp Bd-indent">Set the TCP port used by the Skinny Station protocol. Skinny is used by Cisco IP phones to communicate with Cisco Call Managers to set up voice over IP calls. If this is not set, Skinny aliasing will not be done. The typical port used by Skinny is 2000.</div></section><section class=Sh><h2 class=Sh id=PACKET_HANDLING><a class=permalink href=#PACKET_HANDLING>PACKET HANDLING</a></h2> The packet handling functions are used to modify incoming (remote to local) and outgoing (local to remote) packets. The calling program is responsible for receiving and sending packets via network interfaces. <p class=Pp>Along with <code class=Fn>LibAliasInit</code>() and <code class=Fn>LibAliasSetAddress</code>(), the two packet handling functions, <code class=Fn>LibAliasIn</code>() and <code class=Fn>LibAliasOut</code>(), comprise the minimal set of functions needed for a basic IP masquerading implementation.</p><p class=Pp><var class=Ft>int</var><code class=Fn>LibAliasIn</code>(<var class=Fa>struct libalias *</var>, <var class=Fa>void *buffer</var>, <var class=Fa>int maxpacketsize</var>)</p><div class="Bd Pp Bd-indent">An incoming packet coming from a remote machine to the local network is de-aliased by this function. The IP packet is pointed to by <var class=Fa>buffer</var>, and <var class=Fa>maxpacketsize</var> indicates the size of the data structure containing the packet and should be at least as large as the actual packet size. <p class=Pp>Return codes:</p><dl class=Bl-tag><dt><a class=permalink href=#PKT_ALIAS_OK><code class=Dv id=PKT_ALIAS_OK>PKT_ALIAS_OK</code></a></dt><dd>The packet aliasing process was successful.</dd><dt><a class=permalink href=#PKT_ALIAS_IGNORED><code class=Dv id=PKT_ALIAS_IGNORED>PKT_ALIAS_IGNORED</code></a></dt><dd>The packet was ignored and not de-aliased. This can happen if the protocol is unrecognized, as for an ICMP message type that is not handled, or if incoming packets for new connections are being ignored (if the <code class=Dv>PKT_ALIAS_DENY_INCOMING</code> mode bit was set using <code class=Fn>LibAliasSetMode</code>()).</dd><dt><a class=permalink href=#PKT_ALIAS_UNRESOLVED_FRAGMENT><code class=Dv id=PKT_ALIAS_UNRESOLVED_FRAGMENT>PKT_ALIAS_UNRESOLVED_FRAGMENT</code></a></dt><dd>This is returned when a fragment cannot be resolved because the header fragment has not been sent yet. In this situation, fragments must be saved with <code class=Fn>LibAliasSaveFragment</code>() until a header fragment is found.</dd><dt><a class=permalink href=#PKT_ALIAS_FOUND_HEADER_FRAGMENT><code class=Dv id=PKT_ALIAS_FOUND_HEADER_FRAGMENT>PKT_ALIAS_FOUND_HEADER_FRAGMENT</code></a></dt><dd>The packet aliasing process was successful, and a header fragment was found. This is a signal to retrieve any unresolved fragments with <code class=Fn>LibAliasGetFragment</code>() and de-alias them with <code class=Fn>LibAliasFragmentIn</code>().</dd><dt><a class=permalink href=#PKT_ALIAS_ERROR><code class=Dv id=PKT_ALIAS_ERROR>PKT_ALIAS_ERROR</code></a></dt><dd>An internal error within the packet aliasing engine occurred.</dd></dl></div><p class=Pp><var class=Ft>int</var><code class=Fn>LibAliasOut</code>(<var class=Fa>struct libalias *</var>, <var class=Fa>void *buffer</var>, <var class=Fa>int maxpacketsize</var>)</p><div class="Bd Pp Bd-indent">An outgoing packet coming from the local network to a remote machine is aliased by this function. The IP packet is pointed to by <var class=Fa>buffer</var>, and <var class=Fa>maxpacketsize</var> indicates the maximum packet size permissible should the packet length be changed. IP encoding protocols place address and port information in the encapsulated data stream which has to be modified and can account for changes in packet length. Well known examples of such protocols are FTP and IRC DCC. <p class=Pp>Return codes:</p><dl class=Bl-tag><dt><a class=permalink href=#PKT_ALIAS_OK_2><code class=Dv id=PKT_ALIAS_OK_2>PKT_ALIAS_OK</code></a></dt><dd>The packet aliasing process was successful.</dd><dt><a class=permalink href=#PKT_ALIAS_IGNORED_2><code class=Dv id=PKT_ALIAS_IGNORED_2>PKT_ALIAS_IGNORED</code></a></dt><dd>The packet was ignored and not aliased. This can happen if the protocol is unrecognized, or possibly an ICMP message type is not handled.</dd><dt><a class=permalink href=#PKT_ALIAS_ERROR_2><code class=Dv id=PKT_ALIAS_ERROR_2>PKT_ALIAS_ERROR</code></a></dt><dd>An internal error within the packet aliasing engine occurred.</dd></dl></div></section><section class=Sh><h2 class=Sh id=PORT_AND_ADDRESS_REDIRECTION><a class=permalink href=#PORT_AND_ADDRESS_REDIRECTION>PORT AND ADDRESS REDIRECTION</a></h2> The functions described in this section allow machines on the local network to be accessible in some degree to new incoming connections from the external network. Individual ports can be re-mapped or static network address translations can be designated. <p class=Pp><var class=Ft>struct alias_link *</var><code class=Fn>LibAliasRedirectPort</code>(<var class=Fa>struct libalias *</var>, <var class=Fa>struct in_addr local_addr</var>, <var class=Fa>u_short local_port</var>, <var class=Fa>struct in_addr remote_addr</var>, <var class=Fa>u_short remote_port</var>, <var class=Fa>struct in_addr alias_addr</var>, <var class=Fa>u_short alias_port</var>, <var class=Fa>u_char proto</var>);</p><div class="Bd Pp Bd-indent">This function specifies that traffic from a given remote address/port to an alias address/port be redirected to a specified local address/port. The parameter <var class=Fa>proto</var> can be either <code class=Dv>IPPROTO_TCP</code> or <code class=Dv>IPPROTO_UDP</code>, as defined in <code class=In>&lt;<a class=In href=../src/netinet/in.h.html>netinet/in.h</a>&gt;</code>. <p class=Pp>If <var class=Fa>local_addr</var> or <var class=Fa>alias_addr</var> is zero, this indicates that the packet aliasing address as established by <code class=Fn>LibAliasSetAddress</code>() is to be used. Even if <code class=Fn>LibAliasSetAddress</code>() is called to change the address after <code class=Fn>LibAliasRedirectPort</code>() is called, a zero reference will track this change.</p><p class=Pp>If the link is further set up to operate with load sharing, then <var class=Fa>local_addr</var> and <var class=Fa>local_port</var> are ignored, and are selected dynamically from the server pool, as described in <code class=Fn>LibAliasAddServer</code>() below.</p><p class=Pp>If <var class=Fa>remote_addr</var> is zero, this indicates to redirect packets from any remote address. Likewise, if <var class=Fa>remote_port</var> is zero, this indicates to redirect packets originating from any remote port number. The remote port specification will almost always be zero, but non-zero remote addresses can sometimes be useful for firewalling. If two calls to <code class=Fn>LibAliasRedirectPort</code>() overlap in their address/port specifications, then the most recent call will have precedence.</p><p class=Pp>This function returns a pointer which can subsequently be used by <code class=Fn>LibAliasRedirectDelete</code>(). If <code class=Dv>NULL</code> is returned, then the function call did not complete successfully.</p><p class=Pp>All port numbers should be in network address byte order, so it is necessary to use <a class=Xr href=htons.3.html>htons(3)</a> to convert these parameters from internally readable numbers to network byte order. Addresses are also in network byte order, which is implicit in the use of the <var class=Fa>struct in_addr</var> data type.</p></div><p class=Pp><var class=Ft>struct alias_link *</var><code class=Fn>LibAliasRedirectAddr</code>(<var class=Fa>struct libalias *</var>, <var class=Fa>struct in_addr local_addr</var>, <var class=Fa>struct in_addr alias_addr</var>);</p><div class="Bd Pp Bd-indent">This function designates that all incoming traffic to <var class=Fa>alias_addr</var> be redirected to <var class=Fa>local_addr</var>. Similarly, all outgoing traffic from <var class=Fa>local_addr</var> is aliased to <var class=Fa>alias_addr</var>. <p class=Pp>If <var class=Fa>local_addr</var> or <var class=Fa>alias_addr</var> is zero, this indicates that the packet aliasing address as established by <code class=Fn>LibAliasSetAddress</code>() is to be used. Even if <code class=Fn>LibAliasSetAddress</code>() is called to change the address after <code class=Fn>LibAliasRedirectAddr</code>() is called, a zero reference will track this change.</p><p class=Pp>If the link is further set up to operate with load sharing, then the <var class=Fa>local_addr</var> argument is ignored, and is selected dynamically from the server pool, as described in <code class=Fn>LibAliasAddServer</code>() below.</p><p class=Pp>If subsequent calls to <code class=Fn>LibAliasRedirectAddr</code>() use the same aliasing address, all new incoming traffic to this aliasing address will be redirected to the local address made in the last function call. New traffic generated by any of the local machines, designated in the several function calls, will be aliased to the same address. Consider the following example:</p><p class=Pp>LibAliasRedirectAddr(la, inet_aton("192.168.0.2"), <br> inet_aton("141.221.254.101")); LibAliasRedirectAddr(la, inet_aton("192.168.0.3"), <br> inet_aton("141.221.254.101")); LibAliasRedirectAddr(la, inet_aton("192.168.0.4"), <br> inet_aton("141.221.254.101"));</p><p class=Pp>Any outgoing connections such as <a class=Xr href=telnet.1.html>telnet(1)</a> or <a class=Xr href=ftp.1.html>ftp(1)</a> from 192.168.0.2, 192.168.0.3 and 192.168.0.4 will appear to come from 141.221.254.101. Any incoming connections to 141.221.254.101 will be directed to 192.168.0.4.</p><p class=Pp>Any calls to <code class=Fn>LibAliasRedirectPort</code>() will have precedence over address mappings designated by <code class=Fn>LibAliasRedirectAddr</code>().</p><p class=Pp>This function returns a pointer which can subsequently be used by <code class=Fn>LibAliasRedirectDelete</code>(). If <code class=Dv>NULL</code> is returned, then the function call did not complete successfully.</p></div><p class=Pp><var class=Ft>int</var><code class=Fn>LibAliasAddServer</code>(<var class=Fa>struct libalias *</var>, <var class=Fa>struct alias_link *link</var>, <var class=Fa>struct in_addr addr</var>, <var class=Fa>u_short port</var>);</p><div class="Bd Pp Bd-indent">This function sets the <var class=Fa>link</var> up for Load Sharing using IP Network Address Translation (RFC 2391, LSNAT). LSNAT operates as follows. A client attempts to access a server by using the server virtual address. The LSNAT router transparently redirects the request to one of the hosts in the server pool, using a real-time load sharing algorithm. Multiple sessions may be initiated from the same client, and each session could be directed to a different host based on the load balance across server pool hosts when the sessions are initiated. If load sharing is desired for just a few specific services, the configuration on LSNAT could be defined to restrict load sharing to just the services desired. <p class=Pp>Currently, only the simplest selection algorithm is implemented, where a host is selected on a round-robin basis only, without regard to load on the host.</p><p class=Pp>First, the <var class=Fa>link</var> is created by either <code class=Fn>LibAliasRedirectPort</code>() or <code class=Fn>LibAliasRedirectAddr</code>(). Then, <code class=Fn>LibAliasAddServer</code>() is called multiple times to add entries to the <var class=Fa>link</var>'s server pool.</p><p class=Pp>For links created with <code class=Fn>LibAliasRedirectAddr</code>(), the <var class=Fa>port</var> argument is ignored and could have any value, e.g. htons(~0).</p><p class=Pp>This function returns 0 on success, -1 otherwise.</p></div><p class=Pp><var class=Ft>int</var><code class=Fn>LibAliasRedirectDynamic</code>(<var class=Fa>struct libalias *</var>, <var class=Fa>struct alias_link *link</var>)</p><div class="Bd Pp Bd-indent">This function marks the specified static redirect rule entered by <code class=Fn>LibAliasRedirectPort</code>() as dynamic. This can be used to e.g. dynamically redirect a single TCP connection, after which the rule is removed. Only fully specified links can be made dynamic. (See the <a class=Sx href=#STATIC_AND_DYNAMIC_LINKS>STATIC AND DYNAMIC LINKS</a> and <a class=Sx href=#PARTIALLY_SPECIFIED_ALIASING_LINKS>PARTIALLY SPECIFIED ALIASING LINKS</a> sections below for a definition of static vs. dynamic, and partially vs. fully specified links.) <p class=Pp>This function returns 0 on success, -1 otherwise.</p></div><p class=Pp><var class=Ft>void</var><code class=Fn>LibAliasRedirectDelete</code>(<var class=Fa>struct libalias *</var>, <var class=Fa>struct alias_link *link</var>)</p><div class="Bd Pp Bd-indent">This function will delete a specific static redirect rule entered by <code class=Fn>LibAliasRedirectPort</code>() or <code class=Fn>LibAliasRedirectAddr</code>(). The parameter <var class=Fa>link</var> is the pointer returned by either of the redirection functions. If an invalid pointer is passed to <code class=Fn>LibAliasRedirectDelete</code>(), then a program crash or unpredictable operation could result, so care is needed when using this function.</div><p class=Pp><var class=Ft>int</var><code class=Fn>LibAliasProxyRule</code>(<var class=Fa>struct libalias *</var>, <var class=Fa>const char *cmd</var>)</p><div class="Bd Pp Bd-indent">The passed <var class=Fa>cmd</var> string consists of one or more pairs of words. The first word in each pair is a token and the second is the value that should be applied for that token. Tokens and their argument types are as follows: <dl class=Bl-tag><dt><a class=permalink href=#type_encode_ip_hdr><code class=Cm id=type_encode_ip_hdr>type encode_ip_hdr</code></a> | <a class=permalink href=#encode_tcp_stream><code class=Cm id=encode_tcp_stream>encode_tcp_stream</code></a> | <a class=permalink href=#no_encode><code class=Cm id=no_encode>no_encode</code></a></dt><dd>In order to support transparent proxying, it is necessary to somehow pass the original address and port information into the new destination server. If <code class=Cm>encode_ip_hdr</code> is specified, the original destination address and port are passed as an extra IP option. If <code class=Cm>encode_tcp_stream</code> is specified, the original destination address and port are passed as the first piece of data in the TCP stream in the format “<code class=Li>DEST</code><var class=Ar>IP port</var>”.</dd><dt><a class=permalink href=#port><code class=Cm id=port>port</code></a><var class=Ar>portnum</var></dt><dd>Only packets with the destination port <var class=Ar>portnum</var> are proxied.</dd><dt><a class=permalink href=#server><code class=Cm id=server>server</code></a><var class=Ar>host</var>[:<var class=Ar>portnum</var>]</dt><dd>This specifies the <var class=Ar>host</var> and <var class=Ar>portnum</var> that the data is to be redirected to. <var class=Ar>host</var> must be an IP address rather than a DNS host name. If <var class=Ar>portnum</var> is not specified, the destination port number is not changed. <p class=Pp>The <var class=Ar>server</var> specification is mandatory unless the <code class=Cm>delete</code> command is being used.</p></dd><dt><a class=permalink href=#rule><code class=Cm id=rule>rule</code></a><var class=Ar>index</var></dt><dd>Normally, each call to <code class=Fn>LibAliasProxyRule</code>() inserts the next rule at the start of a linear list of rules. If an <var class=Ar>index</var> is specified, the new rule will be checked after all rules with lower indices. Calls to <code class=Fn>LibAliasProxyRule</code>() that do not specify a rule are assigned rule 0.</dd><dt><a class=permalink href=#delete><code class=Cm id=delete>delete</code></a><var class=Ar>index</var></dt><dd>This token and its argument MUST NOT be used with any other tokens. When used, all existing rules with the given <var class=Ar>index</var> are deleted.</dd><dt><a class=permalink href=#proto_tcp><code class=Cm id=proto_tcp>proto tcp</code></a> | <a class=permalink href=#udp><code class=Cm id=udp>udp</code></a></dt><dd>If specified, only packets of the given protocol type are matched.</dd><dt><a class=permalink href=#src><code class=Cm id=src>src</code></a><var class=Ar>IP</var>[/<var class=Ar>bits</var>]</dt><dd>If specified, only packets with a source address matching the given <var class=Ar>IP</var> are matched. If <var class=Ar>bits</var> is also specified, then the first <var class=Ar>bits</var> bits of <var class=Ar>IP</var> are taken as a network specification, and all IP addresses from that network will be matched.</dd><dt><a class=permalink href=#dst><code class=Cm id=dst>dst</code></a><var class=Ar>IP</var>[/<var class=Ar>bits</var>]</dt><dd>If specified, only packets with a destination address matching the given <var class=Ar>IP</var> are matched. If <var class=Ar>bits</var> is also specified, then the first <var class=Ar>bits</var> bits of <var class=Ar>IP</var> are taken as a network specification, and all IP addresses from that network will be matched.</dd></dl><p class=Pp>This function is usually used to redirect outgoing connections for internal machines that are not permitted certain types of internet access, or to restrict access to certain external machines.</p></div><p class=Pp><var class=Ft>struct alias_link *</var><code class=Fn>LibAliasRedirectProto</code>(<var class=Fa>struct libalias *</var>, <var class=Fa>struct in_addr local_addr</var>, <var class=Fa>struct in_addr remote_addr</var>, <var class=Fa>struct in_addr alias_addr</var>, <var class=Fa>u_char proto</var>);</p><div class="Bd Pp Bd-indent">This function specifies that any IP packet with protocol number of <var class=Fa>proto</var> from a given remote address to an alias address will be redirected to a specified local address. <p class=Pp>If <var class=Fa>local_addr</var> or <var class=Fa>alias_addr</var> is zero, this indicates that the packet aliasing address as established by <code class=Fn>LibAliasSetAddress</code>() is to be used. Even if <code class=Fn>LibAliasSetAddress</code>() is called to change the address after <code class=Fn>LibAliasRedirectProto</code>() is called, a zero reference will track this change.</p><p class=Pp>If <var class=Fa>remote_addr</var> is zero, this indicates to redirect packets from any remote address. Non-zero remote addresses can sometimes be useful for firewalling.</p><p class=Pp>If two calls to <code class=Fn>LibAliasRedirectProto</code>() overlap in their address specifications, then the most recent call will have precedence.</p><p class=Pp>This function returns a pointer which can subsequently be used by <code class=Fn>LibAliasRedirectDelete</code>(). If <code class=Dv>NULL</code> is returned, then the function call did not complete successfully.</p></div></section><section class=Sh><h2 class=Sh id=FRAGMENT_HANDLING><a class=permalink href=#FRAGMENT_HANDLING>FRAGMENT HANDLING</a></h2> The functions in this section are used to deal with incoming fragments. <p class=Pp>Outgoing fragments are handled within <code class=Fn>LibAliasOut</code>() by changing the address according to any applicable mapping set by <code class=Fn>LibAliasRedirectAddr</code>(), or the default aliasing address set by <code class=Fn>LibAliasSetAddress</code>().</p><p class=Pp>Incoming fragments are handled in one of two ways. If the header of a fragmented IP packet has already been seen, then all subsequent fragments will be re-mapped in the same manner the header fragment was. Fragments which arrive before the header are saved and then retrieved once the header fragment has been resolved.</p><p class=Pp><var class=Ft>int</var><code class=Fn>LibAliasSaveFragment</code>(<var class=Fa>struct libalias *</var>, <var class=Fa>void *ptr</var>)</p><div class="Bd Pp Bd-indent">When <code class=Fn>LibAliasIn</code>() returns <code class=Dv>PKT_ALIAS_UNRESOLVED_FRAGMENT</code>, this function can be used to save the pointer to the unresolved fragment. <p class=Pp>It is implicitly assumed that <var class=Fa>ptr</var> points to a block of memory allocated by <a class=Xr href=malloc.3.html>malloc(3)</a>. If the fragment is never resolved, the packet aliasing engine will automatically free the memory after a timeout period. [Eventually this function should be modified so that a callback function for freeing memory is passed as an argument.]</p><p class=Pp>This function returns <code class=Dv>PKT_ALIAS_OK</code> if it was successful and <code class=Dv>PKT_ALIAS_ERROR</code> if there was an error.</p></div><p class=Pp><var class=Ft>void *</var><code class=Fn>LibAliasGetFragment</code>(<var class=Fa>struct libalias *</var>, <var class=Fa>void *buffer</var>)</p><div class="Bd Pp Bd-indent">This function can be used to retrieve fragment pointers saved by <code class=Fn>LibAliasSaveFragment</code>(). The IP header fragment pointed to by <var class=Fa>buffer</var> is the header fragment indicated when <code class=Fn>LibAliasIn</code>() returns <code class=Dv>PKT_ALIAS_FOUND_HEADER_FRAGMENT</code>. Once a fragment pointer is retrieved, it becomes the calling program's responsibility to free the dynamically allocated memory for the fragment. <p class=Pp>The <code class=Fn>LibAliasGetFragment</code>() function can be called sequentially until there are no more fragments available, at which time it returns <code class=Dv>NULL</code>.</p></div><p class=Pp><var class=Ft>void</var><code class=Fn>LibAliasFragmentIn</code>(<var class=Fa>struct libalias *</var>, <var class=Fa>void *header</var>, <var class=Fa>void *fragment</var>)</p><div class="Bd Pp Bd-indent">When a fragment is retrieved with <code class=Fn>LibAliasGetFragment</code>(), it can then be de-aliased with a call to <code class=Fn>LibAliasFragmentIn</code>(). The <var class=Fa>header</var> argument is the pointer to a header fragment used as a template, and <var class=Fa>fragment</var> is the pointer to the packet to be de-aliased.</div></section><section class=Sh><h2 class=Sh id=MISCELLANEOUS_FUNCTIONS><a class=permalink href=#MISCELLANEOUS_FUNCTIONS>MISCELLANEOUS FUNCTIONS</a></h2><var class=Ft>struct alias_link *</var><code class=Fn>AddLink</code>(<var class=Fa>struct libalias *</var>, <var class=Fa>struct in_addr src_addr</var>, <var class=Fa>struct in_addr dst_addr</var>, <var class=Fa>struct in_addr alias_addr</var>, <var class=Fa>u_short src_port</var>, <var class=Fa>u_short dst_port</var>, <var class=Fa>int alias_param</var>, <var class=Fa>int link_type</var>) <div class="Bd Pp Bd-indent">This function adds new state to the instance hash table. The dst_address and/or dst_port may be given as zero, which introduces some dynamic character into the link, since LibAliasSetAddress can change the address that is used. However, in the current implementation, such links can only be used for inbound (ext -&gt; int) traffic.</div><p class=Pp><var class=Ft>void</var><code class=Fn>LibAliasSetTarget</code>(<var class=Fa>struct libalias *</var>, <var class=Fa>struct in_addr addr</var>)</p><div class="Bd Pp Bd-indent">When an incoming packet not associated with any pre-existing aliasing link arrives at the host machine, it will be sent to the address indicated by a call to <code class=Fn>LibAliasSetTarget</code>(). <p class=Pp>If this function is called with an <code class=Dv>INADDR_NONE</code> address argument, then all new incoming packets go to the address set by <code class=Fn>LibAliasSetAddress</code>().</p><p class=Pp>If this function is not called, or is called with an <code class=Dv>INADDR_ANY</code> address argument, then all new incoming packets go to the address specified in the packet. This allows external machines to talk directly to internal machines if they can route packets to the machine in question.</p></div><p class=Pp><var class=Ft>u_short</var><code class=Fn>LibAliasInternetChecksum</code>(<var class=Fa>struct libalias *</var>, <var class=Fa>u_short *buffer</var>, <var class=Fa>int nbytes</var>)</p><div class="Bd Pp Bd-indent">This is a utility function that does not seem to be available elsewhere and is included as a convenience. It computes the internet checksum, which is used in both IP and protocol-specific headers (TCP, UDP, ICMP). <p class=Pp>The <var class=Fa>buffer</var> argument points to the data block to be checksummed, and <var class=Fa>nbytes</var> is the number of bytes. The 16-bit checksum field should be zeroed before computing the checksum.</p><p class=Pp>Checksums can also be verified by operating on a block of data including its checksum. If the checksum is valid, <code class=Fn>LibAliasInternetChecksum</code>() will return zero.</p></div><p class=Pp><var class=Ft>int</var><code class=Fn>LibAliasUnaliasOut</code>(<var class=Fa>struct libalias *</var>, <var class=Fa>void *buffer</var>, <var class=Fa>int maxpacketsize</var>)</p><div class="Bd Pp Bd-indent">An outgoing packet, which has already been aliased, has its private address/port information restored by this function. The IP packet is pointed to by <var class=Fa>buffer</var>, and <var class=Fa>maxpacketsize</var> is provided for error checking purposes. This function can be used if an already-aliased packet needs to have its original IP header restored for further processing (e.g. logging).</div></section><section class=Sh><h2 class=Sh id=CONCEPTUAL_BACKGROUND><a class=permalink href=#CONCEPTUAL_BACKGROUND>CONCEPTUAL BACKGROUND</a></h2> This section is intended for those who are planning to modify the source code or want to create somewhat esoteric applications using the packet aliasing functions. <p class=Pp>The conceptual framework under which the packet aliasing engine operates is described here. Central to the discussion is the idea of an <i class=Em>aliasing link</i> which describes the relationship for a given packet transaction between the local machine, aliased identity and remote machine. It is discussed how such links come into existence and are destroyed.</p><section class=Ss><h2 class=Ss id=ALIASING_LINKS><a class=permalink href=#ALIASING_LINKS>ALIASING LINKS</a></h2> There is a notion of an <i class=Em>aliasing link</i>, which is a 7-tuple describing a specific translation: <div class="Bd Pp Bd-indent"><pre>
(local addr, local port, alias addr, alias port,
 remote addr, remote port, protocol)
</pre></div><p class=Pp>Outgoing packets have the local address and port number replaced with the alias address and port number. Incoming packets undergo the reverse process. The packet aliasing engine attempts to match packets against an internal table of aliasing links to determine how to modify a given IP packet. Both the IP header and protocol dependent headers are modified as necessary. Aliasing links are created and deleted as necessary according to network traffic.</p><p class=Pp>Protocols can be TCP, UDP or even ICMP in certain circumstances. (Some types of ICMP packets can be aliased according to sequence or ID number which acts as an equivalent port number for identifying how individual packets should be handled.)</p><p class=Pp>Each aliasing link must have a unique combination of the following five quantities: alias address/port, remote address/port and protocol. This ensures that several machines on a local network can share the same aliasing IP address. In cases where conflicts might arise, the aliasing port is chosen so that uniqueness is maintained.</p></section><section class=Ss><h2 class=Ss id=STATIC_AND_DYNAMIC_LINKS><a class=permalink href=#STATIC_AND_DYNAMIC_LINKS>STATIC AND DYNAMIC LINKS</a></h2> Aliasing links can either be static or dynamic. Static links persist indefinitely and represent fixed rules for translating IP packets. Dynamic links come into existence for a specific TCP connection or UDP transaction or ICMP ECHO sequence. For the case of TCP, the connection can be monitored to see when the associated aliasing link should be deleted. Aliasing links for UDP transactions (and ICMP ECHO and TIMESTAMP requests) work on a simple timeout rule. When no activity is observed on a dynamic link for a certain amount of time it is automatically deleted. Timeout rules also apply to TCP connections which do not open or close properly. </section><section class=Ss><h2 class=Ss id=PARTIALLY_SPECIFIED_ALIASING_LINKS><a class=permalink href=#PARTIALLY_SPECIFIED_ALIASING_LINKS>PARTIALLY SPECIFIED ALIASING LINKS</a></h2> Aliasing links can be partially specified, meaning that the remote address and/or remote port are unknown. In this case, when a packet matching the incomplete specification is found, a fully specified dynamic link is created. If the original partially specified link is dynamic, it will be deleted after the fully specified link is created, otherwise it will persist. <p class=Pp>For instance, a partially specified link might be</p><div class="Bd Pp Bd-indent"><pre>
(192.168.0.4, 23, 204.228.203.215, 8066, 0, 0, tcp)
</pre></div><p class=Pp>The zeros denote unspecified components for the remote address and port. If this link were static it would have the effect of redirecting all incoming traffic from port 8066 of 204.228.203.215 to port 23 (telnet) of machine 192.168.0.4 on the local network. Each individual telnet connection would initiate the creation of a distinct dynamic link.</p></section><section class=Ss><h2 class=Ss id=DYNAMIC_LINK_CREATION><a class=permalink href=#DYNAMIC_LINK_CREATION>DYNAMIC LINK CREATION</a></h2> In addition to aliasing links, there are also address mappings that can be stored within the internal data table of the packet aliasing mechanism. <div class="Bd Pp Bd-indent"><pre>
(local addr, alias addr)
</pre></div><p class=Pp>Address mappings are searched when creating new dynamic links.</p><p class=Pp>All outgoing packets from the local network automatically create a dynamic link if they do not match an already existing fully specified link. If an address mapping exists for the outgoing packet, this determines the alias address to be used. If no mapping exists, then a default address, usually the address of the packet aliasing host, is used. If necessary, this default address can be changed as often as each individual packet arrives.</p><p class=Pp>The aliasing port number is determined such that the new dynamic link does not conflict with any existing links. In the default operating mode, the packet aliasing engine attempts to set the aliasing port equal to the local port number. If this results in a conflict, then port numbers are randomly chosen until a unique aliasing link can be established. In an alternate operating mode, the first choice of an aliasing port is also random and unrelated to the local port number.</p></section></section><section class=Sh><h2 class=Sh>MODULAR ARCHITECTURE (AND <a class=Xr href=ipfw.4.html>ipfw(4)</a> SUPPORT)</h2> One of the latest improvements to <code class=Nm>libalias</code> was to make its support for new protocols independent from the rest of the library, giving it the ability to load/unload support for new protocols at run-time. To achieve this feature, all the code for protocol handling was moved to a series of modules outside of the main library. These modules are compiled from the same sources but work in different ways, depending on whether they are compiled to work inside a kernel or as part of the userland library. <section class=Ss><h2 class=Ss id=LIBALIAS_MODULES_IN_KERNEL_LAND><a class=permalink href=#LIBALIAS_MODULES_IN_KERNEL_LAND>LIBALIAS MODULES IN KERNEL LAND</a></h2> When compiled for the kernel, <code class=Nm>libalias</code> modules are plain KLDs recognizable with the <span class=Pa>alias_</span> prefix. <p class=Pp>To add support for a new protocol, load the corresponding module. For example:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>kldload alias_ftp</code></div><p class=Pp>When support for a protocol is no longer needed, its module can be unloaded:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>kldunload alias_ftp</code></div></section><section class=Ss><h2 class=Ss id=LIBALIAS_MODULES_IN_USERLAND><a class=permalink href=#LIBALIAS_MODULES_IN_USERLAND>LIBALIAS MODULES IN USERLAND</a></h2> Due to the differences between kernel and userland (no KLD mechanism, many different address spaces, etc.), we had to change a bit how to handle module loading/tracking/unloading in userland. <p class=Pp>While compiled for a userland <code class=Nm>libalias</code>, all the modules are plain libraries, residing in <span class=Pa>/usr/lib</span>, and recognizable with the <span class=Pa>libalias_</span> prefix.</p><p class=Pp>There is a configuration file, <span class=Pa>/etc/libalias.conf</span>, with the following contents (by default):</p><div class="Bd Pp Bd-indent"><pre>
/usr/lib/libalias_ftp.so
/usr/lib/libalias_irc.so
/usr/lib/libalias_nbt.so
/usr/lib/libalias_pptp.so
/usr/lib/libalias_skinny.so
/usr/lib/libalias_smedia.so
</pre></div><p class=Pp>This file contains the paths to the modules that <code class=Nm>libalias</code> will load. To load/unload a new module, just add its path to <span class=Pa>libalias.conf</span> and call <code class=Fn>LibAliasRefreshModules</code>() from the program. In case the application provides a <code class=Dv>SIGHUP</code> signal handler, add a call to <code class=Fn>LibAliasRefreshModules</code>() inside the handler, and every time you want to refresh the loaded modules, send it the <code class=Dv>SIGHUP</code> signal:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>kill -HUP &lt;process_pid&gt;</code></div></section><section class=Ss><h2 class=Ss id=MODULAR_ARCHITECURE:_HOW_IT_WORKS><a class=permalink href=#MODULAR_ARCHITECURE:_HOW_IT_WORKS>MODULAR ARCHITECURE: HOW IT WORKS</a></h2> The modular architecture of <code class=Nm>libalias</code> works similar whether it is running inside the kernel or in userland. From <span class=Pa>alias_mod.c</span>: <div class="Bd Pp"><pre>
/* Protocol and userland module handlers chains. */
LIST_HEAD(handler_chain, proto_handler) handler_chain ...
...
SLIST_HEAD(dll_chain, dll) dll_chain ...
</pre></div><p class=Pp><var class=Va>handler_chain</var> keeps track of all the protocol handlers loaded, while <var class=Va>ddl_chain</var> tracks which userland modules are loaded.</p><p class=Pp><var class=Va>handler_chain</var> is composed of <var class=Vt>struct proto_handler</var> entries:</p><div class="Bd Pp"><pre>
struct proto_handler {
	u_int pri;
	int16_t dir;
	uint8_t proto;
	int (*fingerprint)(struct libalias *la,
		 struct ip *pip, struct alias_data *ah);
	int (*protohandler)(struct libalias *la,
		 struct ip *pip, struct alias_data *ah);
	TAILQ_ENTRY(proto_handler) link;
};
</pre></div><p class=Pp>where:</p><dl class=Bl-inset><dt><var class=Va>pri</var></dt><dd>is the priority assigned to a protocol handler; lower priority is better.</dd><dt><var class=Va>dir</var></dt><dd>is the direction of packets: ingoing or outgoing.</dd><dt><var class=Va>proto</var></dt><dd>indicates to which protocol this packet belongs: IP, TCP or UDP.</dd><dt><var class=Va>fingerprint</var></dt><dd>points to the fingerprint function while protohandler points to the protocol handler function.</dd></dl><p class=Pp>The <var class=Va>fingerprint</var> function has the dual role of checking if the incoming packet is found, and if it belongs to any categories that this module can handle.</p><p class=Pp>The <var class=Va>protohandler</var> function actually manipulates the packet to make <code class=Nm>libalias</code> correctly NAT it.</p><p class=Pp>When a packet enters <code class=Nm>libalias</code>, if it meets a module hook, <var class=Va>handler_chain</var> is searched to see if there is an handler that matches this type of a packet (it checks protocol and direction of packet). Then, if more than one handler is found, it starts with the module with the lowest priority number: it calls the <var class=Va>fingerprint</var> function and interprets the result.</p><p class=Pp>If the result value is equal to 0 then it calls the protocol handler of this handler and returns. Otherwise, it proceeds to the next eligible module until the <var class=Va>handler_chain</var> is exhausted.</p><p class=Pp>Inside <code class=Nm>libalias</code>, the module hook looks like this:</p><div class="Bd Pp Bd-indent"><pre>
struct alias_data ad = {
	lnk,
	&amp;original_address,
	&amp;alias_address,
	&amp;alias_port,
	&amp;ud-&gt;uh_sport,          /* original source port */
	&amp;ud-&gt;uh_dport,		/* original dest port */
	256                     /* maxpacketsize */
};

...

/* walk out chain */
err = find_handler(IN, UDP, la, pip, &amp;ad);
</pre></div><p class=Pp>All data useful to a module are gathered together in an <var class=Vt>alias_data</var> structure, then <code class=Fn>find_handler</code>() is called. The <code class=Fn>find_handler</code>() function is responsible for walking the handler chain; it receives as input parameters:</p><dl class=Bl-tag><dt><var class=Fa>IN</var></dt><dd>direction</dd><dt><var class=Fa>UDP</var></dt><dd>working protocol</dd><dt><var class=Fa>la</var></dt><dd>pointer to this instance of libalias</dd><dt><var class=Fa>pip</var></dt><dd>pointer to a <var class=Vt>struct ip</var></dd><dt><var class=Fa>ad</var></dt><dd>pointer to <var class=Vt>struct alias_data</var> (see above)</dd></dl><p class=Pp>In this case, <code class=Fn>find_handler</code>() will search only for modules registered for supporting INcoming UDP packets.</p><p class=Pp>As was mentioned earlier, <code class=Nm>libalias</code> in userland is a bit different, as care must be taken in module handling as well (avoiding duplicate load of modules, avoiding modules with same name, etc.) so <var class=Va>dll_chain</var> was introduced.</p><p class=Pp><var class=Va>dll_chain</var> contains a list of all userland <code class=Nm>libalias</code> modules loaded.</p><p class=Pp>When an application calls <code class=Fn>LibAliasRefreshModules</code>(), <code class=Nm>libalias</code> first unloads all the loaded modules, then reloads all the modules listed in <span class=Pa>/etc/libalias.conf</span>: for every module loaded, a new entry is added to <var class=Va>dll_chain</var>.</p><p class=Pp><var class=Va>dll_chain</var> is composed of <var class=Vt>struct dll</var> entries:</p><div class="Bd Pp"><pre>
struct dll {
	/* name of module */
	char            name[DLL_LEN];
	/*
	 * ptr to shared obj obtained through
	 * dlopen() - use this ptr to get access
	 * to any symbols from a loaded module
	 * via dlsym()
	 */
	void            *handle;
	struct dll      *next;
};
</pre></div><dl class=Bl-inset><dt><var class=Va>name</var></dt><dd>is the name of the module.</dd><dt><var class=Va>handle</var></dt><dd>is a pointer to the module obtained through <a class=Xr href=dlopen.3.html>dlopen(3)</a>.</dd></dl> Whenever a module is loaded in userland, an entry is added to <var class=Va>dll_chain</var>, then every protocol handler present in that module is resolved and registered in <var class=Va>handler_chain</var>. </section><section class=Ss><h2 class=Ss id=HOW_TO_WRITE_A_MODULE_FOR_LIBALIAS><a class=permalink href=#HOW_TO_WRITE_A_MODULE_FOR_LIBALIAS>HOW TO WRITE A MODULE FOR LIBALIAS</a></h2> There is a module (called <span class=Pa>alias_dummy.[ch]</span>) in <code class=Nm>libalias</code> that can be used as a skeleton for future work. Here we analyse some parts of that module. From <span class=Pa>alias_dummy.c</span>: <div class="Bd Pp"><pre>
struct proto_handler handlers[] = {
    {
	.pri = 666,
	.dir = IN|OUT,
	.proto = UDP|TCP,
	.fingerprint = fingerprint,
	.protohandler= protohandler,
    },
    { EOH }
};
</pre></div><p class=Pp>The variable <var class=Va>handlers</var> is the “most important thing” in a module since it describes the handlers present and lets the outside world use it in an opaque way.</p><p class=Pp>It must ALWAYS be present in every module, and it MUST retain the name <var class=Va>handlers</var>, otherwise attempting to load a module in userland will fail and complain about missing symbols: for more information about module load/unload, please refer to <code class=Fn>LibAliasRefreshModules</code>(), <code class=Fn>LibAliasLoadModule</code>() and <code class=Fn>LibAliasUnloadModule</code>() in <span class=Pa>alias.c</span>.</p><p class=Pp><var class=Va>handlers</var> contains all the <var class=Vt>proto_handler</var> structures present in a module.</p><div class="Bd Pp"><pre>
static int
mod_handler(module_t mod, int type, void *data)
{
	int error;

	switch (type) {
	case MOD_LOAD:
		error = LibAliasAttachHandlers(handlers);
		break;
	case MOD_UNLOAD:
		error = LibAliasDetachHandlers(handlers);
		break;
	default:
		error = EINVAL;
	}
	return (error);
}
</pre></div> When running as KLD, <code class=Fn>mod_handler</code>() registers/deregisters the module using <code class=Fn>LibAliasAttachHandlers</code>() and <code class=Fn>LibAliasDetachHandlers</code>(), respectively. <p class=Pp>Every module must contain at least 2 functions: one fingerprint function and a protocol handler function.</p><div class="Bd Pp"><pre>
#ifdef _KERNEL
static
#endif
int
fingerprint(struct libalias *la, struct ip *pip, struct alias_data *ah)
{

...
}

#ifdef _KERNEL
static
#endif
int
protohandler(struct libalias *la, struct ip *pip,
             struct alias_data *ah)
{

...
}
</pre></div> and they must accept exactly these input parameters. </section><section class=Ss><h2 class=Ss id=PATCHING_AN_APPLICATION_FOR_USERLAND_LIBALIAS_MODULES><a class=permalink href=#PATCHING_AN_APPLICATION_FOR_USERLAND_LIBALIAS_MODULES>PATCHING AN APPLICATION FOR USERLAND LIBALIAS MODULES</a></h2> To add module support into an application that uses <code class=Nm>libalias</code>, the following simple steps can be followed. <ol class=Bl-enum><li>Find the main file of an application (let us call it <span class=Pa>main.c</span>).</li><li>Add this to the header section of <span class=Pa>main.c</span>, if not already present: <p class=Pp></p><div class="Bd Bd-indent"><code class=Li>#include &lt;signal.h&gt;</code></div><p class=Pp>and this just after the header section:</p><p class=Pp></p><div class="Bd Bd-indent"><code class=Li>static void signal_handler(int);</code></div></li><li>Add the following line to the init function of an application or, if it does not have any init function, put it in <code class=Fn>main</code>(): <p class=Pp></p><div class="Bd Bd-indent"><code class=Li>signal(SIGHUP, signal_handler);</code></div><p class=Pp>and place the <code class=Fn>signal_handler</code>() function somewhere in <span class=Pa>main.c</span>:</p><div class="Bd Pp Bd-indent"><pre>
static void
signal_handler(int sig)
{

	LibAliasRefreshModules();
}
    </pre></div><p class=Pp>Otherwise, if an application already traps the <code class=Dv>SIGHUP</code> signal, just add a call to <code class=Fn>LibAliasRefreshModules</code>() in the signal handler function.</p></li></ol> For example, to patch <a class=Xr href=natd.8.html>natd(8)</a> to use <code class=Nm>libalias</code> modules, just add the following line to <code class=Fn>RefreshAddr</code>(<var class=Fa>int sig __unused</var>): <p class=Pp></p><div class="Bd Bd-indent"><code class=Li>LibAliasRefreshModules()</code></div><p class=Pp>recompile and you are done.</p></section><section class=Ss><h2 class=Ss id=LOGGING_SUPPORT_IN_KERNEL_LAND><a class=permalink href=#LOGGING_SUPPORT_IN_KERNEL_LAND>LOGGING SUPPORT IN KERNEL LAND</a></h2> When working as KLD, <code class=Nm>libalias</code> now has log support that happens on a buffer allocated inside <var class=Vt>struct libalias</var> (from <span class=Pa>alias_local.h</span>): <div class="Bd Pp"><pre>
struct libalias {
       ...

	/* log descriptor        */
#ifdef	KERNEL_LOG
	char           *logDesc;        /*
					 * ptr to an auto-malloced
					 * memory buffer when libalias
					 * works as kld
					 */
#else
	FILE           *logDesc;	/*
					 * ptr to /var/log/alias.log
					 * when libalias runs as a
					 * userland lib
					 */
#endif

	...
}
</pre></div> so all applications using <code class=Nm>libalias</code> will be able to handle their own logs, if they want, accessing <var class=Va>logDesc</var>. Moreover, every change to a log buffer is automatically added to <a class=Xr href=syslog.3.html>syslog(3)</a> with the <code class=Dv>LOG_SECURITY</code> facility and the <code class=Dv>LOG_INFO</code> level. </section></section><section class=Sh><h2 class=Sh id=AUTHORS><a class=permalink href=#AUTHORS>AUTHORS</a></h2><span class=An>Charles Mott</span> ⟨cm@linktel.net⟩, versions 1.0 - 1.8, 2.0 - 2.4. <br><span class=An>Eivind Eklund</span> ⟨eivind@FreeBSD.org⟩, versions 1.8b, 1.9 and 2.5. Added IRC DCC support as well as contributing a number of architectural improvements; added the firewall bypass for FTP/IRC DCC. <br><span class=An>Erik Salander</span> ⟨erik@whistle.com⟩ added support for PPTP and RTSP. <br><span class=An>Junichi Satoh</span> ⟨junichi@junichi.org⟩ added support for RTSP/PNA. <br><span class=An>Ruslan Ermilov</span> ⟨ru@FreeBSD.org⟩ added support for PPTP and LSNAT as well as general hacking. <br><span class=An>Gleb Smirnoff</span> ⟨glebius@FreeBSD.org⟩ ported the library to kernel space. <br><span class=An>Paolo Pisati</span> ⟨piso@FreeBSD.org⟩ made the library modular, moving support for all protocols (except for IP, TCP and UDP) to external modules. </section><section class=Sh><h2 class=Sh id=ACKNOWLEDGEMENTS><a class=permalink href=#ACKNOWLEDGEMENTS>ACKNOWLEDGEMENTS</a></h2> Listed below, in approximate chronological order, are individuals who have provided valuable comments and/or debugging assistance. <div class="Bd Pp Bd-indent"><br><span class=An>Gary Roberts</span><br><span class=An>Tom Torrance</span><br><span class=An>Reto Burkhalter</span><br><span class=An>Martin Renters</span><br><span class=An>Brian Somers</span><br><span class=An>Paul Traina</span><br><span class=An>Ari Suutari</span><br><span class=An>Dave Remien</span><br><span class=An>J. Fortes</span><br><span class=An>Andrzej Bialecki</span><br><span class=An>Gordon Burditt</span></div></section></div><table class=foot><tr><td class=foot-date>May 31, 2021</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>