<!DOCTYPE html>
<html><head><meta charset=utf-8><title>callout_schedule_on(9)</title><keywords content=man,callout_schedule_on></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>callout_schedule_on(9)</h1><table class=head><tr><td class=head-ltitle>TIMEOUT(9)</td><td class=head-vol>FreeBSD Kernel Developer's Manual</td><td class=head-rtitle>TIMEOUT(9)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>callout_active</code>, <code class=Nm>callout_deactivate</code>, <code class=Nm>callout_async_drain</code>, <code class=Nm>callout_drain</code>, <code class=Nm>callout_handle_init</code>, <code class=Nm>callout_init</code>, <code class=Nm>callout_init_mtx</code>, <code class=Nm>callout_init_rm</code>, <code class=Nm>callout_init_rw</code>, <code class=Nm>callout_pending</code>, <code class=Nm>callout_reset</code>, <code class=Nm>callout_reset_curcpu</code>, <code class=Nm>callout_reset_on</code>, <code class=Nm>callout_reset_sbt</code>, <code class=Nm>callout_reset_sbt_curcpu</code>, <code class=Nm>callout_reset_sbt_on</code>, <code class=Nm>callout_schedule</code>, <code class=Nm>callout_schedule_curcpu</code>, <code class=Nm>callout_schedule_on</code>, <code class=Nm>callout_schedule_sbt</code>, <code class=Nm>callout_schedule_sbt_curcpu</code>, <code class=Nm>callout_schedule_sbt_on</code>, <code class=Nm>callout_stop</code>, <code class=Nm>callout_when</code>, <code class=Nm>timeout</code>, <code class=Nm>untimeout</code> — <div class=Nd>execute a function after a specified length of time</div></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/sys/types.h.html>sys/types.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/sys/callout.h.html>sys/callout.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/sys/systm.h.html>sys/systm.h</a>&gt;</code><div class="Bd Pp"><pre>
typedef void callout_func_t (void *);
typedef void timeout_t (void *);
</pre></div><br><var class=Ft>int</var><br><code class=Fn>callout_active</code>(<var class=Fa style="white-space: nowrap;">struct callout *c</var>); <p class=Pp><var class=Ft>void</var><br><code class=Fn>callout_deactivate</code>(<var class=Fa style="white-space: nowrap;">struct callout *c</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>callout_async_drain</code>(<var class=Fa style="white-space: nowrap;">struct callout *c</var>, <var class=Fa style="white-space: nowrap;">callout_func_t *drain</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>callout_drain</code>(<var class=Fa style="white-space: nowrap;">struct callout *c</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>callout_handle_init</code>(<var class=Fa style="white-space: nowrap;">struct callout_handle *handle</var>);</p><div class="Bd Pp"><pre>
struct callout_handle handle = CALLOUT_HANDLE_INITIALIZER(&amp;handle);
</pre></div><br><var class=Ft>void</var><br><code class=Fn>callout_init</code>(<var class=Fa style="white-space: nowrap;">struct callout *c</var>, <var class=Fa style="white-space: nowrap;">int mpsafe</var>); <p class=Pp><var class=Ft>void</var><br><code class=Fn>callout_init_mtx</code>(<var class=Fa style="white-space: nowrap;">struct callout *c</var>, <var class=Fa style="white-space: nowrap;">struct mtx *mtx</var>, <var class=Fa style="white-space: nowrap;">int flags</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>callout_init_rm</code>(<var class=Fa style="white-space: nowrap;">struct callout *c</var>, <var class=Fa style="white-space: nowrap;">struct rmlock *rm</var>, <var class=Fa style="white-space: nowrap;">int flags</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>callout_init_rw</code>(<var class=Fa style="white-space: nowrap;">struct callout *c</var>, <var class=Fa style="white-space: nowrap;">struct rwlock *rw</var>, <var class=Fa style="white-space: nowrap;">int flags</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>callout_pending</code>(<var class=Fa style="white-space: nowrap;">struct callout *c</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>callout_reset</code>(<var class=Fa>struct callout *c</var>, <var class=Fa>int ticks</var>, <var class=Fa>callout_func_t *func</var>, <var class=Fa>void *arg</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>callout_reset_curcpu</code>(<var class=Fa>struct callout *c</var>, <var class=Fa>int ticks</var>, <var class=Fa>callout_func_t *func</var>, <var class=Fa>void *arg</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>callout_reset_on</code>(<var class=Fa>struct callout *c</var>, <var class=Fa>int ticks</var>, <var class=Fa>callout_func_t *func</var>, <var class=Fa>void *arg</var>, <var class=Fa>int cpu</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>callout_reset_sbt</code>(<var class=Fa>struct callout *c</var>, <var class=Fa>sbintime_t sbt</var>, <var class=Fa>sbintime_t pr</var>, <var class=Fa>callout_func_t *func</var>, <var class=Fa>void *arg</var>, <var class=Fa>int flags</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>callout_reset_sbt_curcpu</code>(<var class=Fa>struct callout *c</var>, <var class=Fa>sbintime_t sbt</var>, <var class=Fa>sbintime_t pr</var>, <var class=Fa>callout_func_t *func</var>, <var class=Fa>void *arg</var>, <var class=Fa>int flags</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>callout_reset_sbt_on</code>(<var class=Fa>struct callout *c</var>, <var class=Fa>sbintime_t sbt</var>, <var class=Fa>sbintime_t pr</var>, <var class=Fa>callout_func_t *func</var>, <var class=Fa>void *arg</var>, <var class=Fa>int cpu</var>, <var class=Fa>int flags</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>callout_schedule</code>(<var class=Fa style="white-space: nowrap;">struct callout *c</var>, <var class=Fa style="white-space: nowrap;">int ticks</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>callout_schedule_curcpu</code>(<var class=Fa style="white-space: nowrap;">struct callout *c</var>, <var class=Fa style="white-space: nowrap;">int ticks</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>callout_schedule_on</code>(<var class=Fa style="white-space: nowrap;">struct callout *c</var>, <var class=Fa style="white-space: nowrap;">int ticks</var>, <var class=Fa style="white-space: nowrap;">int cpu</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>callout_schedule_sbt</code>(<var class=Fa>struct callout *c</var>, <var class=Fa>sbintime_t sbt</var>, <var class=Fa>sbintime_t pr</var>, <var class=Fa>int flags</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>callout_schedule_sbt_curcpu</code>(<var class=Fa>struct callout *c</var>, <var class=Fa>sbintime_t sbt</var>, <var class=Fa>sbintime_t pr</var>, <var class=Fa>int flags</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>callout_schedule_sbt_on</code>(<var class=Fa>struct callout *c</var>, <var class=Fa>sbintime_t sbt</var>, <var class=Fa>sbintime_t pr</var>, <var class=Fa>int cpu</var>, <var class=Fa>int flags</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>callout_stop</code>(<var class=Fa style="white-space: nowrap;">struct callout *c</var>);</p><p class=Pp><var class=Ft>sbintime_t</var><br><code class=Fn>callout_when</code>(<var class=Fa>sbintime_t sbt</var>, <var class=Fa>sbintime_t precision</var>, <var class=Fa>int flags</var>, <var class=Fa>sbintime_t *sbt_res</var>, <var class=Fa>sbintime_t *precision_res</var>);</p><p class=Pp><var class=Ft>struct callout_handle</var><br><code class=Fn>timeout</code>(<var class=Fa style="white-space: nowrap;">timeout_t *func</var>, <var class=Fa style="white-space: nowrap;">void *arg</var>, <var class=Fa style="white-space: nowrap;">int ticks</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>untimeout</code>(<var class=Fa style="white-space: nowrap;">timeout_t *func</var>, <var class=Fa style="white-space: nowrap;">void *arg</var>, <var class=Fa style="white-space: nowrap;">struct callout_handle handle</var>);</p></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> The <code class=Nm>callout</code> API is used to schedule a call to an arbitrary function at a specific time in the future. Consumers of this API are required to allocate a callout structure (struct callout) for each pending function invocation. This structure stores state about the pending function invocation including the function to be called and the time at which the function should be invoked. Pending function calls can be cancelled or rescheduled to a different time. In addition, a callout structure may be reused to schedule a new function call after a scheduled call is completed. <p class=Pp>Callouts only provide a single-shot mode. If a consumer requires a periodic timer, it must explicitly reschedule each function call. This is normally done by rescheduling the subsequent call within the called function.</p><p class=Pp>Callout functions must not sleep. They may not acquire sleepable locks, wait on condition variables, perform blocking allocation requests, or invoke any other action that might sleep.</p><p class=Pp>Each callout structure must be initialized by <code class=Fn>callout_init</code>(), <code class=Fn>callout_init_mtx</code>(), <code class=Fn>callout_init_rm</code>(), or <code class=Fn>callout_init_rw</code>() before it is passed to any of the other callout functions. The <code class=Fn>callout_init</code>() function initializes a callout structure in <var class=Fa>c</var> that is not associated with a specific lock. If the <var class=Fa>mpsafe</var> argument is zero, the callout structure is not considered to be “multi-processor safe”; and the Giant lock will be acquired before calling the callout function and released when the callout function returns.</p><p class=Pp>The <code class=Fn>callout_init_mtx</code>(), <code class=Fn>callout_init_rm</code>(), and <code class=Fn>callout_init_rw</code>() functions initialize a callout structure in <var class=Fa>c</var> that is associated with a specific lock. The lock is specified by the <var class=Fa>mtx</var>, <var class=Fa>rm</var>, or <var class=Fa>rw</var> parameter. The associated lock must be held while stopping or rescheduling the callout. The callout subsystem acquires the associated lock before calling the callout function and releases it after the function returns. If the callout was cancelled while the callout subsystem waited for the associated lock, the callout function is not called, and the associated lock is released. This ensures that stopping or rescheduling the callout will abort any previously scheduled invocation.</p><p class=Pp>Only regular mutexes may be used with <code class=Fn>callout_init_mtx</code>(); spin mutexes are not supported. A sleepable read-mostly lock (one initialized with the <code class=Dv>RM_SLEEPABLE</code> flag) may not be used with <code class=Fn>callout_init_rm</code>(). Similarly, other sleepable lock types such as <a class=Xr href=sx.9.html>sx(9)</a> and <a class=Xr href=lockmgr.9.html>lockmgr(9)</a> cannot be used with callouts because sleeping is not permitted in the callout subsystem.</p><p class=Pp>These <var class=Fa>flags</var> may be specified for <code class=Fn>callout_init_mtx</code>(), <code class=Fn>callout_init_rm</code>(), or <code class=Fn>callout_init_rw</code>():</p><dl class=Bl-tag><dt><a class=permalink href=#CALLOUT_RETURNUNLOCKED><code class=Dv id=CALLOUT_RETURNUNLOCKED>CALLOUT_RETURNUNLOCKED</code></a></dt><dd>The callout function will release the associated lock itself, so the callout subsystem should not attempt to unlock it after the callout function returns.</dd><dt><a class=permalink href=#CALLOUT_SHAREDLOCK><code class=Dv id=CALLOUT_SHAREDLOCK>CALLOUT_SHAREDLOCK</code></a></dt><dd>The lock is only acquired in read mode when running the callout handler. This flag is ignored by <code class=Fn>callout_init_mtx</code>().</dd></dl><p class=Pp>The function <code class=Fn>callout_stop</code>() cancels a callout <var class=Fa>c</var> if it is currently pending. If the callout is pending and successfully stopped, then <code class=Fn>callout_stop</code>() returns a value of one. If the callout is not set, or has already been serviced, then negative one is returned. If the callout is currently being serviced and cannot be stopped, then zero will be returned. If the callout is currently being serviced and cannot be stopped, and at the same time a next invocation of the same callout is also scheduled, then <code class=Fn>callout_stop</code>() unschedules the next run and returns zero. If the callout has an associated lock, then that lock must be held when this function is called.</p><p class=Pp>The function <code class=Fn>callout_async_drain</code>() is identical to <code class=Fn>callout_stop</code>() with one difference. When <code class=Fn>callout_async_drain</code>() returns zero it will arrange for the function <var class=Fa>drain</var> to be called using the same argument given to the <code class=Fn>callout_reset</code>() function. <code class=Fn>callout_async_drain</code>() If the callout has an associated lock, then that lock must be held when this function is called. Note that when stopping multiple callouts that use the same lock it is possible to get multiple return's of zero and multiple calls to the <var class=Fa>drain</var> function, depending upon which CPU's the callouts are running. The <var class=Fa>drain</var> function itself is called from the context of the completing callout i.e. softclock or hardclock, just like a callout itself.</p><p class=Pp>The function <code class=Fn>callout_drain</code>() is identical to <code class=Fn>callout_stop</code>() except that it will wait for the callout <var class=Fa>c</var> to complete if it is already in progress. This function MUST NOT be called while holding any locks on which the callout might block, or deadlock will result. Note that if the callout subsystem has already begun processing this callout, then the callout function may be invoked before <code class=Fn>callout_drain</code>() returns. However, the callout subsystem does guarantee that the callout will be fully stopped before <code class=Fn>callout_drain</code>() returns.</p><p class=Pp>The <code class=Fn>callout_reset</code>() and <code class=Fn>callout_schedule</code>() function families schedule a future function invocation for callout <var class=Fa>c</var>. If <var class=Fa>c</var> already has a pending callout, it is cancelled before the new invocation is scheduled. These functions return a value of one if a pending callout was cancelled and zero if there was no pending callout. If the callout has an associated lock, then that lock must be held when any of these functions are called.</p><p class=Pp>The time at which the callout function will be invoked is determined by either the <var class=Fa>ticks</var> argument or the <var class=Fa>sbt</var>, <var class=Fa>pr</var>, and <var class=Fa>flags</var> arguments. When <var class=Fa>ticks</var> is used, the callout is scheduled to execute after <var class=Fa>ticks</var><span class=No>/hz</span> seconds. Non-positive values of <var class=Fa>ticks</var> are silently converted to the value ‘1’.</p><p class=Pp>The <var class=Fa>sbt</var>, <var class=Fa>pr</var>, and <var class=Fa>flags</var> arguments provide more control over the scheduled time including support for higher resolution times, specifying the precision of the scheduled time, and setting an absolute deadline instead of a relative timeout. The callout is scheduled to execute in a time window which begins at the time specified in <var class=Fa>sbt</var> and extends for the amount of time specified in <var class=Fa>pr</var>. If <var class=Fa>sbt</var> specifies a time in the past, the window is adjusted to start at the current time. A non-zero value for <var class=Fa>pr</var> allows the callout subsystem to coalesce callouts scheduled close to each other into fewer timer interrupts, reducing processing overhead and power consumption. These <var class=Fa>flags</var> may be specified to adjust the interpretation of <var class=Fa>sbt</var> and <var class=Fa>pr</var>:</p><dl class=Bl-tag><dt><a class=permalink href=#C_ABSOLUTE><code class=Dv id=C_ABSOLUTE>C_ABSOLUTE</code></a></dt><dd>Handle the <var class=Fa>sbt</var> argument as an absolute time since boot. By default, <var class=Fa>sbt</var> is treated as a relative amount of time, similar to <var class=Fa>ticks</var>.</dd><dt><a class=permalink href=#C_DIRECT_EXEC><code class=Dv id=C_DIRECT_EXEC>C_DIRECT_EXEC</code></a></dt><dd>Run the handler directly from hardware interrupt context instead of from the softclock thread. This reduces latency and overhead, but puts more constraints on the callout function. Callout functions run in this context may use only spin mutexes for locking and should be as small as possible because they run with absolute priority.</dd><dt><code class=Fn>C_PREL</code>()</dt><dd>Specifies relative event time precision as binary logarithm of time interval divided by acceptable time deviation: 1 -- 1/2, 2 -- 1/4, etc. Note that the larger of <var class=Fa>pr</var> or this value is used as the length of the time window. Smaller values (which result in larger time intervals) allow the callout subsystem to aggregate more events in one timer interrupt.</dd><dt><a class=permalink href=#C_PRECALC><code class=Dv id=C_PRECALC>C_PRECALC</code></a></dt><dd>The <var class=Fa>sbt</var> argument specifies the absolute time at which the callout should be run, and the <var class=Fa>pr</var> argument specifies the requested precision, which will not be adjusted during the scheduling process. The <var class=Fa>sbt</var> and <var class=Fa>pr</var> values should be calculated by an earlier call to <code class=Fn>callout_when</code>() which uses the user-supplied <var class=Fa>sbt</var>, <var class=Fa>pr</var>, and <var class=Fa>flags</var> values.</dd><dt><a class=permalink href=#C_HARDCLOCK><code class=Dv id=C_HARDCLOCK>C_HARDCLOCK</code></a></dt><dd>Align the timeouts to <code class=Fn>hardclock</code>() calls if possible.</dd></dl><p class=Pp>The <code class=Fn>callout_reset</code>() functions accept a <var class=Fa>func</var> argument which identifies the function to be called when the time expires. It must be a pointer to a function that takes a single <var class=Fa>void *</var> argument. Upon invocation, <var class=Fa>func</var> will receive <var class=Fa>arg</var> as its only argument. The <code class=Fn>callout_schedule</code>() functions reuse the <var class=Fa>func</var> and <var class=Fa>arg</var> arguments from the previous callout. Note that one of the <code class=Fn>callout_reset</code>() functions must always be called to initialize <var class=Fa>func</var> and <var class=Fa>arg</var> before one of the <code class=Fn>callout_schedule</code>() functions can be used.</p><p class=Pp>The callout subsystem provides a softclock thread for each CPU in the system. Callouts are assigned to a single CPU and are executed by the softclock thread for that CPU. Initially, callouts are assigned to CPU 0. The <code class=Fn>callout_reset_on</code>(), <code class=Fn>callout_reset_sbt_on</code>(), <code class=Fn>callout_schedule_on</code>() and <code class=Fn>callout_schedule_sbt_on</code>() functions assign the callout to CPU <var class=Fa>cpu</var>. The <code class=Fn>callout_reset_curcpu</code>(), <code class=Fn>callout_reset_sbt_curpu</code>(), <code class=Fn>callout_schedule_curcpu</code>() and <code class=Fn>callout_schedule_sbt_curcpu</code>() functions assign the callout to the current CPU. The <code class=Fn>callout_reset</code>(), <code class=Fn>callout_reset_sbt</code>(), <code class=Fn>callout_schedule</code>() and <code class=Fn>callout_schedule_sbt</code>() functions schedule the callout to execute in the softclock thread of the CPU to which it is currently assigned.</p><p class=Pp>Softclock threads are not pinned to their respective CPUs by default. The softclock thread for CPU 0 can be pinned to CPU 0 by setting the <var class=Va>kern.pin_default_swi</var> loader tunable to a non-zero value. Softclock threads for CPUs other than zero can be pinned to their respective CPUs by setting the <var class=Va>kern.pin_pcpu_swi</var> loader tunable to a non-zero value.</p><p class=Pp>The macros <code class=Fn>callout_pending</code>(), <code class=Fn>callout_active</code>() and <code class=Fn>callout_deactivate</code>() provide access to the current state of the callout. The <code class=Fn>callout_pending</code>() macro checks whether a callout is <i class=Em>pending</i>; a callout is considered <i class=Em>pending</i> when a timeout has been set but the time has not yet arrived. Note that once the timeout time arrives and the callout subsystem starts to process this callout, <code class=Fn>callout_pending</code>() will return <code class=Dv>FALSE</code> even though the callout function may not have finished (or even begun) executing. The <code class=Fn>callout_active</code>() macro checks whether a callout is marked as <i class=Em>active</i>, and the <code class=Fn>callout_deactivate</code>() macro clears the callout's <i class=Em>active</i> flag. The callout subsystem marks a callout as <i class=Em>active</i> when a timeout is set and it clears the <i class=Em>active</i> flag in <code class=Fn>callout_stop</code>() and <code class=Fn>callout_drain</code>(), but it <i class=Em>does not</i> clear it when a callout expires normally via the execution of the callout function.</p><p class=Pp>The <code class=Fn>callout_when</code>() function may be used to pre-calculate the absolute time at which the timeout should be run and the precision of the scheduled run time according to the required time <var class=Fa>sbt</var>, precision <var class=Fa>precision</var>, and additional adjustments requested by the <var class=Fa>flags</var> argument. Flags accepted by the <code class=Fn>callout_when</code>() function are the same as flags for the <code class=Fn>callout_reset</code>() function. The resulting time is assigned to the variable pointed to by the <var class=Fa>sbt_res</var> argument, and the resulting precision is assigned to <var class=Fa>*precision_res</var>. When passing the results to <var class=Fa>callout_reset</var>, add the <var class=Va>C_PRECALC</var> flag to <var class=Fa>flags</var>, to avoid incorrect re-adjustment. The function is intended for situations where precise time of the callout run should be known in advance, since trying to read this time from the callout structure itself after a <code class=Fn>callout_reset</code>() call is racy.</p><section class=Ss><h2 class=Ss id=Avoiding_Race_Conditions><a class=permalink href=#Avoiding_Race_Conditions>Avoiding Race Conditions</a></h2> The callout subsystem invokes callout functions from its own thread context. Without some kind of synchronization, it is possible that a callout function will be invoked concurrently with an attempt to stop or reset the callout by another thread. In particular, since callout functions typically acquire a lock as their first action, the callout function may have already been invoked, but is blocked waiting for that lock at the time that another thread tries to reset or stop the callout. <p class=Pp>There are three main techniques for addressing these synchronization concerns. The first approach is preferred as it is the simplest:</p><ol class="Bl-enum Bd-indent"><li>Callouts can be associated with a specific lock when they are initialized by <code class=Fn>callout_init_mtx</code>(), <code class=Fn>callout_init_rm</code>(), or <code class=Fn>callout_init_rw</code>(). When a callout is associated with a lock, the callout subsystem acquires the lock before the callout function is invoked. This allows the callout subsystem to transparently handle races between callout cancellation, scheduling, and execution. Note that the associated lock must be acquired before calling <code class=Fn>callout_stop</code>() or one of the <code class=Fn>callout_reset</code>() or <code class=Fn>callout_schedule</code>() functions to provide this safety. <p class=Pp>A callout initialized via <code class=Fn>callout_init</code>() with <var class=Fa>mpsafe</var> set to zero is implicitly associated with the <var class=Va>Giant</var> mutex. If <var class=Va>Giant</var> is held when cancelling or rescheduling the callout, then its use will prevent races with the callout function.</p></li><li>The return value from <code class=Fn>callout_stop</code>() (or the <code class=Fn>callout_reset</code>() and <code class=Fn>callout_schedule</code>() function families) indicates whether or not the callout was removed. If it is known that the callout was set and the callout function has not yet executed, then a return value of <code class=Dv>FALSE</code> indicates that the callout function is about to be called. For example: <div class="Bd Pp Bd-indent"><pre>
if (sc-&gt;sc_flags &amp; SCFLG_CALLOUT_RUNNING) {
	if (callout_stop(&amp;sc-&gt;sc_callout)) {
		sc-&gt;sc_flags &amp;= ~SCFLG_CALLOUT_RUNNING;
		/* successfully stopped */
	} else {
		/*
		 * callout has expired and callout
		 * function is about to be executed
		 */
	}
}
    </pre></div></li><li>The <code class=Fn>callout_pending</code>(), <code class=Fn>callout_active</code>() and <code class=Fn>callout_deactivate</code>() macros can be used together to work around the race conditions. When a callout's timeout is set, the callout subsystem marks the callout as both <i class=Em>active</i> and <i class=Em>pending</i>. When the timeout time arrives, the callout subsystem begins processing the callout by first clearing the <i class=Em>pending</i> flag. It then invokes the callout function without changing the <i class=Em>active</i> flag, and does not clear the <i class=Em>active</i> flag even after the callout function returns. The mechanism described here requires the callout function itself to clear the <i class=Em>active</i> flag using the <code class=Fn>callout_deactivate</code>() macro. The <code class=Fn>callout_stop</code>() and <code class=Fn>callout_drain</code>() functions always clear both the <i class=Em>active</i> and <i class=Em>pending</i> flags before returning. <p class=Pp>The callout function should first check the <i class=Em>pending</i> flag and return without action if <code class=Fn>callout_pending</code>() returns <code class=Dv>TRUE</code>. This indicates that the callout was rescheduled using <code class=Fn>callout_reset</code>() just before the callout function was invoked. If <code class=Fn>callout_active</code>() returns <code class=Dv>FALSE</code> then the callout function should also return without action. This indicates that the callout has been stopped. Finally, the callout function should call <code class=Fn>callout_deactivate</code>() to clear the <i class=Em>active</i> flag. For example:</p><div class="Bd Pp Bd-indent"><pre>
mtx_lock(&amp;sc-&gt;sc_mtx);
if (callout_pending(&amp;sc-&gt;sc_callout)) {
	/* callout was reset */
	mtx_unlock(&amp;sc-&gt;sc_mtx);
	return;
}
if (!callout_active(&amp;sc-&gt;sc_callout)) {
	/* callout was stopped */
	mtx_unlock(&amp;sc-&gt;sc_mtx);
	return;
}
callout_deactivate(&amp;sc-&gt;sc_callout);
/* rest of callout function */
    </pre></div><p class=Pp>Together with appropriate synchronization, such as the mutex used above, this approach permits the <code class=Fn>callout_stop</code>() and <code class=Fn>callout_reset</code>() functions to be used at any time without races. For example:</p><div class="Bd Pp Bd-indent"><pre>
mtx_lock(&amp;sc-&gt;sc_mtx);
callout_stop(&amp;sc-&gt;sc_callout);
/* The callout is effectively stopped now. */
    </pre></div><p class=Pp>If the callout is still pending then these functions operate normally, but if processing of the callout has already begun then the tests in the callout function cause it to return without further action. Synchronization between the callout function and other code ensures that stopping or resetting the callout will never be attempted while the callout function is past the <code class=Fn>callout_deactivate</code>() call.</p><p class=Pp>The above technique additionally ensures that the <i class=Em>active</i> flag always reflects whether the callout is effectively enabled or disabled. If <code class=Fn>callout_active</code>() returns false, then the callout is effectively disabled, since even if the callout subsystem is actually just about to invoke the callout function, the callout function will return without action.</p></li></ol><p class=Pp>There is one final race condition that must be considered when a callout is being stopped for the last time. In this case it may not be safe to let the callout function itself detect that the callout was stopped, since it may need to access data objects that have already been destroyed or recycled. To ensure that the callout is completely finished, a call to <code class=Fn>callout_drain</code>() should be used. In particular, a callout should always be drained prior to destroying its associated lock or releasing the storage for the callout structure.</p></section></section><section class=Sh><h2 class=Sh id=LEGACY_API><a class=permalink href=#LEGACY_API>LEGACY API</a></h2><div class="Bf Sy">The functions below are a legacy API that will be removed in a future release. New code should not use these routines.</div><p class=Pp>The function <code class=Fn>timeout</code>() schedules a call to the function given by the argument <var class=Fa>func</var> to take place after <var class=Fa>ticks</var><span class=No>/hz</span> seconds. Non-positive values of <var class=Fa>ticks</var> are silently converted to the value ‘1’. <var class=Fa>func</var> should be a pointer to a function that takes a <var class=Fa>void *</var> argument. Upon invocation, <var class=Fa>func</var> will receive <var class=Fa>arg</var> as its only argument. The return value from <code class=Fn>timeout</code>() is a <var class=Ft>struct callout_handle</var> which can be used in conjunction with the <code class=Fn>untimeout</code>() function to request that a scheduled timeout be canceled.</p><p class=Pp>The function <code class=Fn>callout_handle_init</code>() can be used to initialize a handle to a state which will cause any calls to <code class=Fn>untimeout</code>() with that handle to return with no side effects.</p><p class=Pp>Assigning a callout handle the value of <code class=Fn>CALLOUT_HANDLE_INITIALIZER</code>() performs the same function as <code class=Fn>callout_handle_init</code>() and is provided for use on statically declared or global callout handles.</p><p class=Pp>The function <code class=Fn>untimeout</code>() cancels the timeout associated with <var class=Fa>handle</var> using the <var class=Fa>func</var> and <var class=Fa>arg</var> arguments to validate the handle. If the handle does not correspond to a timeout with the function <var class=Fa>func</var> taking the argument <var class=Fa>arg</var> no action is taken. <var class=Fa>handle</var> must be initialized by a previous call to <code class=Fn>timeout</code>(), <code class=Fn>callout_handle_init</code>(), or assigned the value of <code class=Fn>CALLOUT_HANDLE_INITIALIZER</code>(<var class=Fa>&amp;handle</var>) before being passed to <code class=Fn>untimeout</code>(). The behavior of calling <code class=Fn>untimeout</code>() with an uninitialized handle is undefined.</p><p class=Pp>As handles are recycled by the system, it is possible (although unlikely) that a handle from one invocation of <code class=Fn>timeout</code>() may match the handle of another invocation of <code class=Fn>timeout</code>() if both calls used the same function pointer and argument, and the first timeout is expired or canceled before the second call. The timeout facility offers O(1) running time for <code class=Fn>timeout</code>() and <code class=Fn>untimeout</code>(). Timeouts are executed from <code class=Fn>softclock</code>() with the <var class=Va>Giant</var> lock held. Thus they are protected from re-entrancy.</p></section><section class=Sh><h2 class=Sh id=RETURN_VALUES><a class=permalink href=#RETURN_VALUES>RETURN VALUES</a></h2> The <code class=Fn>callout_active</code>() macro returns the state of a callout's <i class=Em>active</i> flag. <p class=Pp>The <code class=Fn>callout_pending</code>() macro returns the state of a callout's <i class=Em>pending</i> flag.</p><p class=Pp>The <code class=Fn>callout_reset</code>() and <code class=Fn>callout_schedule</code>() function families return a value of one if the callout was pending before the new function invocation was scheduled.</p><p class=Pp>The <code class=Fn>callout_stop</code>() and <code class=Fn>callout_drain</code>() functions return a value of one if the callout was still pending when it was called, a zero if the callout could not be stopped and a negative one is it was either not running or has already completed. The <code class=Fn>timeout</code>() function returns a <var class=Ft>struct callout_handle</var> that can be passed to <code class=Fn>untimeout</code>().</p></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> The current timeout and untimeout routines are based on the work of <span class=An>Adam M. Costello</span> and <span class=An>George Varghese</span>, published in a technical report entitled <span class=RsT>Redesigning the BSD Callout and Timer Facilities</span> and modified slightly for inclusion in <span class=Ux>FreeBSD</span> by <span class=An>Justin T. Gibbs</span>. The original work on the data structures used in this implementation was published by <span class=An>G. Varghese</span> and <span class=An>A. Lauck</span> in the paper <span class=RsT>Hashed and Hierarchical Timing Wheels: Data Structures for the Efficient Implementation of a Timer Facility</span> in the <i class=RsB>Proceedings of the 11th ACM Annual Symposium on Operating Systems Principles.</i> The current implementation replaces the long standing <span class=Ux>BSD</span> linked list callout mechanism which offered O(n) insertion and removal running time but did not generate or require handles for untimeout operations. </section></div><table class=foot><tr><td class=foot-date>December 10, 2019</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>