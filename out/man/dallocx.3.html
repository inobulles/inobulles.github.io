<!DOCTYPE html>
<html><head><meta charset=utf-8><title>dallocx(3)</title><keywords content=man,dallocx></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>dallocx(3)</h1><table class=head><tr><td class=head-ltitle>JEMALLOC(3)</td><td class=head-vol>User Manual</td><td class=head-rtitle>JEMALLOC(3)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2> jemalloc - general purpose memory allocation functions </section><section class=Sh><h2 class=Sh id=LIBRARY><a class=permalink href=#LIBRARY>LIBRARY</a></h2> This manual describes jemalloc 5.1.0-0-g61efbda7098de6fe64c362d309824864308c36d4. More information can be found at the <b>jemalloc website</b>[1]. <p class=Pp>The following configuration options are enabled in libc's built-in jemalloc: <b>--enable-fill</b>, <b>--enable-lazy-lock</b>, <b>--enable-stats</b>, <b>--enable-utrace</b>, <b>--enable-xmalloc</b>, and <b>--with-malloc-conf=abort_conf:false</b>. Additionally, <b>--enable-debug</b> is enabled in development versions of FreeBSD (controlled by the <b>MK_MALLOC_PRODUCTION</b> make variable).</p></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><pre>
#include &lt;stdlib.h&gt;
#include &lt;malloc_np.h&gt;
</pre><section class=Ss><h2 class=Ss id=Standard_API><a class=permalink href=#Standard_API>Standard API</a></h2><p class="Pp HP"><b>void *malloc(size_t </b><i>size</i><b>);</b></p><p class="Pp HP"><b>void *calloc(size_t </b><i>number</i><b>, size_t </b><i>size</i><b>);</b></p><p class="Pp HP"><b>int posix_memalign(void **</b><i>ptr</i><b>, size_t </b><i>alignment</i><b>, size_t </b><i>size</i><b>);</b></p><p class="Pp HP"><b>void *aligned_alloc(size_t </b><i>alignment</i><b>, size_t </b><i>size</i><b>);</b></p><p class="Pp HP"><b>void *realloc(void *</b><i>ptr</i><b>, size_t </b><i>size</i><b>);</b></p><p class="Pp HP"><b>void free(void *</b><i>ptr</i><b>);</b></p></section><section class=Ss><h2 class=Ss id=Non_-standard_API><a class=permalink href=#Non_-standard_API>Non-standard API</a></h2><p class="Pp HP"><b>void *mallocx(size_t </b><i>size</i><b>, int </b><i>flags</i><b>);</b></p><p class="Pp HP"><b>void *rallocx(void *</b><i>ptr</i><b>, size_t </b><i>size</i><b>, int </b><i>flags</i><b>);</b></p><p class="Pp HP"><b>size_t xallocx(void *</b><i>ptr</i><b>, size_t </b><i>size</i><b>, size_t </b><i>extra</i><b>, int </b><i>flags</i><b>);</b></p><p class="Pp HP"><b>size_t sallocx(void *</b><i>ptr</i><b>, int </b><i>flags</i><b>);</b></p><p class="Pp HP"><b>void dallocx(void *</b><i>ptr</i><b>, int </b><i>flags</i><b>);</b></p><p class="Pp HP"><b>void sdallocx(void *</b><i>ptr</i><b>, size_t </b><i>size</i><b>, int </b><i>flags</i><b>);</b></p><p class="Pp HP"><b>size_t nallocx(size_t </b><i>size</i><b>, int </b><i>flags</i><b>);</b></p><p class="Pp HP"><b>int mallctl(const char *</b><i>name</i><b>, void *</b><i>oldp</i><b>, size_t *</b><i>oldlenp</i><b>, void *</b><i>newp</i><b>, size_t </b><i>newlen</i><b>);</b></p><p class="Pp HP"><b>int mallctlnametomib(const char *</b><i>name</i><b>, size_t *</b><i>mibp</i><b>, size_t *</b><i>miblenp</i><b>);</b></p><p class="Pp HP"><b>int mallctlbymib(const size_t *</b><i>mib</i><b>, size_t </b><i>miblen</i><b>, void *</b><i>oldp</i><b>, size_t *</b><i>oldlenp</i><b>, void *</b><i>newp</i><b>, size_t </b><i>newlen</i><b>);</b></p><p class="Pp HP"><b>void malloc_stats_print(void </b><i>(*write_cb)</i><b> (void *, const char *), void *</b><i>cbopaque</i><b>, const char *</b><i>opts</i><b>);</b></p><p class="Pp HP"><b>size_t malloc_usable_size(const void *</b><i>ptr</i><b>);</b></p><p class="Pp HP"><b>void (*malloc_message)(void *</b><i>cbopaque</i><b>, const char *</b><i>s</i><b>);</b></p><p class=Pp>const char *<i>malloc_conf</i>;</p></section></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2><section class=Ss><h2 class=Ss id=Standard_API_2><a class=permalink href=#Standard_API_2>Standard API</a></h2> The malloc() function allocates <i>size</i> bytes of uninitialized memory. The allocated space is suitably aligned (after possible pointer coercion) for storage of any type of object. <p class=Pp>The calloc() function allocates space for <i>number</i> objects, each <i>size</i> bytes in length. The result is identical to calling malloc() with an argument of <i>number</i> * <i>size</i>, with the exception that the allocated memory is explicitly initialized to zero bytes.</p><p class=Pp>The posix_memalign() function allocates <i>size</i> bytes of memory such that the allocation's base address is a multiple of <i>alignment</i>, and returns the allocation in the value pointed to by <i>ptr</i>. The requested <i>alignment</i> must be a power of 2 at least as large as sizeof(<b>void *</b>).</p><p class=Pp>The aligned_alloc() function allocates <i>size</i> bytes of memory such that the allocation's base address is a multiple of <i>alignment</i>. The requested <i>alignment</i> must be a power of 2. Behavior is undefined if <i>size</i> is not an integral multiple of <i>alignment</i>.</p><p class=Pp>The realloc() function changes the size of the previously allocated memory referenced by <i>ptr</i> to <i>size</i> bytes. The contents of the memory are unchanged up to the lesser of the new and old sizes. If the new size is larger, the contents of the newly allocated portion of the memory are undefined. Upon success, the memory referenced by <i>ptr</i> is freed and a pointer to the newly allocated memory is returned. Note that realloc() may move the memory allocation, resulting in a different return value than <i>ptr</i>. If <i>ptr</i> is <b>NULL</b>, the realloc() function behaves identically to malloc() for the specified size.</p><p class=Pp>The free() function causes the allocated memory referenced by <i>ptr</i> to be made available for future allocations. If <i>ptr</i> is <b>NULL</b>, no action occurs.</p></section><section class=Ss><h2 class=Ss id=Non_-standard_API_2><a class=permalink href=#Non_-standard_API_2>Non-standard API</a></h2> The mallocx(), rallocx(), xallocx(), sallocx(), dallocx(), sdallocx(), and nallocx() functions all have a <i>flags</i> argument that can be used to specify options. The functions only check the options that are contextually relevant. Use bitwise or (|) operations to specify one or more of the following: <p class=Pp><b>MALLOCX_LG_ALIGN(</b><b></b><i>la</i><b>) </b></p><div class=Bd-indent>Align the memory allocation to start at an address that is a multiple of (1 &lt;&lt; <i>la</i>). This macro does not validate that <i>la</i> is within the valid range.</div><p class=Pp><b>MALLOCX_ALIGN(</b><b></b><i>a</i><b>) </b></p><div class=Bd-indent>Align the memory allocation to start at an address that is a multiple of <i>a</i>, where <i>a</i> is a power of two. This macro does not validate that <i>a</i> is a power of 2.</div><p class=Pp><b>MALLOCX_ZERO</b></p><div class=Bd-indent>Initialize newly allocated memory to contain zero bytes. In the growing reallocation case, the real size prior to reallocation defines the boundary between untouched bytes and those that are initialized to contain zero bytes. If this macro is absent, newly allocated memory is uninitialized.</div><p class=Pp><b>MALLOCX_TCACHE(</b><b></b><i>tc</i><b>) </b></p><div class=Bd-indent>Use the thread-specific cache (tcache) specified by the identifier <i>tc</i>, which must have been acquired via the tcache.create mallctl. This macro does not validate that <i>tc</i> specifies a valid identifier.</div><p class=Pp><b>MALLOCX_TCACHE_NONE</b></p><div class=Bd-indent>Do not use a thread-specific cache (tcache). Unless <b>MALLOCX_TCACHE(</b><b></b><i>tc</i><b>)</b> or <b>MALLOCX_TCACHE_NONE</b> is specified, an automatically managed tcache will be used under many circumstances. This macro cannot be used in the same <i>flags</i> argument as <b>MALLOCX_TCACHE(</b><b></b><i>tc</i><b>)</b>.</div><p class=Pp><b>MALLOCX_ARENA(</b><b></b><i>a</i><b>) </b></p><div class=Bd-indent>Use the arena specified by the index <i>a</i>. This macro has no effect for regions that were allocated via an arena other than the one specified. This macro does not validate that <i>a</i> specifies an arena index in the valid range.</div><p class=Pp>The mallocx() function allocates at least <i>size</i> bytes of memory, and returns a pointer to the base address of the allocation. Behavior is undefined if <i>size</i> is <b>0</b>.</p><p class=Pp>The rallocx() function resizes the allocation at <i>ptr</i> to be at least <i>size</i> bytes, and returns a pointer to the base address of the resulting allocation, which may or may not have moved from its original location. Behavior is undefined if <i>size</i> is <b>0</b>.</p><p class=Pp>The xallocx() function resizes the allocation at <i>ptr</i> in place to be at least <i>size</i> bytes, and returns the real size of the allocation. If <i>extra</i> is non-zero, an attempt is made to resize the allocation to be at least (<i>size</i> + <i>extra</i>) bytes, though inability to allocate the extra byte(s) will not by itself result in failure to resize. Behavior is undefined if <i>size</i> is <b>0</b>, or if (<i>size</i> + <i>extra</i> &gt; <b>SIZE_T_MAX</b>).</p><p class=Pp>The sallocx() function returns the real size of the allocation at <i>ptr</i>.</p><p class=Pp>The dallocx() function causes the memory referenced by <i>ptr</i> to be made available for future allocations.</p><p class=Pp>The sdallocx() function is an extension of dallocx() with a <i>size</i> parameter to allow the caller to pass in the allocation size as an optimization. The minimum valid input size is the original requested size of the allocation, and the maximum valid input size is the corresponding value returned by nallocx() or sallocx().</p><p class=Pp>The nallocx() function allocates no memory, but it performs the same size computation as the mallocx() function, and returns the real size of the allocation that would result from the equivalent mallocx() function call, or <b>0</b> if the inputs exceed the maximum supported size class and/or alignment. Behavior is undefined if <i>size</i> is <b>0</b>.</p><p class=Pp>The mallctl() function provides a general interface for introspecting the memory allocator, as well as setting modifiable parameters and triggering actions. The period-separated <i>name</i> argument specifies a location in a tree-structured namespace; see the MALLCTL NAMESPACE section for documentation on the tree contents. To read a value, pass a pointer via <i>oldp</i> to adequate space to contain the value, and a pointer to its length via <i>oldlenp</i>; otherwise pass <b>NULL</b> and <b>NULL</b>. Similarly, to write a value, pass a pointer to the value via <i>newp</i>, and its length via <i>newlen</i>; otherwise pass <b>NULL</b> and <b>0</b>.</p><p class=Pp>The mallctlnametomib() function provides a way to avoid repeated name lookups for applications that repeatedly query the same portion of the namespace, by translating a name to a “Management Information Base” (MIB) that can be passed repeatedly to mallctlbymib(). Upon successful return from mallctlnametomib(), <i>mibp</i> contains an array of <i>*miblenp</i> integers, where <i>*miblenp</i> is the lesser of the number of components in <i>name</i> and the input value of <i>*miblenp</i>. Thus it is possible to pass a <i>*miblenp</i> that is smaller than the number of period-separated name components, which results in a partial MIB that can be used as the basis for constructing a complete MIB. For name components that are integers (e.g. the 2 in arenas.bin.2.size), the corresponding MIB component will always be that integer. Therefore, it is legitimate to construct code like the following:</p><p class=Pp></p><div class=Bd-indent><pre>
unsigned nbins, i;
size_t mib[4];
size_t len, miblen;
len = sizeof(nbins);
mallctl("arenas.nbins", &amp;nbins, &amp;len, NULL, 0);
miblen = 4;
mallctlnametomib("arenas.bin.0.size", mib, &amp;miblen);
for (i = 0; i &lt; nbins; i++) {
	size_t bin_size;
	mib[2] = i;
	len = sizeof(bin_size);
	mallctlbymib(mib, miblen, (void *)&amp;bin_size, &amp;len, NULL, 0);
	/* Do something with bin_size... */
}
</pre></div><p class=Pp></p><div class=Bd-indent></div><p class=Pp>The malloc_stats_print() function writes summary statistics via the <i>write_cb</i> callback function pointer and <i>cbopaque</i> data passed to <i>write_cb</i>, or malloc_message() if <i>write_cb</i> is <b>NULL</b>. The statistics are presented in human-readable form unless “J” is specified as a character within the <i>opts</i> string, in which case the statistics are presented in <b>JSON format</b>[2]. This function can be called repeatedly. General information that never changes during execution can be omitted by specifying “g” as a character within the <i>opts</i> string. Note that malloc_message() uses the mallctl*() functions internally, so inconsistent statistics can be reported if multiple threads use these functions simultaneously. If <b>--enable-stats</b> is specified during configuration, “m”, “d”, and “a” can be specified to omit merged arena, destroyed merged arena, and per arena statistics, respectively; “b” and “l” can be specified to omit per size class statistics for bins and large objects, respectively; “x” can be specified to omit all mutex statistics. Unrecognized characters are silently ignored. Note that thread caching may prevent some statistics from being completely up to date, since extra locking would be required to merge counters that track thread cache operations.</p><p class=Pp>The malloc_usable_size() function returns the usable size of the allocation pointed to by <i>ptr</i>. The return value may be larger than the size that was requested during allocation. The malloc_usable_size() function is not a mechanism for in-place realloc(); rather it is provided solely as a tool for introspection purposes. Any discrepancy between the requested allocation size and the size reported by malloc_usable_size() should not be depended on, since such behavior is entirely implementation-dependent.</p></section></section><section class=Sh><h2 class=Sh id=TUNING><a class=permalink href=#TUNING>TUNING</a></h2> Once, when the first call is made to one of the memory allocation routines, the allocator initializes its internals based in part on various options that can be specified at compile- or run-time. <p class=Pp>The string specified via <b>--with-malloc-conf</b>, the string pointed to by the global variable <i>malloc_conf</i>, the “name” of the file referenced by the symbolic link named /etc/malloc.conf, and the value of the environment variable <b>MALLOC_CONF</b>, will be interpreted, in that order, from left to right as options. Note that <i>malloc_conf</i> may be read before main() is entered, so the declaration of <i>malloc_conf</i> should specify an initializer that contains the final value to be read by jemalloc. <b>--with-malloc-conf</b> and <i>malloc_conf</i> are compile-time mechanisms, whereas /etc/malloc.conf and <b>MALLOC_CONF</b> can be safely set any time prior to program invocation.</p><p class=Pp>An options string is a comma-separated list of option:value pairs. There is one key corresponding to each opt.* mallctl (see the MALLCTL NAMESPACE section for options documentation). For example, abort:true,narenas:1 sets the opt.abort and opt.narenas options. Some options have boolean values (true/false), others have integer values (base 8, 10, or 16, depending on prefix), and yet others have raw string values.</p></section><section class=Sh><h2 class=Sh id=IMPLEMENTATION_NOTES><a class=permalink href=#IMPLEMENTATION_NOTES>IMPLEMENTATION NOTES</a></h2> Traditionally, allocators have used <b>sbrk</b>(2) to obtain memory, which is suboptimal for several reasons, including race conditions, increased fragmentation, and artificial limitations on maximum usable memory. If <b>sbrk</b>(2) is supported by the operating system, this allocator uses both <b>mmap</b>(2) and <b>sbrk</b>(2), in that order of preference; otherwise only <b>mmap</b>(2) is used. <p class=Pp>This allocator uses multiple arenas in order to reduce lock contention for threaded programs on multi-processor systems. This works well with regard to threading scalability, but incurs some costs. There is a small fixed per-arena overhead, and additionally, arenas manage memory completely independently of each other, which means a small fixed increase in overall memory fragmentation. These overheads are not generally an issue, given the number of arenas normally used. Note that using substantially more arenas than the default is not likely to improve performance, mainly due to reduced cache performance. However, it may make sense to reduce the number of arenas if an application does not make much use of the allocation functions.</p><p class=Pp>In addition to multiple arenas, this allocator supports thread-specific caching, in order to make it possible to completely avoid synchronization for most allocation requests. Such caching allows very fast allocation in the common case, but it increases memory usage and fragmentation, since a bounded number of objects can remain allocated in each thread cache.</p><p class=Pp>Memory is conceptually broken into extents. Extents are always aligned to multiples of the page size. This alignment makes it possible to find metadata for user objects quickly. User objects are broken into two categories according to size: small and large. Contiguous small objects comprise a slab, which resides within a single extent, whereas large objects each have their own extents backing them.</p><p class=Pp>Small objects are managed in groups by slabs. Each slab maintains a bitmap to track which regions are in use. Allocation requests that are no more than half the quantum (8 or 16, depending on architecture) are rounded up to the nearest power of two that is at least sizeof(<b>double</b>). All other object size classes are multiples of the quantum, spaced such that there are four size classes for each doubling in size, which limits internal fragmentation to approximately 20% for all but the smallest size classes. Small size classes are smaller than four times the page size, and large size classes extend from four times the page size up to the largest size class that does not exceed <b>PTRDIFF_MAX</b>.</p><p class=Pp>Allocations are packed tightly together, which can be an issue for multi-threaded applications. If you need to assure that allocations do not suffer from cacheline sharing, round your allocation requests up to the nearest multiple of the cacheline size, or specify cacheline alignment when allocating.</p><p class=Pp>The realloc(), rallocx(), and xallocx() functions may resize allocations without moving them under limited circumstances. Unlike the *allocx() API, the standard API does not officially round up the usable size of an allocation to the nearest size class, so technically it is necessary to call realloc() to grow e.g. a 9-byte allocation to 16 bytes, or shrink a 16-byte allocation to 9 bytes. Growth and shrinkage trivially succeeds in place as long as the pre-size and post-size both round up to the same size class. No other API guarantees are made regarding in-place resizing, but the current implementation also tries to resize large allocations in place, as long as the pre-size and post-size are both large. For shrinkage to succeed, the extent allocator must support splitting (see arena.&lt;i&gt;.extent_hooks). Growth only succeeds if the trailing memory is currently available, and the extent allocator supports merging.</p><p class=Pp>Assuming 4 KiB pages and a 16-byte quantum on a 64-bit system, the size classes in each category are as shown in Table 1.</p><p class=Pp><b>Table 1. Size classes</b></p><table border=1 class=tbl style="border-style: solid;"><tr><td>Category</td><td style="text-align: right;">Spacing</td><td>Size</td></tr><tr><td rowspan=9>Small</td><td style="text-align: right;">lg</td><td>[8]</td></tr><tr><td style="text-align: right;">16</td><td>[16, 32, 48, 64, 80, 96, 112, 128]</td></tr><tr><td style="text-align: right;">32</td><td>[160, 192, 224, 256]</td></tr><tr><td style="text-align: right;">64</td><td>[320, 384, 448, 512]</td></tr><tr><td style="text-align: right;">128</td><td>[640, 768, 896, 1024]</td></tr><tr><td style="text-align: right;">256</td><td>[1280, 1536, 1792, 2048]</td></tr><tr><td style="text-align: right;">512</td><td>[2560, 3072, 3584, 4096]</td></tr><tr><td style="text-align: right;">1 KiB</td><td>[5 KiB, 6 KiB, 7 KiB, 8 KiB]</td></tr><tr><td style="text-align: right;">2 KiB</td><td>[10 KiB, 12 KiB, 14 KiB]</td></tr><tr><td rowspan=16>Large</td><td style="text-align: right;">2 KiB</td><td>[16 KiB]</td></tr><tr><td style="text-align: right;">4 KiB</td><td>[20 KiB, 24 KiB, 28 KiB, 32 KiB]</td></tr><tr><td style="text-align: right;">8 KiB</td><td>[40 KiB, 48 KiB, 54 KiB, 64 KiB]</td></tr><tr><td style="text-align: right;">16 KiB</td><td>[80 KiB, 96 KiB, 112 KiB, 128 KiB]</td></tr><tr><td style="text-align: right;">32 KiB</td><td>[160 KiB, 192 KiB, 224 KiB, 256 KiB]</td></tr><tr><td style="text-align: right;">64 KiB</td><td>[320 KiB, 384 KiB, 448 KiB, 512 KiB]</td></tr><tr><td style="text-align: right;">128 KiB</td><td>[640 KiB, 768 KiB, 896 KiB, 1 MiB]</td></tr><tr><td style="text-align: right;">256 KiB</td><td>[1280 KiB, 1536 KiB, 1792 KiB, 2 MiB]</td></tr><tr><td style="text-align: right;">512 KiB</td><td>[2560 KiB, 3 MiB, 3584 KiB, 4 MiB]</td></tr><tr><td style="text-align: right;">1 MiB</td><td>[5 MiB, 6 MiB, 7 MiB, 8 MiB]</td></tr><tr><td style="text-align: right;">2 MiB</td><td>[10 MiB, 12 MiB, 14 MiB, 16 MiB]</td></tr><tr><td style="text-align: right;">4 MiB</td><td>[20 MiB, 24 MiB, 28 MiB, 32 MiB]</td></tr><tr><td style="text-align: right;">8 MiB</td><td>[40 MiB, 48 MiB, 56 MiB, 64 MiB]</td></tr><tr><td style="text-align: right;">...</td><td>...</td></tr><tr><td style="text-align: right;">512 PiB</td><td>[2560 PiB, 3 EiB, 3584 PiB, 4 EiB]</td></tr><tr><td style="text-align: right;">1 EiB</td><td>[5 EiB, 6 EiB, 7 EiB]</td></tr></table><p class=Pp></p></section><section class=Sh><h2 class=Sh id=MALLCTL_NAMESPACE><a class=permalink href=#MALLCTL_NAMESPACE>MALLCTL NAMESPACE</a></h2> The following names are defined in the namespace accessible via the <br> mallctl*() functions. Value types are specified in parentheses, their readable/writable statuses are encoded as rw, r-, -w, or --, and required build configuration flags follow, if any. A name element encoded as &lt;i&gt; or &lt;j&gt; indicates an integer component, where the integer varies from 0 to some upper value that must be determined via introspection. In the case of stats.arenas.&lt;i&gt;.* and arena.&lt;i&gt;.{initialized,purge,decay,dss}, &lt;i&gt; equal to <b>MALLCTL_ARENAS_ALL</b> can be used to operate on all arenas or access the summation of statistics from all arenas; similarly &lt;i&gt; equal to <b>MALLCTL_ARENAS_DESTROYED</b> can be used to access the summation of statistics from all destroyed arenas. These constants can be utilized either via mallctlnametomib() followed by mallctlbymib(), or via code such as the following: <p class=Pp></p><div class=Bd-indent><pre>
#define STRINGIFY_HELPER(x) #x
#define STRINGIFY(x) STRINGIFY_HELPER(x)
mallctl("arena." STRINGIFY(MALLCTL_ARENAS_ALL) ".decay",
    NULL, NULL, NULL, 0);
</pre></div><p class=Pp>Take special note of the epoch mallctl, which controls refreshing of cached dynamic statistics.</p><p class=Pp>version (<b>const char *</b>) r-</p><div class=Bd-indent>Return the jemalloc version string.</div><p class=Pp>epoch (<b>uint64_t</b>) rw</p><div class=Bd-indent>If a value is passed in, refresh the data from which the mallctl*() functions report values, and increment the epoch. Return the current epoch. This is useful for detecting whether another thread caused a refresh.</div><p class=Pp>background_thread (<b>bool</b>) rw</p><div class=Bd-indent>Enable/disable internal background worker threads. When set to true, background threads are created on demand (the number of background threads will be no more than the number of CPUs or active arenas). Threads run periodically, and handle purging asynchronously. When switching off, background threads are terminated synchronously. Note that after <b>fork</b>(2) function, the state in the child process will be disabled regardless the state in parent process. See stats.background_thread for related stats. opt.background_thread can be used to set the default option. This option is only available on selected pthread-based platforms.</div><p class=Pp>max_background_threads (<b>size_t</b>) rw</p><div class=Bd-indent>Maximum number of background worker threads that will be created. This value is capped at opt.max_background_threads at startup.</div><p class=Pp>config.cache_oblivious (<b>bool</b>) r-</p><div class=Bd-indent><b>--enable-cache-oblivious</b> was specified during build configuration.</div><p class=Pp>config.debug (<b>bool</b>) r-</p><div class=Bd-indent><b>--enable-debug</b> was specified during build configuration.</div><p class=Pp>config.fill (<b>bool</b>) r-</p><div class=Bd-indent><b>--enable-fill</b> was specified during build configuration.</div><p class=Pp>config.lazy_lock (<b>bool</b>) r-</p><div class=Bd-indent><b>--enable-lazy-lock</b> was specified during build configuration.</div><p class=Pp>config.malloc_conf (<b>const char *</b>) r-</p><div class=Bd-indent>Embedded configure-time-specified run-time options string, empty unless <b>--with-malloc-conf</b> was specified during build configuration.</div><p class=Pp>config.prof (<b>bool</b>) r-</p><div class=Bd-indent><b>--enable-prof</b> was specified during build configuration.</div><p class=Pp>config.prof_libgcc (<b>bool</b>) r-</p><div class=Bd-indent><b>--disable-prof-libgcc</b> was not specified during build configuration.</div><p class=Pp>config.prof_libunwind (<b>bool</b>) r-</p><div class=Bd-indent><b>--enable-prof-libunwind</b> was specified during build configuration.</div><p class=Pp>config.stats (<b>bool</b>) r-</p><div class=Bd-indent><b>--enable-stats</b> was specified during build configuration.</div><p class=Pp>config.utrace (<b>bool</b>) r-</p><div class=Bd-indent><b>--enable-utrace</b> was specified during build configuration.</div><p class=Pp>config.xmalloc (<b>bool</b>) r-</p><div class=Bd-indent><b>--enable-xmalloc</b> was specified during build configuration.</div><p class=Pp>opt.abort (<b>bool</b>) r-</p><div class=Bd-indent>Abort-on-warning enabled/disabled. If true, most warnings are fatal. Note that runtime option warnings are not included (see opt.abort_conf for that). The process will call <b>abort</b>(3) in these cases. This option is disabled by default unless <b>--enable-debug</b> is specified during configuration, in which case it is enabled by default.</div><p class=Pp>opt.abort_conf (<b>bool</b>) r-</p><div class=Bd-indent>Abort-on-invalid-configuration enabled/disabled. If true, invalid runtime options are fatal. The process will call <b>abort</b>(3) in these cases. This option is disabled by default unless <b>--enable-debug</b> is specified during configuration, in which case it is enabled by default.</div><p class=Pp>opt.metadata_thp (<b>const char *</b>) r-</p><div class=Bd-indent>Controls whether to allow jemalloc to use transparent huge page (THP) for internal metadata (see stats.metadata). “always” allows such usage. “auto” uses no THP initially, but may begin to do so when metadata usage reaches certain level. The default is “disabled”.</div><p class=Pp>opt.retain (<b>bool</b>) r-</p><div class=Bd-indent>If true, retain unused virtual memory for later reuse rather than discarding it by calling <b>munmap</b>(2) or equivalent (see stats.retained for related details). This option is disabled by default unless discarding virtual memory is known to trigger platform-specific performance problems, e.g. for [64-bit] Linux, which has a quirk in its virtual memory allocation algorithm that causes semi-permanent VM map holes under normal jemalloc operation. Although <b>munmap</b>(2) causes issues on 32-bit Linux as well, retaining virtual memory for 32-bit Linux is disabled by default due to the practical possibility of address space exhaustion.</div><p class=Pp>opt.dss (<b>const char *</b>) r-</p><div class=Bd-indent>dss (<b>sbrk</b>(2)) allocation precedence as related to <b>mmap</b>(2) allocation. The following settings are supported if <b>sbrk</b>(2) is supported by the operating system: “disabled”, “primary”, and “secondary”; otherwise only “disabled” is supported. The default is “secondary” if <b>sbrk</b>(2) is supported by the operating system; “disabled” otherwise.</div><p class=Pp>opt.narenas (<b>unsigned</b>) r-</p><div class=Bd-indent>Maximum number of arenas to use for automatic multiplexing of threads and arenas. The default is four times the number of CPUs, or one if there is a single CPU.</div><p class=Pp>opt.percpu_arena (<b>const char *</b>) r-</p><div class=Bd-indent>Per CPU arena mode. Use the “percpu” setting to enable this feature, which uses number of CPUs to determine number of arenas, and bind threads to arenas dynamically based on the CPU the thread runs on currently. “phycpu” setting uses one arena per physical CPU, which means the two hyper threads on the same CPU share one arena. Note that no runtime checking regarding the availability of hyper threading is done at the moment. When set to “disabled”, narenas and thread to arena association will not be impacted by this option. The default is “disabled”.</div><p class=Pp>opt.background_thread (<b>const bool</b>) r-</p><div class=Bd-indent>Internal background worker threads enabled/disabled. Because of potential circular dependencies, enabling background thread using this option may cause crash or deadlock during initialization. For a reliable way to use this feature, see background_thread for dynamic control options and details. This option is disabled by default.</div><p class=Pp>opt.max_background_threads (<b>const size_t</b>) r-</p><div class=Bd-indent>Maximum number of background threads that will be created if background_thread is set. Defaults to number of cpus.</div><p class=Pp>opt.dirty_decay_ms (<b>ssize_t</b>) r-</p><div class=Bd-indent>Approximate time in milliseconds from the creation of a set of unused dirty pages until an equivalent set of unused dirty pages is purged (i.e. converted to muzzy via e.g. madvise(<i>...</i><i></i><b>MADV_FREE</b>) if supported by the operating system, or converted to clean otherwise) and/or reused. Dirty pages are defined as previously having been potentially written to by the application, and therefore consuming physical memory, yet having no current use. The pages are incrementally purged according to a sigmoidal decay curve that starts and ends with zero purge rate. A decay time of 0 causes all unused dirty pages to be purged immediately upon creation. A decay time of -1 disables purging. The default decay time is 10 seconds. See arenas.dirty_decay_ms and arena.&lt;i&gt;.dirty_decay_ms for related dynamic control options. See opt.muzzy_decay_ms for a description of muzzy pages.</div><p class=Pp>opt.muzzy_decay_ms (<b>ssize_t</b>) r-</p><div class=Bd-indent>Approximate time in milliseconds from the creation of a set of unused muzzy pages until an equivalent set of unused muzzy pages is purged (i.e. converted to clean) and/or reused. Muzzy pages are defined as previously having been unused dirty pages that were subsequently purged in a manner that left them subject to the reclamation whims of the operating system (e.g. madvise(<i>...</i><i></i><b>MADV_FREE</b>)), and therefore in an indeterminate state. The pages are incrementally purged according to a sigmoidal decay curve that starts and ends with zero purge rate. A decay time of 0 causes all unused muzzy pages to be purged immediately upon creation. A decay time of -1 disables purging. The default decay time is 10 seconds. See arenas.muzzy_decay_ms and arena.&lt;i&gt;.muzzy_decay_ms for related dynamic control options.</div><p class=Pp>opt.lg_extent_max_active_fit (<b>size_t</b>) r-</p><div class=Bd-indent>When reusing dirty extents, this determines the (log base 2 of the) maximum ratio between the size of the active extent selected (to split off from) and the size of the requested allocation. This prevents the splitting of large active extents for smaller allocations, which can reduce fragmentation over the long run (especially for non-active extents). Lower value may reduce fragmentation, at the cost of extra active extents. The default value is 6, which gives a maximum ratio of 64 (2^6).</div><p class=Pp>opt.stats_print (<b>bool</b>) r-</p><div class=Bd-indent>Enable/disable statistics printing at exit. If enabled, the malloc_stats_print() function is called at program exit via an <b>atexit</b>(3) function. opt.stats_print_opts can be combined to specify output options. If <b>--enable-stats</b> is specified during configuration, this has the potential to cause deadlock for a multi-threaded process that exits while one or more threads are executing in the memory allocation functions. Furthermore, atexit() may allocate memory during application initialization and then deadlock internally when jemalloc in turn calls atexit(), so this option is not universally usable (though the application can register its own atexit() function with equivalent functionality). Therefore, this option should only be used with care; it is primarily intended as a performance tuning aid during application development. This option is disabled by default.</div><p class=Pp>opt.stats_print_opts (<b>const char *</b>) r-</p><div class=Bd-indent>Options (the <i>opts</i> string) to pass to the malloc_stats_print() at exit (enabled through opt.stats_print). See available options in malloc_stats_print(). Has no effect unless opt.stats_print is enabled. The default is “”.</div><p class=Pp>opt.junk (<b>const char *</b>) r- [<b>--enable-fill</b>]</p><div class=Bd-indent>Junk filling. If set to “alloc”, each byte of uninitialized allocated memory will be initialized to 0xa5. If set to “free”, all deallocated memory will be initialized to 0x5a. If set to “true”, both allocated and deallocated memory will be initialized, and if set to “false”, junk filling be disabled entirely. This is intended for debugging and will impact performance negatively. This option is “false” by default unless <b>--enable-debug</b> is specified during configuration, in which case it is “true” by default.</div><p class=Pp>opt.zero (<b>bool</b>) r- [<b>--enable-fill</b>]</p><div class=Bd-indent>Zero filling enabled/disabled. If enabled, each byte of uninitialized allocated memory will be initialized to 0. Note that this initialization only happens once for each byte, so realloc() and rallocx() calls do not zero memory that was previously allocated. This is intended for debugging and will impact performance negatively. This option is disabled by default.</div><p class=Pp>opt.utrace (<b>bool</b>) r- [<b>--enable-utrace</b>]</p><div class=Bd-indent>Allocation tracing based on <b>utrace</b>(2) enabled/disabled. This option is disabled by default.</div><p class=Pp>opt.xmalloc (<b>bool</b>) r- [<b>--enable-xmalloc</b>]</p><div class=Bd-indent>Abort-on-out-of-memory enabled/disabled. If enabled, rather than returning failure for any allocation function, display a diagnostic message on <b>STDERR_FILENO</b> and cause the program to drop core (using <b>abort</b>(3)). If an application is designed to depend on this behavior, set the option at compile time by including the following in the source code: <p class=Pp></p><div class=Bd-indent><pre>
malloc_conf = "xmalloc:true";
</pre></div><p class=Pp>This option is disabled by default.</p></div><p class=Pp>opt.tcache (<b>bool</b>) r-</p><div class=Bd-indent>Thread-specific caching (tcache) enabled/disabled. When there are multiple threads, each thread uses a tcache for objects up to a certain size. Thread-specific caching allows many allocations to be satisfied without performing any thread synchronization, at the cost of increased memory use. See the opt.lg_tcache_max option for related tuning information. This option is enabled by default.</div><p class=Pp>opt.lg_tcache_max (<b>size_t</b>) r-</p><div class=Bd-indent>Maximum size class (log base 2) to cache in the thread-specific cache (tcache). At a minimum, all small size classes are cached, and at a maximum all large size classes are cached. The default maximum is 32 KiB (2^15).</div><p class=Pp>opt.thp (<b>const char *</b>) r-</p><div class=Bd-indent>Transparent hugepage (THP) mode. Settings "always", "never" and "default" are available if THP is supported by the operating system. The "always" setting enables transparent hugepage for all user memory mappings with <i></i><b>MADV_HUGEPAGE</b>; "never" ensures no transparent hugepage with <i></i><b>MADV_NOHUGEPAGE</b>; the default setting "default" makes no changes. Note that: this option does not affect THP for jemalloc internal metadata (see opt.metadata_thp); in addition, for arenas with customized extent_hooks, this option is bypassed as it is implemented as part of the default extent hooks.</div><p class=Pp>opt.prof (<b>bool</b>) r- [<b>--enable-prof</b>]</p><div class=Bd-indent>Memory profiling enabled/disabled. If enabled, profile memory allocation activity. See the opt.prof_active option for on-the-fly activation/deactivation. See the opt.lg_prof_sample option for probabilistic sampling control. See the opt.prof_accum option for control of cumulative sample reporting. See the opt.lg_prof_interval option for information on interval-triggered profile dumping, the opt.prof_gdump option for information on high-water-triggered profile dumping, and the opt.prof_final option for final profile dumping. Profile output is compatible with the <b>jeprof</b> command, which is based on the <b>pprof</b> that is developed as part of the <b>gperftools package</b>[3]. See HEAP PROFILE FORMAT for heap profile format documentation.</div><p class=Pp>opt.prof_prefix (<b>const char *</b>) r- [<b>--enable-prof</b>]</p><div class=Bd-indent>Filename prefix for profile dumps. If the prefix is set to the empty string, no automatic dumps will occur; this is primarily useful for disabling the automatic final heap dump (which also disables leak reporting, if enabled). The default prefix is jeprof.</div><p class=Pp>opt.prof_active (<b>bool</b>) r- [<b>--enable-prof</b>]</p><div class=Bd-indent>Profiling activated/deactivated. This is a secondary control mechanism that makes it possible to start the application with profiling enabled (see the opt.prof option) but inactive, then toggle profiling at any time during program execution with the prof.active mallctl. This option is enabled by default.</div><p class=Pp>opt.prof_thread_active_init (<b>bool</b>) r- [<b>--enable-prof</b>]</p><div class=Bd-indent>Initial setting for thread.prof.active in newly created threads. The initial setting for newly created threads can also be changed during execution via the prof.thread_active_init mallctl. This option is enabled by default.</div><p class=Pp>opt.lg_prof_sample (<b>size_t</b>) r- [<b>--enable-prof</b>]</p><div class=Bd-indent>Average interval (log base 2) between allocation samples, as measured in bytes of allocation activity. Increasing the sampling interval decreases profile fidelity, but also decreases the computational overhead. The default sample interval is 512 KiB (2^19 B).</div><p class=Pp>opt.prof_accum (<b>bool</b>) r- [<b>--enable-prof</b>]</p><div class=Bd-indent>Reporting of cumulative object/byte counts in profile dumps enabled/disabled. If this option is enabled, every unique backtrace must be stored for the duration of execution. Depending on the application, this can impose a large memory overhead, and the cumulative counts are not always of interest. This option is disabled by default.</div><p class=Pp>opt.lg_prof_interval (<b>ssize_t</b>) r- [<b>--enable-prof</b>]</p><div class=Bd-indent>Average interval (log base 2) between memory profile dumps, as measured in bytes of allocation activity. The actual interval between dumps may be sporadic because decentralized allocation counters are used to avoid synchronization bottlenecks. Profiles are dumped to files named according to the pattern &lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.i&lt;iseq&gt;.heap, where &lt;prefix&gt; is controlled by the opt.prof_prefix option. By default, interval-triggered profile dumping is disabled (encoded as -1).</div><p class=Pp>opt.prof_gdump (<b>bool</b>) r- [<b>--enable-prof</b>]</p><div class=Bd-indent>Set the initial state of prof.gdump, which when enabled triggers a memory profile dump every time the total virtual memory exceeds the previous maximum. This option is disabled by default.</div><p class=Pp>opt.prof_final (<b>bool</b>) r- [<b>--enable-prof</b>]</p><div class=Bd-indent>Use an <b>atexit</b>(3) function to dump final memory usage to a file named according to the pattern &lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.f.heap, where &lt;prefix&gt; is controlled by the opt.prof_prefix option. Note that atexit() may allocate memory during application initialization and then deadlock internally when jemalloc in turn calls atexit(), so this option is not universally usable (though the application can register its own atexit() function with equivalent functionality). This option is disabled by default.</div><p class=Pp>opt.prof_leak (<b>bool</b>) r- [<b>--enable-prof</b>]</p><div class=Bd-indent>Leak reporting enabled/disabled. If enabled, use an <b>atexit</b>(3) function to report memory leaks detected by allocation sampling. See the opt.prof option for information on analyzing heap profile output. This option is disabled by default.</div><p class=Pp>thread.arena (<b>unsigned</b>) rw</p><div class=Bd-indent>Get or set the arena associated with the calling thread. If the specified arena was not initialized beforehand (see the arena.i.initialized mallctl), it will be automatically initialized as a side effect of calling this interface.</div><p class=Pp>thread.allocated (<b>uint64_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Get the total number of bytes ever allocated by the calling thread. This counter has the potential to wrap around; it is up to the application to appropriately interpret the counter in such cases.</div><p class=Pp>thread.allocatedp (<b>uint64_t *</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Get a pointer to the the value that is returned by the thread.allocated mallctl. This is useful for avoiding the overhead of repeated mallctl*() calls.</div><p class=Pp>thread.deallocated (<b>uint64_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Get the total number of bytes ever deallocated by the calling thread. This counter has the potential to wrap around; it is up to the application to appropriately interpret the counter in such cases.</div><p class=Pp>thread.deallocatedp (<b>uint64_t *</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Get a pointer to the the value that is returned by the thread.deallocated mallctl. This is useful for avoiding the overhead of repeated mallctl*() calls.</div><p class=Pp>thread.tcache.enabled (<b>bool</b>) rw</p><div class=Bd-indent>Enable/disable calling thread's tcache. The tcache is implicitly flushed as a side effect of becoming disabled (see thread.tcache.flush).</div><p class=Pp>thread.tcache.flush (<b>void</b>) --</p><div class=Bd-indent>Flush calling thread's thread-specific cache (tcache). This interface releases all cached objects and internal data structures associated with the calling thread's tcache. Ordinarily, this interface need not be called, since automatic periodic incremental garbage collection occurs, and the thread cache is automatically discarded when a thread exits. However, garbage collection is triggered by allocation activity, so it is possible for a thread that stops allocating/deallocating to retain its cache indefinitely, in which case the developer may find manual flushing useful.</div><p class=Pp>thread.prof.name (<b>const char *</b>) r- or -w [<b>--enable-prof</b>]</p><div class=Bd-indent>Get/set the descriptive name associated with the calling thread in memory profile dumps. An internal copy of the name string is created, so the input string need not be maintained after this interface completes execution. The output string of this interface should be copied for non-ephemeral uses, because multiple implementation details can cause asynchronous string deallocation. Furthermore, each invocation of this interface can only read or write; simultaneous read/write is not supported due to string lifetime limitations. The name string must be nil-terminated and comprised only of characters in the sets recognized by <b>isgraph</b>(3) and <b>isblank</b>(3).</div><p class=Pp>thread.prof.active (<b>bool</b>) rw [<b>--enable-prof</b>]</p><div class=Bd-indent>Control whether sampling is currently active for the calling thread. This is an activation mechanism in addition to prof.active; both must be active for the calling thread to sample. This flag is enabled by default.</div><p class=Pp>tcache.create (<b>unsigned</b>) r-</p><div class=Bd-indent>Create an explicit thread-specific cache (tcache) and return an identifier that can be passed to the <b>MALLOCX_TCACHE(</b><b></b><i>tc</i><b>)</b> macro to explicitly use the specified cache rather than the automatically managed one that is used by default. Each explicit cache can be used by only one thread at a time; the application must assure that this constraint holds.</div><p class=Pp>tcache.flush (<b>unsigned</b>) -w</p><div class=Bd-indent>Flush the specified thread-specific cache (tcache). The same considerations apply to this interface as to thread.tcache.flush, except that the tcache will never be automatically discarded.</div><p class=Pp>tcache.destroy (<b>unsigned</b>) -w</p><div class=Bd-indent>Flush the specified thread-specific cache (tcache) and make the identifier available for use during a future tcache creation.</div><p class=Pp>arena.&lt;i&gt;.initialized (<b>bool</b>) r-</p><div class=Bd-indent>Get whether the specified arena's statistics are initialized (i.e. the arena was initialized prior to the current epoch). This interface can also be nominally used to query whether the merged statistics corresponding to <b>MALLCTL_ARENAS_ALL</b> are initialized (always true).</div><p class=Pp>arena.&lt;i&gt;.decay (<b>void</b>) --</p><div class=Bd-indent>Trigger decay-based purging of unused dirty/muzzy pages for arena &lt;i&gt;, or for all arenas if &lt;i&gt; equals <b>MALLCTL_ARENAS_ALL</b>. The proportion of unused dirty/muzzy pages to be purged depends on the current time; see opt.dirty_decay_ms and opt.muzy_decay_ms for details.</div><p class=Pp>arena.&lt;i&gt;.purge (<b>void</b>) --</p><div class=Bd-indent>Purge all unused dirty pages for arena &lt;i&gt;, or for all arenas if &lt;i&gt; equals <b>MALLCTL_ARENAS_ALL</b>.</div><p class=Pp>arena.&lt;i&gt;.reset (<b>void</b>) --</p><div class=Bd-indent>Discard all of the arena's extant allocations. This interface can only be used with arenas explicitly created via arenas.create. None of the arena's discarded/cached allocations may accessed afterward. As part of this requirement, all thread caches which were used to allocate/deallocate in conjunction with the arena must be flushed beforehand.</div><p class=Pp>arena.&lt;i&gt;.destroy (<b>void</b>) --</p><div class=Bd-indent>Destroy the arena. Discard all of the arena's extant allocations using the same mechanism as for arena.&lt;i&gt;.reset (with all the same constraints and side effects), merge the arena stats into those accessible at arena index <b>MALLCTL_ARENAS_DESTROYED</b>, and then completely discard all metadata associated with the arena. Future calls to arenas.create may recycle the arena index. Destruction will fail if any threads are currently associated with the arena as a result of calls to thread.arena.</div><p class=Pp>arena.&lt;i&gt;.dss (<b>const char *</b>) rw</p><div class=Bd-indent>Set the precedence of dss allocation as related to mmap allocation for arena &lt;i&gt;, or for all arenas if &lt;i&gt; equals <b>MALLCTL_ARENAS_ALL</b>. See opt.dss for supported settings.</div><p class=Pp>arena.&lt;i&gt;.dirty_decay_ms (<b>ssize_t</b>) rw</p><div class=Bd-indent>Current per-arena approximate time in milliseconds from the creation of a set of unused dirty pages until an equivalent set of unused dirty pages is purged and/or reused. Each time this interface is set, all currently unused dirty pages are considered to have fully decayed, which causes immediate purging of all unused dirty pages unless the decay time is set to -1 (i.e. purging disabled). See opt.dirty_decay_ms for additional information.</div><p class=Pp>arena.&lt;i&gt;.muzzy_decay_ms (<b>ssize_t</b>) rw</p><div class=Bd-indent>Current per-arena approximate time in milliseconds from the creation of a set of unused muzzy pages until an equivalent set of unused muzzy pages is purged and/or reused. Each time this interface is set, all currently unused muzzy pages are considered to have fully decayed, which causes immediate purging of all unused muzzy pages unless the decay time is set to -1 (i.e. purging disabled). See opt.muzzy_decay_ms for additional information.</div><p class=Pp>arena.&lt;i&gt;.retain_grow_limit (<b>size_t</b>) rw</p><div class=Bd-indent>Maximum size to grow retained region (only relevant when opt.retain is enabled). This controls the maximum increment to expand virtual memory, or allocation through arena.&lt;i&gt;extent_hooks. In particular, if customized extent hooks reserve physical memory (e.g. 1G huge pages), this is useful to control the allocation hook's input size. The default is no limit.</div><p class=Pp>arena.&lt;i&gt;.extent_hooks (<b>extent_hooks_t *</b>) rw</p><div class=Bd-indent>Get or set the extent management hook functions for arena &lt;i&gt;. The functions must be capable of operating on all extant extents associated with arena &lt;i&gt;, usually by passing unknown extents to the replaced functions. In practice, it is feasible to control allocation for arenas explicitly created via arenas.create such that all extents originate from an application-supplied extent allocator (by specifying the custom extent hook functions during arena creation), but the automatically created arenas will have already created extents prior to the application having an opportunity to take over extent allocation. <p class=Pp></p><div class=Bd-indent><pre>
typedef extent_hooks_s extent_hooks_t;
struct extent_hooks_s {
	extent_alloc_t		*alloc;
	extent_dalloc_t		*dalloc;
	extent_destroy_t	*destroy;
	extent_commit_t		*commit;
	extent_decommit_t	*decommit;
	extent_purge_t		*purge_lazy;
	extent_purge_t		*purge_forced;
	extent_split_t		*split;
	extent_merge_t		*merge;
};
</pre></div><p class=Pp>The <b>extent_hooks_t</b> structure comprises function pointers which are described individually below. jemalloc uses these functions to manage extent lifetime, which starts off with allocation of mapped committed memory, in the simplest case followed by deallocation. However, there are performance and platform reasons to retain extents for later reuse. Cleanup attempts cascade from deallocation to decommit to forced purging to lazy purging, which gives the extent management functions opportunities to reject the most permanent cleanup operations in favor of less permanent (and often less costly) operations. All operations except allocation can be universally opted out of by setting the hook pointers to <b>NULL</b>, or selectively opted out of by returning failure. Note that once the extent hook is set, the structure is accessed directly by the associated arenas, so it must remain valid for the entire lifetime of the arenas.</p><p class="Pp HP"><b>typedef void *(extent_alloc_t)(extent_hooks_t *</b><i>extent_hooks</i><b>, void *</b><i>new_addr</i><b>, size_t </b><i>size</i><b>, size_t </b><i>alignment</i><b>, bool *</b><i>zero</i><b>, bool *</b><i>commit</i><b>, unsigned </b><i>arena_ind</i><b>);</b></p><p class=Pp></p><div class=Bd-indent><pre>
</pre></div><p class=Pp>An extent allocation function conforms to the <b>extent_alloc_t</b> type and upon success returns a pointer to <i>size</i> bytes of mapped memory on behalf of arena <i>arena_ind</i> such that the extent's base address is a multiple of <i>alignment</i>, as well as setting <i>*zero</i> to indicate whether the extent is zeroed and <i>*commit</i> to indicate whether the extent is committed. Upon error the function returns <b>NULL</b> and leaves <i>*zero</i> and <i>*commit</i> unmodified. The <i>size</i> parameter is always a multiple of the page size. The <i>alignment</i> parameter is always a power of two at least as large as the page size. Zeroing is mandatory if <i>*zero</i> is true upon function entry. Committing is mandatory if <i>*commit</i> is true upon function entry. If <i>new_addr</i> is not <b>NULL</b>, the returned pointer must be <i>new_addr</i> on success or <b>NULL</b> on error. Committed memory may be committed in absolute terms as on a system that does not overcommit, or in implicit terms as on a system that overcommits and satisfies physical memory needs on demand via soft page faults. Note that replacing the default extent allocation function makes the arena's arena.&lt;i&gt;.dss setting irrelevant.</p><p class="Pp HP"><b>typedef bool (extent_dalloc_t)(extent_hooks_t *</b><i>extent_hooks</i><b>, void *</b><i>addr</i><b>, size_t </b><i>size</i><b>, bool </b><i>committed</i><b>, unsigned </b><i>arena_ind</i><b>);</b></p><p class=Pp></p><div class=Bd-indent><pre>
</pre></div><p class=Pp>An extent deallocation function conforms to the <b>extent_dalloc_t</b> type and deallocates an extent at given <i>addr</i> and <i>size</i> with <i>committed</i>/decommited memory as indicated, on behalf of arena <i>arena_ind</i>, returning false upon success. If the function returns true, this indicates opt-out from deallocation; the virtual memory mapping associated with the extent remains mapped, in the same commit state, and available for future use, in which case it will be automatically retained for later reuse.</p><p class="Pp HP"><b>typedef void (extent_destroy_t)(extent_hooks_t *</b><i>extent_hooks</i><b>, void *</b><i>addr</i><b>, size_t </b><i>size</i><b>, bool </b><i>committed</i><b>, unsigned </b><i>arena_ind</i><b>);</b></p><p class=Pp></p><div class=Bd-indent><pre>
</pre></div><p class=Pp>An extent destruction function conforms to the <b>extent_destroy_t</b> type and unconditionally destroys an extent at given <i>addr</i> and <i>size</i> with <i>committed</i>/decommited memory as indicated, on behalf of arena <i>arena_ind</i>. This function may be called to destroy retained extents during arena destruction (see arena.&lt;i&gt;.destroy).</p><p class="Pp HP"><b>typedef bool (extent_commit_t)(extent_hooks_t *</b><i>extent_hooks</i><b>, void *</b><i>addr</i><b>, size_t </b><i>size</i><b>, size_t </b><i>offset</i><b>, size_t </b><i>length</i><b>, unsigned </b><i>arena_ind</i><b>);</b></p><p class=Pp></p><div class=Bd-indent><pre>
</pre></div><p class=Pp>An extent commit function conforms to the <b>extent_commit_t</b> type and commits zeroed physical memory to back pages within an extent at given <i>addr</i> and <i>size</i> at <i>offset</i> bytes, extending for <i>length</i> on behalf of arena <i>arena_ind</i>, returning false upon success. Committed memory may be committed in absolute terms as on a system that does not overcommit, or in implicit terms as on a system that overcommits and satisfies physical memory needs on demand via soft page faults. If the function returns true, this indicates insufficient physical memory to satisfy the request.</p><p class="Pp HP"><b>typedef bool (extent_decommit_t)(extent_hooks_t *</b><i>extent_hooks</i><b>, void *</b><i>addr</i><b>, size_t </b><i>size</i><b>, size_t </b><i>offset</i><b>, size_t </b><i>length</i><b>, unsigned </b><i>arena_ind</i><b>);</b></p><p class=Pp></p><div class=Bd-indent><pre>
</pre></div><p class=Pp>An extent decommit function conforms to the <b>extent_decommit_t</b> type and decommits any physical memory that is backing pages within an extent at given <i>addr</i> and <i>size</i> at <i>offset</i> bytes, extending for <i>length</i> on behalf of arena <i>arena_ind</i>, returning false upon success, in which case the pages will be committed via the extent commit function before being reused. If the function returns true, this indicates opt-out from decommit; the memory remains committed and available for future use, in which case it will be automatically retained for later reuse.</p><p class="Pp HP"><b>typedef bool (extent_purge_t)(extent_hooks_t *</b><i>extent_hooks</i><b>, void *</b><i>addr</i><b>, size_t </b><i>size</i><b>, size_t </b><i>offset</i><b>, size_t </b><i>length</i><b>, unsigned </b><i>arena_ind</i><b>);</b></p><p class=Pp></p><div class=Bd-indent><pre>
</pre></div><p class=Pp>An extent purge function conforms to the <b>extent_purge_t</b> type and discards physical pages within the virtual memory mapping associated with an extent at given <i>addr</i> and <i>size</i> at <i>offset</i> bytes, extending for <i>length</i> on behalf of arena <i>arena_ind</i>. A lazy extent purge function (e.g. implemented via madvise(<i>...</i><i></i><b>MADV_FREE</b>)) can delay purging indefinitely and leave the pages within the purged virtual memory range in an indeterminite state, whereas a forced extent purge function immediately purges, and the pages within the virtual memory range will be zero-filled the next time they are accessed. If the function returns true, this indicates failure to purge.</p><p class="Pp HP"><b>typedef bool (extent_split_t)(extent_hooks_t *</b><i>extent_hooks</i><b>, void *</b><i>addr</i><b>, size_t </b><i>size</i><b>, size_t </b><i>size_a</i><b>, size_t </b><i>size_b</i><b>, bool </b><i>committed</i><b>, unsigned </b><i>arena_ind</i><b>);</b></p><p class=Pp></p><div class=Bd-indent><pre>
</pre></div><p class=Pp>An extent split function conforms to the <b>extent_split_t</b> type and optionally splits an extent at given <i>addr</i> and <i>size</i> into two adjacent extents, the first of <i>size_a</i> bytes, and the second of <i>size_b</i> bytes, operating on <i>committed</i>/decommitted memory as indicated, on behalf of arena <i>arena_ind</i>, returning false upon success. If the function returns true, this indicates that the extent remains unsplit and therefore should continue to be operated on as a whole.</p><p class="Pp HP"><b>typedef bool (extent_merge_t)(extent_hooks_t *</b><i>extent_hooks</i><b>, void *</b><i>addr_a</i><b>, size_t </b><i>size_a</i><b>, void *</b><i>addr_b</i><b>, size_t </b><i>size_b</i><b>, bool </b><i>committed</i><b>, unsigned </b><i>arena_ind</i><b>);</b></p><p class=Pp></p><div class=Bd-indent><pre>
</pre></div><p class=Pp>An extent merge function conforms to the <b>extent_merge_t</b> type and optionally merges adjacent extents, at given <i>addr_a</i> and <i>size_a</i> with given <i>addr_b</i> and <i>size_b</i> into one contiguous extent, operating on <i>committed</i>/decommitted memory as indicated, on behalf of arena <i>arena_ind</i>, returning false upon success. If the function returns true, this indicates that the extents remain distinct mappings and therefore should continue to be operated on independently.</p></div><p class=Pp>arenas.narenas (<b>unsigned</b>) r-</p><div class=Bd-indent>Current limit on number of arenas.</div><p class=Pp>arenas.dirty_decay_ms (<b>ssize_t</b>) rw</p><div class=Bd-indent>Current default per-arena approximate time in milliseconds from the creation of a set of unused dirty pages until an equivalent set of unused dirty pages is purged and/or reused, used to initialize arena.&lt;i&gt;.dirty_decay_ms during arena creation. See opt.dirty_decay_ms for additional information.</div><p class=Pp>arenas.muzzy_decay_ms (<b>ssize_t</b>) rw</p><div class=Bd-indent>Current default per-arena approximate time in milliseconds from the creation of a set of unused muzzy pages until an equivalent set of unused muzzy pages is purged and/or reused, used to initialize arena.&lt;i&gt;.muzzy_decay_ms during arena creation. See opt.muzzy_decay_ms for additional information.</div><p class=Pp>arenas.quantum (<b>size_t</b>) r-</p><div class=Bd-indent>Quantum size.</div><p class=Pp>arenas.page (<b>size_t</b>) r-</p><div class=Bd-indent>Page size.</div><p class=Pp>arenas.tcache_max (<b>size_t</b>) r-</p><div class=Bd-indent>Maximum thread-cached size class.</div><p class=Pp>arenas.nbins (<b>unsigned</b>) r-</p><div class=Bd-indent>Number of bin size classes.</div><p class=Pp>arenas.nhbins (<b>unsigned</b>) r-</p><div class=Bd-indent>Total number of thread cache bin size classes.</div><p class=Pp>arenas.bin.&lt;i&gt;.size (<b>size_t</b>) r-</p><div class=Bd-indent>Maximum size supported by size class.</div><p class=Pp>arenas.bin.&lt;i&gt;.nregs (<b>uint32_t</b>) r-</p><div class=Bd-indent>Number of regions per slab.</div><p class=Pp>arenas.bin.&lt;i&gt;.slab_size (<b>size_t</b>) r-</p><div class=Bd-indent>Number of bytes per slab.</div><p class=Pp>arenas.nlextents (<b>unsigned</b>) r-</p><div class=Bd-indent>Total number of large size classes.</div><p class=Pp>arenas.lextent.&lt;i&gt;.size (<b>size_t</b>) r-</p><div class=Bd-indent>Maximum size supported by this large size class.</div><p class=Pp>arenas.create (<b>unsigned</b>, <b>extent_hooks_t *</b>) rw</p><div class=Bd-indent>Explicitly create a new arena outside the range of automatically managed arenas, with optionally specified extent hooks, and return the new arena index.</div><p class=Pp>arenas.lookup (<b>unsigned</b>, <b>void*</b>) rw</p><div class=Bd-indent>Index of the arena to which an allocation belongs to.</div><p class=Pp>prof.thread_active_init (<b>bool</b>) rw [<b>--enable-prof</b>]</p><div class=Bd-indent>Control the initial setting for thread.prof.active in newly created threads. See the opt.prof_thread_active_init option for additional information.</div><p class=Pp>prof.active (<b>bool</b>) rw [<b>--enable-prof</b>]</p><div class=Bd-indent>Control whether sampling is currently active. See the opt.prof_active option for additional information, as well as the interrelated thread.prof.active mallctl.</div><p class=Pp>prof.dump (<b>const char *</b>) -w [<b>--enable-prof</b>]</p><div class=Bd-indent>Dump a memory profile to the specified file, or if NULL is specified, to a file according to the pattern &lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.m&lt;mseq&gt;.heap, where &lt;prefix&gt; is controlled by the opt.prof_prefix option.</div><p class=Pp>prof.gdump (<b>bool</b>) rw [<b>--enable-prof</b>]</p><div class=Bd-indent>When enabled, trigger a memory profile dump every time the total virtual memory exceeds the previous maximum. Profiles are dumped to files named according to the pattern &lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.u&lt;useq&gt;.heap, where &lt;prefix&gt; is controlled by the opt.prof_prefix option.</div><p class=Pp>prof.reset (<b>size_t</b>) -w [<b>--enable-prof</b>]</p><div class=Bd-indent>Reset all memory profile statistics, and optionally update the sample rate (see opt.lg_prof_sample and prof.lg_sample).</div><p class=Pp>prof.lg_sample (<b>size_t</b>) r- [<b>--enable-prof</b>]</p><div class=Bd-indent>Get the current sample rate (see opt.lg_prof_sample).</div><p class=Pp>prof.interval (<b>uint64_t</b>) r- [<b>--enable-prof</b>]</p><div class=Bd-indent>Average number of bytes allocated between interval-based profile dumps. See the opt.lg_prof_interval option for additional information.</div><p class=Pp>stats.allocated (<b>size_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Total number of bytes allocated by the application.</div><p class=Pp>stats.active (<b>size_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Total number of bytes in active pages allocated by the application. This is a multiple of the page size, and greater than or equal to stats.allocated. This does not include stats.arenas.&lt;i&gt;.pdirty, stats.arenas.&lt;i&gt;.pmuzzy, nor pages entirely devoted to allocator metadata.</div><p class=Pp>stats.metadata (<b>size_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Total number of bytes dedicated to metadata, which comprise base allocations used for bootstrap-sensitive allocator metadata structures (see stats.arenas.&lt;i&gt;.base) and internal allocations (see stats.arenas.&lt;i&gt;.internal). Transparent huge page (enabled with opt.metadata_thp) usage is not considered.</div><p class=Pp>stats.metadata_thp (<b>size_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Number of transparent huge pages (THP) used for metadata. See stats.metadata and opt.metadata_thp) for details.</div><p class=Pp>stats.resident (<b>size_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Maximum number of bytes in physically resident data pages mapped by the allocator, comprising all pages dedicated to allocator metadata, pages backing active allocations, and unused dirty pages. This is a maximum rather than precise because pages may not actually be physically resident if they correspond to demand-zeroed virtual memory that has not yet been touched. This is a multiple of the page size, and is larger than stats.active.</div><p class=Pp>stats.mapped (<b>size_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Total number of bytes in active extents mapped by the allocator. This is larger than stats.active. This does not include inactive extents, even those that contain unused dirty pages, which means that there is no strict ordering between this and stats.resident.</div><p class=Pp>stats.retained (<b>size_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Total number of bytes in virtual memory mappings that were retained rather than being returned to the operating system via e.g. <b>munmap</b>(2) or similar. Retained virtual memory is typically untouched, decommitted, or purged, so it has no strongly associated physical memory (see extent hooks for details). Retained memory is excluded from mapped memory statistics, e.g. stats.mapped.</div><p class=Pp>stats.background_thread.num_threads (<b>size_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Number of background threads running currently.</div><p class=Pp>stats.background_thread.num_runs (<b>uint64_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Total number of runs from all background threads.</div><p class=Pp>stats.background_thread.run_interval (<b>uint64_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Average run interval in nanoseconds of background threads.</div><p class=Pp>stats.mutexes.ctl.{counter}; (<b>counter specific type</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Statistics on <i>ctl</i> mutex (global scope; mallctl related). {counter} is one of the counters below: <p class=Pp></p><div class=Bd-indent><i>num_ops</i> (<b>uint64_t</b>): Total number of lock acquisition operations on this mutex. <p class=Pp><i>num_spin_acq</i> (<b>uint64_t</b>): Number of times the mutex was spin-acquired. When the mutex is currently locked and cannot be acquired immediately, a short period of spin-retry within jemalloc will be performed. Acquired through spin generally means the contention was lightweight and not causing context switches.</p><p class=Pp><i>num_wait</i> (<b>uint64_t</b>): Number of times the mutex was wait-acquired, which means the mutex contention was not solved by spin-retry, and blocking operation was likely involved in order to acquire the mutex. This event generally implies higher cost / longer delay, and should be investigated if it happens often.</p><p class=Pp><i>max_wait_time</i> (<b>uint64_t</b>): Maximum length of time in nanoseconds spent on a single wait-acquired lock operation. Note that to avoid profiling overhead on the common path, this does not consider spin-acquired cases.</p><p class=Pp><i>total_wait_time</i> (<b>uint64_t</b>): Cumulative time in nanoseconds spent on wait-acquired lock operations. Similarly, spin-acquired cases are not considered.</p><p class=Pp><i>max_num_thds</i> (<b>uint32_t</b>): Maximum number of threads waiting on this mutex simultaneously. Similarly, spin-acquired cases are not considered.</p><p class=Pp><i>num_owner_switch</i> (<b>uint64_t</b>): Number of times the current mutex owner is different from the previous one. This event does not generally imply an issue; rather it is an indicator of how often the protected data are accessed by different threads.</p></div></div><p class=Pp>stats.mutexes.background_thread.{counter} (<b>counter specific type</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Statistics on <i>background_thread</i> mutex (global scope; background_thread related). {counter} is one of the counters in mutex profiling counters.</div><p class=Pp>stats.mutexes.prof.{counter} (<b>counter specific type</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Statistics on <i>prof</i> mutex (global scope; profiling related). {counter} is one of the counters in mutex profiling counters.</div><p class=Pp>stats.mutexes.reset (<b>void</b>) -- [<b>--enable-stats</b>]</p><div class=Bd-indent>Reset all mutex profile statistics, including global mutexes, arena mutexes and bin mutexes.</div><p class=Pp>stats.arenas.&lt;i&gt;.dss (<b>const char *</b>) r-</p><div class=Bd-indent>dss (<b>sbrk</b>(2)) allocation precedence as related to <b>mmap</b>(2) allocation. See opt.dss for details.</div><p class=Pp>stats.arenas.&lt;i&gt;.dirty_decay_ms (<b>ssize_t</b>) r-</p><div class=Bd-indent>Approximate time in milliseconds from the creation of a set of unused dirty pages until an equivalent set of unused dirty pages is purged and/or reused. See opt.dirty_decay_ms for details.</div><p class=Pp>stats.arenas.&lt;i&gt;.muzzy_decay_ms (<b>ssize_t</b>) r-</p><div class=Bd-indent>Approximate time in milliseconds from the creation of a set of unused muzzy pages until an equivalent set of unused muzzy pages is purged and/or reused. See opt.muzzy_decay_ms for details.</div><p class=Pp>stats.arenas.&lt;i&gt;.nthreads (<b>unsigned</b>) r-</p><div class=Bd-indent>Number of threads currently assigned to arena.</div><p class=Pp>stats.arenas.&lt;i&gt;.uptime (<b>uint64_t</b>) r-</p><div class=Bd-indent>Time elapsed (in nanoseconds) since the arena was created. If &lt;i&gt; equals <b>0</b> or <b>MALLCTL_ARENAS_ALL</b>, this is the uptime since malloc initialization.</div><p class=Pp>stats.arenas.&lt;i&gt;.pactive (<b>size_t</b>) r-</p><div class=Bd-indent>Number of pages in active extents.</div><p class=Pp>stats.arenas.&lt;i&gt;.pdirty (<b>size_t</b>) r-</p><div class=Bd-indent>Number of pages within unused extents that are potentially dirty, and for which madvise() or similar has not been called. See opt.dirty_decay_ms for a description of dirty pages.</div><p class=Pp>stats.arenas.&lt;i&gt;.pmuzzy (<b>size_t</b>) r-</p><div class=Bd-indent>Number of pages within unused extents that are muzzy. See opt.muzzy_decay_ms for a description of muzzy pages.</div><p class=Pp>stats.arenas.&lt;i&gt;.mapped (<b>size_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Number of mapped bytes.</div><p class=Pp>stats.arenas.&lt;i&gt;.retained (<b>size_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Number of retained bytes. See stats.retained for details.</div><p class=Pp>stats.arenas.&lt;i&gt;.base (<b>size_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Number of bytes dedicated to bootstrap-sensitive allocator metadata structures.</div><p class=Pp>stats.arenas.&lt;i&gt;.internal (<b>size_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Number of bytes dedicated to internal allocations. Internal allocations differ from application-originated allocations in that they are for internal use, and that they are omitted from heap profiles.</div><p class=Pp>stats.arenas.&lt;i&gt;.metadata_thp (<b>size_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Number of transparent huge pages (THP) used for metadata. See opt.metadata_thp for details.</div><p class=Pp>stats.arenas.&lt;i&gt;.resident (<b>size_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Maximum number of bytes in physically resident data pages mapped by the arena, comprising all pages dedicated to allocator metadata, pages backing active allocations, and unused dirty pages. This is a maximum rather than precise because pages may not actually be physically resident if they correspond to demand-zeroed virtual memory that has not yet been touched. This is a multiple of the page size.</div><p class=Pp>stats.arenas.&lt;i&gt;.dirty_npurge (<b>uint64_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Number of dirty page purge sweeps performed.</div><p class=Pp>stats.arenas.&lt;i&gt;.dirty_nmadvise (<b>uint64_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Number of madvise() or similar calls made to purge dirty pages.</div><p class=Pp>stats.arenas.&lt;i&gt;.dirty_purged (<b>uint64_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Number of dirty pages purged.</div><p class=Pp>stats.arenas.&lt;i&gt;.muzzy_npurge (<b>uint64_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Number of muzzy page purge sweeps performed.</div><p class=Pp>stats.arenas.&lt;i&gt;.muzzy_nmadvise (<b>uint64_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Number of madvise() or similar calls made to purge muzzy pages.</div><p class=Pp>stats.arenas.&lt;i&gt;.muzzy_purged (<b>uint64_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Number of muzzy pages purged.</div><p class=Pp>stats.arenas.&lt;i&gt;.small.allocated (<b>size_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Number of bytes currently allocated by small objects.</div><p class=Pp>stats.arenas.&lt;i&gt;.small.nmalloc (<b>uint64_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Cumulative number of times a small allocation was requested from the arena's bins, whether to fill the relevant tcache if opt.tcache is enabled, or to directly satisfy an allocation request otherwise.</div><p class=Pp>stats.arenas.&lt;i&gt;.small.ndalloc (<b>uint64_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Cumulative number of times a small allocation was returned to the arena's bins, whether to flush the relevant tcache if opt.tcache is enabled, or to directly deallocate an allocation otherwise.</div><p class=Pp>stats.arenas.&lt;i&gt;.small.nrequests (<b>uint64_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Cumulative number of allocation requests satisfied by all bin size classes.</div><p class=Pp>stats.arenas.&lt;i&gt;.large.allocated (<b>size_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Number of bytes currently allocated by large objects.</div><p class=Pp>stats.arenas.&lt;i&gt;.large.nmalloc (<b>uint64_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Cumulative number of times a large extent was allocated from the arena, whether to fill the relevant tcache if opt.tcache is enabled and the size class is within the range being cached, or to directly satisfy an allocation request otherwise.</div><p class=Pp>stats.arenas.&lt;i&gt;.large.ndalloc (<b>uint64_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Cumulative number of times a large extent was returned to the arena, whether to flush the relevant tcache if opt.tcache is enabled and the size class is within the range being cached, or to directly deallocate an allocation otherwise.</div><p class=Pp>stats.arenas.&lt;i&gt;.large.nrequests (<b>uint64_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Cumulative number of allocation requests satisfied by all large size classes.</div><p class=Pp>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nmalloc (<b>uint64_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Cumulative number of times a bin region of the corresponding size class was allocated from the arena, whether to fill the relevant tcache if opt.tcache is enabled, or to directly satisfy an allocation request otherwise.</div><p class=Pp>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.ndalloc (<b>uint64_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Cumulative number of times a bin region of the corresponding size class was returned to the arena, whether to flush the relevant tcache if opt.tcache is enabled, or to directly deallocate an allocation otherwise.</div><p class=Pp>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nrequests (<b>uint64_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Cumulative number of allocation requests satisfied by bin regions of the corresponding size class.</div><p class=Pp>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.curregs (<b>size_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Current number of regions for this size class.</div><p class=Pp>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nfills (<b>uint64_t</b>) r-</p><div class=Bd-indent>Cumulative number of tcache fills.</div><p class=Pp>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nflushes (<b>uint64_t</b>) r-</p><div class=Bd-indent>Cumulative number of tcache flushes.</div><p class=Pp>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nslabs (<b>uint64_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Cumulative number of slabs created.</div><p class=Pp>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nreslabs (<b>uint64_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Cumulative number of times the current slab from which to allocate changed.</div><p class=Pp>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.curslabs (<b>size_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Current number of slabs.</div><p class=Pp>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.mutex.{counter} (<b>counter specific type</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Statistics on <i>arena.&lt;i&gt;.bins.&lt;j&gt;</i> mutex (arena bin scope; bin operation related). {counter} is one of the counters in mutex profiling counters.</div><p class=Pp>stats.arenas.&lt;i&gt;.lextents.&lt;j&gt;.nmalloc (<b>uint64_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Cumulative number of times a large extent of the corresponding size class was allocated from the arena, whether to fill the relevant tcache if opt.tcache is enabled and the size class is within the range being cached, or to directly satisfy an allocation request otherwise.</div><p class=Pp>stats.arenas.&lt;i&gt;.lextents.&lt;j&gt;.ndalloc (<b>uint64_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Cumulative number of times a large extent of the corresponding size class was returned to the arena, whether to flush the relevant tcache if opt.tcache is enabled and the size class is within the range being cached, or to directly deallocate an allocation otherwise.</div><p class=Pp>stats.arenas.&lt;i&gt;.lextents.&lt;j&gt;.nrequests (<b>uint64_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Cumulative number of allocation requests satisfied by large extents of the corresponding size class.</div><p class=Pp>stats.arenas.&lt;i&gt;.lextents.&lt;j&gt;.curlextents (<b>size_t</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Current number of large allocations for this size class.</div><p class=Pp>stats.arenas.&lt;i&gt;.mutexes.large.{counter} (<b>counter specific type</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Statistics on <i>arena.&lt;i&gt;.large</i> mutex (arena scope; large allocation related). {counter} is one of the counters in mutex profiling counters.</div><p class=Pp>stats.arenas.&lt;i&gt;.mutexes.extent_avail.{counter} (<b>counter specific type</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Statistics on <i>arena.&lt;i&gt;.extent_avail </i> mutex (arena scope; extent avail related). {counter} is one of the counters in mutex profiling counters.</div><p class=Pp>stats.arenas.&lt;i&gt;.mutexes.extents_dirty.{counter} (<b>counter specific type</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Statistics on <i>arena.&lt;i&gt;.extents_dirty </i> mutex (arena scope; dirty extents related). {counter} is one of the counters in mutex profiling counters.</div><p class=Pp>stats.arenas.&lt;i&gt;.mutexes.extents_muzzy.{counter} (<b>counter specific type</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Statistics on <i>arena.&lt;i&gt;.extents_muzzy </i> mutex (arena scope; muzzy extents related). {counter} is one of the counters in mutex profiling counters.</div><p class=Pp>stats.arenas.&lt;i&gt;.mutexes.extents_retained.{counter} (<b>counter specific type</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Statistics on <i>arena.&lt;i&gt;.extents_retained </i> mutex (arena scope; retained extents related). {counter} is one of the counters in mutex profiling counters.</div><p class=Pp>stats.arenas.&lt;i&gt;.mutexes.decay_dirty.{counter} (<b>counter specific type</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Statistics on <i>arena.&lt;i&gt;.decay_dirty </i> mutex (arena scope; decay for dirty pages related). {counter} is one of the counters in mutex profiling counters.</div><p class=Pp>stats.arenas.&lt;i&gt;.mutexes.decay_muzzy.{counter} (<b>counter specific type</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Statistics on <i>arena.&lt;i&gt;.decay_muzzy </i> mutex (arena scope; decay for muzzy pages related). {counter} is one of the counters in mutex profiling counters.</div><p class=Pp>stats.arenas.&lt;i&gt;.mutexes.base.{counter} (<b>counter specific type</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Statistics on <i>arena.&lt;i&gt;.base</i> mutex (arena scope; base allocator related). {counter} is one of the counters in mutex profiling counters.</div><p class=Pp>stats.arenas.&lt;i&gt;.mutexes.tcache_list.{counter} (<b>counter specific type</b>) r- [<b>--enable-stats</b>]</p><div class=Bd-indent>Statistics on <i>arena.&lt;i&gt;.tcache_list</i> mutex (arena scope; tcache to arena association related). This mutex is expected to be accessed less often. {counter} is one of the counters in mutex profiling counters.</div></section><section class=Sh><h2 class=Sh id=HEAP_PROFILE_FORMAT><a class=permalink href=#HEAP_PROFILE_FORMAT>HEAP PROFILE FORMAT</a></h2> Although the heap profiling functionality was originally designed to be compatible with the <b>pprof</b> command that is developed as part of the <b>gperftools package</b>[3], the addition of per thread heap profiling functionality required a different heap profile format. The <b>jeprof</b> command is derived from <b>pprof</b>, with enhancements to support the heap profile format described here. <p class=Pp>In the following hypothetical heap profile, <b>[...]</b> indicates elision for the sake of compactness.</p><p class=Pp></p><div class=Bd-indent><pre>
heap_v2/524288
  t*: 28106: 56637512 [0: 0]
  [...]
  t3: 352: 16777344 [0: 0]
  [...]
  t99: 17754: 29341640 [0: 0]
  [...]
@ 0x5f86da8 0x5f5a1dc [...] 0x29e4d4e 0xa200316 0xabb2988 [...]
  t*: 13: 6688 [0: 0]
  t3: 12: 6496 [0: ]
  t99: 1: 192 [0: 0]
[...]
MAPPED_LIBRARIES:
[...]
</pre></div><p class=Pp>The following matches the above heap profile, but most tokens are replaced with <b>&lt;description&gt;</b> to indicate descriptions of the corresponding fields.</p><p class=Pp></p><div class=Bd-indent><pre>
&lt;heap_profile_format_version&gt;/&lt;mean_sample_interval&gt;
  &lt;aggregate&gt;: &lt;curobjs&gt;: &lt;curbytes&gt; [&lt;cumobjs&gt;: &lt;cumbytes&gt;]
  [...]
  &lt;thread_3_aggregate&gt;: &lt;curobjs&gt;: &lt;curbytes&gt;[&lt;cumobjs&gt;: &lt;cumbytes&gt;]
  [...]
  &lt;thread_99_aggregate&gt;: &lt;curobjs&gt;: &lt;curbytes&gt;[&lt;cumobjs&gt;: &lt;cumbytes&gt;]
  [...]
@ &lt;top_frame&gt; &lt;frame&gt; [...] &lt;frame&gt; &lt;frame&gt; &lt;frame&gt; [...]
  &lt;backtrace_aggregate&gt;: &lt;curobjs&gt;: &lt;curbytes&gt; [&lt;cumobjs&gt;: &lt;cumbytes&gt;]
  &lt;backtrace_thread_3&gt;: &lt;curobjs&gt;: &lt;curbytes&gt; [&lt;cumobjs&gt;: &lt;cumbytes&gt;]
  &lt;backtrace_thread_99&gt;: &lt;curobjs&gt;: &lt;curbytes&gt; [&lt;cumobjs&gt;: &lt;cumbytes&gt;]
[...]
MAPPED_LIBRARIES:
&lt;/proc/&lt;pid&gt;/maps&gt;
</pre></div></section><section class=Sh><h2 class=Sh id=DEBUGGING_MALLOC_PROBLEMS><a class=permalink href=#DEBUGGING_MALLOC_PROBLEMS>DEBUGGING MALLOC PROBLEMS</a></h2> When debugging, it is a good idea to configure/build jemalloc with the <b>--enable-debug</b> and <b>--enable-fill</b> options, and recompile the program with suitable options and symbols for debugger support. When so configured, jemalloc incorporates a wide variety of run-time assertions that catch application errors such as double-free, write-after-free, etc. <p class=Pp>Programs often accidentally depend on “uninitialized” memory actually being filled with zero bytes. Junk filling (see the opt.junk option) tends to expose such bugs in the form of obviously incorrect results and/or coredumps. Conversely, zero filling (see the opt.zero option) eliminates the symptoms of such bugs. Between these two options, it is usually possible to quickly detect, diagnose, and eliminate such bugs.</p><p class=Pp>This implementation does not provide much detail about the problems it detects, because the performance impact for storing such information would be prohibitive.</p></section><section class=Sh><h2 class=Sh id=DIAGNOSTIC_MESSAGES><a class=permalink href=#DIAGNOSTIC_MESSAGES>DIAGNOSTIC MESSAGES</a></h2> If any of the memory allocation/deallocation functions detect an error or warning condition, a message will be printed to file descriptor <b>STDERR_FILENO</b>. Errors will result in the process dumping core. If the opt.abort option is set, most warnings are treated as errors. <p class=Pp>The <i>malloc_message</i> variable allows the programmer to override the function which emits the text strings forming the errors and warnings if for some reason the <b>STDERR_FILENO</b> file descriptor is not suitable for this. malloc_message() takes the <i>cbopaque</i> pointer argument that is <b>NULL</b> unless overridden by the arguments in a call to malloc_stats_print(), followed by a string pointer. Please note that doing anything which tries to allocate memory in this function is likely to result in a crash or deadlock.</p><p class=Pp>All messages are prefixed by “&lt;jemalloc&gt;: ”.</p></section><section class=Sh><h2 class=Sh id=RETURN_VALUES><a class=permalink href=#RETURN_VALUES>RETURN VALUES</a></h2><section class=Ss><h2 class=Ss id=Standard_API_3><a class=permalink href=#Standard_API_3>Standard API</a></h2> The malloc() and calloc() functions return a pointer to the allocated memory if successful; otherwise a <b>NULL</b> pointer is returned and <i>errno</i> is set to ENOMEM. <p class=Pp>The posix_memalign() function returns the value 0 if successful; otherwise it returns an error value. The posix_memalign() function will fail if:</p><p class=Pp>EINVAL</p><div class=Bd-indent>The <i>alignment</i> parameter is not a power of 2 at least as large as sizeof(<b>void *</b>).</div><p class=Pp>ENOMEM</p><div class=Bd-indent>Memory allocation error.</div><p class=Pp>The aligned_alloc() function returns a pointer to the allocated memory if successful; otherwise a <b>NULL</b> pointer is returned and <i>errno</i> is set. The aligned_alloc() function will fail if:</p><p class=Pp>EINVAL</p><div class=Bd-indent>The <i>alignment</i> parameter is not a power of 2.</div><p class=Pp>ENOMEM</p><div class=Bd-indent>Memory allocation error.</div><p class=Pp>The realloc() function returns a pointer, possibly identical to <i>ptr</i>, to the allocated memory if successful; otherwise a <b>NULL</b> pointer is returned, and <i>errno</i> is set to ENOMEM if the error was the result of an allocation failure. The realloc() function always leaves the original buffer intact when an error occurs.</p><p class=Pp>The free() function returns no value.</p></section><section class=Ss><h2 class=Ss id=Non_-standard_API_3><a class=permalink href=#Non_-standard_API_3>Non-standard API</a></h2> The mallocx() and rallocx() functions return a pointer to the allocated memory if successful; otherwise a <b>NULL</b> pointer is returned to indicate insufficient contiguous memory was available to service the allocation request. <p class=Pp>The xallocx() function returns the real size of the resulting resized allocation pointed to by <i>ptr</i>, which is a value less than <i>size</i> if the allocation could not be adequately grown in place.</p><p class=Pp>The sallocx() function returns the real size of the allocation pointed to by <i>ptr</i>.</p><p class=Pp>The nallocx() returns the real size that would result from a successful equivalent mallocx() function call, or zero if insufficient memory is available to perform the size computation.</p><p class=Pp>The mallctl(), mallctlnametomib(), and mallctlbymib() functions return 0 on success; otherwise they return an error value. The functions will fail if:</p><p class=Pp>EINVAL</p><div class=Bd-indent><i>newp</i> is not <b>NULL</b>, and <i>newlen</i> is too large or too small. Alternatively, <i>*oldlenp</i> is too large or too small; in this case as much data as possible are read despite the error.</div><p class=Pp>ENOENT</p><div class=Bd-indent><i>name</i> or <i>mib</i> specifies an unknown/invalid value.</div><p class=Pp>EPERM</p><div class=Bd-indent>Attempt to read or write void value, or attempt to write read-only value.</div><p class=Pp>EAGAIN</p><div class=Bd-indent>A memory allocation failure occurred.</div><p class=Pp>EFAULT</p><div class=Bd-indent>An interface with side effects failed in some way not directly related to mallctl*() read/write processing.</div><p class=Pp>The malloc_usable_size() function returns the usable size of the allocation pointed to by <i>ptr</i>.</p></section></section><section class=Sh><h2 class=Sh id=ENVIRONMENT><a class=permalink href=#ENVIRONMENT>ENVIRONMENT</a></h2> The following environment variable affects the execution of the allocation functions: <p class=Pp><b>MALLOC_CONF</b></p><div class=Bd-indent>If the environment variable <b>MALLOC_CONF</b> is set, the characters it contains will be interpreted as options.</div></section><section class=Sh><h2 class=Sh id=EXAMPLES><a class=permalink href=#EXAMPLES>EXAMPLES</a></h2> To dump core whenever a problem occurs: <p class=Pp></p><div class=Bd-indent><pre>
ln -s 'abort:true' /etc/malloc.conf
</pre></div><p class=Pp>To specify in the source that only one arena should be automatically created:</p><p class=Pp></p><div class=Bd-indent><pre>
malloc_conf = "narenas:1";
</pre></div></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><b>madvise</b>(2), <b>mmap</b>(2), <b>sbrk</b>(2), <b>utrace</b>(2), <b>alloca</b>(3), <b>atexit</b>(3), <b>getpagesize</b>(3) </section><section class=Sh><h2 class=Sh id=STANDARDS><a class=permalink href=#STANDARDS>STANDARDS</a></h2> The malloc(), calloc(), realloc(), and free() functions conform to ISO/IEC 9899:1990 (“ISO C90”). <p class=Pp>The posix_memalign() function conforms to IEEE Std 1003.1-2001 (“POSIX.1”).</p></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> The malloc_usable_size() and posix_memalign() functions first appeared in FreeBSD 7.0. <p class=Pp>The aligned_alloc(), malloc_stats_print(), and mallctl*() functions first appeared in FreeBSD 10.0.</p><p class=Pp>The *allocx() functions first appeared in FreeBSD 11.0.</p></section><section class=Sh><h2 class=Sh id=AUTHOR><a class=permalink href=#AUTHOR>AUTHOR</a></h2><b>Jason Evans</b><div class=Bd-indent></div></section><section class=Sh><h2 class=Sh id=NOTES><a class=permalink href=#NOTES>NOTES</a></h2><dl class=Bl-tag><dt> 1.</dt><dd>jemalloc website</dd></dl><div class=Bd-indent>http://jemalloc.net/</div><dl class=Bl-tag><dt> 2.</dt><dd>JSON format</dd></dl><div class=Bd-indent>http://www.json.org/</div><dl class=Bl-tag><dt> 3.</dt><dd>gperftools package</dd></dl><div class=Bd-indent>http://code.google.com/p/gperftools/</div></section></div><table class=foot><tr><td class=foot-date>05/08/2018</td><td class=foot-os>jemalloc 5.1.0-0-g61efbda7098d</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>