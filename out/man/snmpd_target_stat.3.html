<!DOCTYPE html>
<html><head><meta charset=utf-8><title>snmpd_target_stat(3)</title><keywords content=man,snmpd_target_stat></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>snmpd_target_stat(3)</h1><table class=head><tr><td class=head-ltitle>SNMPMOD(3)</td><td class=head-vol>FreeBSD Library Functions Manual</td><td class=head-rtitle>SNMPMOD(3)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>INSERT_OBJECT_OID_LINK_INDEX</code>, <code class=Nm>INSERT_OBJECT_INT_LINK_INDEX</code>, <code class=Nm>FIND_OBJECT_OID_LINK_INDEX</code>, <code class=Nm>NEXT_OBJECT_OID_LINK_INDEX</code>, <code class=Nm>FIND_OBJECT_INT_LINK_INDEX</code>, <code class=Nm>NEXT_OBJECT_INT_LINK_INDEX</code>, <code class=Nm>INSERT_OBJECT_OID_LINK</code>, <code class=Nm>INSERT_OBJECT_INT_LINK</code>, <code class=Nm>FIND_OBJECT_OID_LINK</code>, <code class=Nm>NEXT_OBJECT_OID_LINK</code>, <code class=Nm>FIND_OBJECT_INT_LINK</code>, <code class=Nm>NEXT_OBJECT_INT_LINK</code>, <code class=Nm>INSERT_OBJECT_OID</code>, <code class=Nm>INSERT_OBJECT_INT</code>, <code class=Nm>FIND_OBJECT_OID</code>, <code class=Nm>FIND_OBJECT_INT</code>, <code class=Nm>NEXT_OBJECT_OID</code>, <code class=Nm>NEXT_OBJECT_INT</code>, <code class=Nm>this_tick</code>, <code class=Nm>start_tick</code>, <code class=Nm>get_ticks</code>, <code class=Nm>systemg</code>, <code class=Nm>comm_define</code>, <code class=Nm>community</code>, <code class=Nm>oid_zeroDotZero</code>, <code class=Nm>oid_usmUnknownEngineIDs</code>, <code class=Nm>oid_usmNotInTimeWindows</code>, <code class=Nm>reqid_allocate</code>, <code class=Nm>reqid_next</code>, <code class=Nm>reqid_base</code>, <code class=Nm>reqid_istype</code>, <code class=Nm>reqid_type</code>, <code class=Nm>timer_start</code>, <code class=Nm>timer_start_repeat</code>, <code class=Nm>timer_stop</code>, <code class=Nm>fd_select</code>, <code class=Nm>fd_deselect</code>, <code class=Nm>fd_suspend</code>, <code class=Nm>fd_resume</code>, <code class=Nm>or_register</code>, <code class=Nm>or_unregister</code>, <code class=Nm>buf_alloc</code>, <code class=Nm>buf_size</code>, <code class=Nm>snmp_input_start</code>, <code class=Nm>snmp_input_finish</code>, <code class=Nm>snmp_output</code>, <code class=Nm>snmp_send_port</code>, <code class=Nm>snmp_send_trap</code>, <code class=Nm>snmp_pdu_auth_access</code><code class=Nm>string_save</code>, <code class=Nm>string_commit</code>, <code class=Nm>string_rollback</code>, <code class=Nm>string_get</code>, <code class=Nm>string_get_max</code>, <code class=Nm>string_free</code>, <code class=Nm>ip_save</code>, <code class=Nm>ip_rollback</code>, <code class=Nm>ip_commit</code>, <code class=Nm>ip_get</code>, <code class=Nm>oid_save</code>, <code class=Nm>oid_rollback</code>, <code class=Nm>oid_commit</code>, <code class=Nm>oid_get</code>, <code class=Nm>index_decode</code>, <code class=Nm>index_compare</code>, <code class=Nm>index_compare_off</code>, <code class=Nm>index_append</code>, <code class=Nm>index_append_off</code>, <code class=Nm>snmpd_usmstats</code>, <code class=Nm>bsnmpd_get_usm_stats</code>, <code class=Nm>bsnmpd_reset_usm_stats</code>, <code class=Nm>usm_first_user</code>, <code class=Nm>usm_next_user</code>, <code class=Nm>usm_find_user</code>, <code class=Nm>usm_new_user</code>, <code class=Nm>usm_delete_user</code>, <code class=Nm>usm_flush_users</code>, <code class=Nm>usm_user</code>, <code class=Nm>snmpd_target_stat</code>, <code class=Nm>bsnmpd_get_target_stats</code>, <code class=Nm>target_first_address</code>, <code class=Nm>target_next_address</code>, <code class=Nm>target_new_address</code>, <code class=Nm>target_activate_address</code>, <code class=Nm>target_delete_address</code>, <code class=Nm>target_first_param</code>, <code class=Nm>target_next_param</code>, <code class=Nm>target_new_param</code>, <code class=Nm>target_delete_param</code>, <code class=Nm>target_first_notify</code>, <code class=Nm>target_next_notify</code>, <code class=Nm>target_new_notify</code>, <code class=Nm>target_delete_notify</code>, <code class=Nm>target_flush_all</code>, <code class=Nm>target_address</code>, <code class=Nm>target_param</code>, <code class=Nm>target_notify</code> â€” <div class=Nd>SNMP daemon loadable module interface</div></section><section class=Sh><h2 class=Sh id=LIBRARY><a class=permalink href=#LIBRARY>LIBRARY</a></h2> Begemot SNMP library (libbsnmp, -lbsnmp) </section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/bsnmp/snmpmod.h.html>bsnmp/snmpmod.h</a>&gt;</code><p class=Pp><code class=Fn>INSERT_OBJECT_OID_LINK_INDEX</code>(<var class=Fa style="white-space: nowrap;">PTR</var>, <var class=Fa style="white-space: nowrap;">LIST</var>, <var class=Fa style="white-space: nowrap;">LINK</var>, <var class=Fa style="white-space: nowrap;">INDEX</var>);</p><p class=Pp><code class=Fn>INSERT_OBJECT_INT_LINK_INDEX</code>(<var class=Fa style="white-space: nowrap;">PTR</var>, <var class=Fa style="white-space: nowrap;">LIST</var>, <var class=Fa style="white-space: nowrap;">LINK</var>, <var class=Fa style="white-space: nowrap;">INDEX</var>);</p><p class=Pp><code class=Fn>FIND_OBJECT_OID_LINK_INDEX</code>(<var class=Fa style="white-space: nowrap;">LIST</var>, <var class=Fa style="white-space: nowrap;">OID</var>, <var class=Fa style="white-space: nowrap;">SUB</var>, <var class=Fa style="white-space: nowrap;">LINK</var>, <var class=Fa style="white-space: nowrap;">INDEX</var>);</p><p class=Pp><code class=Fn>FIND_OBJECT_INT_LINK_INDEX</code>(<var class=Fa style="white-space: nowrap;">LIST</var>, <var class=Fa style="white-space: nowrap;">OID</var>, <var class=Fa style="white-space: nowrap;">SUB</var>, <var class=Fa style="white-space: nowrap;">LINK</var>, <var class=Fa style="white-space: nowrap;">INDEX</var>);</p><p class=Pp><code class=Fn>NEXT_OBJECT_OID_LINK_INDEX</code>(<var class=Fa style="white-space: nowrap;">LIST</var>, <var class=Fa style="white-space: nowrap;">OID</var>, <var class=Fa style="white-space: nowrap;">SUB</var>, <var class=Fa style="white-space: nowrap;">LINK</var>, <var class=Fa style="white-space: nowrap;">INDEX</var>);</p><p class=Pp><code class=Fn>NEXT_OBJECT_INT_LINK_INDEX</code>(<var class=Fa style="white-space: nowrap;">LIST</var>, <var class=Fa style="white-space: nowrap;">OID</var>, <var class=Fa style="white-space: nowrap;">SUB</var>, <var class=Fa style="white-space: nowrap;">LINK</var>, <var class=Fa style="white-space: nowrap;">INDEX</var>);</p><p class=Pp><code class=Fn>INSERT_OBJECT_OID_LINK</code>(<var class=Fa style="white-space: nowrap;">PTR</var>, <var class=Fa style="white-space: nowrap;">LIST</var>, <var class=Fa style="white-space: nowrap;">LINK</var>);</p><p class=Pp><code class=Fn>INSERT_OBJECT_INT_LINK</code>(<var class=Fa style="white-space: nowrap;">PTR</var>, <var class=Fa style="white-space: nowrap;">LIST</var>, <var class=Fa style="white-space: nowrap;">LINK</var>);</p><p class=Pp><code class=Fn>FIND_OBJECT_OID_LINK</code>(<var class=Fa style="white-space: nowrap;">LIST</var>, <var class=Fa style="white-space: nowrap;">OID</var>, <var class=Fa style="white-space: nowrap;">SUB</var>, <var class=Fa style="white-space: nowrap;">LINK</var>);</p><p class=Pp><code class=Fn>FIND_OBJECT_INT_LINK</code>(<var class=Fa style="white-space: nowrap;">LIST</var>, <var class=Fa style="white-space: nowrap;">OID</var>, <var class=Fa style="white-space: nowrap;">SUB</var>, <var class=Fa style="white-space: nowrap;">LINK</var>);</p><p class=Pp><code class=Fn>NEXT_OBJECT_OID_LINK</code>(<var class=Fa style="white-space: nowrap;">LIST</var>, <var class=Fa style="white-space: nowrap;">OID</var>, <var class=Fa style="white-space: nowrap;">SUB</var>, <var class=Fa style="white-space: nowrap;">LINK</var>);</p><p class=Pp><code class=Fn>NEXT_OBJECT_INT_LINK</code>(<var class=Fa style="white-space: nowrap;">LIST</var>, <var class=Fa style="white-space: nowrap;">OID</var>, <var class=Fa style="white-space: nowrap;">SUB</var>, <var class=Fa style="white-space: nowrap;">LINK</var>);</p><p class=Pp><code class=Fn>INSERT_OBJECT_OID</code>(<var class=Fa style="white-space: nowrap;">PTR</var>, <var class=Fa style="white-space: nowrap;">LIST</var>);</p><p class=Pp><code class=Fn>INSERT_OBJECT_INT</code>(<var class=Fa style="white-space: nowrap;">PTR</var>, <var class=Fa style="white-space: nowrap;">LIST</var>);</p><p class=Pp><code class=Fn>FIND_OBJECT_OID</code>(<var class=Fa style="white-space: nowrap;">LIST</var>, <var class=Fa style="white-space: nowrap;">OID</var>, <var class=Fa style="white-space: nowrap;">SUB</var>);</p><p class=Pp><code class=Fn>FIND_OBJECT_INT</code>(<var class=Fa style="white-space: nowrap;">LIST</var>, <var class=Fa style="white-space: nowrap;">OID</var>, <var class=Fa style="white-space: nowrap;">SUB</var>);</p><p class=Pp><code class=Fn>NEXT_OBJECT_OID</code>(<var class=Fa style="white-space: nowrap;">LIST</var>, <var class=Fa style="white-space: nowrap;">OID</var>, <var class=Fa style="white-space: nowrap;">SUB</var>);</p><p class=Pp><code class=Fn>NEXT_OBJECT_INT</code>(<var class=Fa style="white-space: nowrap;">LIST</var>, <var class=Fa style="white-space: nowrap;">OID</var>, <var class=Fa style="white-space: nowrap;">SUB</var>);</p><p class=Pp><var class=Vt>extern uint64_t this_tick</var>; <br><var class=Vt>extern uint64_t start_tick</var>;</p><p class=Pp><var class=Ft>uint64_t</var><br><code class=Fn>get_ticks</code>(<var class=Fa style="white-space: nowrap;">void</var>);</p><p class=Pp><var class=Vt>extern struct systemg systemg</var>;</p><p class=Pp><var class=Ft>u_int</var><br><code class=Fn>comm_define</code>(<var class=Fa style="white-space: nowrap;">u_int priv</var>, <var class=Fa style="white-space: nowrap;">const char *descr</var>, <var class=Fa style="white-space: nowrap;">struct lmodule *mod</var>, <var class=Fa style="white-space: nowrap;">const char *str</var>);</p><p class=Pp><var class=Ft>const char *</var><br><code class=Fn>comm_string</code>(<var class=Fa style="white-space: nowrap;">u_int comm</var>);</p><p class=Pp><var class=Vt>extern u_int community</var>; <br><var class=Vt>extern const struct asn_oid oid_zeroDotZero</var>;</p><p class=Pp><var class=Ft>u_int</var><br><code class=Fn>reqid_allocate</code>(<var class=Fa style="white-space: nowrap;">int size</var>, <var class=Fa style="white-space: nowrap;">struct lmodule *mod</var>);</p><p class=Pp><var class=Ft>int32_t</var><br><code class=Fn>reqid_next</code>(<var class=Fa style="white-space: nowrap;">u_int type</var>);</p><p class=Pp><var class=Ft>int32_t</var><br><code class=Fn>reqid_base</code>(<var class=Fa style="white-space: nowrap;">u_int type</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>reqid_istype</code>(<var class=Fa style="white-space: nowrap;">int32_t reqid</var>, <var class=Fa style="white-space: nowrap;">u_int type</var>);</p><p class=Pp><var class=Ft>u_int</var><br><code class=Fn>reqid_type</code>(<var class=Fa style="white-space: nowrap;">int32_t reqid</var>);</p><p class=Pp><var class=Ft>void *</var><br><code class=Fn>timer_start</code>(<var class=Fa style="white-space: nowrap;">u_int ticks</var>, <var class=Fa style="white-space: nowrap;">void (*func)(void *)</var>, <var class=Fa style="white-space: nowrap;">void *uarg</var>, <var class=Fa style="white-space: nowrap;">struct lmodule *mod</var>);</p><p class=Pp><var class=Ft>void *</var><br><code class=Fn>timer_start_repeat</code>(<var class=Fa style="white-space: nowrap;">u_int ticks</var>, <var class=Fa style="white-space: nowrap;">u_int repeat_ticks</var>, <var class=Fa style="white-space: nowrap;">void (*func)(void *)</var>, <var class=Fa style="white-space: nowrap;">void *uarg</var>, <var class=Fa style="white-space: nowrap;">struct lmodule *mod</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>timer_stop</code>(<var class=Fa style="white-space: nowrap;">void *timer_id</var>);</p><p class=Pp><var class=Ft>void *</var><br><code class=Fn>fd_select</code>(<var class=Fa style="white-space: nowrap;">int fd</var>, <var class=Fa style="white-space: nowrap;">void (*func)(int, void *)</var>, <var class=Fa style="white-space: nowrap;">void *uarg</var>, <var class=Fa style="white-space: nowrap;">struct lmodule *mod</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>fd_deselect</code>(<var class=Fa style="white-space: nowrap;">void *fd_id</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>fd_suspend</code>(<var class=Fa style="white-space: nowrap;">void *fd_id</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>fd_resume</code>(<var class=Fa style="white-space: nowrap;">void *fd_id</var>);</p><p class=Pp><var class=Ft>u_int</var><br><code class=Fn>or_register</code>(<var class=Fa style="white-space: nowrap;">const struct asn_oid *oid</var>, <var class=Fa style="white-space: nowrap;">const char *descr</var>, <var class=Fa style="white-space: nowrap;">struct lmodule *mod</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>or_unregister</code>(<var class=Fa style="white-space: nowrap;">u_int or_id</var>);</p><p class=Pp><var class=Ft>void *</var><br><code class=Fn>buf_alloc</code>(<var class=Fa style="white-space: nowrap;">int tx</var>);</p><p class=Pp><var class=Ft>size_t</var><br><code class=Fn>buf_size</code>(<var class=Fa style="white-space: nowrap;">int tx</var>);</p><p class=Pp><var class=Ft>enum snmpd_input_err</var><br><code class=Fn>snmp_input_start</code>(<var class=Fa>const u_char *buf</var>, <var class=Fa>size_t len</var>, <var class=Fa>const char *source</var>, <var class=Fa>struct snmp_pdu *pdu</var>, <var class=Fa>int32_t *ip</var>, <var class=Fa>size_t *pdulen</var>);</p><p class=Pp><var class=Ft>enum snmpd_input_err</var><br><code class=Fn>snmp_input_finish</code>(<var class=Fa>struct snmp_pdu *pdu</var>, <var class=Fa>const u_char *rcvbuf</var>, <var class=Fa>size_t rcvlen</var>, <var class=Fa>u_char *sndbuf</var>, <var class=Fa>size_t *sndlen</var>, <var class=Fa>const char *source</var>, <var class=Fa>enum snmpd_input_err ierr</var>, <var class=Fa>int32_t ip</var>, <var class=Fa>void *data</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>snmp_output</code>(<var class=Fa>struct snmp_pdu *pdu</var>, <var class=Fa>u_char *sndbuf</var>, <var class=Fa>size_t *sndlen</var>, <var class=Fa>const char *dest</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>snmp_send_port</code>(<var class=Fa>void *trans</var>, <var class=Fa>const struct asn_oid *port</var>, <var class=Fa>struct snmp_pdu *pdu</var>, <var class=Fa>const struct sockaddr *addr</var>, <var class=Fa>socklen_t addrlen</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>snmp_send_trap</code>(<var class=Fa style="white-space: nowrap;">const struct asn_oid *oid</var>, <var class=Fa style="white-space: nowrap;">...</var>);</p><p class=Pp><var class=Ft>enum snmp_code</var><br><code class=Fn>snmp_pdu_auth_access</code>(<var class=Fa style="white-space: nowrap;">struct snmp_pdu *pdu</var>, <var class=Fa style="white-space: nowrap;">int32_t *ip</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>string_save</code>(<var class=Fa style="white-space: nowrap;">struct snmp_value *val</var>, <var class=Fa style="white-space: nowrap;">struct snmp_context *ctx</var>, <var class=Fa style="white-space: nowrap;">ssize_t req_size</var>, <var class=Fa style="white-space: nowrap;">u_char **strp</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>string_commit</code>(<var class=Fa style="white-space: nowrap;">struct snmp_context *ctx</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>string_rollback</code>(<var class=Fa style="white-space: nowrap;">struct snmp_context *ctx</var>, <var class=Fa style="white-space: nowrap;">u_char **strp</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>string_get</code>(<var class=Fa style="white-space: nowrap;">struct snmp_value *val</var>, <var class=Fa style="white-space: nowrap;">const u_char *str</var>, <var class=Fa style="white-space: nowrap;">ssize_t len</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>string_get_max</code>(<var class=Fa style="white-space: nowrap;">struct snmp_value *val</var>, <var class=Fa style="white-space: nowrap;">const u_char *str</var>, <var class=Fa style="white-space: nowrap;">ssize_t len</var>, <var class=Fa style="white-space: nowrap;">size_t maxlen</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>string_free</code>(<var class=Fa style="white-space: nowrap;">struct snmp_context *ctx</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>ip_save</code>(<var class=Fa style="white-space: nowrap;">struct snmp_value *val</var>, <var class=Fa style="white-space: nowrap;">struct snmp_context *ctx</var>, <var class=Fa style="white-space: nowrap;">u_char *ipa</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>ip_rollback</code>(<var class=Fa style="white-space: nowrap;">struct snmp_context *ctx</var>, <var class=Fa style="white-space: nowrap;">u_char *ipa</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>ip_commit</code>(<var class=Fa style="white-space: nowrap;">struct snmp_context *ctx</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>ip_get</code>(<var class=Fa style="white-space: nowrap;">struct snmp_value *val</var>, <var class=Fa style="white-space: nowrap;">u_char *ipa</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>oid_save</code>(<var class=Fa style="white-space: nowrap;">struct snmp_value *val</var>, <var class=Fa style="white-space: nowrap;">struct snmp_context *ctx</var>, <var class=Fa style="white-space: nowrap;">struct asn_oid *oid</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>oid_rollback</code>(<var class=Fa style="white-space: nowrap;">struct snmp_context *ctx</var>, <var class=Fa style="white-space: nowrap;">struct asn_oid *oid</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>oid_commit</code>(<var class=Fa style="white-space: nowrap;">struct snmp_context *ctx</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>oid_get</code>(<var class=Fa style="white-space: nowrap;">struct snmp_value *val</var>, <var class=Fa style="white-space: nowrap;">const struct asn_oid *oid</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>index_decode</code>(<var class=Fa style="white-space: nowrap;">const struct asn_oid *oid</var>, <var class=Fa style="white-space: nowrap;">u_int sub</var>, <var class=Fa style="white-space: nowrap;">u_int code</var>, <var class=Fa style="white-space: nowrap;">...</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>index_compare</code>(<var class=Fa style="white-space: nowrap;">const struct asn_oid *oid1</var>, <var class=Fa style="white-space: nowrap;">u_int sub</var>, <var class=Fa style="white-space: nowrap;">const struct asn_oid *oid2</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>index_compare_off</code>(<var class=Fa style="white-space: nowrap;">const struct asn_oid *oid1</var>, <var class=Fa style="white-space: nowrap;">u_int sub</var>, <var class=Fa style="white-space: nowrap;">const struct asn_oid *oid2</var>, <var class=Fa style="white-space: nowrap;">u_int off</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>index_append</code>(<var class=Fa style="white-space: nowrap;">struct asn_oid *dst</var>, <var class=Fa style="white-space: nowrap;">u_int sub</var>, <var class=Fa style="white-space: nowrap;">const struct asn_oid *src</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>index_append_off</code>(<var class=Fa style="white-space: nowrap;">struct asn_oid *dst</var>, <var class=Fa style="white-space: nowrap;">u_int sub</var>, <var class=Fa style="white-space: nowrap;">const struct asn_oid *src</var>, <var class=Fa style="white-space: nowrap;">u_int off</var>);</p><p class=Pp><var class=Vt>extern struct snmpd_usmstat snmpd_usmstats</var>;</p><p class=Pp><var class=Ft>struct snmpd_usmstat *</var><br><code class=Fn>bsnmpd_get_usm_stats</code>(<var class=Fa style="white-space: nowrap;">void</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>bsnmpd_reset_usm_stats</code>(<var class=Fa style="white-space: nowrap;">void</var>);</p><p class=Pp><var class=Ft>struct usm_user *</var><br><code class=Fn>usm_first_user</code>(<var class=Fa style="white-space: nowrap;">void</var>);</p><p class=Pp><var class=Ft>struct usm_user *</var><br><code class=Fn>usm_next_user</code>(<var class=Fa style="white-space: nowrap;">struct usm_user *uuser</var>);</p><p class=Pp><var class=Ft>struct usm_user *</var><br><code class=Fn>usm_find_user</code>(<var class=Fa style="white-space: nowrap;">uint8_t *engine</var>, <var class=Fa style="white-space: nowrap;">uint32_t elen</var>, <var class=Fa style="white-space: nowrap;">char *uname</var>);</p><p class=Pp><var class=Ft>struct usm_user *</var><br><code class=Fn>usm_new_user</code>(<var class=Fa style="white-space: nowrap;">uint8_t *engine</var>, <var class=Fa style="white-space: nowrap;">uint32_t elen</var>, <var class=Fa style="white-space: nowrap;">char *uname</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>usm_delete_user</code>(<var class=Fa style="white-space: nowrap;">struct usm_user *</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>usm_flush_users</code>(<var class=Fa style="white-space: nowrap;">void</var>);</p><p class=Pp><var class=Vt>extern struct usm_user *usm_user;</var></p><p class=Pp><var class=Ft>struct snmpd_target_stats *</var><br><code class=Fn>bsnmpd_get_target_stats</code>(<var class=Fa style="white-space: nowrap;">void</var>);</p><p class=Pp><var class=Ft>struct target_address *</var><br><code class=Fn>target_first_address</code>(<var class=Fa style="white-space: nowrap;">void</var>);</p><p class=Pp><var class=Ft>struct target_address *</var><br><code class=Fn>target_next_address</code>(<var class=Fa style="white-space: nowrap;">struct target_address *</var>);</p><p class=Pp><var class=Ft>struct target_address *</var><br><code class=Fn>target_new_address</code>(<var class=Fa style="white-space: nowrap;">char *</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>target_activate_address</code>(<var class=Fa style="white-space: nowrap;">struct target_address *</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>target_delete_address</code>(<var class=Fa style="white-space: nowrap;">struct target_address *</var>);</p><p class=Pp><var class=Ft>struct target_param *</var><br><code class=Fn>target_first_param</code>(<var class=Fa style="white-space: nowrap;">void</var>);</p><p class=Pp><var class=Ft>struct target_param *</var><br><code class=Fn>target_next_param</code>(<var class=Fa style="white-space: nowrap;">struct target_param *</var>);</p><p class=Pp><var class=Ft>struct target_param *</var><br><code class=Fn>target_new_param</code>(<var class=Fa style="white-space: nowrap;">char *</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>target_delete_param</code>(<var class=Fa style="white-space: nowrap;">struct target_param *</var>);</p><p class=Pp><var class=Ft>struct target_notify *</var><br><code class=Fn>target_first_notify</code>(<var class=Fa style="white-space: nowrap;">void</var>);</p><p class=Pp><var class=Ft>struct target_notify *</var><br><code class=Fn>target_next_notify</code>(<var class=Fa style="white-space: nowrap;">struct target_notify *</var>);</p><p class=Pp><var class=Ft>struct target_notify *</var><br><code class=Fn>target_new_notify</code>(<var class=Fa style="white-space: nowrap;">char *</var>);</p><p class=Pp><var class=Ft>int</var><br><code class=Fn>target_delete_notify</code>(<var class=Fa style="white-space: nowrap;">struct target_notify *</var>);</p><p class=Pp><var class=Ft>void</var><br><code class=Fn>target_flush_all</code>(<var class=Fa style="white-space: nowrap;">void</var>);</p><p class=Pp><var class=Vt>extern const struct asn_oid oid_usmUnknownEngineIDs;</var><br><var class=Vt>extern const struct asn_oid oid_usmNotInTimeWindows;</var></p></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> The <a class=Xr href=bsnmpd.1.html>bsnmpd(1)</a> SNMP daemon implements a minimal MIB which consists of the system group, part of the SNMP MIB, a private configuration MIB, a trap destination table, a UDP port table, a community table, a module table, a statistics group and a debugging group. All other MIBs are support through loadable modules. This allows <a class=Xr href=bsnmpd.1.html>bsnmpd(1)</a> to use for task, that are not the classical SNMP task. <section class=Ss><h2 class=Ss id=MODULE_LOADING_AND_UNLOADING><a class=permalink href=#MODULE_LOADING_AND_UNLOADING>MODULE LOADING AND UNLOADING</a></h2> Modules are loaded by writing to the module table. This table is indexed by a string, that identifies the module to the daemon. This identifier is used to select the correct configuration section from the configuration files and to identify resources allocated to this module. A row in the module table is created by writing a string of non-zero length to the <var class=Va>begemotSnmpdModulePath</var> column. This string must be the complete path to the file containing the module. A module can be unloaded by writing a zero length string to the path column of an existing row. <p class=Pp>Modules may depend on each other an hence must be loaded in the correct order. The dependencies are listed in the corresponding manual pages.</p><p class=Pp>Upon loading a module the SNMP daemon expects the module file to a export a global symbol <var class=Va>config</var>. This symbol should be a variable of type <var class=Vt>struct snmp_module</var>:</p><div class="Bd Pp Bd-indent"><pre>
typedef enum snmpd_proxy_err (*proxy_err_f)(struct snmp_pdu *, void *,
    const struct asn_oid *, const struct sockaddr *, socklen_t,
    enum snmpd_input_err, int32_t);


struct snmp_module {
	const char *comment;
	int (*init)(struct lmodule *, int argc, char *argv[]);
	int (*fini)(void);
	void (*idle)(void);
	void (*dump)(void);
	void (*config)(void);
	void (*start)(void);
	proxy_err_f proxy;
	const struct snmp_node *tree;
	u_int tree_size;
	void (*loading)(const struct lmodule *, int);
};
</pre></div><p class=Pp>This structure must be statically initialized and its fields have the following functions:</p><dl class=Bl-tag><dt><var class=Va>comment</var></dt><dd>This is a string that will be visible in the module table. It should give some hint about the function of this module.</dd><dt><var class=Va>init</var></dt><dd>This function is called upon loading the module. The module pointer should be stored by the module because it is needed in other calls and the argument vector will contain the arguments to this module from the daemons command line. This function should return 0 if everything is ok or an UNIX error code (see <a class=Xr href=errno.3.html>errno(3)</a>). Once the function returns 0, the <var class=Va>fini</var> function is called when the module is unloaded.</dd><dt><var class=Va>fini</var></dt><dd>The module is unloaded. This gives the module a chance to free resources that are not automatically freed. Be sure to free all memory, because daemons tend to run very long. This function pointer may be <code class=Li>NULL</code> if it is not needed.</dd><dt><var class=Va>idle</var></dt><dd>If this function pointer is not <code class=Li>NULL</code>, the function pointed to by it is called whenever the daemon is going to wait for an event. Try to avoid using this feature.</dd><dt><var class=Va>dump</var></dt><dd>Whenever the daemon receives a <code class=Li>SIGUSR1</code> it dumps it internal state via <a class=Xr href=syslog.3.html>syslog(3)</a>. If the <var class=Va>dump</var> field is not <code class=Li>NULL</code> it is called by the daemon to dump the state of the module.</dd><dt><var class=Va>config</var></dt><dd>Whenever the daemon receives a <code class=Li>SIGHUP</code> signal it re-reads its configuration file. If the <var class=Va>config</var> field is not <code class=Li>NULL</code> it is called after reading the configuration file to give the module a chance to adapt to the new configuration.</dd><dt><var class=Va>start</var></dt><dd>If not <code class=Li>NULL</code> this function is called after successful loading and initializing the module to start its actual operation.</dd><dt><var class=Va>proxy</var></dt><dd>If the daemon receives a PDU and that PDU has a community string whose community was registered by this module and <var class=Va>proxy</var> is not <code class=Li>NULL</code> than this function is called to handle the PDU.</dd><dt><var class=Va>tree</var></dt><dd>This is a pointer to the node array for the MIB tree implemented by this module.</dd><dt><var class=Va>tree_size</var></dt><dd>This is the number of nodes in <var class=Va>tree</var>.</dd><dt><var class=Va>loading</var></dt><dd>If this pointer is not <code class=Li>NULL</code> it is called whenever another module was loaded or unloaded. It gets a pointer to that module and a flag that is 0 for unloading and 1 for loading.</dd></dl><p class=Pp>When everything is ok, the daemon merges the module's MIB tree into its current global tree, calls the modules <code class=Fn>init</code>() function. If this function returns an error, the modules MIB tree is removed from the global one and the module is unloaded. If initialization is successful, the modules <code class=Fn>start</code>() function is called. After it returns the <code class=Fn>loaded</code>() functions of all modules (including the loaded one) are called.</p><p class=Pp>When the module is unloaded, its MIB tree is removed from the global one, the communities, request id ranges, running timers and selected file descriptors are released, the <code class=Fn>fini</code>() function is called, the module file is unloaded and the <code class=Fn>loaded</code>() functions of all other modules are called.</p></section><section class=Ss><h2 class=Ss id=IMPLEMENTING_TABLES><a class=permalink href=#IMPLEMENTING_TABLES>IMPLEMENTING TABLES</a></h2> There are a number of macros designed to help implementing SNMP tables. A problem while implementing a table is the support for the GETNEXT operator. The GETNEXT operation has to find out whether, given an arbitrary OID, the lessest table row, that has an OID higher than the given OID. The easiest way to do this is to keep the table as an ordered list of structures each one of which contains an OID that is the index of the table row. This allows easy removal, insertion and search. <p class=Pp>The helper macros assume, that the table is organized as a TAILQ (see <a class=Xr href=queue.3.html>queue(3)</a> and each structure contains a <var class=Vt>struct asn_oid</var> that is used as index. For simple tables with only a integer or unsigned index, an alternate form of the macros is available, that presume the existence of an integer or unsigned field as index field.</p><p class=Pp>The macros have name of the form</p><div class="Bd Pp Bd-indent"><pre>
{INSERT,FIND,NEXT}_OBJECT_{OID,INT}[_LINK[_INDEX]]
</pre></div><p class=Pp>The <code class=Fn>INSERT_*</code>() macros are used in the SET operation to insert a new table row into the table. The <code class=Fn>FIND_*</code>() macros are used in the GET operation to find a specific row in the table. The <code class=Fn>NEXT_*</code>() macros are used in the GETNEXT operation to find the next row in the table. The last two macros return a pointer to the row structure if a row is found, <code class=Li>NULL</code> otherwise. The macros <code class=Fn>*_OBJECT_OID_*</code>() assume the existence of a <var class=Vt>struct asn_oid</var> that is used as index, the macros <code class=Fn>*_OBJECT_INT_*</code>() assume the existence of an unsigned integer field that is used as index.</p><p class=Pp>The macros <code class=Fn>*_INDEX</code>() allow the explicit naming of the index field in the parameter <var class=Fa>INDEX</var>, whereas the other macros assume that this field is named <var class=Va>index</var>. The macros <code class=Fn>*_LINK_*</code>() allow the explicit naming of the link field of the tail queues, the others assume that the link field is named <var class=Va>link</var>. Explicitly naming the link field may be necessary if the same structures are held in two or more different tables.</p><p class=Pp>The arguments to the macros are as follows:</p><dl class=Bl-tag><dt><var class=Fa>PTR</var></dt><dd>A pointer to the new structure to be inserted into the table.</dd><dt><var class=Fa>LIST</var></dt><dd>A pointer to the tail queue head.</dd><dt><var class=Fa>LINK</var></dt><dd>The name of the link field in the row structure.</dd><dt><var class=Fa>INDEX</var></dt><dd>The name of the index field in the row structure.</dd><dt><var class=Fa>OID</var></dt><dd>Must point to the <var class=Va>var</var> field of the <var class=Fa>value</var> argument to the node operation callback. This is the OID to search for.</dd><dt><var class=Fa>SUB</var></dt><dd>This is the index of the start of the table index in the OID pointed to by <var class=Fa>OID</var>. This is usually the same as the <var class=Fa>sub</var> argument to the node operation callback.</dd></dl></section><section class=Ss><h2 class=Ss id=DAEMON_TIMESTAMPS><a class=permalink href=#DAEMON_TIMESTAMPS>DAEMON TIMESTAMPS</a></h2> The variable <var class=Va>this_tick</var> contains the tick (there are 100 SNMP ticks in a second) when the current PDU processing was started. The variable <var class=Va>start_tick</var> contains the tick when the daemon was started. The function <code class=Fn>get_ticks</code>() returns the current tick. The number of ticks since the daemon was started is <div class="Bd Pp Bd-indent"><pre>
get_ticks() - start_tick
</pre></div></section><section class=Ss><h2 class=Ss id=THE_SYSTEM_GROUP><a class=permalink href=#THE_SYSTEM_GROUP>THE SYSTEM GROUP</a></h2> The scalar fields of the system group are held in the global variable <var class=Va>systemg</var>: <div class="Bd Pp Bd-indent"><pre>
struct systemg {
	u_char		*descr;
	struct asn_oid	object_id;
	u_char		*contact;
	u_char		*name;
	u_char		*location;
	uint32_t	services;
	uint32_t	or_last_change;
};
</pre></div></section><section class=Ss><h2 class=Ss id=COMMUNITIES><a class=permalink href=#COMMUNITIES>COMMUNITIES</a></h2> The SNMP daemon implements a community table. On recipte of a request message the community string in that message is compared to each of the community strings in that table, if a match is found, the global variable <var class=Va>community</var> is set to the community identifier for that community. Community identifiers are unsigned integers. For the three standard communities there are three constants defined: <div class="Bd Pp Bd-indent"><pre>
#define COMM_INITIALIZE	0
#define COMM_READ	1
#define COMM_WRITE	2
</pre></div><p class=Pp><var class=Va>community</var> is set to <code class=Li>COMM_INITIALIZE</code> while the assignments in the configuration file are processed. To <code class=Li>COMM_READ</code> or <code class=Li>COMM_WRITE</code> when the community strings for the read-write or read-only community are found in the incoming PDU.</p><p class=Pp>Modules can define additional communities. This may be necessary to provide transport proxying (a PDU received on one communication link is proxied to another link) or to implement non-UDP access points to SNMP. A new community is defined with the function <code class=Fn>comm_define</code>(). It takes the following parameters:</p><dl class=Bl-tag><dt><var class=Fa>priv</var></dt><dd>This is an integer identifying the community to the module. Each module has its own namespace with regard to this parameter. The community table is indexed with the module name and this identifier.</dd><dt><var class=Fa>descr</var></dt><dd>This is a string providing a human readable description of the community. It is visible in the community table.</dd><dt><var class=Fa>mod</var></dt><dd>This is the module defining the community.</dd><dt><var class=Fa>str</var></dt><dd>This is the initial community string.</dd></dl><p class=Pp>The function returns a globally unique community identifier. If a SNMPv1 or SNMPv2 PDU is received who's community string matches, this identifier is set into the global <var class=Va>community</var>.</p><p class=Pp>The function <code class=Fn>comm_string</code>() returns the current community string for the given community.</p><p class=Pp>All communities defined by a module are automatically released when the module is unloaded.</p></section><section class=Ss><h2 class=Ss id=THE_USER_BASED_SECURITY_GROUP><a class=permalink href=#THE_USER_BASED_SECURITY_GROUP>THE USER-BASED SECURITY GROUP</a></h2> The scalar statistics of the USM group are held in the global variable <var class=Va>snmpd_usmstats</var>: <div class="Bd Pp Bd-indent"><pre>
struct snmpd_usmstat {
	uint32_t	unsupported_seclevels;
	uint32_t	not_in_time_windows;
	uint32_t	unknown_users;
	uint32_t	unknown_engine_ids;
	uint32_t	wrong_digests;
	uint32_t	decrypt_errors;
};
</pre></div><code class=Fn>bsnmpd_get_usm_stats</code>() returns a pointer to the global structure containing the statistics. <code class=Fn>bsnmpd_reset_usm_stats</code>() clears the statistics of the USM group. <p class=Pp>A global list of configured USM users is maintained by the daemon.</p><div class="Bd Pp Bd-indent"><pre>
struct usm_user {
	struct snmp_user		suser;
	uint8_t				user_engine_id[SNMP_ENGINE_ID_SIZ];
	uint32_t			user_engine_len;
	char				user_public[SNMP_ADM_STR32_SIZ];
	uint32_t			user_public_len;
	int32_t				status;
	int32_t				type;
	SLIST_ENTRY(usm_user)		up;
};
</pre></div> This structure represents an USM user. The daemon only responds to SNMPv3 PDUs with user credentials matching an USM user entry in its global list. If a SNMPv3 PDU is received, whose security model is USM, the global <var class=Va>usm_user</var> is set to point at the user entry that matches the credentials contained in the PDU. However, the daemon does not create or remove USM users, it gives an interface to external loadable module(s) to manage the list. <code class=Fn>usm_new_user</code>() adds an user entry in the list, and <code class=Fn>usm_delete_user</code>() deletes an existing entry from the list. <code class=Fn>usm_flush_users</code>() is used to remove all configured USM users. <code class=Fn>usm_first_user</code>() will return the first user in the list, or <code class=Li>NULL</code> if the list is empty. <code class=Fn>usm_next_user</code>() will return the next user of a given entry if one exists, or <code class=Li>NULL</code>. The list is sorted according to the USM user name and Engine ID. <code class=Fn>usm_find_user</code>() returns the USM user entry matching the given <var class=Fa>engine</var> and <var class=Fa>uname</var> or <code class=Li>NULL</code> if an user with the specified name and engine id is not present in the list. </section><section class=Ss><h2 class=Ss id=THE_MANAGEMENT_TARGET_GROUP><a class=permalink href=#THE_MANAGEMENT_TARGET_GROUP>THE MANAGEMENT TARGET GROUP</a></h2> The Management Target group holds target address information used when sending SNMPv3 notifications. <p class=Pp>The scalar statistics of the Management Target group are held in the global variable <var class=Va>snmpd_target_stats</var>:</p><div class="Bd Pp Bd-indent"><pre>
struct snmpd_target_stats {
	uint32_t			unavail_contexts;
	uint32_t			unknown_contexts;
};
</pre></div><code class=Fn>bsnmpd_get_target_stats</code>() returns a pointer to the global structure containing the statistics. <p class=Pp>Three global lists of configured management target addresses, parameters and notifications respectively are maintained by the daemon.</p><div class="Bd Pp Bd-indent"><pre>
struct target_address {
	char				name[SNMP_ADM_STR32_SIZ];
	uint8_t				address[SNMP_UDP_ADDR_SIZ];
	int32_t				timeout;
	int32_t				retry;
	char				taglist[SNMP_TAG_SIZ];
	char				paramname[SNMP_ADM_STR32_SIZ];
	int32_t				type;
	int32_t				socket;
	int32_t				status;
	SLIST_ENTRY(target_address)	ta;
};
</pre></div> This structure represents a SNMPv3 Management Target address. Each time a SNMP TRAP is send the daemon will send the Trap to all active Management Target addresses in its global list. <div class="Bd Pp Bd-indent"><pre>
struct target_param {
	char				name[SNMP_ADM_STR32_SIZ];
	int32_t				mpmodel;
	int32_t				sec_model;
	char				secname[SNMP_ADM_STR32_SIZ];
	enum snmp_usm_level		sec_level;
	int32_t				type;
	int32_t				status;
	SLIST_ENTRY(target_param)	tp;
};
</pre></div> This structure represents the information used to generate SNMP messages to the associated SNMPv3 Management Target addresses. <div class="Bd Pp Bd-indent"><pre>
struct target_notify {
	char				name[SNMP_ADM_STR32_SIZ];
	char				taglist[SNMP_TAG_SIZ];
	int32_t				notify_type;
	int32_t				type;
	int32_t				status;
	SLIST_ENTRY(target_notify)	tn;
};
</pre></div> This structure represents Notification Tag entries - SNMP notifications are sent to the Target address for each entry in the Management Target Address list that has a tag matching the specified tag in this structure. <p class=Pp>The daemon does not create or remove entries in the Management Target group lists, it gives an interface to external loadable module(s) to manage the lists. <code class=Fn>target_new_address</code>() adds a target address entry, and <code class=Fn>target_delete_address</code>() deletes an existing entry from the target address list. <code class=Fn>target_activate_address</code>() creates a socket associated with the target address entry so that SNMP notifications may actually be send to that target address. <code class=Fn>target_first_address</code>() will return a pointer to the first target address entry in the list, while <code class=Fn>target_next_address</code>() will return a pointer to the next target address of a given entry if one exists. <code class=Fn>target_new_param</code>() adds a target parameters' entry, and <code class=Fn>target_delete_param</code>() deletes an existing entry from the target parameters list. <code class=Fn>target_first_param</code>() will return a pointer to the first target parameters' entry in the list, while <code class=Fn>target_next_param</code>() will return a pointer to the next target parameters of a given entry if one exists. <code class=Fn>target_new_notify</code>() adds a notification target entry, and <code class=Fn>target_delete_notify</code>() deletes an existing entry from the notification target list. <code class=Fn>target_first_notify</code>() will return a pointer to the first notification target entry in the list, while <code class=Fn>target_next_notify</code>() will return a pointer to the next notification target of a given entry if one exists. <code class=Fn>target_flush_all</code>() is used to remove all configured data from the three global Management Target Group lists.</p></section><section class=Ss><h2 class=Ss id=WELL_KNOWN_OIDS><a class=permalink href=#WELL_KNOWN_OIDS>WELL KNOWN OIDS</a></h2> The global variable <var class=Va>oid_zeroDotZero</var> contains the OID 0.0. The global variables <var class=Va>oid_usmUnknownEngineIDs</var><var class=Va>oid_usmNotInTimeWindows</var> contains the OIDs 1.3.6.1.6.3.15.1.1.4.0 and 1.3.6.1.6.3.15.1.1.2.0 used in the SNMPv3 USM Engine Discovery. </section><section class=Ss><h2 class=Ss id=REQUEST_ID_RANGES><a class=permalink href=#REQUEST_ID_RANGES>REQUEST ID RANGES</a></h2> For modules that implement SNMP client functions besides SNMP agent functions it may be necessary to identify SNMP requests by their identifier to allow easier routing of responses to the correct sub-system. Request id ranges provide a way to acquire globally non-overlapping sub-ranges of the entire 31-bit id range. <p class=Pp>A request id range is allocated with <code class=Fn>reqid_allocate</code>(). The arguments are: the size of the range and the module allocating the range. For example, the call</p><div class="Bd Pp Bd-indent"><pre>
id = reqid_allocate(1000, module);
</pre></div><p class=Pp>allocates a range of 1000 request ids. The function returns the request id range identifier or 0 if there is not enough identifier space. The function <code class=Fn>reqid_base</code>() returns the lowest request id in the given range.</p><p class=Pp>Request id are allocated starting at the lowest one linear throughout the range. If the client application may have a lot of outstanding request the range must be large enough so that an id is not reused until it is really expired. <code class=Fn>reqid_next</code>() returns the sequentially next id in the range.</p><p class=Pp>The function <code class=Fn>reqid_istype</code>() checks whether the request id <var class=Fa>reqid</var> is within the range identified by <var class=Fa>type</var>. The function <code class=Fn>reqid_type</code>() returns the range identifier for the given <var class=Fa>reqid</var> or 0 if the request id is in none of the ranges.</p></section><section class=Ss><h2 class=Ss id=TIMERS><a class=permalink href=#TIMERS>TIMERS</a></h2> The SNMP daemon supports an arbitrary number of timers with SNMP tick granularity. The function <code class=Fn>timer_start</code>() arranges for the callback <var class=Fa>func</var> to be called with the argument <var class=Fa>uarg</var> after <var class=Fa>ticks</var> SNMP ticks have expired. <var class=Fa>mod</var> is the module that starts the timer. These timers are one-shot, they are not restarted. Repeatable timers are started with <code class=Fn>timer_start_repeat</code>() which takes an additional argument <var class=Fa>repeat_ticks</var>. The argument <var class=Fa>ticks</var> gives the number of ticks until the first execution of the callback, while <var class=Fa>repeat_ticks</var> is the number of ticks between invocations of the callback. Note, that currently the number of initial ticks silently may be set identical to the number of ticks between callback invocations. The function returns a timer identifier that can be used to stop the timer via <code class=Fn>timer_stop</code>(). If a module is unloaded all timers started by the module that have not expired yet are stopped. </section><section class=Ss><h2 class=Ss id=FILE_DESCRIPTOR_SUPPORT><a class=permalink href=#FILE_DESCRIPTOR_SUPPORT>FILE DESCRIPTOR SUPPORT</a></h2> A module may need to get input from socket file descriptors without blocking the daemon (for example to implement alternative SNMP transports). <p class=Pp>The function <code class=Fn>fd_select</code>() causes the callback function <var class=Fa>func</var> to be called with the file descriptor <var class=Fa>fd</var> and the user argument <var class=Fa>uarg</var> whenever the file descriptor <var class=Fa>fd</var> can be read or has a close condition. If the file descriptor is not in non-blocking mode, it is set to non-blocking mode. If the callback is not needed anymore, <code class=Fn>fd_deselect</code>() may be called with the value returned from <code class=Fn>fd_select</code>(). All file descriptors selected by a module are automatically deselected when the module is unloaded.</p><p class=Pp>To temporarily suspend the file descriptor registration <code class=Fn>fd_suspend</code>() can be called. This also causes the file descriptor to be switched back to blocking mode if it was blocking prior the call to <code class=Fn>fd_select</code>(). This is necessary to do synchronous input on a selected socket. The effect of <code class=Fn>fd_suspend</code>() can be undone with <code class=Fn>fd_resume</code>().</p></section><section class=Ss><h2 class=Ss id=OBJECT_RESOURCES><a class=permalink href=#OBJECT_RESOURCES>OBJECT RESOURCES</a></h2> The system group contains an object resource table. A module may create an entry in this table by calling <code class=Fn>or_register</code>() with the <var class=Fa>oid</var> to be registered, a textual description in <var class=Fa>str</var> and a pointer to the module <var class=Fa>mod</var>. The registration can be removed with <code class=Fn>or_unregister</code>(). All registrations of a module are automatically removed if the module is unloaded. </section><section class=Ss><h2 class=Ss id=TRANSMIT_AND_RECEIVE_BUFFERS><a class=permalink href=#TRANSMIT_AND_RECEIVE_BUFFERS>TRANSMIT AND RECEIVE BUFFERS</a></h2> A buffer is allocated via <code class=Fn>buf_alloc</code>(). The argument must be 1 for transmit and 0 for receive buffers. The function may return <code class=Li>NULL</code> if there is no memory available. The current buffersize can be obtained with <code class=Fn>buf_size</code>(). </section></section><section class=Sh><h2 class=Sh id=PROCESSING_PDUS><a class=permalink href=#PROCESSING_PDUS>PROCESSING PDUS</a></h2> For modules that need to do their own PDU processing (for example for proxying) the following functions are available: <p class=Pp>Function <code class=Fn>snmp_input_start</code>() decodes the PDU, searches the community, and sets the global <var class=Va>this_tick</var>. It returns one of the following error codes:</p><dl class=Bl-tag><dt><code class=Er>SNMPD_INPUT_OK</code></dt><dd>Everything ok, continue with processing.</dd><dt><code class=Er>SNMPD_INPUT_FAILED</code></dt><dd>The PDU could not be decoded, has a wrong version or an unknown community string.</dd><dt><code class=Er>SNMPD_INPUT_VALBADLEN</code></dt><dd>A SET PDU had a value field in a binding with a wrong length field in an ASN.1 header.</dd><dt><code class=Er>SNMPD_INPUT_VALRANGE</code></dt><dd>A SET PDU had a value field in a binding with a value that is out of range for the given ASN.1 type.</dd><dt><code class=Er>SNMPD_INPUT_VALBADENC</code></dt><dd>A SET PDU had a value field in a binding with wrong ASN.1 encoding.</dd><dt><code class=Er>SNMPD_INPUT_TRUNC</code></dt><dd>The buffer appears to contain a valid begin of a PDU, but is too short. For streaming transports this means that the caller must save what he already has and trying to obtain more input and reissue this input to the function. For datagram transports this means that part of the datagram was lost and the input should be ignored.</dd></dl><p class=Pp>The function <code class=Fn>snmp_input_finish</code>() does the other half of processing: if <code class=Fn>snmp_input_start</code>() did not return OK, tries to construct an error response. If the start was OK, it calls the correct function from <a class=Xr href=bsnmpagent.3.html>bsnmpagent(3)</a> to execute the request and depending on the outcome constructs a response or error response PDU or ignores the request PDU. It returns either <code class=Er>SNMPD_INPUT_OK</code> or <code class=Er>SNMPD_INPUT_FAILED</code>. In the first case a response PDU was constructed and should be sent.</p><p class=Pp>The function <code class=Fn>snmp_output</code>() takes a PDU and encodes it.</p><p class=Pp>The function <code class=Fn>snmp_send_port</code>() takes a PDU, encodes it and sends it through the given port (identified by the transport and the index in the port table) to the given address.</p><p class=Pp>The function <code class=Fn>snmp_send_trap</code>() sends a trap to all trap destinations. The arguments are the <var class=Fa>oid</var> identifying the trap and a NULL-terminated list of <var class=Vt>struct snmp_value</var> pointers that are to be inserted into the trap binding list. <code class=Fn>snmp_pdu_auth_access</code>() verifies whether access to the object IDs contained in the <var class=Fa>pdu</var><br> should be granted or denied, according to the configured View-Based Access rules. <var class=Fa>ip</var> contains the index of the first varbinding to which access was denied, or 0 if access to all varbindings in the PDU is granted.</p><section class=Ss><h2 class=Ss id=SIMPLE_ACTION_SUPPORT><a class=permalink href=#SIMPLE_ACTION_SUPPORT>SIMPLE ACTION SUPPORT</a></h2> For simple scalar variables that need no dependencies a number of support functions is available to handle the set, commit, rollback and get. <p class=Pp>The following functions are used for OCTET STRING scalars, either NUL terminated or not:</p><dl class=Bl-tag><dt><code class=Fn>string_save</code>()</dt><dd>should be called for SNMP_OP_SET. <var class=Fa>value</var> and <var class=Fa>ctx</var> are the resp. arguments to the node callback. <var class=Fa>valp</var> is a pointer to the pointer that holds the current value and <var class=Fa>req_size</var> should be -1 if any size of the string is acceptable or a number larger or equal zero if the string must have a specific size. The function saves the old value in the scratch area (note, that any initial value must have been allocated by <a class=Xr href=malloc.3.html>malloc(3)</a>), allocates a new string, copies over the new value, NUL-terminates it and sets the new current value.</dd><dt><code class=Fn>string_commit</code>()</dt><dd>simply frees the saved old value in the scratch area.</dd><dt><code class=Fn>string_rollback</code>()</dt><dd>frees the new value, and puts back the old one.</dd><dt><code class=Fn>string_get</code>()</dt><dd>is used for GET or GETNEXT. The function</dd><dt><code class=Fn>string_get_max</code>()</dt><dd>can be used instead of <code class=Fn>string_get</code>() to ensure that the returned string has a certain maximum length. If <var class=Fa>len</var> is -1, the length is computed via <a class=Xr href=strlen.3.html>strlen(3)</a> from the current string value. If the current value is NULL, a OCTET STRING of zero length is returned.</dd><dt><code class=Fn>string_free</code>()</dt><dd>must be called if either rollback or commit fails to free the saved old value.</dd></dl><p class=Pp>The following functions are used to process scalars of type IP-address:</p><dl class=Bl-tag><dt><code class=Fn>ip_save</code>()</dt><dd>Saves the current value in the scratch area and sets the new value from <var class=Fa>valp</var>.</dd><dt><code class=Fn>ip_commit</code>()</dt><dd>Does nothing.</dd><dt><code class=Fn>ip_rollback</code>()</dt><dd>Restores the old IP address from the scratch area.</dd><dt><code class=Fn>ip_get</code>()</dt><dd>Retrieves the IP current address.</dd></dl><p class=Pp>The following functions handle OID-typed variables:</p><dl class=Bl-tag><dt><code class=Fn>oid_save</code>()</dt><dd>Saves the current value in the scratch area by allocating a <var class=Vt>struct asn_oid</var> with <a class=Xr href=malloc.3.html>malloc(3)</a> and sets the new value from <var class=Fa>oid</var>.</dd><dt><code class=Fn>oid_commit</code>()</dt><dd>Frees the old value in the scratch area.</dd><dt><code class=Fn>oid_rollback</code>()</dt><dd>Restores the old OID from the scratch area and frees the old OID.</dd><dt><code class=Fn>oid_get</code>()</dt><dd>Retrieves the OID</dd></dl></section><section class=Ss><h2 class=Ss id=TABLE_INDEX_HANDLING><a class=permalink href=#TABLE_INDEX_HANDLING>TABLE INDEX HANDLING</a></h2> The following functions help in handling table indexes: <dl class=Bl-tag><dt><code class=Fn>index_decode</code>()</dt><dd>Decodes the index part of the OID. The parameter <var class=Fa>oid</var> must be a pointer to the <var class=Va>var</var> field of the <var class=Fa>value</var> argument of the node callback. The <var class=Fa>sub</var> argument must be the index of the start of the index in the OID (this is the <var class=Fa>sub</var> argument to the node callback). <var class=Fa>code</var> is the index expression (parameter <var class=Fa>idx</var> to the node callback). These parameters are followed by parameters depending on the syntax of the index elements as follows: <dl class=Bl-tag><dt><a class=permalink href=#INTEGER><code class=Li id=INTEGER>INTEGER</code></a></dt><dd><var class=Vt>int32_t *</var> expected as argument.</dd><dt><a class=permalink href=#COUNTER64><code class=Li id=COUNTER64>COUNTER64</code></a></dt><dd><var class=Vt>uint64_t *</var> expected as argument. Note, that this syntax is illegal for indexes.</dd><dt><a class=permalink href=#OCTET_STRING><code class=Li id=OCTET_STRING>OCTET STRING</code></a></dt><dd>A <var class=Vt>u_char **</var> and a <var class=Vt>size_t *</var> expected as arguments. A buffer is allocated to hold the decoded string.</dd><dt><a class=permalink href=#OID><code class=Li id=OID>OID</code></a></dt><dd>A <var class=Vt>struct asn_oid *</var> is expected as argument.</dd><dt><a class=permalink href=#IP_ADDRESS><code class=Li id=IP_ADDRESS>IP ADDRESS</code></a></dt><dd>A <var class=Vt>u_int8_t *</var> expected as argument that points to a buffer of at least four byte.</dd><dt><a class=permalink href=#COUNTER,_GAUGE,_TIMETICKS><code class=Li id=COUNTER,_GAUGE,_TIMETICKS>COUNTER, GAUGE, TIMETICKS</code></a></dt><dd>A <var class=Vt>u_int32_t</var> expected.</dd><dt><a class=permalink href=#NULL><code class=Li id=NULL>NULL</code></a></dt><dd>No argument expected.</dd></dl></dd><dt><code class=Fn>index_compare</code>()</dt><dd>compares the current variable with an OID. <var class=Fa>oid1</var> and <var class=Fa>sub</var> come from the node callback arguments <var class=Fa>value-&gt;var</var> and <var class=Fa>sub</var> resp. <var class=Fa>oid2</var> is the OID to compare to. The function returns -1, 0, +1 when the variable is lesser, equal, higher to the given OID. <var class=Fa>oid2</var> must contain only the index part of the table column.</dd><dt><code class=Fn>index_compare_off</code>()</dt><dd>is equivalent to <code class=Fn>index_compare</code>() except that it takes an additional parameter <var class=Fa>off</var> that causes it to ignore the first <var class=Fa>off</var> components of both indexes.</dd><dt><code class=Fn>index_append</code>()</dt><dd>appends OID <var class=Fa>src</var> beginning at position <var class=Fa>sub</var> to <var class=Fa>dst</var>.</dd><dt><code class=Fn>index_append_off</code>()</dt><dd>appends OID <var class=Fa>src</var> beginning at position <var class=Fa>off</var> to <var class=Fa>dst</var> beginning at position <var class=Fa>sub</var> + <var class=Fa>off</var>.</dd></dl></section></section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=gensnmptree.1.html>gensnmptree(1)</a>, <a class=Xr href=bsnmpd.1.html>bsnmpd(1)</a>, <a class=Xr href=bsnmpagent.3.html>bsnmpagent(3)</a>, <a class=Xr href=bsnmpclient.3.html>bsnmpclient(3)</a>, <a class=Xr href=bsnmplib.3.html>bsnmplib(3)</a></section><section class=Sh><h2 class=Sh id=STANDARDS><a class=permalink href=#STANDARDS>STANDARDS</a></h2> This implementation conforms to the applicable IETF RFCs and ITU-T recommendations. </section><section class=Sh><h2 class=Sh id=AUTHORS><a class=permalink href=#AUTHORS>AUTHORS</a></h2><span class=An>Hartmut Brandt</span> âŸ¨harti@FreeBSD.orgâŸ© </section></div><table class=foot><tr><td class=foot-date>December 19, 2010</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>Â©ï¸ 2023 Inobulles</p></footer></body></html></body></html>