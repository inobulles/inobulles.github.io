<!DOCTYPE html>
<html><head><meta charset=utf-8><title>ALTQ(9)</title><keywords content=man,ALTQ></keywords><style>:root { --monitor-bleed: rgba(183, 0, 255, 0.46); --gradient: -webkit-linear-gradient(50deg, rgb(126, 119, 255), rgb(255, 34, 137)); --background-colour: #fff; --title-colour: #000; --text-colour: #000; --article-colour: #fff; --accent-colour: #4385f5; --muted-colour: #555; --shadow-colour: rgba(183, 0, 255, 0.487); --border-radius: 12px; --blur-radius: 0px; --navbar-colour: #fffc; --navbar-shadow: rgba(183, 0, 255, 0.1) 0 8px 32px; --code-background: #ddd; } .dark { visibility: hidden; } @media (prefers-color-scheme: light) { } @media (prefers-color-scheme: dark) { :root { --monitor-bleed: rgba(183, 0, 255, 0.172); --gradient: -webkit-linear-gradient(50deg, rgb(255, 79, 79), rgb(255, 52, 221)); --background-colour: #000; --title-colour: #fff; --text-colour: #ddd; --article-colour: #00000033; --accent-colour: #98beff; --muted-colour: #999; --shadow-colour: #ff00cc29; --blur-radius: 96px; --navbar-colour: #000a; --navbar-shadow: rgba(183, 0, 255, 0.05) 0 8px 32px; --code-background: #111; } .dark { visibility: visible; } .light { visibility: hidden; } } html, body { overflow-x: hidden; } body { background-image: url(bg.svg); background-size: cover; margin: 0; background-color: var(--background-colour); color: var(--text-colour); font-size: 22px; font-display: optional; font-family: "Montserrat", sans-serif; overflow-y: hidden; } h1 { color: var(--title-colour); font-size: 70px; font-display: optional; font-family: "Montserrat", sans-serif; } h2 { color: var(--title-colour); font-size: 40px; font-display: optional; font-family: "Montserrat", sans-serif; } h3 { color: var(--title-colour); font-size: 24px; font-display: optional; font-family: "Roboto Slab", serif; } q, blockquote { font-style: italic; white-space: pre-wrap; padding-left: 42px; } pre { margin: 32px; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } strong { background: var(--gradient); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold; } code { border-radius: 8px; background-color: var(--code-background); } pre { white-space: pre-wrap; } .info-container { max-width: 400px; margin: 32px; } .info-container p { margin-inline: 16px; margin-block: 32px; text-align: justify; font-size: 18px; } .labeled-img { max-width: 100%; position: relative; } .labeled-img div { position: absolute; bottom: 0; width: 100%; height: 70%; background: linear-gradient(to bottom, transparent, black); border-radius: var(--border-radius); } .labeled-img div h2 { color: white; position: absolute; bottom: 0; left: 32px; } .labeled-img img { width: 100%; border-radius: var(--border-radius); } a { background: var(--gradient); background-clip: none; color: var(--background-colour); font-weight: bold; text-decoration: none; border-radius: 3px; } a:hover { background: var(--text-colour); } .link, .link:hover { background: none; } button { background: var(--gradient); color: var(--background-colour); box-shadow: none; border: none; border-radius: 48px; padding: 8px; padding-left: 32px; padding-right: 32px; margin: 24px; font-size: 24px; font-display: optional; font-family: "Montserrat", sans-serif; font-weight: bold; cursor: pointer; transition: background .2s, color .2s, opacity .2s, box-shadow .2s, transform .2s; } button:hover { box-shadow: var(--shadow-colour) 0 8px 32px; transform: translateY(-4px); } button:active { transform: none; opacity: 50%; } .clickable { padding: 2px; transition: background-color 0.05s ease-out; border-radius: var(--border-radius); } .clickable:hover { background-color: var(--shadow-colour); } .docs-container { margin: auto; margin-top: 64px; max-width: 1200px; display: grid; justify-content: center; grid-template-columns: 1fr 3fr; } .docs { max-width: 900px; } .sidebar { min-width: 250px; position: fixed; padding: 16px; display: grid; justify-content: center; grid-auto-flow: row; grid-gap: 32px; padding-top: 64px; } .sidebar * { margin: auto; display: grid; justify-content: left; grid-auto-flow: column; grid-gap: 8px; } .sidebar p { font-size: 18px; } .sidebar-item { color: var(--text-colour); background: none; padding-inline: 8px; width: 100%; height: 100%; } .sidebar-item div svg { fill: var(--text-colour); } .navbar-container { width: 100vw; height: 48px; } .navbar { position: fixed; z-index: 100; width: 100vw; background-color: var(--navbar-colour); backdrop-filter: blur(20px); display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 32px; padding: 12px; } .navbar * { margin: auto; display: grid; justify-content: center; grid-auto-flow: column; grid-gap: 8px; } .navbar p { font-size: 18px; } .navbar-logo { height: 100%; max-height: 32px; stroke: var(--text-colour); } .navbar-icon { fill: var(--text-colour); } .navbar-item { color: var(--text-colour); background-color: transparent; padding-inline: 8px; width: 100%; height: 100%; border-radius: 8px; } @media only screen and (max-width: 800px) { .navbar-item { position: absolute; visibility: hidden; } } footer { text-align: center; padding: 64px; border-radius: 64px 64px 0 0; background: -webkit-linear-gradient(50deg, transparent, var(--monitor-bleed)); } footer p { margin: auto; } .permalink { color: var(--text-colour); background: none; } .permalink:hover { background: none; } </style></head><body><html><body><div class=navbar-container><div class=navbar><a class="navbar-item clickable link" href=https://inobulles.github.io><div><svg class=navbar-logo fill=none height=24px viewbox="0 0 144 144" width=24px xmlns=http://www.w3.org/2000/svg><path d=m22,115l50,-88l50,88l-100,0z stroke-width=20 transform="rotate(180 72 72)"></path></svg><p><strong>aquaBSD</strong></p></div></a><a class="navbar-item clickable link" href=https://inobulles.github.io/docs><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></svg><p>Develop</p></div></a><a class="navbar-item clickable link" href=mailto:inobulles@gmail.com><div><svg class=navbar-icon fill=none height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"></path></svg><p>Contact</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><path d="M12,2C6.48,2,2,6.48,2,12c0,5.52,4.48,10,10,10s10-4.48,10-10C22,6.48,17.52,2,12,2z M19.46,9.12l-2.78,1.15 c-0.51-1.36-1.58-2.44-2.95-2.94l1.15-2.78C16.98,5.35,18.65,7.02,19.46,9.12z M12,15c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3 S13.66,15,12,15z M9.13,4.54l1.17,2.78c-1.38,0.5-2.47,1.59-2.98,2.97L4.54,9.13C5.35,7.02,7.02,5.35,9.13,4.54z M4.54,14.87 l2.78-1.15c0.51,1.38,1.59,2.46,2.97,2.96l-1.17,2.78C7.02,18.65,5.35,16.98,4.54,14.87z M14.88,19.46l-1.15-2.78 c1.37-0.51,2.45-1.59,2.95-2.97l2.78,1.17C18.65,16.98,16.98,18.65,14.88,19.46z"></path></g></svg><p>Support</p></div></a><a class="navbar-item clickable link" href=#><div><svg class=navbar-icon fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 12 7.4l3.38 4.6L17 10.83 14.92 8H20v6z"></path></svg><p>Log in</p></div></a></div></div></body></html><div class=docs-container><html><body><div class=sidebar-container><div class=sidebar><a class="sidebar-item clickable" href=https://inobulles.github.io/docs><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M12.36 6l.4 2H18v6h-3.36l-.4-2H7V6h5.36M14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6L14 4z"></path></svg><p>Introduction</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/struct><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><rect fill=none height=24 width=24></rect><path d="M22,11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3H22z M7,9H4V5h3V9z M17,15h3v4h-3V15z M17,5h3v4h-3V5z"></path></svg><p>OS Components</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/dev-tools><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><rect height=8.48 transform="matrix(0.7071 -0.7071 0.7071 0.7071 -6.8717 17.6255)" width=3 x=16.34 y=12.87></rect><path d="M17.5,10c1.93,0,3.5-1.57,3.5-3.5c0-0.58-0.16-1.12-0.41-1.6l-2.7,2.7L16.4,6.11l2.7-2.7C18.62,3.16,18.08,3,17.5,3 C15.57,3,14,4.57,14,6.5c0,0.41,0.08,0.8,0.21,1.16l-1.85,1.85l-1.78-1.78l0.71-0.71L9.88,5.61L12,3.49 c-1.17-1.17-3.07-1.17-4.24,0L4.22,7.03l1.41,1.41H2.81L2.1,9.15l3.54,3.54l0.71-0.71V9.15l1.41,1.41l0.71-0.71l1.78,1.78 l-7.41,7.41l2.12,2.12L16.34,9.79C16.7,9.92,17.09,10,17.5,10z"></path></g></g></svg><p>Developer Tools</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/create-app><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24 x=0></rect></g><g><g><polygon points="19,9 20.25,6.25 23,5 20.25,3.75 19,1 17.75,3.75 15,5 17.75,6.25"></polygon><polygon points="19,15 17.75,17.75 15,19 17.75,20.25 19,23 20.25,20.25 23,19 20.25,17.75"></polygon><path d="M11.5,9.5L9,4L6.5,9.5L1,12l5.5,2.5L9,20l2.5-5.5L17,12L11.5,9.5z M9.99,12.99L9,15.17l-0.99-2.18L5.83,12l2.18-0.99 L9,8.83l0.99,2.18L12.17,12L9.99,12.99z"></path></g></g></svg><p>Creating an App</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/packaging><div><svg enable-background="new 0 0 24 24" fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><g><rect fill=none height=24 width=24></rect></g><g><g><path d="M20,2H4C3,2,2,2.9,2,4v3.01C2,7.73,2.43,8.35,3,8.7V20c0,1.1,1.1,2,2,2h14c0.9,0,2-0.9,2-2V8.7c0.57-0.35,1-0.97,1-1.69V4 C22,2.9,21,2,20,2z M19,20H5V9h14V20z M20,7H4V4h16V7z"></path><rect height=2 width=6 x=9 y=12></rect></g></g></svg><p>Packaging Apps</p></div></a><a class="sidebar-item clickable" href=https://inobulles.github.io/docs/publishing><div><svg fill=#000000 height=24px viewbox="0 0 24 24" width=24px xmlns=http://www.w3.org/2000/svg><path d="M0 0h24v24H0V0z" fill=none></path><path d="M13 3v1h-2V3h2m-1 7.11l5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94L16 13.96l-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32s-2.15-.92-2.49-1.32L8 13.96l-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79L12 10.11M15 1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1zM6 9.97V6h12v3.97L12 8 6 9.97zm10 9.71c-1.22.85-2.61 1.28-4 1.28s-2.78-.43-4-1.28C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32z"></path></svg><p>Publishing Apps</p></div></a></div></div></body></html><div class=docs><h1>ALTQ(9)</h1><table class=head><tr><td class=head-ltitle>ALTQ(9)</td><td class=head-vol>FreeBSD Kernel Developer's Manual</td><td class=head-rtitle>ALTQ(9)</td></tr></table><div class=manual-text><section class=Sh><h2 class=Sh id=NAME><a class=permalink href=#NAME>NAME</a></h2><code class=Nm>ALTQ</code> — <div class=Nd>kernel interfaces for manipulating output queues on network interfaces</div></section><section class=Sh><h2 class=Sh id=SYNOPSIS><a class=permalink href=#SYNOPSIS>SYNOPSIS</a></h2><code class=In>#include &lt;<a class=In href=../src/sys/types.h.html>sys/types.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/sys/socket.h.html>sys/socket.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/net/if.h.html>net/if.h</a>&gt;</code><br><code class=In>#include &lt;<a class=In href=../src/net/if_var.h.html>net/if_var.h</a>&gt;</code><section class=Ss><h2 class=Ss id=Enqueue_macros><a class=permalink href=#Enqueue_macros>Enqueue macros</a></h2><code class=Fn>IFQ_ENQUEUE</code>(<var class=Fa style="white-space: nowrap;">struct ifaltq *ifq</var>, <var class=Fa style="white-space: nowrap;">struct mbuf *m</var>, <var class=Fa style="white-space: nowrap;">int error</var>); <p class=Pp><code class=Fn>IFQ_HANDOFF</code>(<var class=Fa style="white-space: nowrap;">struct ifnet *ifp</var>, <var class=Fa style="white-space: nowrap;">struct mbuf *m</var>, <var class=Fa style="white-space: nowrap;">int error</var>);</p><p class=Pp><code class=Fn>IFQ_HANDOFF_ADJ</code>(<var class=Fa>struct ifnet *ifp</var>, <var class=Fa>struct mbuf *m</var>, <var class=Fa>int adjust</var>, <var class=Fa>int error</var>);</p></section><section class=Ss><h2 class=Ss id=Dequeue_macros><a class=permalink href=#Dequeue_macros>Dequeue macros</a></h2><code class=Fn>IFQ_DEQUEUE</code>(<var class=Fa style="white-space: nowrap;">struct ifaltq *ifq</var>, <var class=Fa style="white-space: nowrap;">struct mbuf *m</var>); <p class=Pp><code class=Fn>IFQ_POLL_NOLOCK</code>(<var class=Fa style="white-space: nowrap;">struct ifaltq *ifq</var>, <var class=Fa style="white-space: nowrap;">struct mbuf *m</var>);</p><p class=Pp><code class=Fn>IFQ_PURGE</code>(<var class=Fa style="white-space: nowrap;">struct ifaltq *ifq</var>);</p><p class=Pp><code class=Fn>IFQ_IS_EMPTY</code>(<var class=Fa style="white-space: nowrap;">struct ifaltq *ifq</var>);</p></section><section class=Ss><h2 class=Ss id=Driver_managed_dequeue_macros><a class=permalink href=#Driver_managed_dequeue_macros>Driver managed dequeue macros</a></h2><code class=Fn>IFQ_DRV_DEQUEUE</code>(<var class=Fa style="white-space: nowrap;">struct ifaltq *ifq</var>, <var class=Fa style="white-space: nowrap;">struct mbuf *m</var>); <p class=Pp><code class=Fn>IFQ_DRV_PREPEND</code>(<var class=Fa style="white-space: nowrap;">struct ifaltq *ifq</var>, <var class=Fa style="white-space: nowrap;">struct mbuf *m</var>);</p><p class=Pp><code class=Fn>IFQ_DRV_PURGE</code>(<var class=Fa style="white-space: nowrap;">struct ifaltq *ifq</var>);</p><p class=Pp><code class=Fn>IFQ_DRV_IS_EMPTY</code>(<var class=Fa style="white-space: nowrap;">struct ifaltq *ifq</var>);</p></section><section class=Ss><h2 class=Ss id=General_setup_macros><a class=permalink href=#General_setup_macros>General setup macros</a></h2><code class=Fn>IFQ_SET_MAXLEN</code>(<var class=Fa style="white-space: nowrap;">struct ifaltq *ifq</var>, <var class=Fa style="white-space: nowrap;">int len</var>); <p class=Pp><code class=Fn>IFQ_INC_LEN</code>(<var class=Fa style="white-space: nowrap;">struct ifaltq *ifq</var>);</p><p class=Pp><code class=Fn>IFQ_DEC_LEN</code>(<var class=Fa style="white-space: nowrap;">struct ifaltq *ifq</var>);</p><p class=Pp><code class=Fn>IFQ_INC_DROPS</code>(<var class=Fa style="white-space: nowrap;">struct ifaltq *ifq</var>);</p><p class=Pp><code class=Fn>IFQ_SET_READY</code>(<var class=Fa style="white-space: nowrap;">struct ifaltq *ifq</var>);</p></section></section><section class=Sh><h2 class=Sh id=DESCRIPTION><a class=permalink href=#DESCRIPTION>DESCRIPTION</a></h2> The <code class=Nm>ALTQ</code> system is a framework to manage queuing disciplines on network interfaces. <code class=Nm>ALTQ</code> introduces new macros to manipulate output queues. The output queue macros are used to abstract queue operations and not to touch the internal fields of the output queue structure. The macros are independent from the <code class=Nm>ALTQ</code> implementation, and compatible with the traditional <var class=Vt>ifqueue</var> macros for ease of transition. <p class=Pp><code class=Fn>IFQ_ENQUEUE</code>(), <code class=Fn>IFQ_HANDOFF</code>() and <code class=Fn>IFQ_HANDOFF_ADJ</code>() enqueue a packet <var class=Fa>m</var> to the queue <var class=Fa>ifq</var>. The underlying queuing discipline may discard the packet. The <var class=Fa>error</var> argument is set to 0 on success, or <code class=Er>ENOBUFS</code> if the packet is discarded. The packet pointed to by <var class=Fa>m</var> will be freed by the device driver on success, or by the queuing discipline on failure, so the caller should not touch <var class=Fa>m</var> after enqueuing. <code class=Fn>IFQ_HANDOFF</code>() and <code class=Fn>IFQ_HANDOFF_ADJ</code>() combine the enqueue operation with statistic generation and call <code class=Fn>if_start</code>() upon successful enqueue to initiate the actual send.</p><p class=Pp><code class=Fn>IFQ_DEQUEUE</code>() dequeues a packet from the queue. The dequeued packet is returned in <var class=Fa>m</var>, or <var class=Fa>m</var> is set to <code class=Dv>NULL</code> if no packet is dequeued. The caller must always check <var class=Fa>m</var> since a non-empty queue could return <code class=Dv>NULL</code> under rate-limiting.</p><p class=Pp><code class=Fn>IFQ_POLL_NOLOCK</code>() returns the next packet without removing it from the queue. The caller must hold the queue mutex when calling <code class=Fn>IFQ_POLL_NOLOCK</code>() in order to guarantee that a subsequent call to <code class=Fn>IFQ_DEQUEUE_NOLOCK</code>() dequeues the same packet.</p><p class=Pp><code class=Fn>IFQ_*_NOLOCK</code>() variants (if available) always assume that the caller holds the queue mutex. They can be grabbed with <code class=Fn>IFQ_LOCK</code>() and released with <code class=Fn>IFQ_UNLOCK</code>().</p><p class=Pp><code class=Fn>IFQ_PURGE</code>() discards all the packets in the queue. The purge operation is needed since a non-work conserving queue cannot be emptied by a dequeue loop.</p><p class=Pp><code class=Fn>IFQ_IS_EMPTY</code>() can be used to check if the queue is empty. Note that <code class=Fn>IFQ_DEQUEUE</code>() could still return <code class=Dv>NULL</code> if the queuing discipline is non-work conserving.</p><p class=Pp><code class=Fn>IFQ_DRV_DEQUEUE</code>() moves up to <var class=Fa>ifq-&gt;ifq_drv_maxlen</var> packets from the queue to the “driver managed” queue and returns the first one via <var class=Fa>m</var>. As for <code class=Fn>IFQ_DEQUEUE</code>(), <var class=Fa>m</var> can be <code class=Dv>NULL</code> even for a non-empty queue. Subsequent calls to <code class=Fn>IFQ_DRV_DEQUEUE</code>() pass the packets from the “driver managed” queue without obtaining the queue mutex. It is the responsibility of the caller to protect against concurrent access. Enabling <code class=Nm>ALTQ</code> for a given queue sets <var class=Va>ifq_drv_maxlen</var> to 0 as the “bulk dequeue” performed by <code class=Fn>IFQ_DRV_DEQUEUE</code>() for higher values of <var class=Va>ifq_drv_maxlen</var> is adverse to <code class=Nm>ALTQ</code>'s internal timing. Note that a driver must not mix <code class=Fn>IFQ_DRV_*</code>() macros with the default dequeue macros as the default macros do not look at the “driver managed” queue which might lead to an mbuf leak.</p><p class=Pp><code class=Fn>IFQ_DRV_PREPEND</code>() prepends <var class=Fa>m</var> to the “driver managed” queue from where it will be obtained with the next call to <code class=Fn>IFQ_DRV_DEQUEUE</code>().</p><p class=Pp><code class=Fn>IFQ_DRV_PURGE</code>() flushes all packets in the “driver managed” queue and calls to <code class=Fn>IFQ_PURGE</code>() afterwards.</p><p class=Pp><code class=Fn>IFQ_DRV_IS_EMPTY</code>() checks for packets in the “driver managed” part of the queue. If it is empty, it forwards to <code class=Fn>IFQ_IS_EMPTY</code>().</p><p class=Pp><code class=Fn>IFQ_SET_MAXLEN</code>() sets the queue length limit to the default FIFO queue. The <var class=Va>ifq_drv_maxlen</var> member of the <var class=Vt>ifaltq</var> structure controls the length limit of the “driver managed” queue.</p><p class=Pp><code class=Fn>IFQ_INC_LEN</code>() and <code class=Fn>IFQ_DEC_LEN</code>() increment or decrement the current queue length in packets. This is mostly for internal purposes.</p><p class=Pp><code class=Fn>IFQ_INC_DROPS</code>() increments the drop counter and is identical to <code class=Fn>IF_DROP</code>(). It is defined for naming consistency only.</p><p class=Pp><code class=Fn>IFQ_SET_READY</code>() sets a flag to indicate that a driver was converted to use the new macros. <code class=Nm>ALTQ</code> can be enabled only on interfaces with this flag.</p></section><section class=Sh><h2 class=Sh id=COMPATIBILITY><a class=permalink href=#COMPATIBILITY>COMPATIBILITY</a></h2><section class=Ss><h2 class=Ss><var class=Vt>ifaltq structure</var></h2> In order to keep compatibility with the existing code, the new output queue structure <var class=Vt>ifaltq</var> has the same fields. The traditional <code class=Fn>IF_*</code>() macros and the code directly referencing the fields within <var class=Va>if_snd</var> still work with <var class=Vt>ifaltq</var>. <div class="Bd Pp"><pre>
            ##old-style##                           ##new-style##
                                       |
 struct ifqueue {                      | struct ifaltq {
    struct mbuf *ifq_head;             |    struct mbuf *ifq_head;
    struct mbuf *ifq_tail;             |    struct mbuf *ifq_tail;
    int          ifq_len;              |    int          ifq_len;
    int          ifq_maxlen;           |    int          ifq_maxlen;
 };                                    |    /* driver queue fields */
                                       |    ......
                                       |    /* altq related fields */
                                       |    ......
                                       | };
                                       |
</pre></div> The new structure replaces <var class=Vt>struct ifqueue</var> in <var class=Vt>struct ifnet</var>. <div class="Bd Pp"><pre>
            ##old-style##                           ##new-style##
                                       |
 struct ifnet {                        | struct ifnet {
     ....                              |     ....
                                       |
     struct ifqueue if_snd;            |     struct ifaltq if_snd;
                                       |
     ....                              |     ....
 };                                    | };
                                       |
</pre></div> The (simplified) new <code class=Fn>IFQ_*</code>() macros look like: <div class="Bd Pp"><pre>
	#define IFQ_DEQUEUE(ifq, m)			\
		if (ALTQ_IS_ENABLED((ifq))		\
			ALTQ_DEQUEUE((ifq), (m));	\
		else					\
			IF_DEQUEUE((ifq), (m));
</pre></div></section><section class=Ss><h2 class=Ss id=Enqueue_operation><a class=permalink href=#Enqueue_operation>Enqueue operation</a></h2> The semantics of the enqueue operation is changed. In the new style, enqueue and packet drop are combined since they cannot be easily separated in many queuing disciplines. The new enqueue operation corresponds to the following macro that is written with the old macros. <div class="Bd Pp"><pre>
#define	IFQ_ENQUEUE(ifq, m, error)                      \
do {                                                    \
        if (IF_QFULL((ifq))) {                          \
                m_freem((m));                           \
                (error) = ENOBUFS;                      \
                IF_DROP(ifq);                           \
        } else {                                        \
                IF_ENQUEUE((ifq), (m));                 \
                (error) = 0;                            \
        }                                               \
} while (0)
</pre></div><p class=Pp><code class=Fn>IFQ_ENQUEUE</code>() does the following:</p><p class=Pp></p><ul class="Bl-dash Bl-compact"><li>queue a packet,</li><li>drop (and free) a packet if the enqueue operation fails.</li></ul><p class=Pp>If the enqueue operation fails, <var class=Fa>error</var> is set to <code class=Er>ENOBUFS</code>. The <var class=Fa>m</var> mbuf is freed by the queuing discipline. The caller should not touch mbuf after calling <code class=Fn>IFQ_ENQUEUE</code>() so that the caller may need to copy <var class=Va>m_pkthdr.len</var> or <var class=Va>m_flags</var> field beforehand for statistics. <code class=Fn>IFQ_HANDOFF</code>() and <code class=Fn>IFQ_HANDOFF_ADJ</code>() can be used if only default interface statistics and an immediate call to <code class=Fn>if_start</code>() are desired. The caller should not use <code class=Fn>senderr</code>() since mbuf was already freed.</p><p class=Pp>The new style <code class=Fn>if_output</code>() looks as follows:</p><div class="Bd Pp"><pre>
            ##old-style##                           ##new-style##
                                       |
 int                                   | int
 ether_output(ifp, m0, dst, rt0)       | ether_output(ifp, m0, dst, rt0)
 {                                     | {
     ......                            |     ......
                                       |
                                       |     mflags = m-&gt;m_flags;
                                       |     len = m-&gt;m_pkthdr.len;
     s = splimp();                     |     s = splimp();
     if (IF_QFULL(&amp;ifp-&gt;if_snd)) {     |     IFQ_ENQUEUE(&amp;ifp-&gt;if_snd, m,
                                       |                 error);
         IF_DROP(&amp;ifp-&gt;if_snd);        |     if (error != 0) {
         splx(s);                      |         splx(s);
         senderr(ENOBUFS);             |         return (error);
     }                                 |     }
     IF_ENQUEUE(&amp;ifp-&gt;if_snd, m);      |
     ifp-&gt;if_obytes +=                 |     ifp-&gt;if_obytes += len;
                    m-&gt;m_pkthdr.len;   |
     if (m-&gt;m_flags &amp; M_MCAST)         |     if (mflags &amp; M_MCAST)
         ifp-&gt;if_omcasts++;            |         ifp-&gt;if_omcasts++;
                                       |
     if ((ifp-&gt;if_flags &amp; IFF_OACTIVE) |     if ((ifp-&gt;if_flags &amp; IFF_OACTIVE)
         == 0)                         |         == 0)
         (*ifp-&gt;if_start)(ifp);        |         (*ifp-&gt;if_start)(ifp);
     splx(s);                          |     splx(s);
     return (error);                   |     return (error);
                                       |
 bad:                                  | bad:
     if (m)                            |     if (m)
         m_freem(m);                   |         m_freem(m);
     return (error);                   |     return (error);
 }                                     | }
                                       |
</pre></div></section></section><section class=Sh><h2 class=Sh id=HOW_TO_CONVERT_THE_EXISTING_DRIVERS><a class=permalink href=#HOW_TO_CONVERT_THE_EXISTING_DRIVERS>HOW TO CONVERT THE EXISTING DRIVERS</a></h2> First, make sure the corresponding <code class=Fn>if_output</code>() is already converted to the new style. <p class=Pp>Look for <var class=Va>if_snd</var> in the driver. Probably, you need to make changes to the lines that include <var class=Va>if_snd</var>.</p><section class=Ss><h2 class=Ss id=Empty_check_operation><a class=permalink href=#Empty_check_operation>Empty check operation</a></h2> If the code checks <var class=Va>ifq_head</var> to see whether the queue is empty or not, use <code class=Fn>IFQ_IS_EMPTY</code>(). <div class="Bd Pp"><pre>
            ##old-style##                           ##new-style##
                                       |
 if (ifp-&gt;if_snd.ifq_head != NULL)     | if (!IFQ_IS_EMPTY(&amp;ifp-&gt;if_snd))
                                       |
</pre></div><code class=Fn>IFQ_IS_EMPTY</code>() only checks if there is any packet stored in the queue. Note that even when <code class=Fn>IFQ_IS_EMPTY</code>() is <code class=Dv>FALSE</code>, <code class=Fn>IFQ_DEQUEUE</code>() could still return <code class=Dv>NULL</code> if the queue is under rate-limiting. </section><section class=Ss><h2 class=Ss id=Dequeue_operation><a class=permalink href=#Dequeue_operation>Dequeue operation</a></h2> Replace <code class=Fn>IF_DEQUEUE</code>() by <code class=Fn>IFQ_DEQUEUE</code>(). Always check whether the dequeued mbuf is <code class=Dv>NULL</code> or not. Note that even when <code class=Fn>IFQ_IS_EMPTY</code>() is <code class=Dv>FALSE</code>, <code class=Fn>IFQ_DEQUEUE</code>() could return <code class=Dv>NULL</code> due to rate-limiting. <div class="Bd Pp"><pre>
            ##old-style##                           ##new-style##
                                       |
 IF_DEQUEUE(&amp;ifp-&gt;if_snd, m);          | IFQ_DEQUEUE(&amp;ifp-&gt;if_snd, m);
                                       | if (m == NULL)
                                       |     return;
                                       |
</pre></div> A driver is supposed to call <code class=Fn>if_start</code>() from transmission complete interrupts in order to trigger the next dequeue. </section><section class=Ss><h2 class=Ss id=Poll_and_dequeue_operation><a class=permalink href=#Poll_and_dequeue_operation>Poll-and-dequeue operation</a></h2> If the code polls the packet at the head of the queue and actually uses the packet before dequeuing it, use <code class=Fn>IFQ_POLL_NOLOCK</code>() and <code class=Fn>IFQ_DEQUEUE_NOLOCK</code>(). <div class="Bd Pp"><pre>
            ##old-style##                           ##new-style##
                                       |
                                       | IFQ_LOCK(&amp;ifp-&gt;if_snd);
 m = ifp-&gt;if_snd.ifq_head;             | IFQ_POLL_NOLOCK(&amp;ifp-&gt;if_snd, m);
 if (m != NULL) {                      | if (m != NULL) {
                                       |
     /* use m to get resources */      |     /* use m to get resources */
     if (something goes wrong)         |     if (something goes wrong)
                                       |         IFQ_UNLOCK(&amp;ifp-&gt;if_snd);
         return;                       |         return;
                                       |
     IF_DEQUEUE(&amp;ifp-&gt;if_snd, m);      |     IFQ_DEQUEUE_NOLOCK(&amp;ifp-&gt;if_snd, m);
                                       |     IFQ_UNLOCK(&amp;ifp-&gt;if_snd);
                                       |
     /* kick the hardware */           |     /* kick the hardware */
 }                                     | }
                                       |
</pre></div> It is guaranteed that <code class=Fn>IFQ_DEQUEUE_NOLOCK</code>() under the same lock as a previous <code class=Fn>IFQ_POLL_NOLOCK</code>() returns the same packet. Note that they need to be guarded by <code class=Fn>IFQ_LOCK</code>(). </section><section class=Ss><h2 class=Ss>Eliminating <code class=Fn>IF_PREPEND</code>()</h2> If the code uses <code class=Fn>IF_PREPEND</code>(), you have to eliminate it unless you can use a “driver managed” queue which allows the use of <code class=Fn>IFQ_DRV_PREPEND</code>() as a substitute. A common usage of <code class=Fn>IF_PREPEND</code>() is to cancel the previous dequeue operation. You have to convert the logic into poll-and-dequeue. <div class="Bd Pp"><pre>
            ##old-style##                           ##new-style##
                                       |
                                       | IFQ_LOCK(&amp;ifp-&gt;if_snd);
 IF_DEQUEUE(&amp;ifp-&gt;if_snd, m);          | IFQ_POLL_NOLOCK(&amp;ifp-&gt;if_snd, m);
 if (m != NULL) {                      | if (m != NULL) {
                                       |
     if (something_goes_wrong) {       |     if (something_goes_wrong) {
         IF_PREPEND(&amp;ifp-&gt;if_snd, m);  |         IFQ_UNLOCK(&amp;ifp-&gt;if_snd);
         return;                       |         return;
     }                                 |     }
                                       |
                                       |     /* at this point, the driver
                                       |      * is committed to send this
                                       |      * packet.
                                       |      */
                                       |     IFQ_DEQUEUE_NOLOCK(&amp;ifp-&gt;if_snd, m);
                                       |     IFQ_UNLOCK(&amp;ifp-&gt;if_snd);
                                       |
     /* kick the hardware */           |     /* kick the hardware */
 }                                     | }
                                       |
</pre></div></section><section class=Ss><h2 class=Ss id=Purge_operation><a class=permalink href=#Purge_operation>Purge operation</a></h2> Use <code class=Fn>IFQ_PURGE</code>() to empty the queue. Note that a non-work conserving queue cannot be emptied by a dequeue loop. <div class="Bd Pp"><pre>
            ##old-style##                           ##new-style##
                                       |
 while (ifp-&gt;if_snd.ifq_head != NULL) {|  IFQ_PURGE(&amp;ifp-&gt;if_snd);
     IF_DEQUEUE(&amp;ifp-&gt;if_snd, m);      |
     m_freem(m);                       |
 }                                     |
                                       |
</pre></div></section><section class=Ss><h2 class=Ss id=Conversion_using_a_driver_managed_queue><a class=permalink href=#Conversion_using_a_driver_managed_queue>Conversion using a driver managed queue</a></h2> Convert <code class=Fn>IF_*</code>() macros to their equivalent <code class=Fn>IFQ_DRV_*</code>() and employ <code class=Fn>IFQ_DRV_IS_EMPTY</code>() where appropriate. <div class="Bd Pp"><pre>
            ##old-style##                           ##new-style##
                                       |
 if (ifp-&gt;if_snd.ifq_head != NULL)     | if (!IFQ_DRV_IS_EMPTY(&amp;ifp-&gt;if_snd))
                                       |
</pre></div> Make sure that calls to <code class=Fn>IFQ_DRV_DEQUEUE</code>(), <code class=Fn>IFQ_DRV_PREPEND</code>() and <code class=Fn>IFQ_DRV_PURGE</code>() are protected with a mutex of some kind. </section><section class=Ss><h2 class=Ss id=Attach_routine><a class=permalink href=#Attach_routine>Attach routine</a></h2> Use <code class=Fn>IFQ_SET_MAXLEN</code>() to set <var class=Va>ifq_maxlen</var> to <var class=Fa>len</var>. Initialize <var class=Va>ifq_drv_maxlen</var> with a sensible value if you plan to use the <code class=Fn>IFQ_DRV_*</code>() macros. Add <code class=Fn>IFQ_SET_READY</code>() to show this driver is converted to the new style. (This is used to distinguish new-style drivers.) <div class="Bd Pp"><pre>
            ##old-style##                           ##new-style##
                                       |
 ifp-&gt;if_snd.ifq_maxlen = qsize;       | IFQ_SET_MAXLEN(&amp;ifp-&gt;if_snd, qsize);
                                       | ifp-&gt;if_snd.ifq_drv_maxlen = qsize;
                                       | IFQ_SET_READY(&amp;ifp-&gt;if_snd);
 if_attach(ifp);                       | if_attach(ifp);
                                       |
</pre></div></section><section class=Ss><h2 class=Ss id=Other_issues><a class=permalink href=#Other_issues>Other issues</a></h2> The new macros for statistics: <div class="Bd Pp"><pre>
            ##old-style##                           ##new-style##
                                       |
 IF_DROP(&amp;ifp-&gt;if_snd);                | IFQ_INC_DROPS(&amp;ifp-&gt;if_snd);
                                       |
 ifp-&gt;if_snd.ifq_len++;                | IFQ_INC_LEN(&amp;ifp-&gt;if_snd);
                                       |
 ifp-&gt;if_snd.ifq_len--;                | IFQ_DEC_LEN(&amp;ifp-&gt;if_snd);
                                       |
</pre></div></section></section><section class=Sh><h2 class=Sh id=QUEUING_DISCIPLINES><a class=permalink href=#QUEUING_DISCIPLINES>QUEUING DISCIPLINES</a></h2> Queuing disciplines need to maintain <var class=Fa>ifq_len</var> (used by <code class=Fn>IFQ_IS_EMPTY</code>()). Queuing disciplines also need to guarantee that the same mbuf is returned if <code class=Fn>IFQ_DEQUEUE</code>() is called immediately after <code class=Fn>IFQ_POLL</code>(). </section><section class=Sh><h2 class=Sh id=SEE_ALSO><a class=permalink href=#SEE_ALSO>SEE ALSO</a></h2><a class=Xr href=pf.4.html>pf(4)</a>, <a class=Xr href=pf.conf.5.html>pf.conf(5)</a>, <a class=Xr href=pfctl.8.html>pfctl(8)</a></section><section class=Sh><h2 class=Sh id=HISTORY><a class=permalink href=#HISTORY>HISTORY</a></h2> The <code class=Nm>ALTQ</code> system first appeared in March 1997 and found home in the KAME project (http://www.kame.net). It was imported to <span class=Ux>FreeBSD</span> in 5.3 . </section></div><table class=foot><tr><td class=foot-date>March 20, 2018</td><td class=foot-os>FreeBSD 13.1-RELEASE-p2</td></tr></table></div></div><html><body><footer><p>©️ 2023 Inobulles</p></footer></body></html></body></html>